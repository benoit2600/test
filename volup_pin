./firmware/ihex2fw.c:	record->len = len;
./firmware/ihex2fw.c:	if (i + 8 + (record->len * 2) > size) {
./firmware/ihex2fw.c:	record->addr  = hex(data + i, &crc) << 8; i += 2;
./firmware/ihex2fw.c:	record->addr |= hex(data + i, &crc); i += 2;
./firmware/ihex2fw.c:	for (j = 0; j < record->len; j++, i += 2)
./firmware/ihex2fw.c:		record->data[j] = hex(data + i, &crc);
./firmware/ihex2fw.c:		if (!record->len)
./firmware/ihex2fw.c:		record->addr += offset;
./firmware/ihex2fw.c:		if (record->addr || record->len) {
./firmware/ihex2fw.c:		if (record->addr || record->len != 2) {
./firmware/ihex2fw.c:		offset = record->data[0] << 8 | record->data[1];
./firmware/ihex2fw.c:		if (record->addr || record->len != 4) {
./firmware/ihex2fw.c:		memcpy(&data32, &record->data[0], sizeof(data32));
./firmware/ihex2fw.c:		memcpy(&record->data[0], &data32, sizeof(data32));
./firmware/ihex2fw.c:	while ((*p) && (!sort_records || (*p)->addr < record->addr))
./firmware/ihex2fw.c:	record->next = *p;
./fs/namei.c: * with linux 2.0, and to avoid hard-linking to directories
./fs/ocfs2/xattr.c:	 * the start of our downward-filling free space.
./fs/ocfs2/xattr.c: * downward-growing free space.
./fs/binfmt_som.c:	/* Word-align the stack pointer */
./fs/ntfs/mft.c:		 * is set to 1 but the mft record->link_count is 0.  The caller
./fs/xfs/xfs_rtalloc.c:	 * If the starting position is not word-aligned, deal with the
./fs/xfs/xfs_rtalloc.c:	 * If the starting position is not word-aligned, deal with the
./fs/jbd2/revoke.c:	record->sequence = seq;
./fs/jbd2/revoke.c:	record->blocknr = blocknr;
./fs/jbd2/revoke.c:	list_add(&record->hash, hash_list);
./fs/jbd2/revoke.c:	while (&(record->hash) != hash_list) {
./fs/jbd2/revoke.c:		if (record->blocknr == blocknr) {
./fs/jbd2/revoke.c:		record = (struct jbd2_revoke_record_s *) record->hash.next;
./fs/jbd2/revoke.c:			list_del(&record->hash);
./fs/jbd2/revoke.c:			list_del(&record->hash);
./fs/jbd2/revoke.c:			cpu_to_be64(record->blocknr);
./fs/jbd2/revoke.c:			cpu_to_be32(record->blocknr);
./fs/jbd2/revoke.c:		if (tid_gt(sequence, record->sequence))
./fs/jbd2/revoke.c:			record->sequence = sequence;
./fs/jbd2/revoke.c:	if (tid_gt(sequence, record->sequence))
./fs/jbd2/revoke.c:			list_del(&record->hash);
./fs/ubifs/dir.c:		 * Directories cannot have hard-links, so if this is a
./fs/ubifs/super.c:		 * We accept them in order to be backward-compatible. But this
./fs/btrfs/volumes.c:			fs_devices->num_can_discard--;
./fs/ext4/mballoc.c:		ord--;
./fs/jfs/jfs_logmgr.c:	lrd->length = cpu_to_le16(len);
./fs/jfs/jfs_logmgr.c:		if (lrd->type & cpu_to_le16(LOG_COMMIT)) {
./fs/jfs/jfs_logmgr.c:			le16_to_cpu(lrd->type), log->bp, log->page, dstoffset);
./fs/jfs/jfs_txnmgr.c:	lrd->logtid = cpu_to_le32(tblk->logtid);
./fs/jfs/jfs_txnmgr.c:	lrd->backchain = 0;
./fs/jfs/jfs_txnmgr.c:	lrd->type = cpu_to_le16(LOG_COMMIT);
./fs/jfs/jfs_txnmgr.c:	lrd->length = 0;
./fs/jfs/jfs_txnmgr.c:		lrd->aggregate = cpu_to_le32(JFS_SBI(ip->i_sb)->aggregate);
./fs/jfs/jfs_txnmgr.c:		lrd->log.redopage.fileset = cpu_to_le32(JFS_IP(ip)->fileset);
./fs/jfs/jfs_txnmgr.c:		lrd->log.redopage.inode = cpu_to_le32(ip->i_ino);
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.type = cpu_to_le16(LOG_INODE);
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.l2linesize = cpu_to_le16(L2INODESLOTSIZE);
./fs/jfs/jfs_txnmgr.c:	pxd = &lrd->log.redopage.pxd;
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_REDOPAGE);
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_NOREDOINOEXT);
./fs/jfs/jfs_txnmgr.c:		lrd->log.noredoinoext.iagnum =
./fs/jfs/jfs_txnmgr.c:		lrd->log.noredoinoext.inoext_idx =
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_UPDATEMAP);
./fs/jfs/jfs_txnmgr.c:				lrd->log.updatemap.type =
./fs/jfs/jfs_txnmgr.c:				lrd->log.updatemap.type =
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.nxd = cpu_to_le16(1);
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.pxd = pxdlock->pxd;
./fs/jfs/jfs_txnmgr.c:			lrd->backchain =
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.type = cpu_to_le16(LOG_DATA);
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.l2linesize = cpu_to_le16(L2DATASLOTSIZE);
./fs/jfs/jfs_txnmgr.c:	pxd = &lrd->log.redopage.pxd;
./fs/jfs/jfs_txnmgr.c:	lrd->type = cpu_to_le16(LOG_REDOPAGE);
./fs/jfs/jfs_txnmgr.c:	lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.type = cpu_to_le16(LOG_DTREE);
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.l2linesize = cpu_to_le16(L2DTSLOTSIZE);
./fs/jfs/jfs_txnmgr.c:	pxd = &lrd->log.redopage.pxd;
./fs/jfs/jfs_txnmgr.c:		lrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_REDOPAGE);
./fs/jfs/jfs_txnmgr.c:			lrd->log.redopage.type |= cpu_to_le16(LOG_EXTEND);
./fs/jfs/jfs_txnmgr.c:			lrd->log.redopage.type |= cpu_to_le16(LOG_NEW);
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_REDOPAGE);
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_NOREDOPAGE);
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.type = cpu_to_le16(LOG_XTREE);
./fs/jfs/jfs_txnmgr.c:	lrd->log.redopage.l2linesize = cpu_to_le16(L2XTSLOTSIZE);
./fs/jfs/jfs_txnmgr.c:	page_pxd = &lrd->log.redopage.pxd;
./fs/jfs/jfs_txnmgr.c:		lrd->log.redopage.type |= cpu_to_le16(LOG_BTROOT);
./fs/jfs/jfs_txnmgr.c:			lrd->log.redopage.type |=
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_REDOPAGE);
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));
./fs/jfs/jfs_txnmgr.c:			lrd->type = cpu_to_le16(LOG_NOREDOPAGE);
./fs/jfs/jfs_txnmgr.c:			lrd->backchain =
./fs/jfs/jfs_txnmgr.c:				lrd->type = cpu_to_le16(LOG_REDOPAGE);
./fs/jfs/jfs_txnmgr.c:				lrd->backchain =
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_UPDATEMAP);
./fs/jfs/jfs_txnmgr.c:		lrd->log.updatemap.type = cpu_to_le16(LOG_FREEXADLIST);
./fs/jfs/jfs_txnmgr.c:		lrd->log.updatemap.nxd =
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_REDOPAGE);
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, tlck));
./fs/jfs/jfs_txnmgr.c:			lrd->type = cpu_to_le16(LOG_UPDATEMAP);
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.nxd = cpu_to_le16(1);
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.pxd = pxdlock->pxd;
./fs/jfs/jfs_txnmgr.c:			lrd->backchain =
./fs/jfs/jfs_txnmgr.c:			lrd->type = cpu_to_le16(LOG_UPDATEMAP);
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.type =
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.nxd =
./fs/jfs/jfs_txnmgr.c:			lrd->backchain =
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_NOREDOPAGE);
./fs/jfs/jfs_txnmgr.c:		pxd = &lrd->log.redopage.pxd;
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_UPDATEMAP);
./fs/jfs/jfs_txnmgr.c:		lrd->log.updatemap.type = cpu_to_le16(LOG_FREEPXD);
./fs/jfs/jfs_txnmgr.c:		lrd->log.updatemap.nxd = cpu_to_le16(1);
./fs/jfs/jfs_txnmgr.c:		lrd->log.updatemap.pxd = pxdlock->pxd;
./fs/jfs/jfs_txnmgr.c:		lrd->backchain = cpu_to_le32(lmLog(log, tblk, lrd, NULL));
./fs/jfs/jfs_txnmgr.c:		lrd->type = cpu_to_le16(LOG_UPDATEMAP);
./fs/jfs/jfs_txnmgr.c:				lrd->log.updatemap.type =
./fs/jfs/jfs_txnmgr.c:				lrd->log.updatemap.type =
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.nxd = cpu_to_le16(1);
./fs/jfs/jfs_txnmgr.c:			lrd->log.updatemap.pxd = pxdlock->pxd;
./fs/jfs/jfs_txnmgr.c:			lrd->backchain =
./fs/cachefiles/namei.c:	if (!S_ISDIR(cache->graveyard->d_inode->i_mode)) {
./fs/cachefiles/namei.c:				 cache->graveyard->d_inode, grave);
./fs/cramfs/inode.c:	/* correct strange, hard-coded permissions of mkcramfs */
./fs/hpfs/dnode.c:	rd->root_dnode = 1;
./fs/hpfs/dnode.c:	rd->up = d->up;
./fs/hfsplus/dir.c:		rd->file = filp;
./fs/hfsplus/dir.c:		list_add(&rd->list, &HFSPLUS_I(inode)->open_dir_list);
./fs/hfsplus/dir.c:	memcpy(&rd->key, fd.key, sizeof(struct hfsplus_cat_key));
./fs/hfsplus/dir.c:		list_del(&rd->list);
./fs/hfsplus/catalog.c:		if (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)
./fs/hfsplus/catalog.c:			rd->file->f_pos--;
./fs/cifs/sess.c:		/* unicode string area must be word-aligned */
./fs/jffs2/gc.c:			if (je16_to_cpu(rd->nodetype) != JFFS2_NODETYPE_DIRENT)
./fs/jffs2/gc.c:			if (je32_to_cpu(rd->name_crc) != name_crc)
./fs/jffs2/gc.c:			if (rd->nsize != name_len || !je32_to_cpu(rd->ino))
./fs/jffs2/gc.c:			if (memcmp(rd->name, fd->name, name_len))
./fs/jffs2/gc.c:				  ref_offset(fd->raw), fd->name, ref_offset(raw), je32_to_cpu(rd->ino)));
./fs/jffs2/dir.c:	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
./fs/jffs2/dir.c:	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
./fs/jffs2/dir.c:	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
./fs/jffs2/dir.c:	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
./fs/jffs2/dir.c:	rd->pino = cpu_to_je32(dir_i->i_ino);
./fs/jffs2/dir.c:	rd->version = cpu_to_je32(++dir_f->highest_version);
./fs/jffs2/dir.c:	rd->ino = cpu_to_je32(inode->i_ino);
./fs/jffs2/dir.c:	rd->mctime = cpu_to_je32(get_seconds());
./fs/jffs2/dir.c:	rd->nsize = namelen;
./fs/jffs2/dir.c:	rd->type = DT_LNK;
./fs/jffs2/dir.c:	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
./fs/jffs2/dir.c:	rd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));
./fs/jffs2/dir.c:	dir_i->i_mtime = dir_i->i_ctime = ITIME(je32_to_cpu(rd->mctime));
./fs/jffs2/dir.c:	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
./fs/jffs2/dir.c:	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
./fs/jffs2/dir.c:	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
./fs/jffs2/dir.c:	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
./fs/jffs2/dir.c:	rd->pino = cpu_to_je32(dir_i->i_ino);
./fs/jffs2/dir.c:	rd->version = cpu_to_je32(++dir_f->highest_version);
./fs/jffs2/dir.c:	rd->ino = cpu_to_je32(inode->i_ino);
./fs/jffs2/dir.c:	rd->mctime = cpu_to_je32(get_seconds());
./fs/jffs2/dir.c:	rd->nsize = namelen;
./fs/jffs2/dir.c:	rd->type = DT_DIR;
./fs/jffs2/dir.c:	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
./fs/jffs2/dir.c:	rd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));
./fs/jffs2/dir.c:	dir_i->i_mtime = dir_i->i_ctime = ITIME(je32_to_cpu(rd->mctime));
./fs/jffs2/dir.c:	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
./fs/jffs2/dir.c:	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
./fs/jffs2/dir.c:	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
./fs/jffs2/dir.c:	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
./fs/jffs2/dir.c:	rd->pino = cpu_to_je32(dir_i->i_ino);
./fs/jffs2/dir.c:	rd->version = cpu_to_je32(++dir_f->highest_version);
./fs/jffs2/dir.c:	rd->ino = cpu_to_je32(inode->i_ino);
./fs/jffs2/dir.c:	rd->mctime = cpu_to_je32(get_seconds());
./fs/jffs2/dir.c:	rd->nsize = namelen;
./fs/jffs2/dir.c:	rd->type = (mode & S_IFMT) >> 12;
./fs/jffs2/dir.c:	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
./fs/jffs2/dir.c:	rd->name_crc = cpu_to_je32(crc32(0, dentry->d_name.name, namelen));
./fs/jffs2/dir.c:	dir_i->i_mtime = dir_i->i_ctime = ITIME(je32_to_cpu(rd->mctime));
./fs/jffs2/readinode.c:	if (unlikely(crc != je32_to_cpu(rd->node_crc))) {
./fs/jffs2/readinode.c:			     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);
./fs/jffs2/readinode.c:		if (unlikely(PAD((rd->nsize + sizeof(*rd))) != PAD(je32_to_cpu(rd->totlen)))) {
./fs/jffs2/readinode.c:				    ref_offset(ref), rd->nsize, je32_to_cpu(rd->totlen));
./fs/jffs2/readinode.c:	fd = jffs2_alloc_full_dirent(rd->nsize + 1);
./fs/jffs2/readinode.c:	fd->version = je32_to_cpu(rd->version);
./fs/jffs2/readinode.c:	fd->ino = je32_to_cpu(rd->ino);
./fs/jffs2/readinode.c:	fd->type = rd->type;
./fs/jffs2/readinode.c:	if(fd->version > rii->mctime_ver && je32_to_cpu(rd->mctime)) {
./fs/jffs2/readinode.c:		rii->latest_mctime = je32_to_cpu(rd->mctime);
./fs/jffs2/readinode.c:		memcpy(&fd->name[0], &rd->name[0],
./fs/jffs2/readinode.c:		       min_t(uint32_t, rd->nsize, (read - sizeof(*rd)) ));
./fs/jffs2/readinode.c:	if (rd->nsize + sizeof(*rd) > read) {
./fs/jffs2/readinode.c:				rd->nsize - already, &read, &fd->name[already]);
./fs/jffs2/readinode.c:		if (unlikely(read != rd->nsize - already) && likely(!err))
./fs/jffs2/readinode.c:	fd->nhash = full_name_hash(fd->name, rd->nsize);
./fs/jffs2/readinode.c:	fd->name[rd->nsize] = '\0';
./fs/jffs2/readinode.c:	if (unlikely(crc != je32_to_cpu(rd->node_crc))) {
./fs/jffs2/readinode.c:			     ref_offset(ref), je32_to_cpu(rd->node_crc), crc);
./fs/jffs2/readinode.c:	csize = je32_to_cpu(rd->csize);
./fs/jffs2/readinode.c:		if (unlikely(je32_to_cpu(rd->offset) > je32_to_cpu(rd->isize)) ||
./fs/jffs2/readinode.c:		    unlikely(PAD(je32_to_cpu(rd->csize) + sizeof(*rd)) != PAD(je32_to_cpu(rd->totlen)))) {
./fs/jffs2/readinode.c:			if (len >= csize && unlikely(tn->partial_crc != je32_to_cpu(rd->data_crc))) {
./fs/jffs2/readinode.c:					ref_offset(ref), tn->partial_crc, je32_to_cpu(rd->data_crc));
./fs/jffs2/readinode.c:	tn->version = je32_to_cpu(rd->version);
./fs/jffs2/readinode.c:	tn->fn->ofs = je32_to_cpu(rd->offset);
./fs/jffs2/readinode.c:	tn->data_crc = je32_to_cpu(rd->data_crc);
./fs/jffs2/readinode.c:	if (rd->compr == JFFS2_COMPR_ZERO && !je32_to_cpu(rd->dsize) && csize)
./fs/jffs2/readinode.c:		tn->fn->size = je32_to_cpu(rd->dsize);
./fs/jffs2/readinode.c:		       ref_offset(ref), je32_to_cpu(rd->version),
./fs/jffs2/readinode.c:		       je32_to_cpu(rd->offset), je32_to_cpu(rd->dsize), csize);
./fs/jffs2/readinode.c:	dbg_readinode2("After adding ver %d:\n", je32_to_cpu(rd->version));
./fs/jffs2/write.c:		  je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),
./fs/jffs2/write.c:		  je32_to_cpu(rd->name_crc)));
./fs/jffs2/write.c:	D1(if(je32_to_cpu(rd->hdr_crc) != crc32(0, rd, sizeof(struct jffs2_unknown_node)-4)) {
./fs/jffs2/write.c:		       je32_to_cpu(rd->pino), name, name, je32_to_cpu(rd->ino),
./fs/jffs2/write.c:		       je32_to_cpu(rd->name_crc));
./fs/jffs2/write.c:	fd->version = je32_to_cpu(rd->version);
./fs/jffs2/write.c:	fd->ino = je32_to_cpu(rd->ino);
./fs/jffs2/write.c:	fd->type = rd->type;
./fs/jffs2/write.c:	if ((alloc_mode!=ALLOC_GC) && (je32_to_cpu(rd->version) < f->highest_version)) {
./fs/jffs2/write.c:				     je32_to_cpu(rd->version), f->highest_version));
./fs/jffs2/write.c:		rd->version = cpu_to_je32(++f->highest_version);
./fs/jffs2/write.c:		fd->version = je32_to_cpu(rd->version);
./fs/jffs2/write.c:		rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
./fs/jffs2/write.c:				 (alloc_mode==ALLOC_GC)?0:je32_to_cpu(rd->pino));
./fs/jffs2/write.c:	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
./fs/jffs2/write.c:	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
./fs/jffs2/write.c:	rd->totlen = cpu_to_je32(sizeof(*rd) + qstr->len);
./fs/jffs2/write.c:	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
./fs/jffs2/write.c:	rd->pino = cpu_to_je32(dir_f->inocache->ino);
./fs/jffs2/write.c:	rd->version = cpu_to_je32(++dir_f->highest_version);
./fs/jffs2/write.c:	rd->ino = ri->ino;
./fs/jffs2/write.c:	rd->mctime = ri->ctime;
./fs/jffs2/write.c:	rd->nsize = qstr->len;
./fs/jffs2/write.c:	rd->type = DT_REG;
./fs/jffs2/write.c:	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
./fs/jffs2/write.c:	rd->name_crc = cpu_to_je32(crc32(0, qstr->name, qstr->len));
./fs/jffs2/write.c:		rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
./fs/jffs2/write.c:		rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
./fs/jffs2/write.c:		rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
./fs/jffs2/write.c:		rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
./fs/jffs2/write.c:		rd->pino = cpu_to_je32(dir_f->inocache->ino);
./fs/jffs2/write.c:		rd->version = cpu_to_je32(++dir_f->highest_version);
./fs/jffs2/write.c:		rd->ino = cpu_to_je32(0);
./fs/jffs2/write.c:		rd->mctime = cpu_to_je32(time);
./fs/jffs2/write.c:		rd->nsize = namelen;
./fs/jffs2/write.c:		rd->type = DT_UNKNOWN;
./fs/jffs2/write.c:		rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
./fs/jffs2/write.c:		rd->name_crc = cpu_to_je32(crc32(0, name, namelen));
./fs/jffs2/write.c:	rd->magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);
./fs/jffs2/write.c:	rd->nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);
./fs/jffs2/write.c:	rd->totlen = cpu_to_je32(sizeof(*rd) + namelen);
./fs/jffs2/write.c:	rd->hdr_crc = cpu_to_je32(crc32(0, rd, sizeof(struct jffs2_unknown_node)-4));
./fs/jffs2/write.c:	rd->pino = cpu_to_je32(dir_f->inocache->ino);
./fs/jffs2/write.c:	rd->version = cpu_to_je32(++dir_f->highest_version);
./fs/jffs2/write.c:	rd->ino = cpu_to_je32(ino);
./fs/jffs2/write.c:	rd->mctime = cpu_to_je32(time);
./fs/jffs2/write.c:	rd->nsize = namelen;
./fs/jffs2/write.c:	rd->type = type;
./fs/jffs2/write.c:	rd->node_crc = cpu_to_je32(crc32(0, rd, sizeof(*rd)-8));
./fs/jffs2/write.c:	rd->name_crc = cpu_to_je32(crc32(0, name, namelen));
./fs/jffs2/summary.c:		kmalloc(sizeof(struct jffs2_sum_dirent_mem) + rd->nsize, GFP_KERNEL);
./fs/jffs2/summary.c:	temp->nodetype = rd->nodetype;
./fs/jffs2/summary.c:	temp->totlen = rd->totlen;
./fs/jffs2/summary.c:	temp->pino = rd->pino;
./fs/jffs2/summary.c:	temp->version = rd->version;
./fs/jffs2/summary.c:	temp->ino = rd->ino;
./fs/jffs2/summary.c:	temp->nsize = rd->nsize;
./fs/jffs2/summary.c:	temp->type = rd->type;
./fs/jffs2/summary.c:	memcpy(temp->name, rd->name, rd->nsize);
./fs/jffs2/scan.c:			printk(KERN_WARNING "Eep. ofs 0x%08x not word-aligned!\n", ofs);
./fs/jffs2/scan.c:	if (crc != je32_to_cpu(rd->node_crc)) {
./fs/jffs2/scan.c:		       ofs, je32_to_cpu(rd->node_crc), crc);
./fs/jffs2/scan.c:		if ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))
./fs/jffs2/scan.c:	pseudo_random += je32_to_cpu(rd->version);
./fs/jffs2/scan.c:	checkedlen = strnlen(rd->name, rd->nsize);
./fs/jffs2/scan.c:	if (checkedlen < rd->nsize) {
./fs/jffs2/scan.c:	memcpy(&fd->name, rd->name, checkedlen);
./fs/jffs2/scan.c:	crc = crc32(0, fd->name, rd->nsize);
./fs/jffs2/scan.c:	if (crc != je32_to_cpu(rd->name_crc)) {
./fs/jffs2/scan.c:		       ofs, je32_to_cpu(rd->name_crc), crc);
./fs/jffs2/scan.c:		D1(printk(KERN_NOTICE "Name for which CRC failed is (now) '%s', ino #%d\n", fd->name, je32_to_cpu(rd->ino)));
./fs/jffs2/scan.c:		if ((err = jffs2_scan_dirty_space(c, jeb, PAD(je32_to_cpu(rd->totlen)))))
./fs/jffs2/scan.c:	ic = jffs2_scan_make_ino_cache(c, je32_to_cpu(rd->pino));
./fs/jffs2/scan.c:				      PAD(je32_to_cpu(rd->totlen)), ic);
./fs/jffs2/scan.c:	fd->version = je32_to_cpu(rd->version);
./fs/jffs2/scan.c:	fd->ino = je32_to_cpu(rd->ino);
./fs/jffs2/scan.c:	fd->type = rd->type;
./fs/hfs/dir.c:		rd->file = filp;
./fs/hfs/dir.c:		list_add(&rd->list, &HFS_I(inode)->open_dir_list);
./fs/hfs/dir.c:	memcpy(&rd->key, &fd.key, sizeof(struct hfs_cat_key));
./fs/hfs/dir.c:		list_del(&rd->list);
./fs/hfs/catalog.c:		if (fd.tree->keycmp(fd.search_key, (void *)&rd->key) < 0)
./fs/hfs/catalog.c:			rd->file->f_pos--;
./fs/jbd/revoke.c:	record->sequence = seq;
./fs/jbd/revoke.c:	record->blocknr = blocknr;
./fs/jbd/revoke.c:	list_add(&record->hash, hash_list);
./fs/jbd/revoke.c:	while (&(record->hash) != hash_list) {
./fs/jbd/revoke.c:		if (record->blocknr == blocknr) {
./fs/jbd/revoke.c:		record = (struct jbd_revoke_record_s *) record->hash.next;
./fs/jbd/revoke.c:			list_del(&record->hash);
./fs/jbd/revoke.c:			list_del(&record->hash);
./fs/jbd/revoke.c:		cpu_to_be32(record->blocknr);
./fs/jbd/revoke.c:		if (tid_gt(sequence, record->sequence))
./fs/jbd/revoke.c:			record->sequence = sequence;
./fs/jbd/revoke.c:	if (tid_gt(sequence, record->sequence))
./fs/jbd/revoke.c:			list_del(&record->hash);
./scripts/mod/file2alias.c:			const char *id = (char *)card->devs[j].id;
./scripts/mod/file2alias.c:				char acpi_id[sizeof(card->devs[0].id)];
./lib/locking-selftest.c:	DO_TESTCASE_1("hard-"desc, name##_hard, nr);		\
./lib/locking-selftest.c:	DO_TESTCASE_1B("hard-"desc, name##_hard, nr);		\
./lib/locking-selftest.c:	DO_TESTCASE_3("hard-"desc, name##_hard, nr);		\
./lib/locking-selftest.c:	DO_TESTCASE_3RW("hard-"desc, name##_hard, nr);		\
./lib/bitmap.c:	     		ord--;
./mm/slab.c:	 * Both debugging options require word-alignment which is calculated
./arch/um/drivers/cow_user.c: * Define PATH_LEN_V3 as the usual value of MAXPATHLEN, just hard-code it in
./arch/x86/boot/video.c:		nmodes += card->nmodes;
./arch/x86/boot/video.c:		mi = card->modes;
./arch/x86/boot/video.c:		for (i = 0; i < card->nmodes; i++, mi++) {
./arch/x86/boot/video.c:			       ch, mode_id, mi->x, resbuf, card->card_name);
./arch/x86/boot/video-mode.c:		if (card->unsafe == unsafe) {
./arch/x86/boot/video-mode.c:			if (card->probe)
./arch/x86/boot/video-mode.c:				card->nmodes = card->probe();
./arch/x86/boot/video-mode.c:				card->nmodes = 0;
./arch/x86/boot/video-mode.c:		mi = card->modes;
./arch/x86/boot/video-mode.c:		for (i = 0; i < card->nmodes; i++, mi++) {
./arch/x86/boot/video-mode.c:		mi = card->modes;
./arch/x86/boot/video-mode.c:		for (i = 0; i < card->nmodes; i++, mi++) {
./arch/x86/boot/video-mode.c:				return card->set_mode(mi);
./arch/x86/boot/video-mode.c:		if (mode >= card->xmode_first &&
./arch/x86/boot/video-mode.c:		    mode < card->xmode_first+card->xmode_n) {
./arch/x86/boot/video-mode.c:			return card->set_mode(&mix);
./arch/x86/platform/olpc/olpc.c:	rev = of_get_property(root, "board-revision-int", &propsize);
./arch/sparc/mm/sun4c.c:/* Find an entry in the third-level page table.. */ 
./arch/sparc/mm/srmmu.c:/* Find an entry in the third-level page table.. */ 
./arch/sparc/mm/srmmu.c:/* Create a third-level SRMMU 16MB page mapping. */
./arch/sparc/math-emu/math_32.c:	case FMOVS: rd->s = rs2->s; break;
./arch/sparc/math-emu/math_32.c:	case FABSS: rd->s = rs2->s & 0x7fffffff; break;
./arch/sparc/math-emu/math_32.c:	case FNEGS: rd->s = rs2->s ^ 0x80000000; break;
./arch/sparc/math-emu/math_32.c:		case 1: rd->s = IR; break;
./arch/sparc/math-emu/math_64.c:		case FMOVQ: rd->q[0] = rs2->q[0]; rd->q[1] = rs2->q[1]; break;
./arch/sparc/math-emu/math_64.c:		case FABSQ: rd->q[0] = rs2->q[0] & 0x7fffffffffffffffUL; rd->q[1] = rs2->q[1]; break;
./arch/sparc/math-emu/math_64.c:		case FNEGQ: rd->q[0] = rs2->q[0] ^ 0x8000000000000000UL; rd->q[1] = rs2->q[1]; break;
./arch/sparc/math-emu/math_64.c:			case 1: rd->s = IR; break;
./arch/sparc/math-emu/math_64.c:			case 2: rd->d = XR; break;
./arch/sparc/kernel/of_device_64.c: * This is just needed to hard-code the address and size cell
./arch/sparc/kernel/smp_64.c:	 * busy/nack fields hard-coded by ITID number for this Ultra-III
./arch/sparc/kernel/central.c:	p->leds_pdev.name = "sunfire-clockboard-leds";
./arch/sparc/kernel/perf_event.c:/* Niagara1 is very limited.  The upper PIC is hard-locked to count
./arch/avr32/boards/atngw100/flash.c: * ATNGW100 board-specific flash initialization
./arch/avr32/boards/atngw100/mrmt.c: * Board-specific setup code for Remote Media Terminal 1 (RMT1)
./arch/avr32/boards/atngw100/mrmt.c:/* Define board-specifoic GPIO assignments */
./arch/avr32/boards/atngw100/evklcd10x.c: * Board-specific setup code for the ATEVKLCD10X addon board to the ATNGW100
./arch/avr32/boards/atngw100/setup.c: * Board-specific setup code for the ATNGW100 Network Gateway
./arch/avr32/boards/atngw100/setup.c:/* Oscillator frequencies. These are board-specific */
./arch/avr32/boards/atngw100/setup.c:	 * Since this is board-specific code, we'll cheat and use the
./arch/avr32/boards/hammerhead/flash.c: * Hammerhead board-specific flash initialization
./arch/avr32/boards/hammerhead/setup.c: * Board-specific setup code for the Miromico Hammerhead board
./arch/avr32/boards/hammerhead/setup.c:/* Oscillator frequencies. These are board-specific */
./arch/avr32/boards/hammerhead/setup.c:	 * Since this is board-specific code, we'll cheat and use the
./arch/avr32/boards/favr-32/flash.c: * Favr-32 board-specific flash initialization
./arch/avr32/boards/favr-32/setup.c: * Favr-32 board-specific setup code.
./arch/avr32/boards/favr-32/setup.c:/* Oscillator frequencies. These are board-specific */
./arch/avr32/boards/favr-32/setup.c:	 * Since this is board-specific code, we'll cheat and use the
./arch/avr32/boards/merisc/flash.c: * Merisc board-specific flash initialization
./arch/avr32/boards/merisc/setup.c: * Board-specific setup code for the Merisc
./arch/avr32/boards/atstk1000/atstk1002.c: * ATSTK1002/ATSTK1006 daughterboard-specific init code
./arch/avr32/boards/atstk1000/atstk1002.c:	 * Since this is board-specific code, we'll cheat and use the
./arch/avr32/boards/atstk1000/flash.c: * ATSTK1000 board-specific flash initialization
./arch/avr32/boards/atstk1000/atstk1004.c: * ATSTK1003 daughterboard-specific init code
./arch/avr32/boards/atstk1000/atstk1003.c: * ATSTK1003 daughterboard-specific init code
./arch/avr32/boards/atstk1000/setup.c: * ATSTK1000 board-specific setup code.
./arch/avr32/boards/mimc200/flash.c: * MIMC200 board-specific flash initialization
./arch/avr32/boards/mimc200/fram.c: * At the moment, this is hard-coded to the MIMC200 platform, and only
./arch/avr32/boards/mimc200/setup.c: * Board-specific setup code for the MIMC200
./arch/avr32/boards/mimc200/setup.c:/* Oscillator frequencies. These are board-specific */
./arch/avr32/boards/mimc200/setup.c:	 * Since this is board-specific code, we'll cheat and use the
./arch/avr32/kernel/setup.c: * Board-specific code may use these variables to set up platform data
./arch/microblaze/kernel/reset.c:	ret = of_parse_phandles_with_args(root, "hard-reset-gpios",
./arch/microblaze/kernel/cpu/cpuinfo-static.c:	ci->num_rd_brk = fcpu(cpu, "xlnx,number-of-rd-addr-brk");
./arch/sh/boards/board-urquell.c: * Based on board-sh7785lcr.c
./arch/mips/pci/ops-loongson2.c:		/* board-specific part,currently,only fuloong2f,yeeloong2f
./arch/mips/loongson/fuloong-2e/reset.c:/* Board-specific reboot/shutdown routines
./arch/mips/loongson/lemote-2f/reset.c:/* Board-specific reboot/shutdown routines
./arch/mips/loongson/common/pm.c: * Setup the board-specific events for waking up loongson from wait mode
./arch/mips/mm/c-tx39.c:		/* board-dependent init code may set WBON */
./arch/mips/alchemy/devboards/db1200/setup.c:		"  Board-ID %d  Daughtercard ID %d\n",
./arch/mips/jz4740/board-qi_lb60.c: * linux/arch/mips/jz4740/board-qi_lb60.c
./arch/mips/sgi-ip27/ip27-memory.c:		if (brd->brd_type == KLTYPE_ROUTER) {
./arch/mips/sgi-ip27/ip27-memory.c:			router = (klrou_t *)NODE_OFFSET_TO_K0(NASID_GET(brd), brd->brd_compts[0]);
./arch/mips/sgi-ip27/ip27-memory.c:			if (brd->brd_flags & DUPLICATE_BOARD)
./arch/mips/sgi-ip27/ip27-memory.c:			router = (klrou_t *)NODE_OFFSET_TO_K0(NASID_GET(brd), brd->brd_compts[0]);
./arch/mips/sgi-ip27/ip27-memory.c:				if (dest_brd->brd_type == KLTYPE_IP27) {
./arch/mips/sgi-ip27/ip27-memory.c:					if (dest_brd->brd_nasid == nasid_a)
./arch/mips/sgi-ip27/ip27-memory.c:					if (dest_brd->brd_nasid == nasid_b)
./arch/mips/sgi-ip27/ip27-memory.c:			if (brd->brd_flags & DUPLICATE_BOARD)
./arch/mips/sgi-ip27/ip27-memory.c:			router = (klrou_t *)NODE_OFFSET_TO_K0(NASID_GET(brd), brd->brd_compts[0]);
./arch/mips/sgi-ip27/ip27-memory.c:				if (dest_brd->brd_type == KLTYPE_IP27)
./arch/mips/sgi-ip27/ip27-memory.c:					printk(" %d", dest_brd->brd_nasid);
./arch/mips/sgi-ip27/ip27-memory.c:				if (dest_brd->brd_type == KLTYPE_ROUTER)
./arch/mips/sgi-ip27/ip27-smp.c:		return brd->brd_nasid;
./arch/mips/sgi-ip27/ip27-smp.c:			if (get_actual_nasid(brd) == brd->brd_nasid)
./arch/ia64/sn/kernel/setup.c:			if (board_needs_cnode(brd->brd_type) && physical_node_map[brd->brd_nasid] < 0) {
./arch/ia64/sn/kernel/setup.c:				sn_cnodeid_to_nasid[num_cnodes] = brd->brd_nasid;
./arch/ia64/sn/kernel/setup.c:				physical_node_map[brd->brd_nasid] = num_cnodes++;
./arch/ia64/kernel/sal.c:		 * SGI Altix has hard-coded version 2.9 in their prom
./arch/arm/mach-imx/mach-mxt_td60.c:				"sdhc1-card-detect", data);
./arch/arm/mach-imx/mx31moboard-smartbot.c:#include <mach/board-mx31moboard.h>
./arch/arm/mach-imx/mach-pcm038.c:#include <mach/board-pcm038.h>
./arch/arm/mach-imx/mach-mx27_3ds.c:			IRQF_TRIGGER_RISING, "sdhc1-card-detect", data);
./arch/arm/mach-imx/mach-mx27ads.c:			   "sdhc1-card-detect", data);
./arch/arm/mach-imx/mach-mx27ads.c:			   "sdhc2-card-detect", data);
./arch/arm/mach-imx/mx31lite-db.c:#include <mach/board-mx31lite.h>
./arch/arm/mach-imx/mx31lite-db.c: * This file contains board-specific initialization routines for the
./arch/arm/mach-imx/mach-armadillo5x0.c:	ret = gpio_request(gpio_det, "sdhc-card-detect");
./arch/arm/mach-imx/mach-mx31_3ds.c:	{ MX31_3DS_GPIO_SDHC1_CD, GPIOF_IN, "sdhc1-card-detect" },
./arch/arm/mach-imx/mach-mx31_3ds.c:		pr_warning("Unable to request the SD/MMC card-detect IRQ.\n");
./arch/arm/mach-imx/mach-mx31lite.c:#include <mach/board-mx31lite.h>
./arch/arm/mach-imx/mach-mx31lite.c: * The MC13783 is the only hard-wired SPI device on the module.
./arch/arm/mach-imx/mx31lilly-db.c:#include <mach/board-mx31lilly.h>
./arch/arm/mach-imx/mx31lilly-db.c: * This file contains board-specific initialization routines for the
./arch/arm/mach-imx/mach-mx31ads.c:#include <mach/board-mx31ads.h>
./arch/arm/mach-imx/mx31moboard-devboard.c:		"sdhc2-card-detect", data);
./arch/arm/mach-imx/mx31moboard-marxbot.c:		"sdhc2-card-detect", data);
./arch/arm/mach-imx/mach-mx31moboard.c:#include <mach/board-mx31moboard.h>
./arch/arm/mach-imx/mach-mx31moboard.c:		.name = "coreboard-led-4:red",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name = "coreboard-led-4:green",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name = "coreboard-led-4:blue",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name = "coreboard-led-5:red",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name = "coreboard-led-5:green",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name = "coreboard-led-5:blue",
./arch/arm/mach-imx/mach-mx31moboard.c:		"sdhc1-card-detect", data);
./arch/arm/mach-imx/mach-mx31moboard.c:		.name	= "coreboard-led-0:red:running",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name	= "coreboard-led-1:red",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name	= "coreboard-led-2:red",
./arch/arm/mach-imx/mach-mx31moboard.c:		.name	= "coreboard-led-3:red",
./arch/arm/mach-imx/mach-mx31lilly.c:#include <mach/board-mx31lilly.h>
./arch/arm/mach-s3c2440/mach-gta02.c:		 * This name is also hard-coded in the boot loaders, so
./arch/arm/mach-clps711x/edb7211-arch.c:	 * detect them, but instead we hard-code them.
./arch/arm/mach-mxs/mach-mx28evk.c:	 * so hard-code Freescale OUI (00:04:9f) here.
./arch/arm/plat-s3c24xx/dma.c:			if (!is_channel_valid(ord->list[ch]))
./arch/arm/plat-s3c24xx/dma.c:			tmp = ord->list[ch] & ~DMA_CH_VALID;
./arch/arm/plat-s3c24xx/dma.c:		if (ord->flags & DMA_CH_NEVER)
./arch/arm/plat-s3c24xx/cpu-freq.c:		if (cpu_cur.board->auto_io) {
./arch/arm/plat-s3c24xx/cpu-freq.c:		if (cpu_cur.board->need_io && !cpu_cur.info->set_iotiming) {
./arch/arm/plat-s3c24xx/cpu-freq.c:		s3c_cpufreq_freq_min(&cpu_cur.max, &cpu_cur.board->max,
./arch/arm/plat-s3c24xx/s3c2412-iotiming.c:	refresh = (cfg->freq.hclk / 100) * (board->refresh / 10);
./arch/arm/plat-s3c24xx/s3c2410-cpufreq-utils.c:	refresh = (cfg->freq.hclk / 100) * (board->refresh / 10);
./arch/arm/plat-s3c24xx/cpu-freq-debugfs.c:	seq_printf(seq, "SDRAM refresh %u ns\n", brd->refresh);
./arch/arm/plat-s3c24xx/cpu-freq-debugfs.c:	seq_printf(seq, "auto_io=%u\n", brd->auto_io);
./arch/arm/plat-s3c24xx/cpu-freq-debugfs.c:	seq_printf(seq, "need_io=%u\n", brd->need_io);
./arch/arm/plat-s3c24xx/cpu-freq-debugfs.c:	show_max(seq, &brd->max);
./arch/arm/mach-davinci/dma.c: * controller will be word-at-a-time.
./arch/arm/mach-davinci/board-dm646x-evm.c: * Derived from: arch/arm/mach-davinci/board-evm.c
./arch/arm/mach-davinci/board-da830-evm.c: * Derived from: arch/arm/mach-davinci/board-dm644x-evm.c
./arch/arm/mach-davinci/board-dm355-leopard.c: * Based on board-dm355-evm.c
./arch/arm/mach-davinci/devices.c:			 * is a hard-wired SDIO device...
./arch/arm/mach-davinci/devices.c:			/* REVISIT: should this be in board-init code? */
./arch/arm/mach-davinci/dm355.c:	/* FIXME -- crystal rate is board-specific */
./arch/arm/mach-davinci/board-da850-evm.c: * Derived from: arch/arm/mach-davinci/board-da830-evm.c
./arch/arm/mach-pxa/mxm8x10.c:Card-Bus Interface  - Leave unconfigured for now...
./arch/arm/mach-pxa/zylonite.c:	/* board-processor specific initialization */
./arch/arm/mach-pxa/lpd270.c:		.name		= "mainboard-flash",
./arch/arm/mach-pxa/mainstone.c:	mst_flash_data[SW7 ^ 1].name = "mainboard-flash";
./arch/arm/mach-pxa/cm-x300.c:	/* board-processor specific GPIO initialization */
./arch/arm/mach-u300/regulator.c: * Handle board-bound regulators and board power not related
./arch/arm/mach-realview/realview_pb1176.c:#include <mach/board-pb1176.h>
./arch/arm/mach-realview/platsmp.c:#include <mach/board-eb.h>
./arch/arm/mach-realview/platsmp.c:#include <mach/board-pb11mp.h>
./arch/arm/mach-realview/platsmp.c:#include <mach/board-pbx.h>
./arch/arm/mach-realview/realview_pb11mp.c:#include <mach/board-pb11mp.h>
./arch/arm/mach-realview/realview_pbx.c:#include <mach/board-pbx.h>
./arch/arm/mach-realview/realview_pba8.c:#include <mach/board-pba8.h>
./arch/arm/mach-realview/realview_eb.c:#include <mach/board-eb.h>
./arch/arm/mach-ixp4xx/avila-setup.c: * Gateworks Avila board-setup
./arch/arm/mach-ixp4xx/dsmg600-setup.c: * DSM-G600 board-setup
./arch/arm/mach-ixp4xx/nslu2-pci.c: * NSLU2 board-level PCI initialization
./arch/arm/mach-ixp4xx/ixdp425-setup.c: * IXDP425/IXCDP1100 board-setup
./arch/arm/mach-ixp4xx/nslu2-setup.c: * NSLU2 board-setup
./arch/arm/mach-ixp4xx/fsg-pci.c: * FSG board-level PCI initialization
./arch/arm/mach-ixp4xx/vulcan-setup.c: * Arcom/Eurotech Vulcan board-setup
./arch/arm/mach-ixp4xx/nas100d-setup.c: * NAS 100d board-setup
./arch/arm/mach-ixp4xx/fsg-setup.c: * FSG board-setup
./arch/arm/mach-ixp4xx/nas100d-pci.c: * NAS 100d board-level PCI initialization
./arch/arm/mach-ixp4xx/dsmg600-pci.c: * DSM-G600 board-level PCI initialization
./arch/arm/mach-ixp4xx/vulcan-pci.c: * Vulcan board-level PCI initialization
./arch/arm/mach-ixp4xx/avila-pci.c: * Gateworks Avila board-level PCI initialization
./arch/arm/mach-ixp4xx/ixdp425-pci.c: * IXDP425 board-level PCI initialization
./arch/arm/mach-omap2/board-4430sdp.c: * Based on mach-omap2/board-3430sdp.c
./arch/arm/mach-omap2/board-4430sdp.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-omap3stalker.c: * linux/arch/arm/mach-omap2/board-omap3evm.c
./arch/arm/mach-omap2/board-omap3stalker.c: * Modified from mach-omap2/board-omap3evm.c
./arch/arm/mach-omap2/board-omap3stalker.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-2430sdp.c: * linux/arch/arm/mach-omap2/board-2430sdp.c
./arch/arm/mach-omap2/board-2430sdp.c: * Modified from mach-omap2/board-generic.c
./arch/arm/mach-omap2/board-2430sdp.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-omap3pandora.c: * board-omap3pandora.c (Pandora Handheld Console)
./arch/arm/mach-omap2/board-omap3pandora.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-omap3pandora.c:	card->quirks |= MMC_QUIRK_NONSTD_SDIO;
./arch/arm/mach-omap2/board-omap3pandora.c:	card->cccr.wide_bus = 1;
./arch/arm/mach-omap2/board-omap3pandora.c:	card->cis.vendor = 0x104c;
./arch/arm/mach-omap2/board-omap3pandora.c:	card->cis.device = 0x9066;
./arch/arm/mach-omap2/board-omap3pandora.c:	card->cis.blksize = 512;
./arch/arm/mach-omap2/board-omap3pandora.c:	card->cis.max_dtr = 20000000;
./arch/arm/mach-omap2/gpmc-smsc911x.c: * assume that pin multiplexing is done in the board-*.c file,
./arch/arm/mach-omap2/board-am3517crane.c: * Based on mach-omap2/board-am3517evm.c
./arch/arm/mach-omap2/board-omap3logic.c: * linux/arch/arm/mach-omap2/board-omap3logic.c
./arch/arm/mach-omap2/board-omap3logic.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/omap_l3_smx.c: * Called in hard-irq context. Caller should take care of locking
./arch/arm/mach-omap2/board-cm-t35.c: * board-cm-t35.c (CompuLab CM-T35 module)
./arch/arm/mach-omap2/board-cm-t35.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-zoom-peripherals.c: * Modified from mach-omap2/board-zoom2.c
./arch/arm/mach-omap2/board-zoom-peripherals.c:#include <mach/board-zoom.h>
./arch/arm/mach-omap2/board-zoom-peripherals.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-flash.c: * board-flash.c
./arch/arm/mach-omap2/board-flash.c: * Modified from mach-omap2/board-3430sdp-flash.c
./arch/arm/mach-omap2/board-flash.c:#include "board-flash.h"
./arch/arm/mach-omap2/board-am3517evm.c: * linux/arch/arm/mach-omap2/board-am3517evm.c
./arch/arm/mach-omap2/board-am3517evm.c: * Based on mach-omap2/board-omap3evm.c
./arch/arm/mach-omap2/board-rm680.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-n8x0.c: * linux/arch/arm/mach-omap2/board-n8x0.c
./arch/arm/mach-omap2/board-n8x0.c: * Modified from mach-omap2/board-generic.c
./arch/arm/mach-omap2/usb-fs.c:	/* NOTE:  board-specific code must set up pin muxing for usb1,
./arch/arm/mach-omap2/usb-fs.c:		/* NOTE: board-specific code must override this setting if
./arch/arm/mach-omap2/usb-fs.c:		/* NOTE: board-specific code must override this setting if
./arch/arm/mach-omap2/usb-fs.c:		/* NOTE: board-specific code must mux this setting depending
./arch/arm/mach-omap2/usb-tusb6010.c:/* this may be called only from board-*.c setup code */
./arch/arm/mach-omap2/board-3630sdp.c:#include <mach/board-zoom.h>
./arch/arm/mach-omap2/board-3630sdp.c:#include "board-flash.h"
./arch/arm/mach-omap2/board-3430sdp.c: * linux/arch/arm/mach-omap2/board-3430sdp.c
./arch/arm/mach-omap2/board-3430sdp.c: * Modified from mach-omap2/board-generic.c
./arch/arm/mach-omap2/board-3430sdp.c:#include "board-flash.h"
./arch/arm/mach-omap2/board-3430sdp.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-zoom.c: * Modified from mach-omap2/board-ldp.c
./arch/arm/mach-omap2/board-zoom.c:#include <mach/board-zoom.h>
./arch/arm/mach-omap2/board-zoom.c:#include "board-flash.h"
./arch/arm/mach-omap2/hsmmc.c:			 * need to be muxed in the board-*.c files
./arch/arm/mach-omap2/hsmmc.c:		 * For MMC3 the pins need to be muxed in the board-*.c files
./arch/arm/mach-omap2/board-omap3touchbook.c: * linux/arch/arm/mach-omap2/board-omap3touchbook.c
./arch/arm/mach-omap2/board-omap3touchbook.c: * Modified from mach-omap2/board-omap3beagleboard.c
./arch/arm/mach-omap2/board-omap3touchbook.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-cm-t3517.c: * linux/arch/arm/mach-omap2/board-cm-t3517.c
./arch/arm/mach-omap2/board-cm-t3517.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-ldp.c: * linux/arch/arm/mach-omap2/board-ldp.c
./arch/arm/mach-omap2/board-ldp.c: * Modified from mach-omap2/board-3430sdp.c
./arch/arm/mach-omap2/board-ldp.c:#include <mach/board-zoom.h>
./arch/arm/mach-omap2/board-ldp.c:#include "board-flash.h"
./arch/arm/mach-omap2/board-ldp.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/gpmc-smc91x.c: * assume that pin multiplexing is done in the board-*.c file,
./arch/arm/mach-omap2/usb-musb.c:	 * 100 mA ... but this value is board-specific, like
./arch/arm/mach-omap2/board-rx51-peripherals.c: * linux/arch/arm/mach-omap2/board-rx51-peripherals.c
./arch/arm/mach-omap2/board-rx51-peripherals.c:#include <mach/board-rx51.h>
./arch/arm/mach-omap2/board-rx51-peripherals.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-rx51-video.c: * linux/arch/arm/mach-omap2/board-rx51-video.c
./arch/arm/mach-omap2/board-rx51-video.c:#include <mach/board-rx51.h>
./arch/arm/mach-omap2/board-h4.c: * linux/arch/arm/mach-omap2/board-h4.c
./arch/arm/mach-omap2/board-h4.c: * Modified from mach-omap/omap1/board-generic.c
./arch/arm/mach-omap2/board-omap3evm.c: * linux/arch/arm/mach-omap2/board-omap3evm.c
./arch/arm/mach-omap2/board-omap3evm.c: * Modified from mach-omap2/board-3430sdp.c
./arch/arm/mach-omap2/board-omap3evm.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/common-board-devices.c: * common-board-devices.c
./arch/arm/mach-omap2/common-board-devices.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-apollon.c: * linux/arch/arm/mach-omap2/board-apollon.c
./arch/arm/mach-omap2/board-apollon.c: * Modified from mach-omap/omap2/board-h4.c
./arch/arm/mach-omap2/board-apollon.c: * the bootloader passes the board-specific data to the kernel.
./arch/arm/mach-omap2/prm2xxx_3xxx.c: * IP.  These modules may have multiple hard-reset lines that reset
./arch/arm/mach-omap2/prm2xxx_3xxx.c: * IP.  These modules may have multiple hard-reset lines that reset
./arch/arm/mach-omap2/board-omap4panda.c: * Based on mach-omap2/board-4430sdp.c
./arch/arm/mach-omap2/board-omap4panda.c: * Based on mach-omap2/board-3430sdp.c
./arch/arm/mach-omap2/board-omap4panda.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/omap_hwmod.c: * Intended for use by board-*.c files on boards with devices that
./arch/arm/mach-omap2/board-igep0020.c: * Modified from mach-omap2/board-generic.c
./arch/arm/mach-omap2/board-igep0020.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-zoom-display.c: * Modified from mach-omap2/board-zoom-peripherals.c
./arch/arm/mach-omap2/prm44xx.c: * IP.  These modules may have multiple hard-reset lines that reset
./arch/arm/mach-omap2/prm44xx.c: * IP.  These modules may have multiple hard-reset lines that reset
./arch/arm/mach-omap2/board-rx51.c: * linux/arch/arm/mach-omap2/board-rx51.c
./arch/arm/mach-omap2/board-generic.c: * linux/arch/arm/mach-omap2/board-generic.c
./arch/arm/mach-omap2/board-generic.c: * Modified from mach-omap/omap1/board-generic.c
./arch/arm/mach-omap2/board-generic.c: * the bootloader passes the board-specific data to the kernel.
./arch/arm/mach-omap2/board-overo.c: * board-overo.c (Gumstix Overo)
./arch/arm/mach-omap2/board-overo.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-omap3beagle.c: * linux/arch/arm/mach-omap2/board-omap3beagle.c
./arch/arm/mach-omap2/board-omap3beagle.c: * Modified from mach-omap2/board-3430sdp.c
./arch/arm/mach-omap2/board-omap3beagle.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/timer-gp.c: * Meant to be called from board-*.c files in the event that GPTIMER1, the
./arch/arm/mach-omap2/board-devkit8000.c: * board-devkit8000.c - TimLL Devkit8000
./arch/arm/mach-omap2/board-devkit8000.c: * Modified from mach-omap2/board-omap3beagle.c
./arch/arm/mach-omap2/board-devkit8000.c:#include "common-board-devices.h"
./arch/arm/mach-omap2/board-zoom-debugboard.c:#include <mach/board-zoom.h>
./arch/arm/mach-shmobile/board-ag5evm.c: * arch/arm/mach-shmobile/board-ag5evm.c
./arch/arm/mach-tegra/board-paz00.c: * arch/arm/mach-tegra/board-paz00.c
./arch/arm/mach-tegra/board-paz00.c: * Based on board-harmony.c
./arch/arm/mach-tegra/board-paz00.c:#include "board-paz00.h"
./arch/arm/mach-tegra/common.c: * arch/arm/mach-tegra/board-harmony.c
./arch/arm/mach-tegra/board-paz00-pinmux.c: * arch/arm/mach-tegra/board-paz00-pinmux.c
./arch/arm/mach-tegra/board-paz00-pinmux.c:#include "board-paz00.h"
./arch/arm/mach-tegra/board-harmony-pcie.c: * arch/arm/mach-tegra/board-harmony-pcie.c
./arch/arm/mach-tegra/board-trimslice.c: * arch/arm/mach-tegra/board-trimslice.c
./arch/arm/mach-tegra/board-trimslice.c: * Based on board-harmony.c
./arch/arm/mach-tegra/board-trimslice.c:#include "board-trimslice.h"
./arch/arm/mach-tegra/board-harmony.c: * arch/arm/mach-tegra/board-harmony.c
./arch/arm/mach-tegra/board-harmony.c:#include "board-harmony.h"
./arch/arm/mach-tegra/board-harmony-pinmux.c: * arch/arm/mach-tegra/board-harmony-pinmux.c
./arch/arm/mach-tegra/board-harmony-pinmux.c:#include "board-harmony.h"
./arch/arm/mach-tegra/board-seaboard.c:#include "board-seaboard.h"
./arch/arm/mach-tegra/devices.c: * See board-harmony.c for an example
./arch/arm/mach-tegra/board-seaboard-pinmux.c:#include "board-seaboard.h"
./arch/arm/mach-tegra/board-harmony-power.c:#include "board-harmony.h"
./arch/arm/mach-tegra/board-trimslice-pinmux.c: * arch/arm/mach-tegra/board-trimslice-pinmux.c
./arch/arm/mach-tegra/board-trimslice-pinmux.c:#include "board-trimslice.h"
./arch/arm/mach-at91/clock.c:		 * multiplier is hard-wired to 40
./arch/arm/mach-at91/at91rm9200_devices.c: * These devices are always present and don't need any board-specific
./arch/arm/mach-at91/board-sam9m10g45ek.c: *  Board-specific setup code for the AT91SAM9M10G45 Evaluation Kit family
./arch/arm/mach-at91/board-usb-a9263.c: * linux/arch/arm/mach-at91/board-usb-a9263.c
./arch/arm/mach-at91/board-1arm.c: * linux/arch/arm/mach-at91/board-1arm.c
./arch/arm/mach-at91/board-afeb-9260v1.c: * linux/arch/arm/mach-at91/board-afeb-9260v1.c
./arch/arm/mach-at91/board-eb01.c: * arch/arm/mach-at91/board-eb01.c
./arch/arm/mach-at91/board-cam60.c: * based on board-sam9260ek.c
./arch/arm/mach-at91/board-snapper9260.c: * linux/arch/arm/mach-at91/board-snapper9260.c
./arch/arm/mach-at91/board-sam9g20ek.c:	.supply_name	= "board-3V3",
./arch/arm/mach-at91/board-picotux200.c: * linux/arch/arm/mach-at91/board-picotux200.c
./arch/arm/mach-at91/at91sam9263_devices.c: * These devices are always present and don't need any board-specific
./arch/arm/mach-at91/board-pcontrol-g20.c: * copied and adjusted from board-stamp9g20.c
./arch/arm/mach-at91/board-kb9202.c: * linux/arch/arm/mach-at91/board-kb9202.c
./arch/arm/mach-at91/board-qil-a9260.c: * linux/arch/arm/mach-at91/board-qil-a9260.c
./arch/arm/mach-at91/board-flexibity.c: * linux/arch/arm/mach-at91/board-flexibity.c
./arch/arm/mach-at91/at91sam9261_devices.c: * These devices are always present and don't need any board-specific
./arch/arm/mach-at91/board-csb637.c: * linux/arch/arm/mach-at91/board-csb637.c
./arch/arm/mach-at91/board-rm9200dk.c: * linux/arch/arm/mach-at91/board-rm9200dk.c
./arch/arm/mach-at91/board-usb-a9260.c: * linux/arch/arm/mach-at91/board-usb-a9260.c
./arch/arm/mach-at91/board-csb337.c: * linux/arch/arm/mach-at91/board-csb337.c
./arch/arm/mach-at91/board-eb9200.c: * linux/arch/arm/mach-at91/board-eb9200.c
./arch/arm/mach-at91/board-sam9260ek.c: * linux/arch/arm/mach-at91/board-sam9260ek.c
./arch/arm/mach-at91/board-yl-9200.c: * linux/arch/arm/mach-at91/board-yl-9200.c
./arch/arm/mach-at91/pm.c:		/* board-specific code enabled the wakeup sources */
./arch/arm/mach-at91/board-neocore926.c: * linux/arch/arm/mach-at91/board-neocore926.c
./arch/arm/mach-at91/board-cap9adk.c: * linux/arch/arm/mach-at91/board-cap9adk.c
./arch/arm/mach-at91/board-rm9200ek.c: * linux/arch/arm/mach-at91/board-rm9200ek.c
./arch/arm/mach-at91/board-sam9261ek.c: * linux/arch/arm/mach-at91/board-sam9261ek.c
./arch/arm/mach-at91/board-cpuat91.c: * linux/arch/arm/mach-at91/board-cpuat91.c
./arch/arm/mach-at91/at91cap9_devices.c: * These devices are always present and don't need any board-specific
./arch/arm/mach-at91/board-sam9263ek.c: * linux/arch/arm/mach-at91/board-sam9263ek.c
./arch/arm/mach-at91/board-ecbat91.c: * linux/arch/arm/mach-at91rm9200/board-ecbat91.c
./arch/arm/mach-at91/board-ecbat91.c: * We started from board-dk.c, which is Copyright (C) 2005 SAN People.
./arch/arm/mach-at91/at91sam9260_devices.c: * These devices are always present and don't need any board-specific
./arch/arm/mach-at91/at91sam9g45_devices.c: * These devices are always present and don't need any board-specific
./arch/arm/mach-at91/board-carmeva.c: * linux/arch/arm/mach-at91/board-carmeva.c
./arch/arm/mach-at91/board-cpu9krea.c: * linux/arch/arm/mach-at91/board-cpu9krea.c
./arch/arm/mach-at91/at91sam9rl_devices.c: * These devices are always present and don't need any board-specific
./arch/arm/mach-at91/board-sam9-l9260.c: * linux/arch/arm/mach-at91/board-sam9-l9260.c
./arch/arm/mach-at91/board-kafa.c: * linux/arch/arm/mach-at91/board-kafa.c
./arch/arm/mach-nomadik/board-nhk8815.c: *  linux/arch/arm/mach-nomadik/board-8815nhk.c
./arch/arm/mach-s5pv210/setup-sdhci.c:		if (card->type == MMC_TYPE_MMC)  /* MMC */
./arch/arm/mach-s5pv210/setup-sdhci.c:			//if(card->type & MMC_TYPE_SDIO)
./arch/arm/plat-omap/omap-pm-noop.c: * Device-driver-originated constraints (via board-*.c files)
./arch/arm/plat-omap/omap-pm-noop.c:	 * OPP ID using the tables defined in board-*.c/chip-*.c files.
./arch/arm/plat-omap/common.c:	/* Try to find the config from the board-specific structures
./arch/arm/plat-omap/debug-devices.c: * Modified from mach-omap2/board-h4.c
./arch/arm/plat-omap/devices.c:	/* board-specific code must configure chipselects (only a few
./arch/arm/plat-omap/devices.c: * This gets called after board-specific INIT_MACHINE, and initializes most
./arch/arm/plat-omap/devices.c: *  (a) Does any "standard config" pin muxing needed.  Board-specific
./arch/arm/plat-omap/devices.c: *  (b) Populating board-specific platform_data with the data drivers
./arch/arm/plat-omap/devices.c: * Board-specific knowledge like creating devices or pin setup is to be
./arch/arm/mach-orion5x/rd88f5181l-ge-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/db88f5281-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/rd88f5182-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/wnr854t-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/ts209-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/ts409-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/wrt350n-v2-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/mss2-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/dns323-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/kurobox_pro-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/terastation_pro2-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-orion5x/rd88f5181l-fxo-setup.c:	 * Check for devices with hard-wired IRQs.
./arch/arm/mach-ux500/board-mop500-uib.c:#include "board-mop500.h"
./arch/arm/mach-ux500/board-mop500-regulators.c:#include "board-mop500-regulators.h"
./arch/arm/mach-ux500/usb.c:		.name   = "mc", /* hard-coded in musb */
./arch/arm/mach-ux500/board-mop500.c:#include "board-mop500.h"
./arch/arm/mach-ux500/board-mop500.c:#include "board-mop500-regulators.h"
./arch/arm/mach-ux500/board-mop500-u8500uib.c:#include "board-mop500.h"
./arch/arm/mach-ux500/board-mop500-stuib.c:#include "board-mop500.h"
./arch/arm/mach-ux500/board-mop500-sdi.c:#include "board-mop500.h"
./arch/arm/mach-kirkwood/openrd-setup.c: * arch/arm/mach-kirkwood/openrd-setup.c
./arch/arm/mach-mx5/board-cpuimx51sd.c: * based on board-mx51_babbage.c which is
./arch/arm/mach-mx5/board-cpuimx51.c: * based on board-mx51_babbage.c which is
./arch/arm/mach-ixp23xx/roadrunner.c: * RoadRunner board-specific routines
./arch/arm/mach-ixp23xx/ixdp2351.c: * IXDP2351 board-specific routines
./arch/arm/mach-s3c2412/cpu-freq.c:		     board->refresh, cfg->freq.hclk);
./arch/arm/mach-s3c2412/cpu-freq.c:	refresh = (board->refresh / 10);
./arch/arm/kernel/ptrace.c:		 * of sizes, so pretend that the registers are word-sized:
./arch/arm/kernel/ptrace.c:		 * Pretend that the VFP regs are word-sized, since the FPSCR is
./arch/arm/mach-omap1/board-htcherald.c: * Based on the board-htcwizard.c file from the linwizard project:
./arch/arm/mach-omap1/board-palmz71.c: * linux/arch/arm/mach-omap1/board-palmz71.c
./arch/arm/mach-omap1/board-palmz71.c: * Modified from board-generic.c
./arch/arm/mach-omap1/board-h3-mmc.c: * linux/arch/arm/mach-omap1/board-h3-mmc.c
./arch/arm/mach-omap1/board-h3-mmc.c: * This code is based on linux/arch/arm/mach-omap2/board-n800-mmc.c, which is:
./arch/arm/mach-omap1/board-h3-mmc.c:#include "board-h3.h"
./arch/arm/mach-omap1/board-palmtt.c: * linux/arch/arm/mach-omap1/board-palmtt.c
./arch/arm/mach-omap1/board-palmtt.c: * Modified from board-palmtt2.c
./arch/arm/mach-omap1/board-osk.c: * linux/arch/arm/mach-omap1/board-osk.c
./arch/arm/mach-omap1/usb.c: * Some board-*.c files will need to set up additional mux options,
./arch/arm/mach-omap1/usb.c: *  - 5912 OSK OHCI (with usb0 standard-A), standard A-to-B cables
./arch/arm/mach-omap1/board-fsample.c: * linux/arch/arm/mach-omap1/board-fsample.c
./arch/arm/mach-omap1/board-fsample.c: * Modified from board-perseus2.c
./arch/arm/mach-omap1/board-fsample.c:	/* Early, board-dependent init */
./arch/arm/mach-omap1/board-h2.c: * linux/arch/arm/mach-omap1/board-h2.c
./arch/arm/mach-omap1/board-h2.c:#include "board-h2.h"
./arch/arm/mach-omap1/board-innovator.c: * linux/arch/arm/mach-omap1/board-innovator.c
./arch/arm/mach-omap1/devices.c: * This gets called after board-specific INIT_MACHINE, and initializes most
./arch/arm/mach-omap1/devices.c: *  (a) Does any "standard config" pin muxing needed.  Board-specific
./arch/arm/mach-omap1/devices.c: *  (b) Populating board-specific platform_data with the data drivers
./arch/arm/mach-omap1/devices.c: * Board-specific knowledge like creating devices or pin setup is to be
./arch/arm/mach-omap1/board-voiceblue.c: * linux/arch/arm/mach-omap1/board-voiceblue.c
./arch/arm/mach-omap1/board-voiceblue.c: * Modified from board-generic.c
./arch/arm/mach-omap1/board-voiceblue.c:#include <plat/board-voiceblue.h>
./arch/arm/mach-omap1/board-sx1.c:* linux/arch/arm/mach-omap1/board-sx1.c
./arch/arm/mach-omap1/board-sx1.c:* Modified from board-generic.c
./arch/arm/mach-omap1/board-sx1.c:#include <plat/board-sx1.h>
./arch/arm/mach-omap1/board-perseus2.c: * linux/arch/arm/mach-omap1/board-perseus2.c
./arch/arm/mach-omap1/board-perseus2.c: * Modified from board-generic.c
./arch/arm/mach-omap1/board-perseus2.c:	/* Early, board-dependent init */
./arch/arm/mach-omap1/board-ams-delta.c: * linux/arch/arm/mach-omap1/board-ams-delta.c
./arch/arm/mach-omap1/board-ams-delta.c: * Modified from board-generic.c
./arch/arm/mach-omap1/board-ams-delta.c:#include <plat/board-ams-delta.h>
./arch/arm/mach-omap1/board-palmte.c: * linux/arch/arm/mach-omap1/board-palmte.c
./arch/arm/mach-omap1/board-palmte.c: * Modified from board-generic.c
./arch/arm/mach-omap1/board-generic.c: * linux/arch/arm/mach-omap1/board-generic.c
./arch/arm/mach-omap1/board-generic.c: * Modified from board-innovator1510.c
./arch/arm/mach-omap1/board-sx1-mmc.c: * linux/arch/arm/mach-omap1/board-sx1-mmc.c
./arch/arm/mach-omap1/board-sx1-mmc.c: * This code is based on linux/arch/arm/mach-omap1/board-h2-mmc.c, which is:
./arch/arm/mach-omap1/board-sx1-mmc.c:#include <plat/board-sx1.h>
./arch/arm/mach-omap1/board-h3.c: * linux/arch/arm/mach-omap1/board-h3.c
./arch/arm/mach-omap1/board-h3.c:#include "board-h3.h"
./arch/arm/mach-omap1/ams-delta-fiq.c:#include <plat/board-ams-delta.h>
./arch/arm/mach-omap1/board-nokia770.c: * linux/arch/arm/mach-omap1/board-nokia770.c
./arch/arm/mach-omap1/board-nokia770.c: * Modified from board-generic.c
./arch/arm/mach-omap1/board-h2-mmc.c: * linux/arch/arm/mach-omap1/board-h2-mmc.c
./arch/arm/mach-omap1/board-h2-mmc.c: * This code is based on linux/arch/arm/mach-omap2/board-n800-mmc.c, which is:
./arch/arm/mach-omap1/board-h2-mmc.c:#include "board-h2.h"
./arch/arm/mach-msm/board-trout-gpio.c:#include "board-trout.h"
./arch/arm/mach-msm/board-mahimahi.c:/* linux/arch/arm/mach-msm/board-mahimahi.c
./arch/arm/mach-msm/board-mahimahi.c:#include "board-mahimahi.h"
./arch/arm/mach-msm/board-sapphire.c:/* linux/arch/arm/mach-msm/board-sapphire.c
./arch/arm/mach-msm/board-sapphire.c:#include "board-sapphire.h"
./arch/arm/mach-msm/board-trout-panel.c:/* linux/arch/arm/mach-msm/board-trout-mddi.c
./arch/arm/mach-msm/board-trout-panel.c:#include "board-trout.h"
./arch/arm/mach-msm/board-halibut.c:/* linux/arch/arm/mach-msm/board-halibut.c
./arch/arm/mach-msm/board-trout-mmc.c:/* linux/arch/arm/mach-msm/board-trout-mmc.c
./arch/arm/mach-msm/board-trout-mmc.c:#include "board-trout.h"
./arch/arm/mach-msm/board-trout.c:/* linux/arch/arm/mach-msm/board-trout.c
./arch/arm/mach-msm/board-trout.c:#include "board-trout.h"
./arch/arm/mach-exynos4/setup-sdhci.c:	/* don't need to alter anything according to card-type */
./arch/arm/mach-s5pc100/setup-sdhci.c:	/* don't need to alter anything according to card-type */
./arch/arm/mach-ks8695/pci.c:	ks8695_pci.map_irq = cfg->map_irq;	/* board-specific map_irq method */
./arch/arm/mach-ks8695/board-dsm320.c: * arch/arm/mach-ks8695/board-dsm320.c
./arch/arm/mach-ks8695/board-acs5k.c: * arch/arm/mach-ks8695/board-acs5k.c
./arch/arm/mach-ks8695/board-micrel.c: * arch/arm/mach-ks8695/board-micrel.c
./arch/arm/mach-ks8695/devices.c: * These devices are always present and don't need any board-specific
./arch/arm/common/pl330.c:	return (IS_FREE(&thrd->req[0]) && IS_FREE(&thrd->req[1]))
./arch/arm/common/pl330.c:	return (IS_FREE(&thrd->req[0]) || IS_FREE(&thrd->req[1]))
./arch/arm/common/pl330.c:	struct pl330_dmac *pl330 = thrd->dmac;
./arch/arm/common/pl330.c:	if (thrd->id == pl330->pinfo->pcfg.num_chan)
./arch/arm/common/pl330.c:	struct pl330_dmac *pl330 = thrd->dmac;
./arch/arm/common/pl330.c:	void __iomem *regs = thrd->dmac->pinfo->base;
./arch/arm/common/pl330.c:	void __iomem *regs = thrd->dmac->pinfo->base;
./arch/arm/common/pl330.c:		val |= (thrd->id << 8); /* Channel Number */
./arch/arm/common/pl330.c:		dev_err(thrd->dmac->pinfo->dev, "DMAC halted!\n");
./arch/arm/common/pl330.c:	void __iomem *regs = thrd->dmac->pinfo->base;
./arch/arm/common/pl330.c:		val = readl(regs + CS(thrd->id)) & 0xf;
./arch/arm/common/pl330.c:	void __iomem *regs = thrd->dmac->pinfo->base;
./arch/arm/common/pl330.c:	u32 buf = req->mc_bus, pc = readl(regs + CPC(thrd->id));
./arch/arm/common/pl330.c:	if (_req_active(thrd, &thrd->req[0]))
./arch/arm/common/pl330.c:	if (_req_active(thrd, &thrd->req[1]))
./arch/arm/common/pl330.c:	void __iomem *regs = thrd->dmac->pinfo->base;
./arch/arm/common/pl330.c:	writel(readl(regs + INTEN) & ~(1 << thrd->ev), regs + INTEN);
./arch/arm/common/pl330.c:	void __iomem *regs = thrd->dmac->pinfo->base;
./arch/arm/common/pl330.c:	if (!IS_FREE(&thrd->req[1 - thrd->lstenq]))
./arch/arm/common/pl330.c:		req = &thrd->req[1 - thrd->lstenq];
./arch/arm/common/pl330.c:	else if (!IS_FREE(&thrd->req[thrd->lstenq]))
./arch/arm/common/pl330.c:		req = &thrd->req[thrd->lstenq];
./arch/arm/common/pl330.c:	else if (readl(regs + CS(thrd->id)) & CS_CNS)
./arch/arm/common/pl330.c:		dev_info(thrd->dmac->pinfo->dev, "%s:%d Recipe for ABORT!\n",
./arch/arm/common/pl330.c:	go.chan = thrd->id;
./arch/arm/common/pl330.c:	writel(readl(regs + INTEN) | (1 << thrd->ev), regs + INTEN);
./arch/arm/common/pl330.c:	struct _pl330_req *req = &thrd->req[index];
./arch/arm/common/pl330.c:	off += _emit_SEV(dry_run, &buf[off], thrd->ev);
./arch/arm/common/pl330.c:	if (!r || !thrd || thrd->free)
./arch/arm/common/pl330.c:	pl330 = thrd->dmac;
./arch/arm/common/pl330.c:		|| pl330->dmac_tbd.reset_chan & (1 << thrd->id)) {
./arch/arm/common/pl330.c:		dev_info(thrd->dmac->pinfo->dev, "%s:%d\n",
./arch/arm/common/pl330.c:		dev_info(thrd->dmac->pinfo->dev,
./arch/arm/common/pl330.c:		ccr = readl(regs + CC(thrd->id));
./arch/arm/common/pl330.c:		dev_info(thrd->dmac->pinfo->dev, "%s:%d Invalid CCR(%x)!\n",
./arch/arm/common/pl330.c:	idx = IS_FREE(&thrd->req[0]) ? 0 : 1;
./arch/arm/common/pl330.c:		dev_info(thrd->dmac->pinfo->dev,
./arch/arm/common/pl330.c:	thrd->lstenq = idx;
./arch/arm/common/pl330.c:	thrd->req[idx].mc_len = _setup_req(0, thrd, idx, &xs);
./arch/arm/common/pl330.c:	thrd->req[idx].r = r;
./arch/arm/common/pl330.c:			if (readl(regs + FSC) & (1 << thrd->id))
./arch/arm/common/pl330.c:			_callback(thrd->req[1 - thrd->lstenq].r, err);
./arch/arm/common/pl330.c:			_callback(thrd->req[thrd->lstenq].r, err);
./arch/arm/common/pl330.c:			thrd->req[0].r = NULL;
./arch/arm/common/pl330.c:			thrd->req[1].r = NULL;
./arch/arm/common/pl330.c:			MARK_FREE(&thrd->req[0]);
./arch/arm/common/pl330.c:			MARK_FREE(&thrd->req[1]);
./arch/arm/common/pl330.c:			rqdone = &thrd->req[active];
./arch/arm/common/pl330.c:	if (!thrd || thrd->free || thrd->dmac->state == DYING)
./arch/arm/common/pl330.c:	pl330 = thrd->dmac;
./arch/arm/common/pl330.c:		thrd->req[0].r = NULL;
./arch/arm/common/pl330.c:		thrd->req[1].r = NULL;
./arch/arm/common/pl330.c:		MARK_FREE(&thrd->req[0]);
./arch/arm/common/pl330.c:		MARK_FREE(&thrd->req[1]);
./arch/arm/common/pl330.c:		thrd->req[active].r = NULL;
./arch/arm/common/pl330.c:		MARK_FREE(&thrd->req[active]);
./arch/arm/common/pl330.c:	if (!pstatus || !thrd || thrd->free)
./arch/arm/common/pl330.c:	pl330 = thrd->dmac;
./arch/arm/common/pl330.c:	if (val & (1 << thrd->id))
./arch/arm/common/pl330.c:		pstatus->top_req = thrd->req[active].r;
./arch/arm/common/pl330.c:		pstatus->wait_req = !IS_FREE(&thrd->req[1 - active])
./arch/arm/common/pl330.c:					? thrd->req[1 - active].r : NULL;
./arch/arm/common/pl330.c:	pstatus->src_addr = readl(regs + SA(thrd->id));
./arch/arm/common/pl330.c:	pstatus->dst_addr = readl(regs + DA(thrd->id));
./arch/arm/common/pl330.c:	struct pl330_dmac *pl330 = thrd->dmac;
./arch/arm/common/pl330.c:			pl330->events[ev] = thrd->id;
./arch/arm/common/pl330.c:		if (thrd->free) {
./arch/arm/common/pl330.c:			thrd->ev = _alloc_event(thrd);
./arch/arm/common/pl330.c:			if (thrd->ev >= 0) {
./arch/arm/common/pl330.c:				thrd->free = false;
./arch/arm/common/pl330.c:				thrd->lstenq = 1;
./arch/arm/common/pl330.c:				thrd->req[0].r = NULL;
./arch/arm/common/pl330.c:				MARK_FREE(&thrd->req[0]);
./arch/arm/common/pl330.c:				thrd->req[1].r = NULL;
./arch/arm/common/pl330.c:				MARK_FREE(&thrd->req[1]);
./arch/arm/common/pl330.c:	struct pl330_dmac *pl330 = thrd->dmac;
./arch/arm/common/pl330.c:			&& pl330->events[ev] == thrd->id)
./arch/arm/common/pl330.c:	if (!thrd || thrd->free)
./arch/arm/common/pl330.c:	_callback(thrd->req[1 - thrd->lstenq].r, PL330_ERR_ABORT);
./arch/arm/common/pl330.c:	_callback(thrd->req[thrd->lstenq].r, PL330_ERR_ABORT);
./arch/arm/common/pl330.c:	pl330 = thrd->dmac;
./arch/arm/common/pl330.c:	_free_event(thrd, thrd->ev);
./arch/arm/common/pl330.c:	thrd->free = true;
./arch/arm/common/pl330.c:	struct pl330_dmac *pl330 = thrd->dmac;
./arch/arm/common/pl330.c:	thrd->req[0].mc_cpu = pl330->mcode_cpu
./arch/arm/common/pl330.c:				+ (thrd->id * pi->mcbufsz);
./arch/arm/common/pl330.c:	thrd->req[0].mc_bus = pl330->mcode_bus
./arch/arm/common/pl330.c:				+ (thrd->id * pi->mcbufsz);
./arch/arm/common/pl330.c:	thrd->req[0].r = NULL;
./arch/arm/common/pl330.c:	MARK_FREE(&thrd->req[0]);
./arch/arm/common/pl330.c:	thrd->req[1].mc_cpu = thrd->req[0].mc_cpu
./arch/arm/common/pl330.c:	thrd->req[1].mc_bus = thrd->req[0].mc_bus
./arch/arm/common/pl330.c:	thrd->req[1].r = NULL;
./arch/arm/common/pl330.c:	MARK_FREE(&thrd->req[1]);
./arch/arm/common/pl330.c:		thrd->id = i;
./arch/arm/common/pl330.c:		thrd->dmac = pl330;
./arch/arm/common/pl330.c:		thrd->free = true;
./arch/arm/common/pl330.c:	thrd->id = chans;
./arch/arm/common/pl330.c:	thrd->dmac = pl330;
./arch/arm/common/pl330.c:	thrd->free = false;
./arch/alpha/kernel/sys_sable.c:		/* Must be a card-based bridge.  */
./arch/alpha/kernel/io.c:	/* The tail is word-aligned if we still have count >= 4 */
./arch/alpha/kernel/sys_ruffian.c:		/* Must be a card-based bridge.  */
./arch/alpha/kernel/sys_noritake.c:		/* Must be a card-based bridge.  */
./arch/alpha/kernel/sys_eiger.c:		/* Must be a card-based bridge.  */
./arch/alpha/kernel/sys_miata.c:		/* Must be a card-based bridge.  */
./arch/alpha/kernel/sys_dp264.c:		/* Must be a card-based bridge.  */
./arch/alpha/kernel/sys_takara.c:		/* Must be a card-based bridge.  */
./arch/alpha/kernel/sys_takara.c:		       "card-bridge behind builtin bridge yet.\n");
./arch/m68k/mac/config.c:	const u_long *data = record->data;
./arch/m68k/mac/config.c:	switch (record->tag) {
./arch/m68k/amiga/config.c:	const unsigned long *data = record->data;
./arch/m68k/amiga/config.c:	switch (record->tag) {
./arch/m68k/atari/ataints.c: * hard-code the MFP register address and value, are necessary to mask the
./arch/m68k/atari/config.c:	const u_long *data = record->data;
./arch/m68k/atari/config.c:	switch (record->tag) {
./arch/m68k/hp300/config.c:	const unsigned long *data = record->data;
./arch/m68k/hp300/config.c:	switch (record->tag) {
./arch/m68k/kernel/setup_mm.c:	while (record->tag != BI_LAST) {
./arch/m68k/kernel/setup_mm.c:		const unsigned long *data = record->data;
./arch/m68k/kernel/setup_mm.c:		switch (record->tag) {
./arch/m68k/kernel/setup_mm.c:			       record->tag);
./arch/m68k/kernel/setup_mm.c:					      record->size);
./arch/m68k/apollo/config.c:	const unsigned long *data = record->data;
./arch/m68k/apollo/config.c:	switch(record->tag) {
./arch/powerpc/boot/main.c:	setprop_val(chosen, "linux,initrd-start", (u32)(initrd_addr));
./arch/powerpc/boot/main.c:	setprop_val(chosen, "linux,initrd-end", (u32)(initrd_addr+initrd_size));
./arch/powerpc/boot/ps3.c:		setprop_val(chosen, "linux,initrd-start", (u32)(_initrd_start));
./arch/powerpc/boot/ps3.c:		setprop_val(chosen, "linux,initrd-end", (u32)(_initrd_end));
./arch/powerpc/mm/slb.c:	 * We need interrupts hard-disabled here, not just soft-disabled,
./arch/powerpc/mm/stab.c:	 * We need interrupts hard-disabled here, not just soft-disabled,
./arch/powerpc/kernel/prom_init.c:		prom_setprop(_prom->chosen, "/chosen", "linux,initrd-start",
./arch/powerpc/kernel/prom_init.c:		prom_setprop(_prom->chosen, "/chosen", "linux,initrd-end",
./arch/powerpc/kernel/perf_event_fsl_emb.c:	 * are soft-disabled, as long as interrupts are hard-enabled.
./arch/powerpc/kernel/perf_event_fsl_emb.c: * things if requested.  Note that interrupts are hard-disabled
./arch/powerpc/kernel/irq.c:	 * Need to hard-enable interrupts here.  Since currently disabled,
./arch/powerpc/kernel/perf_event.c:	 * are soft-disabled, as long as interrupts are hard-enabled.
./arch/powerpc/kernel/perf_event.c: * things if requested.  Note that interrupts are hard-disabled
./arch/powerpc/kernel/rtas.c: * is why the token is hard-coded to 10.
./arch/powerpc/platforms/embedded6xx/gamecube.c: * Nintendo GameCube board-specific support
./arch/powerpc/platforms/embedded6xx/wii.c: * Nintendo Wii board-specific support
./arch/powerpc/platforms/85xx/xes_mpc85xx.c: * X-ES board-specific functionality
./arch/powerpc/platforms/85xx/p1022_ds.c: * Board-specific initialization of the DIU.  This code should probably be
./arch/powerpc/platforms/iseries/dt.c:		dt_prop_u64(dt, "linux,initrd-start", (u64)naca.xRamDisk);
./arch/powerpc/platforms/iseries/dt.c:		dt_prop_u64(dt, "linux,initrd-end",
./arch/powerpc/platforms/powermac/bootx_init.c:		bootx_dt_add_prop("linux,initrd-start", &val, 4, mem_end);
./arch/powerpc/platforms/powermac/bootx_init.c:		bootx_dt_add_prop("linux,initrd-end", &val, 4, mem_end);
./arch/powerpc/platforms/powermac/bootx_init.c:		bootx_dt_add_string("linux,initrd-start", mem_end);
./arch/powerpc/platforms/powermac/bootx_init.c:		bootx_dt_add_string("linux,initrd-end", mem_end);
./arch/tile/lib/memcpy_64.c:	/* Copy bytes until dst is word-aligned. */
./arch/tile/lib/memcpy_64.c:		/* src8 and dst8 are both word-aligned. */
./arch/tile/mm/fault.c: * Synthesize the fault a PL0 process would get by doing a word-load of
./arch/cris/arch-v32/kernel/signal.c:	/* Make sure the frame is dword-aligned. */
./arch/cris/arch-v10/kernel/signal.c:	/* make sure the frame is dword-aligned */
./arch/cris/arch-v10/drivers/eeprom.c:   *        is probably to define your model within #ifdef's, and hard-
./sound/soc/soc-jack.c:	return snd_jack_new(codec->card->snd_card, id, type, &jack->jack);
./sound/soc/soc-jack.c:	struct device *dev = gpio->jack->codec->card->dev;
./sound/soc/txx9/txx9aclc.c:		card->dev, 64 * 1024, 4 * 1024 * 1024);
./sound/soc/kirkwood/kirkwood-dma.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/kirkwood/kirkwood-dma.c:	buf->area = dma_alloc_coherent(pcm->card->dev, size,
./sound/soc/kirkwood/kirkwood-dma.c:	if (!card->dev->dma_mask)
./sound/soc/kirkwood/kirkwood-dma.c:		card->dev->dma_mask = &kirkwood_dma_dmamask;
./sound/soc/kirkwood/kirkwood-dma.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/kirkwood/kirkwood-dma.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/kirkwood/kirkwood-dma.c:		dma_free_coherent(pcm->card->dev, buf->bytes,
./sound/soc/pxa/pxa2xx-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/pxa/pxa2xx-pcm.c:		card->dev->dma_mask = &pxa2xx_pcm_dmamask;
./sound/soc/pxa/pxa2xx-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/pxa/pxa2xx-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/pxa/zylonite.c:			dev_err(card->dev, "Unable to obtain CLK_POUT: %ld\n",
./sound/soc/pxa/zylonite.c:			dev_err(card->dev, "Unable to enable CLK_POUT: %d\n",
./sound/soc/pxa/zylonite.c:		dev_dbg(card->dev, "MCLK enabled at %luHz\n",
./sound/soc/pxa/zylonite.c:			dev_err(card->dev, "Unable to enable CLK_POUT: %d\n",
./sound/soc/au1x/dbdma2.c:		card->dev, AU1XPSC_BUFFER_MIN_BYTES, (4096 * 1024) - 1);
./sound/soc/au1x/psc-ac97.c:/* this could theoretically work, but ac97->bus->card->private_data can be NULL
./sound/soc/au1x/psc-ac97.c:	struct snd_soc_card *c = x->bus->card->private_data;
./sound/soc/tegra/tegra_wm8903.c:		dev_err(card->dev, "Can't configure clocks\n");
./sound/soc/tegra/tegra_wm8903.c:		dev_err(card->dev, "codec_dai fmt not set\n");
./sound/soc/tegra/tegra_wm8903.c:		dev_err(card->dev, "cpu_dai fmt not set\n");
./sound/soc/tegra/tegra_wm8903.c:		dev_err(card->dev, "codec_dai clock not set\n");
./sound/soc/tegra/tegra_wm8903.c:			dev_err(card->dev, "cannot get spkr_en gpio\n");
./sound/soc/tegra/tegra_wm8903.c:			dev_err(card->dev, "cannot get hp_mute gpio\n");
./sound/soc/tegra/tegra_wm8903.c:			dev_err(card->dev, "cannot get int_mic_en gpio\n");
./sound/soc/tegra/tegra_wm8903.c:			dev_err(card->dev, "cannot get ext_mic_en gpio\n");
./sound/soc/tegra/tegra_wm8903.c:	card->dev = &pdev->dev;
./sound/soc/tegra/tegra_wm8903.c:		card->dapm_routes = harmony_audio_map;
./sound/soc/tegra/tegra_wm8903.c:		card->num_dapm_routes = ARRAY_SIZE(harmony_audio_map);
./sound/soc/tegra/tegra_wm8903.c:		card->dapm_routes = seaboard_audio_map;
./sound/soc/tegra/tegra_wm8903.c:		card->num_dapm_routes = ARRAY_SIZE(seaboard_audio_map);
./sound/soc/tegra/tegra_wm8903.c:		card->dapm_routes = kaen_audio_map;
./sound/soc/tegra/tegra_wm8903.c:		card->num_dapm_routes = ARRAY_SIZE(kaen_audio_map);
./sound/soc/tegra/tegra_wm8903.c:		card->dapm_routes = aebl_audio_map;
./sound/soc/tegra/tegra_wm8903.c:		card->num_dapm_routes = ARRAY_SIZE(aebl_audio_map);
./sound/soc/tegra/tegra_pcm.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/soc/tegra/tegra_pcm.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/soc/tegra/tegra_pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/tegra/tegra_pcm.c:	dma_free_writecombine(pcm->card->dev, buf->bytes,
./sound/soc/tegra/tegra_pcm.c:	if (!card->dev->dma_mask)
./sound/soc/tegra/tegra_pcm.c:		card->dev->dma_mask = &tegra_dma_mask;
./sound/soc/tegra/tegra_pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/tegra/tegra_pcm.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/tegra/trimslice.c:		dev_err(card->dev, "Can't configure clocks\n");
./sound/soc/tegra/trimslice.c:		dev_err(card->dev, "codec_dai fmt not set\n");
./sound/soc/tegra/trimslice.c:		dev_err(card->dev, "cpu_dai fmt not set\n");
./sound/soc/tegra/trimslice.c:		dev_err(card->dev, "codec_dai clock not set\n");
./sound/soc/tegra/trimslice.c:	card->dev = &pdev->dev;
./sound/soc/tegra/tegra_i2s.c:        struct device *dev = substream->pcm->card->dev;
./sound/soc/tegra/tegra_i2s.c:	 * FIXME: Until a codec driver exists for the tegra DAS, hard-code a
./sound/soc/omap/zoom2.c:#include <mach/board-zoom.h>
./sound/soc/omap/omap-pcm.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/soc/omap/omap-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/omap/omap-pcm.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/soc/omap/omap-pcm.c:		dma_free_writecombine(pcm->card->dev, buf->bytes,
./sound/soc/omap/omap-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/omap/omap-pcm.c:		card->dev->dma_mask = &omap_pcm_dmamask;
./sound/soc/omap/omap-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/omap/omap-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(64);
./sound/soc/omap/ams-delta.c:#include <plat/board-ams-delta.h>
./sound/soc/omap/ams-delta.c:	struct snd_soc_codec *codec = card->rtd->codec;
./sound/soc/omap/ams-delta.c:		dev_warn(card->dev,
./sound/soc/omap/ams-delta.c:			dev_warn(card->dev,
./sound/soc/omap/ams-delta.c:		dev_warn(card->dev,
./sound/soc/omap/ams-delta.c:		dev_warn(card->dev,
./sound/soc/omap/ams-delta.c:		dev_warn(card->dev,
./sound/soc/omap/ams-delta.c:		dev_warn(card->dev,
./sound/soc/omap/rx51.c: * gpio is reserved in arch/arm/mach-omap2/board-rx51-peripherals.c
./sound/soc/codecs/uda1380.c:	"3rd-order",
./sound/soc/codecs/ac97.c:	ret = snd_ac97_bus(codec->card->snd_card, 0, &soc_ac97_ops, NULL, &ac97_bus);
./sound/soc/codecs/cx20442.c:	codec->card->pop_time = 0;
./sound/soc/codecs/cx20442.c:		codec->card->pop_time = 1;
./sound/soc/codecs/cx20442.c:	codec->card->pop_time = 0;
./sound/soc/codecs/cs4270.c: * The .ops functions are used to provide board-specific data, like input
./sound/soc/codecs/wm8994_samsung.c:	//wm8994_socdev->card->codec = codec;
./sound/soc/codecs/tlv320aic3x.c:		list_for_each_entry(path, &widget->dapm->card->paths, list) {
./sound/soc/codecs/uda134x.c:/* In-data addresses are hard-coded into the reg-cache values */
./sound/soc/codecs/uda134x.c:	struct uda134x_platform_data *pd = codec->card->dev->platform_data;
./sound/soc/codecs/wm8960.c:	list_for_each_entry(w, &codec->card->widgets, list) {
./sound/soc/fsl/mpc8610_hpcd.c: * This function is used to initialize the board-specific hardware.
./sound/soc/fsl/mpc8610_hpcd.c:		dev_err(card->dev, "could not map global utilities\n");
./sound/soc/fsl/mpc8610_hpcd.c: * This function takes board-specific information, like clock frequencies
./sound/soc/fsl/mpc8610_hpcd.c:	struct device *dev = rtd->card->dev;
./sound/soc/fsl/mpc8610_hpcd.c:		dev_err(card->dev, "could not map global utilities\n");
./sound/soc/fsl/mpc5200_dma.c:		dev_err(substream->pcm->card->dev, "invalid buffer size\n");
./sound/soc/fsl/mpc5200_dma.c:	if (!card->dev->dma_mask)
./sound/soc/fsl/mpc5200_dma.c:		card->dev->dma_mask = &psc_dma_dmamask;
./sound/soc/fsl/mpc5200_dma.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/fsl/mpc5200_dma.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/fsl/mpc5200_dma.c:		rc = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->card->dev,
./sound/soc/fsl/mpc5200_dma.c:		rc = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, pcm->card->dev,
./sound/soc/fsl/mpc5200_dma.c:	dev_err(card->dev, "Cannot allocate buffer(s)\n");
./sound/soc/fsl/fsl_ssi.c:			dev_err(substream->pcm->card->dev,
./sound/soc/fsl/fsl_ssi.c:			dev_err(substream->pcm->card->dev,
./sound/soc/fsl/fsl_dma.c:	if (!card->dev->dma_mask)
./sound/soc/fsl/fsl_dma.c:		card->dev->dma_mask = &fsl_dma_dmamask;
./sound/soc/fsl/fsl_dma.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/fsl/fsl_dma.c:		card->dev->coherent_dma_mask = fsl_dma_dmamask;
./sound/soc/fsl/fsl_dma.c:		ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, card->dev,
./sound/soc/fsl/fsl_dma.c:			dev_err(card->dev, "can't alloc playback dma buffer\n");
./sound/soc/fsl/fsl_dma.c:		ret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, card->dev,
./sound/soc/fsl/fsl_dma.c:			dev_err(card->dev, "can't alloc capture dma buffer\n");
./sound/soc/fsl/p1022_ds.c: * This function is used to initialize the board-specific hardware.
./sound/soc/fsl/p1022_ds.c:		dev_err(card->dev, "could not map global utilities\n");
./sound/soc/fsl/p1022_ds.c: * This function takes board-specific information, like clock frequencies
./sound/soc/fsl/p1022_ds.c:	struct device *dev = rtd->card->dev;
./sound/soc/fsl/p1022_ds.c:		dev_err(card->dev, "could not map global utilities\n");
./sound/soc/sh/siu_dai.c:	dev_dbg(port_info->pcm->card->dev, "%s\n", __func__);
./sound/soc/sh/siu_dai.c:	dev_dbg(port_info->pcm->card->dev, "%s\n", __func__);
./sound/soc/sh/siu_dai.c:	struct device *dev = port_info->pcm->card->dev;
./sound/soc/sh/siu_dai.c:	struct device *dev = port_info->pcm->card->dev;
./sound/soc/sh/siu_dai.c:	struct device *dev = card->dev;
./sound/soc/sh/siu_dai.c:	dev_dbg(substream->pcm->card->dev, "%s: port=%d@%p\n", __func__,
./sound/soc/sh/siu_dai.c:	dev_dbg(substream->pcm->card->dev, "%s: port=%d@%p\n", __func__,
./sound/soc/sh/siu_dai.c:	dev_dbg(substream->pcm->card->dev,
./sound/soc/sh/siu_pcm.c:	struct device *dev = substream->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = substream->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = substream->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = siu_stream->substream->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = ss->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = ss->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = ss->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = ss->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = ss->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = ss->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	struct device *dev = ss->pcm->card->dev;
./sound/soc/sh/siu_pcm.c:	/* card->dev == socdev->dev, see snd_soc_new_pcms() */
./sound/soc/sh/siu_pcm.c:	struct platform_device *pdev = to_platform_device(card->dev);
./sound/soc/sh/siu_pcm.c:			dev_err(card->dev,
./sound/soc/sh/siu_pcm.c:	dev_info(card->dev, "SuperH SIU driver initialized.\n");
./sound/soc/sh/siu_pcm.c:	dev_err(card->dev, "SIU: failed to initialize.\n");
./sound/soc/sh/siu_pcm.c:	struct platform_device *pdev = to_platform_device(pcm->card->dev);
./sound/soc/sh/siu_pcm.c:	dev_dbg(pcm->card->dev, "%s\n", __func__);
./sound/soc/soc-core.c:	struct dentry *debugfs_card_root = codec->card->debugfs_card_root;
./sound/soc/soc-core.c:	card->debugfs_card_root = debugfs_create_dir(card->name,
./sound/soc/soc-core.c:	if (!card->debugfs_card_root) {
./sound/soc/soc-core.c:		dev_warn(card->dev,
./sound/soc/soc-core.c:	card->debugfs_pop_time = debugfs_create_u32("dapm_pop_time", 0644,
./sound/soc/soc-core.c:						    card->debugfs_card_root,
./sound/soc/soc-core.c:						    &card->pop_time);
./sound/soc/soc-core.c:	if (!card->debugfs_pop_time)
./sound/soc/soc-core.c:		dev_warn(card->dev,
./sound/soc/soc-core.c:	debugfs_remove_recursive(card->debugfs_card_root);
./sound/soc/soc-core.c:	codec->ac97->dev.parent = codec->card->dev;
./sound/soc/soc-core.c:		     codec->card->snd_card->number, 0, codec->name);
./sound/soc/soc-core.c:	if (list_empty(&card->codec_dev_list))
./sound/soc/soc-core.c:	snd_power_lock(card->snd_card);
./sound/soc/soc-core.c:	snd_power_wait(card->snd_card, SNDRV_CTL_POWER_D0);
./sound/soc/soc-core.c:	snd_power_unlock(card->snd_card);
./sound/soc/soc-core.c:	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D3hot);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:		snd_pcm_suspend_all(card->rtd[i].pcm);
./sound/soc/soc-core.c:	if (card->suspend_pre)
./sound/soc/soc-core.c:		card->suspend_pre(card);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
./sound/soc/soc-core.c:		struct snd_soc_platform *platform = card->rtd[i].platform;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		flush_delayed_work_sync(&card->rtd[i].delayed_work);
./sound/soc/soc-core.c:		card->rtd[i].codec->dapm.suspend_bias_level = card->rtd[i].codec->dapm.bias_level;
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
./sound/soc/soc-core.c:			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
./sound/soc/soc-core.c:	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:	if (card->suspend_post)
./sound/soc/soc-core.c:		card->suspend_post(card);
./sound/soc/soc-core.c:	dev_dbg(card->dev, "starting resume work\n");
./sound/soc/soc-core.c:	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D2);
./sound/soc/soc-core.c:	if (card->resume_pre)
./sound/soc/soc-core.c:		card->resume_pre(card);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai_driver *driver = card->rtd[i].codec_dai->driver;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:			snd_soc_dapm_stream_event(&card->rtd[i], driver->playback.stream_name,
./sound/soc/soc-core.c:			snd_soc_dapm_stream_event(&card->rtd[i], driver->capture.stream_name,
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai *dai = card->rtd[i].codec_dai;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
./sound/soc/soc-core.c:		struct snd_soc_platform *platform = card->rtd[i].platform;
./sound/soc/soc-core.c:		if (card->rtd[i].dai_link->ignore_suspend)
./sound/soc/soc-core.c:	if (card->resume_post)
./sound/soc/soc-core.c:		card->resume_post(card);
./sound/soc/soc-core.c:	dev_dbg(card->dev, "resume work completed\n");
./sound/soc/soc-core.c:	snd_power_change_state(card->snd_card, SNDRV_CTL_POWER_D0);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_dai *cpu_dai = card->rtd[i].cpu_dai;
./sound/soc/soc-core.c:		soc_resume_deferred(&card->deferred_resume_work);
./sound/soc/soc-core.c:		if (!schedule_work(&card->deferred_resume_work))
./sound/soc/soc-core.c:	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
./sound/soc/soc-core.c:	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
./sound/soc/soc-core.c:	dev_dbg(card->dev, "binding %s at idx %d\n", dai_link->name, num);
./sound/soc/soc-core.c:	dev_dbg(card->dev, "CPU DAI %s not registered\n",
./sound/soc/soc-core.c:			dev_dbg(card->dev, "CODEC DAI %s not registered\n",
./sound/soc/soc-core.c:	dev_dbg(card->dev, "CODEC %s not registered\n",
./sound/soc/soc-core.c:	dev_dbg(card->dev, "platform %s not registered\n",
./sound/soc/soc-core.c:		card->num_rtd++;
./sound/soc/soc-core.c:	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++)
./sound/soc/soc-core.c:	card->num_rtd = 0;
./sound/soc/soc-core.c:	if (card->codec_conf == NULL)
./sound/soc/soc-core.c:	for (i = 0; i < card->num_configs; i++) {
./sound/soc/soc-core.c:		struct snd_soc_codec_conf *map = &card->codec_conf[i];
./sound/soc/soc-core.c:	list_add(&codec->card_list, &card->codec_dev_list);
./sound/soc/soc-core.c:	list_add(&codec->dapm.list, &card->dapm_list);
./sound/soc/soc-core.c:		dai_link = &card->dai_link[num];
./sound/soc/soc-core.c:		rtd = &card->rtd[num];
./sound/soc/soc-core.c:		aux_dev = &card->aux_dev[num];
./sound/soc/soc-core.c:		rtd = &card->rtd_aux[num];
./sound/soc/soc-core.c:		dev_err(card->dev, "asoc: failed to init %s: %d\n", name, ret);
./sound/soc/soc-core.c:	rtd->dev.parent = card->dev;
./sound/soc/soc-core.c:		dev_err(card->dev,
./sound/soc/soc-core.c:	struct snd_soc_dai_link *dai_link = &card->dai_link[num];
./sound/soc/soc-core.c:	struct snd_soc_pcm_runtime *rtd = &card->rtd[num];
./sound/soc/soc-core.c:	dev_dbg(card->dev, "probe %s dai link %d\n", card->name, num);
./sound/soc/soc-core.c:		list_add(&cpu_dai->card_list, &card->dai_dev_list);
./sound/soc/soc-core.c:		list_add(&platform->card_list, &card->platform_dev_list);
./sound/soc/soc-core.c:		list_add(&codec_dai->card_list, &card->dai_dev_list);
./sound/soc/soc-core.c:	struct snd_soc_aux_dev *aux_dev = &card->aux_dev[num];
./sound/soc/soc-core.c:	dev_err(card->dev, "asoc: codec %s not found", aux_dev->codec_name);
./sound/soc/soc-core.c:	struct snd_soc_pcm_runtime *rtd = &card->rtd_aux[num];
./sound/soc/soc-core.c:	mutex_lock(&card->mutex);
./sound/soc/soc-core.c:	if (card->instantiated) {
./sound/soc/soc-core.c:		mutex_unlock(&card->mutex);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_links; i++)
./sound/soc/soc-core.c:	if (card->num_rtd != card->num_links) {
./sound/soc/soc-core.c:		mutex_unlock(&card->mutex);
./sound/soc/soc-core.c:		for (i = 0; i < card->num_configs; ++i) {
./sound/soc/soc-core.c:			codec_conf = &card->codec_conf[i];
./sound/soc/soc-core.c:			mutex_unlock(&card->mutex);
./sound/soc/soc-core.c:			card->owner, 0, &card->snd_card);
./sound/soc/soc-core.c:			card->name);
./sound/soc/soc-core.c:		mutex_unlock(&card->mutex);
./sound/soc/soc-core.c:	card->snd_card->dev = card->dev;
./sound/soc/soc-core.c:	card->dapm.bias_level = SND_SOC_BIAS_OFF;
./sound/soc/soc-core.c:	card->dapm.dev = card->dev;
./sound/soc/soc-core.c:	card->dapm.card = card;
./sound/soc/soc-core.c:	list_add(&card->dapm.list, &card->dapm_list);
./sound/soc/soc-core.c:	snd_soc_dapm_debugfs_init(&card->dapm, card->debugfs_card_root);
./sound/soc/soc-core.c:	INIT_WORK(&card->deferred_resume_work, soc_resume_deferred);
./sound/soc/soc-core.c:	if (card->dapm_widgets)
./sound/soc/soc-core.c:		snd_soc_dapm_new_controls(&card->dapm, card->dapm_widgets,
./sound/soc/soc-core.c:					  card->num_dapm_widgets);
./sound/soc/soc-core.c:	if (card->probe) {
./sound/soc/soc-core.c:		ret = card->probe(card);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_links; i++) {
./sound/soc/soc-core.c:			       card->name, ret);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_aux_devs; i++) {
./sound/soc/soc-core.c:			       card->name, ret);
./sound/soc/soc-core.c:	if (card->controls)
./sound/soc/soc-core.c:		snd_soc_add_controls(list_first_entry(&card->codec_dev_list,
./sound/soc/soc-core.c:				     card->controls,
./sound/soc/soc-core.c:				     card->num_controls);
./sound/soc/soc-core.c:	if (card->dapm_routes)
./sound/soc/soc-core.c:		snd_soc_dapm_add_routes(&card->dapm, card->dapm_routes,
./sound/soc/soc-core.c:					card->num_dapm_routes);
./sound/soc/soc-core.c:	snprintf(card->snd_card->shortname, sizeof(card->snd_card->shortname),
./sound/soc/soc-core.c:		 "%s", card->name);
./sound/soc/soc-core.c:	snprintf(card->snd_card->longname, sizeof(card->snd_card->longname),
./sound/soc/soc-core.c:		 "%s", card->long_name ? card->long_name : card->name);
./sound/soc/soc-core.c:	snprintf(card->snd_card->driver, sizeof(card->snd_card->driver),
./sound/soc/soc-core.c:		 "%s", card->driver_name ? card->driver_name : card->name);
./sound/soc/soc-core.c:	for (i = 0; i < ARRAY_SIZE(card->snd_card->driver); i++) {
./sound/soc/soc-core.c:		switch (card->snd_card->driver[i]) {
./sound/soc/soc-core.c:			if (!isalnum(card->snd_card->driver[i]))
./sound/soc/soc-core.c:				card->snd_card->driver[i] = '_';
./sound/soc/soc-core.c:	if (card->late_probe) {
./sound/soc/soc-core.c:		ret = card->late_probe(card);
./sound/soc/soc-core.c:			dev_err(card->dev, "%s late_probe() failed: %d\n",
./sound/soc/soc-core.c:				card->name, ret);
./sound/soc/soc-core.c:	ret = snd_card_register(card->snd_card);
./sound/soc/soc-core.c:		printk(KERN_ERR "asoc: failed to register soundcard for %s\n", card->name);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		ret = soc_register_ac97_dai_link(&card->rtd[i]);
./sound/soc/soc-core.c:			printk(KERN_ERR "asoc: failed to register AC97 %s\n", card->name);
./sound/soc/soc-core.c:				soc_unregister_ac97_dai_link(card->rtd[i].codec);
./sound/soc/soc-core.c:	card->instantiated = 1;
./sound/soc/soc-core.c:	mutex_unlock(&card->mutex);
./sound/soc/soc-core.c:	for (i = 0; i < card->num_aux_devs; i++)
./sound/soc/soc-core.c:	if (card->remove)
./sound/soc/soc-core.c:		card->remove(card);
./sound/soc/soc-core.c:	snd_card_free(card->snd_card);
./sound/soc/soc-core.c:	mutex_unlock(&card->mutex);
./sound/soc/soc-core.c:	card->dev = &pdev->dev;
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
./sound/soc/soc-core.c:	for (i = 0; i < card->num_aux_devs; i++)
./sound/soc/soc-core.c:	if (card->remove)
./sound/soc/soc-core.c:		card->remove(card);
./sound/soc/soc-core.c:	snd_soc_dapm_free(&card->dapm);
./sound/soc/soc-core.c:	kfree(card->rtd);
./sound/soc/soc-core.c:	snd_card_free(card->snd_card);
./sound/soc/soc-core.c:	if (!card->instantiated)
./sound/soc/soc-core.c:	for (i = 0; i < card->num_rtd; i++) {
./sound/soc/soc-core.c:		struct snd_soc_pcm_runtime *rtd = &card->rtd[i];
./sound/soc/soc-core.c:	dev_dbg(rtd->card->dev, "registered pcm #%d %s\n",num,new_name);
./sound/soc/soc-core.c:	ret = snd_pcm_new(rtd->card->snd_card, new_name,
./sound/soc/soc-core.c:		ret = platform->driver->pcm_new(rtd->card->snd_card,
./sound/soc/soc-core.c:	struct snd_card *card = codec->card->snd_card;
./sound/soc/soc-core.c:	struct snd_card *card = codec->card->snd_card;
./sound/soc/soc-core.c:	list_for_each_entry(kctl, &card->controls, list) {
./sound/soc/soc-core.c:	if (!card->name || !card->dev)
./sound/soc/soc-core.c:	dev_set_drvdata(card->dev, card);
./sound/soc/soc-core.c:	card->rtd = kzalloc(sizeof(struct snd_soc_pcm_runtime) *
./sound/soc/soc-core.c:			    (card->num_links + card->num_aux_devs),
./sound/soc/soc-core.c:	if (card->rtd == NULL)
./sound/soc/soc-core.c:	card->rtd_aux = &card->rtd[card->num_links];
./sound/soc/soc-core.c:	for (i = 0; i < card->num_links; i++)
./sound/soc/soc-core.c:		card->rtd[i].dai_link = &card->dai_link[i];
./sound/soc/soc-core.c:	INIT_LIST_HEAD(&card->list);
./sound/soc/soc-core.c:	card->instantiated = 0;
./sound/soc/soc-core.c:	mutex_init(&card->mutex);
./sound/soc/soc-core.c:	list_add(&card->list, &card_list);
./sound/soc/soc-core.c:	dev_dbg(card->dev, "Registered card '%s'\n", card->name);
./sound/soc/soc-core.c:	if (card->instantiated)
./sound/soc/soc-core.c:	list_del(&card->list);
./sound/soc/soc-core.c:	dev_dbg(card->dev, "Unregistered card '%s'\n", card->name);
./sound/soc/jz4740/jz4740-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/jz4740/jz4740-pcm.c:	buf->area = dma_alloc_noncoherent(pcm->card->dev, size,
./sound/soc/jz4740/jz4740-pcm.c:		dma_free_noncoherent(pcm->card->dev, buf->bytes, buf->area,
./sound/soc/jz4740/jz4740-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/jz4740/jz4740-pcm.c:		card->dev->dma_mask = &jz4740_pcm_dmamask;
./sound/soc/jz4740/jz4740-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/jz4740/jz4740-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/nuc900/nuc900-pcm.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/soc/nuc900/nuc900-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/nuc900/nuc900-pcm.c:		card->dev->dma_mask = &nuc900_pcm_dmamask;
./sound/soc/nuc900/nuc900-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/nuc900/nuc900-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/nuc900/nuc900-pcm.c:		card->dev, 4 * 1024, (4 * 1024) - 1);
./sound/soc/samsung/dma.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/soc/samsung/dma.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/samsung/dma.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/soc/samsung/dma.c:		dma_free_writecombine(pcm->card->dev, buf->bytes,
./sound/soc/samsung/dma.c:	if (!card->dev->dma_mask)
./sound/soc/samsung/dma.c:		card->dev->dma_mask = &dma_mask;
./sound/soc/samsung/dma.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/samsung/dma.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/samsung/s3c24xx_simtec.c:	card->dai_link->ops = &simtec_snd_ops;
./sound/soc/samsung/s3c-idma.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/samsung/s3c-idma.c:	if (!card->dev->dma_mask)
./sound/soc/samsung/s3c-idma.c:		card->dev->dma_mask = &s3c_idma_mask;
./sound/soc/samsung/s3c-idma.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/samsung/s3c-idma.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/samsung/speyside.c:	struct snd_soc_dai *codec_dai = card->rtd[0].codec_dai;
./sound/soc/samsung/speyside.c:	snd_soc_dapm_ignore_suspend(&card->dapm, "Headphone");
./sound/soc/samsung/speyside.c:	snd_soc_dapm_ignore_suspend(&card->dapm, "Headset Mic");
./sound/soc/samsung/speyside.c:	snd_soc_dapm_ignore_suspend(&card->dapm, "Main AMIC");
./sound/soc/samsung/speyside.c:	snd_soc_dapm_ignore_suspend(&card->dapm, "Main DMIC");
./sound/soc/samsung/speyside.c:	snd_soc_dapm_ignore_suspend(&card->dapm, "Speaker");
./sound/soc/samsung/speyside.c:	snd_soc_dapm_ignore_suspend(&card->dapm, "WM1250 Output");
./sound/soc/samsung/speyside.c:	snd_soc_dapm_ignore_suspend(&card->dapm, "WM1250 Input");
./sound/soc/samsung/speyside.c:	card->dev = &pdev->dev;
./sound/soc/samsung/s3c24xx_uda134x.c:  hardware engineer wasn't very forward-looking it's better to leave
./sound/soc/samsung/s3c-dma.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/soc/samsung/s3c-dma.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/samsung/s3c-dma.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/soc/samsung/s3c-dma.c:		dma_free_writecombine(pcm->card->dev, buf->bytes,
./sound/soc/samsung/s3c-dma.c:	if (!card->dev->dma_mask)
./sound/soc/samsung/s3c-dma.c:		card->dev->dma_mask = &s3c_dma_mask;
./sound/soc/samsung/s3c-dma.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/samsung/s3c-dma.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/ep93xx/ep93xx-pcm.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/soc/ep93xx/ep93xx-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/ep93xx/ep93xx-pcm.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/soc/ep93xx/ep93xx-pcm.c:		dma_free_writecombine(pcm->card->dev, buf->bytes, buf->area,
./sound/soc/ep93xx/ep93xx-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/ep93xx/ep93xx-pcm.c:		card->dev->dma_mask = &ep93xx_pcm_dmamask;
./sound/soc/ep93xx/ep93xx-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/ep93xx/ep93xx-pcm.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/soc-dapm.c:	if (card && card->set_bias_level)
./sound/soc/soc-dapm.c:		ret = card->set_bias_level(card, level);
./sound/soc/soc-dapm.c:		if (card && card->set_bias_level_post)
./sound/soc/soc-dapm.c:			ret = card->set_bias_level_post(card, level);
./sound/soc/soc-dapm.c:			list_add(&path->list, &dapm->card->paths);
./sound/soc/soc-dapm.c:			list_add(&path->list, &dapm->card->paths);
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &dapm->card->widgets, list) {
./sound/soc/soc-dapm.c:	struct snd_card *card = dapm->card->snd_card;
./sound/soc/soc-dapm.c:	struct snd_card *card = dapm->card->snd_card;
./sound/soc/soc-dapm.c:	list_for_each_entry(p, &dapm->card->paths, list)
./sound/soc/soc-dapm.c:	int level = snd_power_get_state(widget->dapm->card->snd_card);
./sound/soc/soc-dapm.c:		pop_dbg(dapm->dev, card->pop_time, "pop test : %s %s\n",
./sound/soc/soc-dapm.c:		pop_dbg(dapm->dev, card->pop_time,
./sound/soc/soc-dapm.c:		pop_dbg(dapm->dev, card->pop_time,
./sound/soc/soc-dapm.c:			value, mask, reg, card->pop_time);
./sound/soc/soc-dapm.c:		pop_wait(card->pop_time);
./sound/soc/soc-dapm.c:	list_for_each_entry(d, &card->dapm_list, list)
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &card->widgets, list) {
./sound/soc/soc-dapm.c:	list_for_each_entry(d, &card->dapm_list, list)
./sound/soc/soc-dapm.c:	list_for_each_entry(d, &card->dapm_list, list)
./sound/soc/soc-dapm.c:	list_for_each_entry(d, &dapm->card->dapm_list, list)
./sound/soc/soc-dapm.c:	list_for_each_entry(d, &dapm->card->dapm_list, list)
./sound/soc/soc-dapm.c:	pop_dbg(dapm->dev, card->pop_time,
./sound/soc/soc-dapm.c:		"DAPM sequencing finished, waiting %dms\n", card->pop_time);
./sound/soc/soc-dapm.c:	pop_wait(card->pop_time);
./sound/soc/soc-dapm.c:	list_for_each_entry(path, &widget->dapm->card->paths, list) {
./sound/soc/soc-dapm.c:	list_for_each_entry(path, &widget->dapm->card->paths, list) {
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &codec->card->widgets, list) {
./sound/soc/soc-dapm.c:	list_for_each_entry_safe(w, next_w, &dapm->card->widgets, list) {
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &dapm->card->widgets, list) {
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &dapm->card->widgets, list) {
./sound/soc/soc-dapm.c:		list_add(&path->list, &dapm->card->paths);
./sound/soc/soc-dapm.c:		list_add(&path->list, &dapm->card->paths);
./sound/soc/soc-dapm.c:		list_add(&path->list, &dapm->card->paths);
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &dapm->card->widgets, list)
./sound/soc/soc-dapm.c:	list_add(&w->list, &dapm->card->widgets);
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &dapm->card->widgets, list)
./sound/soc/soc-dapm.c:	list_for_each_entry(w, &dapm->card->widgets, list) {
./sound/soc/soc-dapm.c:	list_for_each_entry(codec, &card->codec_dev_list, list) {
./sound/soc/s6000/s6105-ipcam.c:	snd_ctl_add(codec->card->snd_card, snd_ctl_new1(&audio_out_mux, codec));
./sound/soc/s6000/s6000-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/s6000/s6000-pcm.c:		card->dev->dma_mask = &s6000_pcm_dmamask;
./sound/soc/s6000/s6000-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/s6000/s6000-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/s6000/s6000-pcm.c:						    card->dev,
./sound/soc/imx/imx-ssi.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/imx/imx-ssi.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/soc/imx/imx-ssi.c:	if (!card->dev->dma_mask)
./sound/soc/imx/imx-ssi.c:		card->dev->dma_mask = &imx_pcm_dmamask;
./sound/soc/imx/imx-ssi.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/imx/imx-ssi.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/imx/imx-ssi.c:		dma_free_writecombine(pcm->card->dev, buf->bytes,
./sound/soc/atmel/atmel-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/atmel/atmel-pcm.c:	buf->area = dma_alloc_coherent(pcm->card->dev, size,
./sound/soc/atmel/atmel-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/atmel/atmel-pcm.c:		card->dev->dma_mask = &atmel_pcm_dmamask;
./sound/soc/atmel/atmel-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/atmel/atmel-pcm.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/atmel/atmel-pcm.c:		dma_free_coherent(pcm->card->dev, buf->bytes,
./sound/soc/davinci/davinci-i2s.c: *    backward-compatible, possibly explaining that confusion.
./sound/soc/davinci/davinci-pcm.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/soc/davinci/davinci-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/davinci/davinci-pcm.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/soc/davinci/davinci-pcm.c:		dma_free_writecombine(pcm->card->dev, buf->bytes,
./sound/soc/davinci/davinci-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/davinci/davinci-pcm.c:		card->dev->dma_mask = &davinci_pcm_dmamask;
./sound/soc/davinci/davinci-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/davinci/davinci-pcm.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/soc/davinci/davinci-evm.c:	 * board-dm644x-evm.c using GPIOs from U18.  There are six
./sound/soc/blackfin/bf5xx-ac97-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/blackfin/bf5xx-ac97-pcm.c:	buf->area = dma_alloc_coherent(pcm->card->dev, size,
./sound/soc/blackfin/bf5xx-ac97-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/blackfin/bf5xx-ac97-pcm.c:		card->dev->dma_mask = &bf5xx_pcm_dmamask;
./sound/soc/blackfin/bf5xx-ac97-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/blackfin/bf5xx-ac97-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/blackfin/bf5xx-tdm-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/blackfin/bf5xx-tdm-pcm.c:	buf->area = dma_alloc_coherent(pcm->card->dev, size * 4,
./sound/soc/blackfin/bf5xx-tdm-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/blackfin/bf5xx-tdm-pcm.c:		card->dev->dma_mask = &bf5xx_pcm_dmamask;
./sound/soc/blackfin/bf5xx-tdm-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/blackfin/bf5xx-tdm-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/soc/blackfin/bf5xx-i2s-pcm.c:	buf->dev.dev = pcm->card->dev;
./sound/soc/blackfin/bf5xx-i2s-pcm.c:	buf->area = dma_alloc_coherent(pcm->card->dev, size,
./sound/soc/blackfin/bf5xx-i2s-pcm.c:	if (!card->dev->dma_mask)
./sound/soc/blackfin/bf5xx-i2s-pcm.c:		card->dev->dma_mask = &bf5xx_pcm_dmamask;
./sound/soc/blackfin/bf5xx-i2s-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/soc/blackfin/bf5xx-i2s-pcm.c:		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
./sound/spi/at73c213.c:#define get_chip(card) ((struct snd_at73c213 *)card->private_data)
./sound/spi/at73c213.c:		status = clk_round_rate(chip->board->dac_clk, dac_rate_new);
./sound/spi/at73c213.c:	status = clk_set_rate(chip->board->dac_clk, status);
./sound/spi/at73c213.c:	retval = snd_pcm_new(chip->card, chip->card->shortname,
./sound/spi/at73c213.c:	strcpy(card->mixername, chip->pcm->name);
./sound/spi/at73c213.c:	clk_enable(chip->board->dac_clk);
./sound/spi/at73c213.c:	clk_disable(chip->board->dac_clk);
./sound/spi/at73c213.c:	if (!board->dac_clk) {
./sound/spi/at73c213.c:	if (IS_ERR(board->dac_clk)) {
./sound/spi/at73c213.c:		return PTR_ERR(board->dac_clk);
./sound/spi/at73c213.c:	snprintf(id, sizeof id, "at73c213_%d", board->ssc_id);
./sound/spi/at73c213.c:	chip = card->private_data;
./sound/spi/at73c213.c:	chip->ssc = ssc_request(board->ssc_id);
./sound/spi/at73c213.c:				board->ssc_id);
./sound/spi/at73c213.c:	strcpy(card->driver, "at73c213");
./sound/spi/at73c213.c:	strcpy(card->shortname, board->shortname);
./sound/spi/at73c213.c:	sprintf(card->longname, "%s on irq %d", card->shortname, chip->irq);
./sound/spi/at73c213.c:	struct snd_at73c213 *chip = card->private_data;
./sound/spi/at73c213.c:	clk_disable(chip->board->dac_clk);
./sound/spi/at73c213.c:	struct snd_at73c213 *chip = card->private_data;
./sound/spi/at73c213.c:	clk_disable(chip->board->dac_clk);
./sound/spi/at73c213.c:	struct snd_at73c213 *chip = card->private_data;
./sound/spi/at73c213.c:	clk_enable(chip->board->dac_clk);
./sound/parisc/harmony.c:	strcpy(card->mixername, "Harmony Gain control interface");
./sound/parisc/harmony.c:	strcpy(card->driver, "harmony");
./sound/parisc/harmony.c:	strcpy(card->shortname, "Harmony");
./sound/parisc/harmony.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/parisc/harmony.c:		card->shortname, h->hpa, h->irq);
./sound/sparc/dbri.c:	pcm->private_data = card->private_data;
./sound/sparc/dbri.c:	strcpy(pcm->name, card->shortname);
./sound/sparc/dbri.c:	if (snd_BUG_ON(!card || !card->private_data))
./sound/sparc/dbri.c:	dbri = card->private_data;
./sound/sparc/dbri.c:	strcpy(card->mixername, card->shortname);
./sound/sparc/dbri.c:	struct snd_dbri *dbri = card->private_data;
./sound/sparc/dbri.c:	struct snd_dbri *dbri = card->private_data;
./sound/sparc/dbri.c:	strcpy(card->driver, "DBRI");
./sound/sparc/dbri.c:	strcpy(card->shortname, "Sun DBRI");
./sound/sparc/dbri.c:	sprintf(card->longname, "%s at 0x%02lx:0x%016Lx, irq %d",
./sound/sparc/dbri.c:		card->shortname,
./sound/sparc/dbri.c:	dbri = card->private_data;
./sound/sparc/dbri.c:	snd_dbri_free(card->private_data);
./sound/sparc/cs4231.c:	struct snd_cs4231 *chip = card->private_data;
./sound/sparc/cs4231.c:	struct snd_cs4231 *chip = card->private_data;
./sound/sparc/cs4231.c:	tid.card = card->number;
./sound/sparc/cs4231.c:	struct snd_cs4231 *chip = card->private_data;
./sound/sparc/cs4231.c:	strcpy(card->mixername, chip->pcm->name);
./sound/sparc/cs4231.c:	strcpy(card->driver, "CS4231");
./sound/sparc/cs4231.c:	strcpy(card->shortname, "Sun CS4231");
./sound/sparc/cs4231.c:	chip = card->private_data;
./sound/sparc/cs4231.c:	struct snd_cs4231 *chip = card->private_data;
./sound/sparc/cs4231.c:	struct snd_cs4231 *chip = card->private_data;
./sound/sparc/cs4231.c:	sprintf(card->longname, "%s at 0x%02lx:0x%016Lx, irq %d",
./sound/sparc/cs4231.c:		card->shortname,
./sound/sparc/cs4231.c:	struct snd_cs4231 *chip = card->private_data;
./sound/sparc/cs4231.c:	sprintf(card->longname, "%s at 0x%llx, irq %d",
./sound/sparc/cs4231.c:		card->shortname,
./sound/sparc/amd7930.c:	strcpy(pcm->name, amd->card->shortname);
./sound/sparc/amd7930.c:	strcpy(card->mixername, card->shortname);
./sound/sparc/amd7930.c:	strcpy(card->driver, "AMD7930");
./sound/sparc/amd7930.c:	strcpy(card->shortname, "Sun AMD7930");
./sound/sparc/amd7930.c:	sprintf(card->longname, "%s at 0x%02lx:0x%08Lx, irq %d",
./sound/sparc/amd7930.c:		card->shortname,
./sound/pci/es1968.c: *  Rewritted from card-es1938.c source.
./sound/pci/es1968.c:	struct es1968 *chip = card->private_data;
./sound/pci/es1968.c:	struct es1968 *chip = card->private_data;
./sound/pci/es1968.c:	input_dev->name = chip->card->driver;
./sound/pci/es1968.c:	card->private_data = chip;
./sound/pci/es1968.c:		strcpy(card->driver, "ES1978");
./sound/pci/es1968.c:		strcpy(card->shortname, "ESS ES1978 (Maestro 2E)");
./sound/pci/es1968.c:		strcpy(card->driver, "ES1968");
./sound/pci/es1968.c:		strcpy(card->shortname, "ESS ES1968 (Maestro 2)");
./sound/pci/es1968.c:		strcpy(card->driver, "ESM1");
./sound/pci/es1968.c:		strcpy(card->shortname, "ESS Maestro 1");
./sound/pci/es1968.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/es1968.c:		card->shortname, chip->io_port, chip->irq);
./sound/pci/ad1889.c:	err = snd_pcm_new(chip->card, chip->card->driver, device, 1, 1, &pcm);
./sound/pci/ad1889.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/ad1889.c:	if (!snd_card_proc_new(chip->card, chip->card->driver, &entry))
./sound/pci/ad1889.c:	card->private_data = chip;
./sound/pci/ad1889.c:	if ((err = pci_request_regions(pci, card->driver)) < 0)
./sound/pci/ad1889.c:			IRQF_SHARED, card->driver, chip)) {
./sound/pci/ad1889.c:	strcpy(card->driver, "AD1889");
./sound/pci/ad1889.c:	strcpy(card->shortname, "Analog Devices AD1889");
./sound/pci/ad1889.c:	sprintf(card->longname, "%s at 0x%lx irq %i",
./sound/pci/ad1889.c:		card->shortname, chip->bar, chip->irq);
./sound/pci/als4000.c: *  card-als4000.c - driver for Avance Logic ALS4000 based soundcards.
./sound/pci/als4000.c: *  Framework borrowed from Massimo Piccioni's card-als100.c.
./sound/pci/als4000.c:	acard->gameport = gp = gameport_allocate_port();
./sound/pci/als4000.c:	gameport_set_phys(gp, "pci%s/gameport0", pci_name(acard->pci));
./sound/pci/als4000.c:	gameport_set_dev_parent(gp, &acard->pci->dev);
./sound/pci/als4000.c:	snd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);
./sound/pci/als4000.c:	gameport_register_port(acard->gameport);
./sound/pci/als4000.c:	if (acard->gameport) {
./sound/pci/als4000.c:		struct resource *r = gameport_get_port_data(acard->gameport);
./sound/pci/als4000.c:		gameport_unregister_port(acard->gameport);
./sound/pci/als4000.c:		acard->gameport = NULL;
./sound/pci/als4000.c:		snd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);
./sound/pci/als4000.c:	struct snd_card_als4000 *acard = card->private_data;
./sound/pci/als4000.c:	snd_als4k_gcr_write_addr(acard->iobase, ALS4K_GCR8C_MISC_CTRL, 0);
./sound/pci/als4000.c:	pci_release_regions(acard->pci);
./sound/pci/als4000.c:	pci_disable_device(acard->pci);
./sound/pci/als4000.c:	acard = card->private_data;
./sound/pci/als4000.c:	acard->pci = pci;
./sound/pci/als4000.c:	acard->iobase = iobase;
./sound/pci/als4000.c:	card->private_free = snd_card_als4000_free;
./sound/pci/als4000.c:	snd_als4000_set_addr(acard->iobase, 0, 0, 0, 0);
./sound/pci/als4000.c:	acard->chip = chip;
./sound/pci/als4000.c:	strcpy(card->driver, "ALS4000");
./sound/pci/als4000.c:	strcpy(card->shortname, "Avance Logic ALS4000");
./sound/pci/als4000.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/als4000.c:		card->shortname, chip->alt_port, chip->irq);
./sound/pci/als4000.c:	struct snd_card_als4000 *acard = card->private_data;
./sound/pci/als4000.c:	struct snd_sb *chip = acard->chip;
./sound/pci/als4000.c:	struct snd_card_als4000 *acard = card->private_data;
./sound/pci/als4000.c:	struct snd_sb *chip = acard->chip;
./sound/pci/als4000.c:	if (acard->gameport)
./sound/pci/als4000.c:		snd_als4000_set_addr(acard->iobase, 0, 0, 0, 1);
./sound/pci/mixart/mixart.c:		strcpy(card->driver, CARD_NAME);
./sound/pci/mixart/mixart.c:		sprintf(card->shortname, "%s [PCM #%d]", mgr->shortname, i);
./sound/pci/mixart/mixart.c:		sprintf(card->longname, "%s [PCM #%d]", mgr->longname, i);
./sound/pci/emu10k1/emumixer.c:			strcpy(emu->card->mixername, "EMU APS");
./sound/pci/emu10k1/emumixer.c:			strcpy(emu->card->mixername, "SB Audigy");
./sound/pci/emu10k1/emumixer.c:			strcpy(emu->card->mixername, "Emu10k1");
./sound/pci/emu10k1/emu10k1.c:	card->private_data = emu;
./sound/pci/emu10k1/emu10k1.c:	strcpy(card->driver, emu->card_capabilities->driver);
./sound/pci/emu10k1/emu10k1.c:	strcpy(card->shortname, emu->card_capabilities->name);
./sound/pci/emu10k1/emu10k1.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/emu10k1/emu10k1.c:		 card->shortname, emu->revision, emu->serial, emu->port, emu->irq);
./sound/pci/emu10k1/emu10k1.c:	struct snd_emu10k1 *emu = card->private_data;
./sound/pci/emu10k1/emu10k1.c:	struct snd_emu10k1 *emu = card->private_data;
./sound/pci/emu10k1/emu10k1_main.c:	if (!*card->id && c->id) {
./sound/pci/emu10k1/emu10k1_main.c:		strlcpy(card->id, c->id, sizeof(card->id));
./sound/pci/emu10k1/emu10k1_main.c:				if (snd_cards[i] && !strcmp(snd_cards[i]->id, card->id))
./sound/pci/emu10k1/emu10k1_main.c:			snprintf(card->id, sizeof(card->id), "%s_%d", c->id, n);
./sound/pci/emu10k1/timer.c:	tid.card = emu->card->number;
./sound/pci/emu10k1/emufx.c:		down_read(&emu->card->controls_rwsem);
./sound/pci/emu10k1/emufx.c:			up_read(&emu->card->controls_rwsem);
./sound/pci/emu10k1/emufx.c:		up_read(&emu->card->controls_rwsem);
./sound/pci/emu10k1/emufx.c:		down_write(&card->controls_rwsem);
./sound/pci/emu10k1/emufx.c:		up_write(&card->controls_rwsem);
./sound/pci/emu10k1/p16v.c:	runtime->sync.id32[0] = substream->pcm->card->number;
./sound/pci/emu10k1/emu10k1x.c:	strcpy(card->driver, "EMU10K1X");
./sound/pci/emu10k1/emu10k1x.c:	strcpy(card->shortname, "Dell Sound Blaster Live!");
./sound/pci/emu10k1/emu10k1x.c:	sprintf(card->longname, "%s at 0x%lx irq %i",
./sound/pci/emu10k1/emu10k1x.c:		card->shortname, chip->port, chip->irq);
./sound/pci/rme96.c:	snd_iprintf(buffer, rme96->card->longname);
./sound/pci/rme96.c:	snd_iprintf(buffer, " (index #%d)\n", rme96->card->number + 1);
./sound/pci/rme96.c:	snd_rme96_free(card->private_data);
./sound/pci/rme96.c:	card->private_free = snd_rme96_card_free;
./sound/pci/rme96.c:	rme96 = card->private_data;
./sound/pci/rme96.c:	strcpy(card->driver, "Digi96");
./sound/pci/rme96.c:		strcpy(card->shortname, "RME Digi96");
./sound/pci/rme96.c:		strcpy(card->shortname, "RME Digi96/8");
./sound/pci/rme96.c:		strcpy(card->shortname, "RME Digi96/8 PRO");
./sound/pci/rme96.c:			strcpy(card->shortname, "RME Digi96/8 PAD");
./sound/pci/rme96.c:			strcpy(card->shortname, "RME Digi96/8 PST");
./sound/pci/rme96.c:	sprintf(card->longname, "%s at 0x%lx, irq %d", card->shortname,
./sound/pci/oxygen/oxygen_lib.c:	struct oxygen *chip = card->private_data;
./sound/pci/oxygen/oxygen_lib.c:	chip = card->private_data;
./sound/pci/oxygen/oxygen_lib.c:	card->private_free = oxygen_card_free;
./sound/pci/oxygen/oxygen_lib.c:	strcpy(card->driver, chip->model.chip);
./sound/pci/oxygen/oxygen_lib.c:	strcpy(card->shortname, chip->model.shortname);
./sound/pci/oxygen/oxygen_lib.c:	sprintf(card->longname, "%s at %#lx, irq %i",
./sound/pci/oxygen/oxygen_lib.c:	strcpy(card->mixername, chip->model.chip);
./sound/pci/oxygen/oxygen_lib.c:	struct oxygen *chip = card->private_data;
./sound/pci/oxygen/oxygen_lib.c:	struct oxygen *chip = card->private_data;
./sound/pci/oxygen/oxygen_lib.c:	struct oxygen *chip = card->private_data;
./sound/pci/vx222/vx222.c:	card->private_data = vx;
./sound/pci/vx222/vx222.c:	sprintf(card->longname, "%s at 0x%lx & 0x%lx, irq %i",
./sound/pci/vx222/vx222.c:		card->shortname, vx->port[0], vx->port[1], vx->core.irq);
./sound/pci/vx222/vx222.c:		    card->shortname, vx->port[0], vx->port[1], vx->core.irq);
./sound/pci/vx222/vx222.c:	struct snd_vx222 *vx = card->private_data;
./sound/pci/vx222/vx222.c:	struct snd_vx222 *vx = card->private_data;
./sound/pci/fm801.c:	card->private_data = chip;
./sound/pci/fm801.c:	strcpy(card->driver, "FM801");
./sound/pci/fm801.c:	strcpy(card->shortname, "ForteMedia FM801-");
./sound/pci/fm801.c:	strcat(card->shortname, chip->multichannel ? "AU" : "AS");
./sound/pci/fm801.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/fm801.c:		card->shortname, chip->port, chip->irq);
./sound/pci/fm801.c:	struct fm801 *chip = card->private_data;
./sound/pci/fm801.c:	struct fm801 *chip = card->private_data;
./sound/pci/ctxfi/ctmixer.c:	strcpy(atc->card->mixername, device_name);
./sound/pci/ctxfi/xfi.c:	card->private_data = atc;
./sound/pci/ctxfi/xfi.c:	strcpy(card->driver, "SB-XFi");
./sound/pci/ctxfi/xfi.c:	strcpy(card->shortname, "Creative X-Fi");
./sound/pci/ctxfi/xfi.c:	snprintf(card->longname, sizeof(card->longname), "%s %s %s",
./sound/pci/ctxfi/xfi.c:		 card->shortname, atc->chip_name, atc->model_name);
./sound/pci/ctxfi/xfi.c:	struct ct_atc *atc = card->private_data;
./sound/pci/ctxfi/xfi.c:	struct ct_atc *atc = card->private_data;
./sound/pci/cs46xx/cs46xx_lib.c:	struct snd_cs46xx *chip = card->private_data;
./sound/pci/cs46xx/cs46xx_lib.c:	struct snd_cs46xx *chip = card->private_data;
./sound/pci/cs46xx/dsp_spos.c:	if ((entry = snd_info_create_card_entry(card, "dsp", card->proc_root)) != NULL) {
./sound/pci/cs46xx/cs46xx.c:	card->private_data = chip;
./sound/pci/cs46xx/cs46xx.c:	strcpy(card->driver, "CS46xx");
./sound/pci/cs46xx/cs46xx.c:	strcpy(card->shortname, "Sound Fusion CS46xx");
./sound/pci/cs46xx/cs46xx.c:	sprintf(card->longname, "%s at 0x%lx/0x%lx, irq %i",
./sound/pci/cs46xx/cs46xx.c:		card->shortname,
./sound/pci/hda/hda_intel.c:		       chip->card->number);
./sound/pci/hda/hda_intel.c:	struct azx *chip = card->private_data;
./sound/pci/hda/hda_intel.c:	struct azx *chip = card->private_data;
./sound/pci/hda/hda_intel.c:	strcpy(card->driver, "HDA-Intel");
./sound/pci/hda/hda_intel.c:	strlcpy(card->shortname, driver_short_names[chip->driver_type],
./sound/pci/hda/hda_intel.c:		sizeof(card->shortname));
./sound/pci/hda/hda_intel.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/hda/hda_intel.c:		 card->shortname, chip->addr, chip->irq);
./sound/pci/hda/hda_intel.c:	card->private_data = chip;
./sound/pci/hda/hda_beep.c:		"card%d/codec#%d/beep0", codec->bus->card->number, codec->addr);
./sound/pci/hda/patch_sigmatel.c: * and 9202/925x. For those, dac_nids[] must be hard-coded.
./sound/pci/hda/patch_realtek.c:	SND_PCI_QUIRK(0x1025, 0x0155, "Packard-Bell M5120", PINFIX_PB_M5210),
./sound/pci/hda/hda_hwdep.c:	struct device *dev = bus->card->dev;
./sound/pci/hda/patch_via.c:		snprintf(codec->bus->card->mixername,
./sound/pci/hda/patch_via.c:			 sizeof(codec->bus->card->mixername),
./sound/pci/hda/patch_via.c:		snprintf(codec->bus->card->mixername,
./sound/pci/hda/patch_via.c:			 sizeof(codec->bus->card->mixername),
./sound/pci/hda/hda_codec.c:		 "hd-audio%d", card->number);
./sound/pci/hda/hda_codec.c:	if (!err && (codec->afg || !*codec->bus->card->mixername))
./sound/pci/hda/hda_codec.c:		snprintf(codec->bus->card->mixername,
./sound/pci/hda/hda_codec.c:			 sizeof(codec->bus->card->mixername),
./sound/pci/hda/hda_codec.c: * toggle card->shutdown to allow/disallow the device access (as a hack)
./sound/pci/hda/hda_codec.c:	spin_lock(&card->files_lock);
./sound/pci/hda/hda_codec.c:	if (card->shutdown) {
./sound/pci/hda/hda_codec.c:		spin_unlock(&card->files_lock);
./sound/pci/hda/hda_codec.c:	card->shutdown = 1;
./sound/pci/hda/hda_codec.c:	spin_unlock(&card->files_lock);
./sound/pci/hda/hda_codec.c:	spin_lock(&card->files_lock);
./sound/pci/hda/hda_codec.c:	card->shutdown = 0;
./sound/pci/hda/hda_codec.c:	spin_unlock(&card->files_lock);
./sound/pci/hda/hda_codec.c:	if (!list_empty(&card->ctl_files)) {
./sound/pci/cs4281.c:	card->private_data = chip;
./sound/pci/cs4281.c:	strcpy(card->driver, "CS4281");
./sound/pci/cs4281.c:	strcpy(card->shortname, "Cirrus Logic CS4281");
./sound/pci/cs4281.c:	sprintf(card->longname, "%s at 0x%lx, irq %d",
./sound/pci/cs4281.c:		card->shortname,
./sound/pci/cs4281.c:	struct cs4281 *chip = card->private_data;
./sound/pci/cs4281.c:	struct cs4281 *chip = card->private_data;
./sound/pci/azt3328.c:	strcpy(card->mixername, "AZF3328 mixer");
./sound/pci/azt3328.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/azt3328.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/azt3328.c:	tid.card = chip->card->number;
./sound/pci/azt3328.c:			IRQF_SHARED, card->shortname, chip)) {
./sound/pci/azt3328.c:	strcpy(card->driver, "AZF3328");
./sound/pci/azt3328.c:	strcpy(card->shortname, "Aztech AZF3328 (PCI168)");
./sound/pci/azt3328.c:	card->private_data = chip;
./sound/pci/azt3328.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/azt3328.c:		card->shortname, chip->ctrl_io, chip->irq);
./sound/pci/azt3328.c:	struct snd_azf3328 *chip = card->private_data;
./sound/pci/azt3328.c:	const struct snd_azf3328 *chip = card->private_data;
./sound/pci/cmipci.c:#define CM_NXCHG		0x80000000	/* don't map base reg dword->sample */
./sound/pci/cmipci.c:	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);
./sound/pci/cmipci.c:	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 0, &pcm);
./sound/pci/cmipci.c:	err = snd_pcm_new(cm->card, cm->card->driver, device, 1, 1, &pcm);
./sound/pci/cmipci.c:	strcpy(card->mixername, "CMedia PCI");
./sound/pci/cmipci.c:	snd_iprintf(buffer, "%s\n", cm->card->longname);
./sound/pci/cmipci.c:	if ((err = pci_request_regions(pci, card->driver)) < 0) {
./sound/pci/cmipci.c:			IRQF_SHARED, card->driver, cm)) {
./sound/pci/cmipci.c:		sprintf(cm->card->driver + strlen(cm->card->driver),
./sound/pci/cmipci.c:		strcpy(cm->card->driver + strlen(cm->card->driver), "-SWIEC");
./sound/pci/cmipci.c:	sprintf(card->shortname, "C-Media CMI%d", val);
./sound/pci/cmipci.c:	sprintf(card->longname, "%s%s at %#lx, irq %i",
./sound/pci/cmipci.c:		card->shortname, modelstr, cm->iobase, cm->irq);
./sound/pci/cmipci.c:		strcpy(card->driver, "CMI8738");
./sound/pci/cmipci.c:		strcpy(card->driver, "CMI8338");
./sound/pci/cmipci.c:		strcpy(card->driver, "CMIPCI");
./sound/pci/cmipci.c:	card->private_data = cm;
./sound/pci/cmipci.c:	struct cmipci *cm = card->private_data;
./sound/pci/cmipci.c:	struct cmipci *cm = card->private_data;
./sound/pci/rme9652/hdspm.c:			sprintf(buf, "%s MIDIoverMADI", card->shortname);
./sound/pci/rme9652/hdspm.c:			sprintf(buf, "%s MIDIoverMADI", card->shortname);
./sound/pci/rme9652/hdspm.c:			sprintf(buf, "%s MIDI %d", card->shortname, id+1);
./sound/pci/rme9652/hdspm.c:				card->id, id+1);
./sound/pci/rme9652/hdspm.c:		sprintf(buf, "%s MTC %d", card->shortname, id+1);
./sound/pci/rme9652/hdspm.c:				"%s MTC %d", card->id, id+1);
./sound/pci/rme9652/hdspm.c:			hdspm->card_name, hdspm->card->number + 1,
./sound/pci/rme9652/hdspm.c:		    hdspm->card_name, hdspm->card->number + 1,
./sound/pci/rme9652/hdspm.c:	strcpy(card->mixername, "Xilinx FPGA");
./sound/pci/rme9652/hdspm.c:	strcpy(card->driver, "HDSPM");
./sound/pci/rme9652/hdspm.c:	struct hdspm *hdspm = card->private_data;
./sound/pci/rme9652/hdspm.c:	hdspm = card->private_data;
./sound/pci/rme9652/hdspm.c:	card->private_free = snd_hdspm_card_free;
./sound/pci/rme9652/hdspm.c:		sprintf(card->shortname, "%s_%x",
./sound/pci/rme9652/hdspm.c:		sprintf(card->longname, "%s S/N 0x%x at 0x%lx, irq %d",
./sound/pci/rme9652/hdspm.c:		sprintf(card->shortname, "%s", hdspm->card_name);
./sound/pci/rme9652/hdspm.c:		sprintf(card->longname, "%s at 0x%lx, irq %d",
./sound/pci/rme9652/hdsp.c:	sprintf (buf, "%s MIDI %d", card->shortname, id+1);
./sound/pci/rme9652/hdsp.c:		    hdsp->card->number + 1);
./sound/pci/rme9652/hdsp.c:		strcpy(card->shortname, "Hammerfall DSP");
./sound/pci/rme9652/hdsp.c:		sprintf(card->longname, "%s at 0x%lx, irq %d", hdsp->card_name,
./sound/pci/rme9652/hdsp.c:	strcpy(card->driver, "H-DSP");
./sound/pci/rme9652/hdsp.c:	strcpy(card->mixername, "Xilinx FPGA");
./sound/pci/rme9652/hdsp.c:	struct hdsp *hdsp = card->private_data;
./sound/pci/rme9652/hdsp.c:	hdsp = card->private_data;
./sound/pci/rme9652/hdsp.c:	card->private_free = snd_hdsp_card_free;
./sound/pci/rme9652/hdsp.c:	strcpy(card->shortname, "Hammerfall DSP");
./sound/pci/rme9652/hdsp.c:	sprintf(card->longname, "%s at 0x%lx, irq %d", hdsp->card_name,
./sound/pci/rme9652/rme9652.c:#define RME9652_wsel_rd	   (1<<5)	/* if Word-Clock is used and valid then 1 */
./sound/pci/rme9652/rme9652.c:	snd_iprintf(buffer, "%s (Card #%d)\n", rme9652->card_name, rme9652->card->number + 1);
./sound/pci/rme9652/rme9652.c:		strcpy(card->driver, "RME9636");
./sound/pci/rme9652/rme9652.c:		strcpy(card->driver, "RME9636");
./sound/pci/rme9652/rme9652.c:		strcpy(card->driver, "RME9652");
./sound/pci/rme9652/rme9652.c:		strcpy(card->driver, "RME9652");
./sound/pci/rme9652/rme9652.c:	struct snd_rme9652 *rme9652 = (struct snd_rme9652 *) card->private_data;
./sound/pci/rme9652/rme9652.c:	rme9652 = (struct snd_rme9652 *) card->private_data;
./sound/pci/rme9652/rme9652.c:	card->private_free = snd_rme9652_card_free;
./sound/pci/rme9652/rme9652.c:	strcpy(card->shortname, rme9652->card_name);
./sound/pci/rme9652/rme9652.c:	sprintf(card->longname, "%s at 0x%lx, irq %d",
./sound/pci/rme9652/rme9652.c:		card->shortname, rme9652->port, rme9652->irq);
./sound/pci/aw2/aw2-alsa.c:	strcpy(card->driver, "aw2");
./sound/pci/aw2/aw2-alsa.c:	strcpy(card->shortname, "Audiowerk2");
./sound/pci/aw2/aw2-alsa.c:	sprintf(card->longname, "%s with SAA7146 irq %i",
./sound/pci/aw2/aw2-alsa.c:		card->shortname, chip->irq);
./sound/pci/ak4531_codec.c:	strcpy(card->mixername, "Asahi Kasei AK4531");
./sound/pci/asihpi/asihpi.c:		 substream->pcm->card->number,
./sound/pci/asihpi/asihpi.c:	if (card->can_dma) {
./sound/pci/asihpi/asihpi.c:			if (card->support_grouping) {
./sound/pci/asihpi/asihpi.c:			!card->can_dma)
./sound/pci/asihpi/asihpi.c:			if (card->support_grouping) {
./sound/pci/asihpi/asihpi.c:		if (card->support_grouping)
./sound/pci/asihpi/asihpi.c:		if (!card->can_dma)
./sound/pci/asihpi/asihpi.c:			if (card->can_dma) { /* buffer wrap is handled at lower level */
./sound/pci/asihpi/asihpi.c:	    hpi_outstream_open(card->adapter_index,
./sound/pci/asihpi/asihpi.c:	snd_card_asihpi_playback.channels_max = card->out_max_chans;
./sound/pci/asihpi/asihpi.c:	card->out_max_chans * 4096; */
./sound/pci/asihpi/asihpi.c:	if (card->support_grouping)
./sound/pci/asihpi/asihpi.c:	if (card->can_dma)
./sound/pci/asihpi/asihpi.c:		card->update_interval_frames);
./sound/pci/asihpi/asihpi.c:		card->update_interval_frames * 2, UINT_MAX);
./sound/pci/asihpi/asihpi.c:		   card->adapter_index, substream->number);
./sound/pci/asihpi/asihpi.c:	    hpi_instream_open(card->adapter_index,
./sound/pci/asihpi/asihpi.c:	snd_card_asihpi_capture.channels_max = card->in_max_chans;
./sound/pci/asihpi/asihpi.c:	if (card->support_grouping)
./sound/pci/asihpi/asihpi.c:	if (card->can_dma)
./sound/pci/asihpi/asihpi.c:		card->update_interval_frames);
./sound/pci/asihpi/asihpi.c:		card->update_interval_frames * 2, UINT_MAX);
./sound/pci/asihpi/asihpi.c:	strcpy(card->mixername, "Asihpi Mixer");
./sound/pci/asihpi/asihpi.c:	/* Should this be enable[hpi_card->index] ? */
./sound/pci/asihpi/asihpi.c:	err = snd_card_create(hpi_card->index,
./sound/pci/asihpi/asihpi.c:			      id[hpi_card->index], THIS_MODULE,
./sound/pci/asihpi/asihpi.c:			hpi_card->index, card->number);
./sound/pci/asihpi/asihpi.c:	asihpi = (struct snd_card_asihpi *) card->private_data;
./sound/pci/asihpi/asihpi.c:	asihpi->adapter_index = hpi_card->index;
./sound/pci/asihpi/asihpi.c:	strcpy(card->driver, "ASIHPI");
./sound/pci/asihpi/asihpi.c:	sprintf(card->shortname, "AudioScience ASI%4X", asihpi->type);
./sound/pci/asihpi/asihpi.c:	sprintf(card->longname, "%s %i",
./sound/pci/asihpi/asihpi.c:			card->shortname, asihpi->adapter_index);
./sound/pci/asihpi/asihpi.c:		hpi_card->snd_card_asihpi = card;
./sound/pci/asihpi/asihpi.c:	snd_card_free(hpi_card->snd_card_asihpi);
./sound/pci/asihpi/asihpi.c:	hpi_card->snd_card_asihpi = NULL;
./sound/pci/sonicvibes.c:	strcpy(card->mixername, "S3 SonicVibes");
./sound/pci/sonicvibes.c:	strcpy(card->driver, "SonicVibes");
./sound/pci/sonicvibes.c:	strcpy(card->shortname, "S3 SonicVibes");
./sound/pci/sonicvibes.c:	sprintf(card->longname, "%s rev %i at 0x%llx, irq %i",
./sound/pci/sonicvibes.c:		card->shortname,
./sound/pci/via82xx_modem.c:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);
./sound/pci/via82xx_modem.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx_modem.c:	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
./sound/pci/via82xx_modem.c:	struct via82xx_modem *chip = card->private_data;
./sound/pci/via82xx_modem.c:	struct via82xx_modem *chip = card->private_data;
./sound/pci/via82xx_modem.c:	if ((err = pci_request_regions(pci, card->driver)) < 0) {
./sound/pci/via82xx_modem.c:			card->driver, chip)) {
./sound/pci/via82xx_modem.c:		strcpy(card->driver, "VIA82XX-MODEM");
./sound/pci/via82xx_modem.c:		sprintf(card->shortname, "VIA 82XX modem");
./sound/pci/via82xx_modem.c:	card->private_data = chip;
./sound/pci/via82xx_modem.c:	sprintf(card->longname, "%s at 0x%lx, irq %d",
./sound/pci/via82xx_modem.c:		card->shortname, chip->port, chip->irq);
./sound/pci/cs5535audio/cs5535audio_pm.c:	struct cs5535audio *cs5535au = card->private_data;
./sound/pci/cs5535audio/cs5535audio_pm.c:	struct cs5535audio *cs5535au = card->private_data;
./sound/pci/cs5535audio/cs5535audio.c:	card->private_data = cs5535au;
./sound/pci/cs5535audio/cs5535audio.c:	strcpy(card->driver, DRIVER_NAME);
./sound/pci/cs5535audio/cs5535audio.c:	strcpy(card->shortname, "CS5535 Audio");
./sound/pci/cs5535audio/cs5535audio.c:	sprintf(card->longname, "%s %s at 0x%lx, irq %i",
./sound/pci/cs5535audio/cs5535audio.c:		card->shortname, card->driver,
./sound/pci/atiixp_modem.c:	struct atiixp_modem *chip = card->private_data;
./sound/pci/atiixp_modem.c:	struct atiixp_modem *chip = card->private_data;
./sound/pci/atiixp_modem.c:			card->shortname, chip)) {
./sound/pci/atiixp_modem.c:	strcpy(card->driver, "ATIIXP-MODEM");
./sound/pci/atiixp_modem.c:	strcpy(card->shortname, "ATI IXP Modem");
./sound/pci/atiixp_modem.c:	card->private_data = chip;
./sound/pci/atiixp_modem.c:	sprintf(card->longname, "%s rev %x at 0x%lx, irq %i",
./sound/pci/atiixp_modem.c:		card->shortname, pci->revision, chip->addr, chip->irq);
./sound/pci/rme32.c:	/* enable AutoSync for record-preparing */
./sound/pci/rme32.c:	snd_iprintf(buffer, rme32->card->longname);
./sound/pci/rme32.c:	snd_iprintf(buffer, " (index #%d)\n", rme32->card->number + 1);
./sound/pci/rme32.c:	snd_rme32_free(card->private_data);
./sound/pci/rme32.c:	card->private_free = snd_rme32_card_free;
./sound/pci/rme32.c:	rme32 = (struct rme32 *) card->private_data;
./sound/pci/rme32.c:	strcpy(card->driver, "Digi32");
./sound/pci/rme32.c:		strcpy(card->shortname, "RME Digi32");
./sound/pci/rme32.c:		strcpy(card->shortname, "RME Digi32/8");
./sound/pci/rme32.c:		strcpy(card->shortname, "RME Digi32 PRO");
./sound/pci/rme32.c:	sprintf(card->longname, "%s (Rev. %d) at 0x%lx, irq %d",
./sound/pci/rme32.c:		card->shortname, rme32->rev, rme32->port, rme32->irq);
./sound/pci/sis7019.c:	struct sis7019 *sis = card->private_data;
./sound/pci/sis7019.c:	struct sis7019 *sis = card->private_data;
./sound/pci/sis7019.c:				card->shortname, sis)) {
./sound/pci/sis7019.c:	struct sis7019 *sis = card->private_data;
./sound/pci/sis7019.c:				card->shortname, sis)) {
./sound/pci/sis7019.c:	strcpy(card->driver, "SiS7019");
./sound/pci/sis7019.c:	strcpy(card->shortname, "SiS7019");
./sound/pci/sis7019.c:	sis = card->private_data;
./sound/pci/sis7019.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/sis7019.c:			card->shortname, snd_ac97_get_short_name(sis->ac97[0]),
./sound/pci/atiixp.c:	struct atiixp *chip = card->private_data;
./sound/pci/atiixp.c:	struct atiixp *chip = card->private_data;
./sound/pci/atiixp.c:			card->shortname, chip)) {
./sound/pci/atiixp.c:	strcpy(card->driver, spdif_aclink ? "ATIIXP" : "ATIIXP-SPDMA");
./sound/pci/atiixp.c:	strcpy(card->shortname, "ATI IXP");
./sound/pci/atiixp.c:	card->private_data = chip;
./sound/pci/atiixp.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/atiixp.c:		 "%s rev %x with %s at %#lx, irq %i", card->shortname,
./sound/pci/via82xx.c:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 4, 1, &pcm);
./sound/pci/via82xx.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:	err = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 1, &pcm);
./sound/pci/via82xx.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);
./sound/pci/via82xx.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:	err = snd_pcm_new(chip->card, chip->card->shortname, 1, 1, 0, &pcm);
./sound/pci/via82xx.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:	err = snd_pcm_new(chip->card, chip->card->shortname, 0, 1, 1, &pcm);
./sound/pci/via82xx.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/via82xx.c:	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
./sound/pci/via82xx.c:	struct via82xx *chip = card->private_data;
./sound/pci/via82xx.c:	struct via82xx *chip = card->private_data;
./sound/pci/via82xx.c:	if ((err = pci_request_regions(pci, card->driver)) < 0) {
./sound/pci/via82xx.c:			card->driver, chip)) {
./sound/pci/via82xx.c:		strcpy(card->driver, "VIA686A");
./sound/pci/via82xx.c:		sprintf(card->shortname, "VIA 82C686A/B rev%x", pci->revision);
./sound/pci/via82xx.c:		sprintf(card->shortname, "VIA 823x rev%x", pci->revision);
./sound/pci/via82xx.c:				strcpy(card->shortname, via823x_cards[i].name);
./sound/pci/via82xx.c:			strcpy(card->driver, "VIA8233A");
./sound/pci/via82xx.c:			strcpy(card->driver, "VIA8237"); /* no slog assignment */
./sound/pci/via82xx.c:			strcpy(card->driver, "VIA8233");
./sound/pci/via82xx.c:	card->private_data = chip;
./sound/pci/via82xx.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/via82xx.c:		 "%s with %s at %#lx, irq %d", card->shortname,
./sound/pci/lola/lola.c:	strcpy(card->driver, "Lola");
./sound/pci/lola/lola.c:	strlcpy(card->shortname, "Digigram Lola", sizeof(card->shortname));
./sound/pci/lola/lola.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/lola/lola.c:		 card->shortname, chip->bar[0].addr, chip->irq);
./sound/pci/lola/lola.c:	strcpy(card->mixername, card->shortname);
./sound/pci/lola/lola.c:	card->private_data = chip;
./sound/pci/intel8x0.c:		sprintf(pcm->name, "%s - %s", chip->card->shortname, rec->suffix);
./sound/pci/intel8x0.c:		strcpy(pcm->name, chip->card->shortname);
./sound/pci/intel8x0.c:	struct intel8x0 *chip = card->private_data;
./sound/pci/intel8x0.c:	struct intel8x0 *chip = card->private_data;
./sound/pci/intel8x0.c:			IRQF_SHARED, card->shortname, chip)) {
./sound/pci/intel8x0.c:	if ((err = pci_request_regions(pci, card->shortname)) < 0) {
./sound/pci/intel8x0.c:			IRQF_SHARED, card->shortname, chip)) {
./sound/pci/intel8x0.c:	strcpy(card->driver, "ICH");
./sound/pci/intel8x0.c:			strcpy(card->driver, "NFORCE");
./sound/pci/intel8x0.c:			strcpy(card->driver, "ICH4");
./sound/pci/intel8x0.c:	strcpy(card->shortname, "Intel ICH");
./sound/pci/intel8x0.c:			strcpy(card->shortname, name->s);
./sound/pci/intel8x0.c:	card->private_data = chip;
./sound/pci/intel8x0.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/intel8x0.c:		 "%s with %s at irq %i", card->shortname,
./sound/pci/lx6464es/lx6464es.c:	strcpy(card->driver, "lx6464es");
./sound/pci/lx6464es/lx6464es.c:	strcpy(card->shortname, "Digigram LX6464ES");
./sound/pci/lx6464es/lx6464es.c:	sprintf(card->longname, "%s at 0x%lx, 0x%p, irq %i",
./sound/pci/lx6464es/lx6464es.c:		card->shortname, chip->port_plx,
./sound/pci/als300.c:			card->shortname, chip)) {
./sound/pci/als300.c:	struct snd_als300 *chip = card->private_data;
./sound/pci/als300.c:	struct snd_als300 *chip = card->private_data;
./sound/pci/als300.c:	card->private_data = chip;
./sound/pci/als300.c:	strcpy(card->driver, "ALS300");
./sound/pci/als300.c:		sprintf(card->shortname, "ALS300+ (Rev. %d)", chip->revision);
./sound/pci/als300.c:		sprintf(card->shortname, "ALS300 (Rev. %c)", 'A' +
./sound/pci/als300.c:	sprintf(card->longname, "%s at 0x%lx irq %i",
./sound/pci/als300.c:				card->shortname, chip->port, chip->irq);
./sound/pci/korg1212/korg1212.c:        u32 __iomem * inDoorbellPtr;	     // address of the card->host doorbell register
./sound/pci/korg1212/korg1212.c:	snd_iprintf(buffer, korg1212->card->longname);
./sound/pci/korg1212/korg1212.c:	snd_iprintf(buffer, " (index #%d)\n", korg1212->card->number + 1);
./sound/pci/korg1212/korg1212.c:	strcpy(card->driver, "korg1212");
./sound/pci/korg1212/korg1212.c:	strcpy(card->shortname, "korg1212");
./sound/pci/korg1212/korg1212.c:	sprintf(card->longname, "%s at 0x%lx, irq %d", card->shortname,
./sound/pci/korg1212/korg1212.c:        K1212_DEBUG_PRINTK("K1212_DEBUG: %s\n", card->longname);
./sound/pci/ali5451/ali5451.c:	struct snd_ali *chip = card->private_data;
./sound/pci/ali5451/ali5451.c:	struct snd_ali *chip = card->private_data;
./sound/pci/ali5451/ali5451.c:	card->private_data = codec;
./sound/pci/ali5451/ali5451.c:	strcpy(card->driver, "ALI5451");
./sound/pci/ali5451/ali5451.c:	strcpy(card->shortname, "ALI 5451");
./sound/pci/ali5451/ali5451.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/ali5451/ali5451.c:		card->shortname, codec->port, codec->irq);
./sound/pci/ymfpci/ymfpci.c:	card->private_data = chip;
./sound/pci/ymfpci/ymfpci.c:	strcpy(card->driver, str);
./sound/pci/ymfpci/ymfpci.c:	sprintf(card->shortname, "Yamaha %s (%s)", model, str);
./sound/pci/ymfpci/ymfpci.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/ymfpci/ymfpci.c:		card->shortname,
./sound/pci/ymfpci/ymfpci_main.c:	tid.card = chip->card->number;
./sound/pci/ymfpci/ymfpci_main.c:	struct snd_ymfpci *chip = card->private_data;
./sound/pci/ymfpci/ymfpci_main.c:	struct snd_ymfpci *chip = card->private_data;
./sound/pci/es1938.c:	struct es1938 *chip = card->private_data;
./sound/pci/es1938.c:	struct es1938 *chip = card->private_data;
./sound/pci/es1938.c:	strcpy(card->mixername, "ESS Solo-1");
./sound/pci/es1938.c:	card->private_data = chip;
./sound/pci/es1938.c:	strcpy(card->driver, "ES1938");
./sound/pci/es1938.c:	strcpy(card->shortname, "ESS ES1938 (Solo-1)");
./sound/pci/es1938.c:	sprintf(card->longname, "%s rev %i, irq %i",
./sound/pci/es1938.c:		card->shortname,
./sound/pci/pcxhr/pcxhr.c:		strcpy(card->driver, DRIVER_NAME);
./sound/pci/pcxhr/pcxhr.c:		sprintf(card->shortname, "%s [PCM #%d]", mgr->shortname, i);
./sound/pci/pcxhr/pcxhr.c:		sprintf(card->longname, "%s [PCM #%d]", mgr->longname, i);
./sound/pci/echoaudio/midi.c:	if ((err = snd_rawmidi_new(card, card->shortname, 0, 1, 1,
./sound/pci/echoaudio/midi.c:	strcpy(chip->rmidi->name, card->shortname);
./sound/pci/echoaudio/echoaudio.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pci/echoaudio/echoaudio.c:	strcpy(card->driver, "Echo_" ECHOCARD_NAME);
./sound/pci/echoaudio/echoaudio.c:	strcpy(card->shortname, chip->card_name);
./sound/pci/echoaudio/echoaudio.c:	sprintf(card->longname, "%s rev.%d (DSP%s) at 0x%lx irq %i",
./sound/pci/echoaudio/echoaudio.c:		card->shortname, pci_id->subdevice & 0x000f, dsp,
./sound/pci/echoaudio/echoaudio.c:	snd_printk(KERN_INFO "Card registered: %s\n", card->longname);
./sound/pci/bt87x.c:	strcpy(card->driver, "Bt87x");
./sound/pci/bt87x.c:	sprintf(card->shortname, "Brooktree Bt%x", pci->device);
./sound/pci/bt87x.c:	sprintf(card->longname, "%s at %#llx, irq %i",
./sound/pci/bt87x.c:		card->shortname, (unsigned long long)pci_resource_start(pci, 0),
./sound/pci/bt87x.c:	strcpy(card->mixername, "Bt87x");
./sound/pci/riptide/riptide.c:	struct snd_riptide *chip = card->private_data;
./sound/pci/riptide/riptide.c:	struct snd_riptide *chip = card->private_data;
./sound/pci/riptide/riptide.c:	snd_iprintf(buffer, "%s\n\n", chip->card->longname);
./sound/pci/riptide/riptide.c:	card->private_data = chip;
./sound/pci/riptide/riptide.c:	strcpy(card->driver, "RIPTIDE");
./sound/pci/riptide/riptide.c:	strcpy(card->shortname, "Riptide");
./sound/pci/riptide/riptide.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/riptide/riptide.c:		 card->shortname, chip->port, chip->irq, chip->mpuaddr,
./sound/pci/riptide/riptide.c:	snprintf(card->longname, sizeof(card->longname),
./sound/pci/riptide/riptide.c:		 card->shortname, chip->port, chip->irq, chip->mpuaddr,
./sound/pci/intel8x0m.c:		sprintf(pcm->name, "%s - %s", chip->card->shortname, rec->suffix);
./sound/pci/intel8x0m.c:		strcpy(pcm->name, chip->card->shortname);
./sound/pci/intel8x0m.c:	struct intel8x0m *chip = card->private_data;
./sound/pci/intel8x0m.c:	struct intel8x0m *chip = card->private_data;
./sound/pci/intel8x0m.c:			IRQF_SHARED, card->shortname, chip)) {
./sound/pci/intel8x0m.c:	if ((err = pci_request_regions(pci, card->shortname)) < 0) {
./sound/pci/intel8x0m.c:			card->shortname, chip)) {
./sound/pci/intel8x0m.c:	strcpy(card->driver, "ICH-MODEM");
./sound/pci/intel8x0m.c:	strcpy(card->shortname, "Intel ICH");
./sound/pci/intel8x0m.c:			strcpy(card->shortname, name->s);
./sound/pci/intel8x0m.c:	strcat(card->shortname," Modem");
./sound/pci/intel8x0m.c:	card->private_data = chip;
./sound/pci/intel8x0m.c:	sprintf(card->longname, "%s at irq %i",
./sound/pci/intel8x0m.c:		card->shortname, chip->irq);
./sound/pci/ac97/ac97_proc.c:	if ((entry = snd_info_create_card_entry(bus->card, name, bus->card->proc_root)) != NULL) {
./sound/pci/ac97/ac97_codec.c:	ac97->dev.parent = ac97->bus->card->dev;
./sound/pci/ac97/ac97_codec.c:		     ac97->bus->card->number, ac97->num,
./sound/pci/ac97/ac97_codec.c:		if (card->mixername[0] == '\0') {
./sound/pci/ac97/ac97_codec.c:			strcpy(card->mixername, name);
./sound/pci/ac97/ac97_codec.c:			if (strlen(card->mixername) + 1 + strlen(name) + 1 <= sizeof(card->mixername)) {
./sound/pci/ac97/ac97_codec.c:				strcat(card->mixername, ",");
./sound/pci/ac97/ac97_codec.c:				strcat(card->mixername, name);
./sound/pci/ac97/ac97_codec.c:		if (card->mixername[0] == '\0') {
./sound/pci/ac97/ac97_codec.c:			strcpy(card->mixername, name);
./sound/pci/ac97/ac97_codec.c:			if (strlen(card->mixername) + 1 + strlen(name) + 1 <= sizeof(card->mixername)) {
./sound/pci/ac97/ac97_codec.c:				strcat(card->mixername, ",");
./sound/pci/ac97/ac97_codec.c:				strcat(card->mixername, name);
./sound/pci/ens1370.c:	struct ensoniq *ensoniq = card->private_data;
./sound/pci/ens1370.c:	struct ensoniq *ensoniq = card->private_data;
./sound/pci/ens1370.c:	card->private_data = ensoniq;
./sound/pci/ens1370.c:	strcpy(card->driver, DRIVER_NAME);
./sound/pci/ens1370.c:	strcpy(card->shortname, "Ensoniq AudioPCI");
./sound/pci/ens1370.c:	sprintf(card->longname, "%s %s at 0x%lx, irq %i",
./sound/pci/ens1370.c:		card->shortname,
./sound/pci/ens1370.c:		card->driver,
./sound/pci/cs5530.c:	strcpy(card->driver, "CS5530");
./sound/pci/cs5530.c:	strcpy(card->shortname, "CS5530 Audio");
./sound/pci/cs5530.c:	sprintf(card->longname, "%s at 0x%lx", card->shortname, chip->pci_base);
./sound/pci/nm256/nm256.c:				chip->card->driver, chip)) {
./sound/pci/nm256/nm256.c:	err = snd_pcm_new(chip->card, chip->card->driver, device,
./sound/pci/nm256/nm256.c:		sprintf(chip->card->mixername, "%s AC97", chip->card->driver);
./sound/pci/nm256/nm256.c:	struct nm256 *chip = card->private_data;
./sound/pci/nm256/nm256.c:	struct nm256 *chip = card->private_data;
./sound/pci/nm256/nm256.c:					     card->driver);
./sound/pci/nm256/nm256.c:	if (!strcmp(card->driver, "NM256AV")) {
./sound/pci/nm256/nm256.c:					      card->driver);
./sound/pci/nm256/nm256.c:		strcpy(card->driver, "NM256AV");
./sound/pci/nm256/nm256.c:		strcpy(card->driver, "NM256ZX");
./sound/pci/nm256/nm256.c:		strcpy(card->driver, "NM256XL+");
./sound/pci/nm256/nm256.c:	card->private_data = chip;
./sound/pci/nm256/nm256.c:	sprintf(card->shortname, "NeoMagic %s", card->driver);
./sound/pci/nm256/nm256.c:	sprintf(card->longname, "%s at 0x%lx & 0x%lx, irq %d",
./sound/pci/nm256/nm256.c:		card->shortname,
./sound/pci/ca0106/ca0106_mixer.c:	strcpy(card->mixername, "CA0106");
./sound/pci/ca0106/ca0106_main.c:	strcpy(card->driver, "CA0106");
./sound/pci/ca0106/ca0106_main.c:	strcpy(card->shortname, "CA0106");
./sound/pci/ca0106/ca0106_main.c:	sprintf(card->longname, "%s at 0x%lx irq %i",
./sound/pci/ca0106/ca0106_main.c:	card->private_data = chip;
./sound/pci/ca0106/ca0106_main.c:	struct snd_ca0106 *chip = card->private_data;
./sound/pci/ca0106/ca0106_main.c:	struct snd_ca0106 *chip = card->private_data;
./sound/pci/ice1712/ice1712.c:	strcat(ice->card->mixername, "ICE1712 - multitrack");
./sound/pci/ice1712/ice1712.c:	snd_iprintf(buffer, "%s\n\n", ice->card->longname);
./sound/pci/ice1712/ice1712.c:	strcpy(card->driver, "ICE1712");
./sound/pci/ice1712/ice1712.c:	strcpy(card->shortname, "ICEnsemble ICE1712");
./sound/pci/ice1712/ice1712.c:				strcpy(card->shortname, c->name);
./sound/pci/ice1712/ice1712.c:					strcpy(card->driver, c->driver);
./sound/pci/ice1712/ice1712.c:				 "%s %d", c->mpu401_1_name, card->number);
./sound/pci/ice1712/ice1712.c:					 card->number);
./sound/pci/ice1712/ice1712.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/ice1712/ice1712.c:		card->shortname, ice->port, ice->irq);
./sound/pci/ice1712/ice1724.c:	strcat(ice->card->mixername, "ICE1724 - multitrack");
./sound/pci/ice1712/ice1724.c:	snd_iprintf(buffer, "%s\n\n", ice->card->longname);
./sound/pci/ice1712/ice1724.c:	card->private_data = ice;
./sound/pci/ice1712/ice1724.c:	strcpy(card->driver, "ICE1724");
./sound/pci/ice1712/ice1724.c:	strcpy(card->shortname, "ICEnsemble ICE1724");
./sound/pci/ice1712/ice1724.c:				strcpy(card->shortname, c->name);
./sound/pci/ice1712/ice1724.c:					strcpy(card->driver, c->driver);
./sound/pci/ice1712/ice1724.c:	sprintf(card->longname, "%s at 0x%lx, irq %i",
./sound/pci/ice1712/ice1724.c:		card->shortname, ice->port, ice->irq);
./sound/pci/ice1712/ice1724.c:	struct snd_ice1712 *ice = card->private_data;
./sound/pci/ice1712/ice1724.c:	struct snd_ice1712 *ice = card->private_data;
./sound/pci/au88x0/au88x0_mpu401.c:	snprintf(rmidi->name, sizeof(rmidi->name), "%s MIDI %d", CARD_NAME_SHORT , vortex->card->number);
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_SRC_U0 + (src << 2),
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_SRC_U1 + (src << 2), b & 0xffff);
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_SRC_U2 + (src << 2),
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_IRQ_CTRL,
./sound/pci/au88x0/au88x0_core.c:		hwread(card->mmio, VORTEX_IRQ_CTRL) | IRQ_TIMER | 0x60);
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_IRQ_CTRL,
./sound/pci/au88x0/au88x0_core.c:		hwread(card->mmio, VORTEX_IRQ_CTRL) & ~IRQ_TIMER);
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_CTRL,
./sound/pci/au88x0/au88x0_core.c:		hwread(card->mmio, VORTEX_CTRL) | CTRL_IRQ_ENABLE);
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_IRQ_CTRL,
./sound/pci/au88x0/au88x0_core.c:		(hwread(card->mmio, VORTEX_IRQ_CTRL) & 0xffffefc0) | 0x24);
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_CTRL,
./sound/pci/au88x0/au88x0_core.c:		hwread(card->mmio, VORTEX_CTRL) & ~CTRL_IRQ_ENABLE);
./sound/pci/au88x0/au88x0_core.c:	while (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_CODEC_IO,
./sound/pci/au88x0/au88x0_core.c:	hwread(card->mmio, VORTEX_CODEC_IO);
./sound/pci/au88x0/au88x0_core.c:	while (!(hwread(card->mmio, VORTEX_CODEC_CTRL) & 0x100)) {
./sound/pci/au88x0/au88x0_core.c:	hwwrite(card->mmio, VORTEX_CODEC_IO, read_addr);
./sound/pci/au88x0/au88x0_core.c:		data = hwread(card->mmio, VORTEX_CODEC_IO);
./sound/pci/au88x0/au88x0.c:	strcpy(card->driver, CARD_NAME_SHORT);
./sound/pci/au88x0/au88x0.c:	sprintf(card->shortname, "Aureal Vortex %s", CARD_NAME_SHORT);
./sound/pci/au88x0/au88x0.c:	sprintf(card->longname, "%s at 0x%lx irq %i",
./sound/pci/au88x0/au88x0.c:		card->shortname, chip->io, chip->irq);
./sound/pci/maestro3.c:	err = snd_pcm_new(chip->card, chip->card->driver, device,
./sound/pci/maestro3.c:	strcpy(pcm->name, chip->card->driver);
./sound/pci/maestro3.c:	struct snd_m3 *chip = card->private_data;
./sound/pci/maestro3.c:	struct snd_m3 *chip = card->private_data;
./sound/pci/maestro3.c:	input_dev->name = chip->card->driver;
./sound/pci/maestro3.c:	if ((err = pci_request_regions(pci, card->driver)) < 0) {
./sound/pci/maestro3.c:			card->driver, chip)) {
./sound/pci/maestro3.c:		strcpy(card->driver, "Allegro");
./sound/pci/maestro3.c:		strcpy(card->driver, "Canyon3D-2");
./sound/pci/maestro3.c:		strcpy(card->driver, "Maestro3");
./sound/pci/maestro3.c:	card->private_data = chip;
./sound/pci/maestro3.c:	sprintf(card->shortname, "ESS %s PCI", card->driver);
./sound/pci/maestro3.c:	sprintf(card->longname, "%s at 0x%lx, irq %d",
./sound/pci/maestro3.c:		card->shortname, chip->iobase, chip->irq);
./sound/pci/trident/trident.c:	card->private_data = trident;
./sound/pci/trident/trident.c:	strcpy(card->driver, str);
./sound/pci/trident/trident.c:		strcpy(card->shortname, "SiS ");
./sound/pci/trident/trident.c:		strcpy(card->shortname, "Trident ");
./sound/pci/trident/trident.c:	strcat(card->shortname, card->driver);
./sound/pci/trident/trident.c:	sprintf(card->longname, "%s PCI Audio at 0x%lx, irq %d",
./sound/pci/trident/trident.c:		card->shortname, trident->port, trident->irq);
./sound/pci/trident/trident_main.c:	struct snd_trident *trident = card->private_data;
./sound/pci/trident/trident_main.c:	struct snd_trident *trident = card->private_data;
./sound/oss/sb_card.c:	       "%s, Device PnP id = %s\n", card->card->name, card_id->id,
./sound/oss/dmasound/dmasound_core.c:/* we allow more space for record-enabled because there are extra output lines.
./sound/oss/aedsp16.c:   It is software-only configurable (no jumpers to hard-set irq/dma/mpu-irq),
./sound/isa/cmi8330.c:	strcpy(card->mixername, (acard->type == CMI8329) ? "CMI8329" : "CMI8330/C3D");
./sound/isa/cmi8330.c:					     acard->wss));
./sound/isa/cmi8330.c:	if ((err = cmi8330_add_sb_mixers(acard->sb)) < 0)
./sound/isa/cmi8330.c:	acard->type = (id->devs[3].id[0]) ? CMI8329 : CMI8330;
./sound/isa/cmi8330.c:	acard->cap = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/cmi8330.c:	if (acard->cap == NULL)
./sound/isa/cmi8330.c:	acard->play = pnp_request_card_device(card, id->devs[1].id, NULL);
./sound/isa/cmi8330.c:	if (acard->play == NULL)
./sound/isa/cmi8330.c:	acard->mpu = pnp_request_card_device(card, id->devs[2].id, NULL);
./sound/isa/cmi8330.c:	if (acard->mpu == NULL)
./sound/isa/cmi8330.c:	pdev = acard->cap;
./sound/isa/cmi8330.c:	pdev = acard->play;
./sound/isa/cmi8330.c:	pdev = acard->mpu;
./sound/isa/cmi8330.c:	struct snd_cmi8330 *acard = card->private_data;
./sound/isa/cmi8330.c:	snd_pcm_suspend_all(acard->pcm);
./sound/isa/cmi8330.c:	acard->wss->suspend(acard->wss);
./sound/isa/cmi8330.c:	snd_sbmixer_suspend(acard->sb);
./sound/isa/cmi8330.c:	struct snd_cmi8330 *acard = card->private_data;
./sound/isa/cmi8330.c:	snd_sbdsp_reset(acard->sb);
./sound/isa/cmi8330.c:	snd_sbmixer_suspend(acard->sb);
./sound/isa/cmi8330.c:	acard->wss->resume(acard->wss);
./sound/isa/cmi8330.c:	acard = card->private_data;
./sound/isa/cmi8330.c:	acard->card = card;
./sound/isa/cmi8330.c:	acard = card->private_data;
./sound/isa/cmi8330.c:			     WSS_HW_DETECT, 0, &acard->wss);
./sound/isa/cmi8330.c:	if (acard->wss->hardware != WSS_HW_CMI8330) {
./sound/isa/cmi8330.c:				    SB_HW_AUTO, &acard->sb)) < 0) {
./sound/isa/cmi8330.c:	if (acard->sb->hardware != SB_HW_16) {
./sound/isa/cmi8330.c:	snd_wss_out(acard->wss, CS4231_MISC_INFO, 0x40); /* switch on MODE2 */
./sound/isa/cmi8330.c:		snd_wss_out(acard->wss, i,
./sound/isa/cmi8330.c:	strcpy(card->driver, (acard->type == CMI8329) ? "CMI8329" : "CMI8330/C3D");
./sound/isa/cmi8330.c:	strcpy(card->shortname, (acard->type == CMI8329) ? "C-Media CMI8329" : "C-Media CMI8330/C3D");
./sound/isa/cmi8330.c:	sprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",
./sound/isa/cmi8330.c:		card->shortname,
./sound/isa/cmi8330.c:		acard->wss->port,
./sound/isa/cmi8330.c:	if ((res = snd_cmi8330_pnp(dev, card->private_data, pcard, pid)) < 0) {
./sound/isa/cmi8330.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/msnd/msnd.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle_mixer.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle_mixer.c:	strcpy(card->mixername, "MSND Pinnacle Mixer");
./sound/isa/msnd/msnd_midi.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	strcpy(card->shortname, "Classic/Tahiti/Monterey");
./sound/isa/msnd/msnd_pinnacle.c:	strcpy(card->longname, "Turtle Beach Multisound");
./sound/isa/msnd/msnd_pinnacle.c:	       card->shortname,
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, pin);
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, pin);
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, pin);
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, pin);
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, fiji);
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, fiji);
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, fiji);
./sound/isa/msnd/msnd_pinnacle.c:		strcpy(card->shortname, pinfiji);
./sound/isa/msnd/msnd_pinnacle.c:	strcpy(card->longname, "Turtle Beach Multisound Pinnacle");
./sound/isa/msnd/msnd_pinnacle.c:	       card->shortname,
./sound/isa/msnd/msnd_pinnacle.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	err = request_firmware(&init_fw, INITCODEFILE, card->dev);
./sound/isa/msnd/msnd_pinnacle.c:	err = request_firmware(&perm_fw, PERMCODEFILE, card->dev);
./sound/isa/msnd/msnd_pinnacle.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	err = request_irq(chip->irq, snd_msnd_interrupt, 0, card->shortname,
./sound/isa/msnd/msnd_pinnacle.c:	if (request_region(chip->io, DSP_NUMIO, card->shortname) == NULL) {
./sound/isa/msnd/msnd_pinnacle.c:	if (!request_mem_region(chip->base, BUFFSIZE, card->shortname)) {
./sound/isa/msnd/msnd_pinnacle.c:	struct snd_msnd *chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	chip = card->private_data;
./sound/isa/msnd/msnd_pinnacle.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/sb/sb8.c:	struct snd_sb8 *acard = card->private_data;
./sound/isa/sb/sb8.c:	release_and_free_resource(acard->fm_res);
./sound/isa/sb/sb8.c:	acard = card->private_data;
./sound/isa/sb/sb8.c:	card->private_free = snd_sb8_free;
./sound/isa/sb/sb8.c:	acard->fm_res = request_region(0x388, 4, "SoundBlaster FM");
./sound/isa/sb/sb8.c:	acard->chip = chip;
./sound/isa/sb/sb8.c:	strcpy(card->driver, chip->hardware == SB_HW_PRO ? "SB Pro" : "SB8");
./sound/isa/sb/sb8.c:	strcpy(card->shortname, chip->name);
./sound/isa/sb/sb8.c:	sprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",
./sound/isa/sb/sb8.c:	struct snd_sb8 *acard = card->private_data;
./sound/isa/sb/sb8.c:	struct snd_sb *chip = acard->chip;
./sound/isa/sb/sb8.c:	struct snd_sb8 *acard = card->private_data;
./sound/isa/sb/sb8.c:	struct snd_sb *chip = acard->chip;
./sound/isa/sb/sb16_csp.c:				       p->chip->card->dev);
./sound/isa/sb/sb16_csp.c:	down_write(&card->controls_rwsem);
./sound/isa/sb/sb16_csp.c:	up_write(&card->controls_rwsem);
./sound/isa/sb/emu8000.c:		down_write(&card->controls_rwsem);
./sound/isa/sb/emu8000.c:		up_write(&card->controls_rwsem);
./sound/isa/sb/jazz16.c:	jazz16 = card->private_data;
./sound/isa/sb/jazz16.c:	strcpy(card->driver, "jazz16");
./sound/isa/sb/jazz16.c:	strcpy(card->shortname, "Media Vision Jazz16");
./sound/isa/sb/jazz16.c:	sprintf(card->longname,
./sound/isa/sb/jazz16.c:	struct snd_card_jazz16 *acard = card->private_data;
./sound/isa/sb/jazz16.c:	struct snd_sb *chip = acard->chip;
./sound/isa/sb/jazz16.c:	struct snd_card_jazz16 *acard = card->private_data;
./sound/isa/sb/jazz16.c:	struct snd_sb *chip = acard->chip;
./sound/isa/sb/sb_mixer.c:	strcpy(card->mixername, name);
./sound/isa/sb/sb_mixer.c:		strcpy(card->mixername, "???");
./sound/isa/sb/sb16.c:#define DRIVER_NAME	"snd-card-sbawe"
./sound/isa/sb/sb16.c:#define DRIVER_NAME	"snd-card-sb16"
./sound/isa/sb/sb16.c:	acard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/sb/sb16.c:	if (acard->dev == NULL)
./sound/isa/sb/sb16.c:	acard->devwt = pnp_request_card_device(card, id->devs[1].id, acard->dev);
./sound/isa/sb/sb16.c:	pdev = acard->dev;
./sound/isa/sb/sb16.c:	pdev = acard->devwt;
./sound/isa/sb/sb16.c:		acard->devwt = NULL;
./sound/isa/sb/sb16.c:	struct snd_card_sb16 *acard = card->private_data;
./sound/isa/sb/sb16.c:	release_and_free_resource(acard->fm_res);
./sound/isa/sb/sb16.c:	card->private_free = snd_sb16_free;
./sound/isa/sb/sb16.c:	struct snd_card_sb16 *acard = card->private_data;
./sound/isa/sb/sb16.c:	acard->chip = chip;
./sound/isa/sb/sb16.c:	strcpy(card->driver,
./sound/isa/sb/sb16.c:	strcpy(card->shortname, chip->name);
./sound/isa/sb/sb16.c:	sprintf(card->longname, "%s at 0x%lx, irq %i, dma ",
./sound/isa/sb/sb16.c:		sprintf(card->longname + strlen(card->longname), "%d", xdma8);
./sound/isa/sb/sb16.c:		sprintf(card->longname + strlen(card->longname), "%s%d",
./sound/isa/sb/sb16.c:				    acard->fm_res != NULL || fm_port[dev] == port[dev],
./sound/isa/sb/sb16.c:	struct snd_card_sb16 *acard = card->private_data;
./sound/isa/sb/sb16.c:	struct snd_sb *chip = acard->chip;
./sound/isa/sb/sb16.c:	struct snd_card_sb16 *acard = card->private_data;
./sound/isa/sb/sb16.c:	struct snd_sb *chip = acard->chip;
./sound/isa/sb/sb16.c:	acard = card->private_data;
./sound/isa/sb/sb16.c:	acard->fm_res = request_region(0x388, 4, "SoundBlaster FM");
./sound/isa/sb/sb16.c:		snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/sb/sb16.c:		if ((res = snd_card_sb16_pnp(dev, card->private_data, pcard, pid)) < 0 ||
./sound/isa/galaxy/galaxy.c:	struct snd_galaxy *galaxy = card->private_data;
./sound/isa/galaxy/galaxy.c:	card->private_free = snd_galaxy_free;
./sound/isa/galaxy/galaxy.c:	galaxy = card->private_data;
./sound/isa/galaxy/galaxy.c:	strcpy(card->driver, DRV_NAME);
./sound/isa/galaxy/galaxy.c:	strcpy(card->shortname, DRV_NAME);
./sound/isa/galaxy/galaxy.c:	sprintf(card->longname, "%s at %#lx/%#lx, irq %d, dma %d/%d",
./sound/isa/galaxy/galaxy.c:		card->shortname, port[n], wss_port[n], irq[n], dma1[n],
./sound/isa/als100.c:    card-als100.c - driver for Avance Logic ALS100 based soundcards.
./sound/isa/als100.c:	acard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/als100.c:	if (acard->dev == NULL)
./sound/isa/als100.c:	acard->devmpu = pnp_request_card_device(card, id->devs[1].id, acard->dev);
./sound/isa/als100.c:	acard->devopl = pnp_request_card_device(card, id->devs[2].id, acard->dev);
./sound/isa/als100.c:	pdev = acard->dev;
./sound/isa/als100.c:	pdev = acard->devmpu;
./sound/isa/als100.c:	     	acard->devmpu = NULL;
./sound/isa/als100.c:	pdev = acard->devopl;
./sound/isa/als100.c:	     	acard->devopl = NULL;
./sound/isa/als100.c:	acard = card->private_data;
./sound/isa/als100.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/als100.c:	acard->chip = chip;
./sound/isa/als100.c:		strcpy(card->driver, "DT-019X");
./sound/isa/als100.c:		strcpy(card->shortname, "Diamond Tech. DT-019X");
./sound/isa/als100.c:		sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",
./sound/isa/als100.c:			card->shortname, chip->name, chip->port,
./sound/isa/als100.c:		strcpy(card->driver, "ALS100");
./sound/isa/als100.c:		strcpy(card->shortname, "Avance Logic ALS100");
./sound/isa/als100.c:		sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",
./sound/isa/als100.c:			card->shortname, chip->name, chip->port,
./sound/isa/als100.c:	struct snd_card_als100 *acard = card->private_data;
./sound/isa/als100.c:	struct snd_sb *chip = acard->chip;
./sound/isa/als100.c:	struct snd_card_als100 *acard = card->private_data;
./sound/isa/als100.c:	struct snd_sb *chip = acard->chip;
./sound/isa/es1688/es1688_lib.c:	strcpy(card->mixername, snd_es1688_chip_id(chip));
./sound/isa/es1688/es1688.c:	struct snd_es1688 *chip = card->private_data;
./sound/isa/es1688/es1688.c:	struct snd_es1688 *chip = card->private_data;
./sound/isa/es1688/es1688.c:	strlcpy(card->driver, "ES1688", sizeof(card->driver));
./sound/isa/es1688/es1688.c:	strlcpy(card->shortname, pcm->name, sizeof(card->shortname));
./sound/isa/es1688/es1688.c:	snprintf(card->longname, sizeof(card->longname),
./sound/isa/es1688/es1688.c:			dev_warn(card->dev,
./sound/isa/es1688/es1688.c:	struct snd_es1688 *chip = card->private_data;
./sound/isa/es1688/es1688.c:	chip = card->private_data;
./sound/isa/es1688/es1688.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/es1688/es1688.c:	struct snd_es1688 *chip = card->private_data;
./sound/isa/es1688/es1688.c:	struct snd_es1688 *chip = card->private_data;
./sound/isa/wavefront/wavefront_midi.c:	if (card->private_data == NULL) 
./sound/isa/wavefront/wavefront_midi.c:	acard = card->private_data;
./sound/isa/wavefront/wavefront_midi.c:	return &acard->wavefront.midi;
./sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi = &card->wavefront.midi;
./sound/isa/wavefront/wavefront_midi.c:	snd_wavefront_midi_t *midi = &card->wavefront.midi;
./sound/isa/wavefront/wavefront_midi.c:				midi->timer.data = (unsigned long) substream->rmidi->card->private_data;
./sound/isa/wavefront/wavefront_midi.c:		snd_wavefront_midi_output_write((snd_wavefront_card_t *)substream->rmidi->card->private_data);
./sound/isa/wavefront/wavefront_midi.c:	midi = &card->wavefront.midi;
./sound/isa/wavefront/wavefront_midi.c:	spin_lock_irqsave (&card->wavefront.midi.virtual, flags);
./sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.isvirtual = 1;
./sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.output_mpu = internal_mpu;
./sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.input_mpu = internal_mpu;
./sound/isa/wavefront/wavefront_midi.c:	spin_unlock_irqrestore (&card->wavefront.midi.virtual, flags);
./sound/isa/wavefront/wavefront_midi.c:	spin_lock_irqsave (&card->wavefront.midi.virtual, flags);
./sound/isa/wavefront/wavefront_midi.c:	// snd_wavefront_midi_input_close (card->ics2115_external_rmidi);
./sound/isa/wavefront/wavefront_midi.c:	// snd_wavefront_midi_output_close (card->ics2115_external_rmidi);
./sound/isa/wavefront/wavefront_midi.c:	card->wavefront.midi.isvirtual = 0;
./sound/isa/wavefront/wavefront_midi.c:	spin_unlock_irqrestore (&card->wavefront.midi.virtual, flags);
./sound/isa/wavefront/wavefront_midi.c:	dev = &card->wavefront;
./sound/isa/wavefront/wavefront.c: *  ALSA card-level driver for Turtle Beach Wavefront cards 
./sound/isa/wavefront/wavefront.c:	acard->wss = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/wavefront/wavefront.c:	if (acard->wss == NULL)
./sound/isa/wavefront/wavefront.c:		acard->mpu = pnp_request_card_device(card, id->devs[2].id, NULL);
./sound/isa/wavefront/wavefront.c:		if (acard->mpu == NULL)
./sound/isa/wavefront/wavefront.c:	acard->synth = pnp_request_card_device(card, id->devs[3].id, NULL);
./sound/isa/wavefront/wavefront.c:	if (acard->synth == NULL)
./sound/isa/wavefront/wavefront.c:	pdev = acard->wss;
./sound/isa/wavefront/wavefront.c:	pdev = acard->synth;
./sound/isa/wavefront/wavefront.c:		pdev = acard->mpu;
./sound/isa/wavefront/wavefront.c:	if (acard->wavefront.interrupts_are_midi) {
./sound/isa/wavefront/wavefront.c:	if (snd_wavefront_start (&acard->wavefront) < 0) {
./sound/isa/wavefront/wavefront.c:	if (snd_wavefront_fx_start (&acard->wavefront)) {
./sound/isa/wavefront/wavefront.c:		acard->wavefront.midi.base = port;
./sound/isa/wavefront/wavefront.c:	snd_wavefront_card_t *acard = (snd_wavefront_card_t *)card->private_data;
./sound/isa/wavefront/wavefront.c:		release_and_free_resource(acard->wavefront.res_base);
./sound/isa/wavefront/wavefront.c:		if (acard->wavefront.irq > 0)
./sound/isa/wavefront/wavefront.c:			free_irq(acard->wavefront.irq, (void *)acard);
./sound/isa/wavefront/wavefront.c:	acard = card->private_data;
./sound/isa/wavefront/wavefront.c:	acard->wavefront.irq = -1;
./sound/isa/wavefront/wavefront.c:	spin_lock_init(&acard->wavefront.irq_lock);
./sound/isa/wavefront/wavefront.c:	init_waitqueue_head(&acard->wavefront.interrupt_sleeper);
./sound/isa/wavefront/wavefront.c:	spin_lock_init(&acard->wavefront.midi.open);
./sound/isa/wavefront/wavefront.c:	spin_lock_init(&acard->wavefront.midi.virtual);
./sound/isa/wavefront/wavefront.c:	acard->wavefront.card = card;
./sound/isa/wavefront/wavefront.c:	card->private_free = snd_wavefront_free;
./sound/isa/wavefront/wavefront.c:	snd_wavefront_card_t *acard = card->private_data;
./sound/isa/wavefront/wavefront.c:	acard->wavefront.res_base = request_region(ics2115_port[dev], 16,
./sound/isa/wavefront/wavefront.c:	if (acard->wavefront.res_base == NULL) {
./sound/isa/wavefront/wavefront.c:	acard->wavefront.irq = ics2115_irq[dev];
./sound/isa/wavefront/wavefront.c:	acard->wavefront.base = ics2115_port[dev];
./sound/isa/wavefront/wavefront.c:	if (acard->wavefront.has_fx) {
./sound/isa/wavefront/wavefront.c:		strcpy(card->driver, "Tropez+");
./sound/isa/wavefront/wavefront.c:		strcpy(card->shortname, "Turtle Beach Tropez+");
./sound/isa/wavefront/wavefront.c:		strcpy(card->driver, "WaveFront");
./sound/isa/wavefront/wavefront.c:		strcpy(card->shortname, "Turtle Beach WaveFront");
./sound/isa/wavefront/wavefront.c:	sprintf(card->longname, "%s PCM 0x%lx irq %d dma %d",
./sound/isa/wavefront/wavefront.c:		card->driver,
./sound/isa/wavefront/wavefront.c:		sprintf(card->longname + strlen(card->longname), "&%d", dma2[dev]);
./sound/isa/wavefront/wavefront.c:		sprintf (card->longname + strlen (card->longname), 
./sound/isa/wavefront/wavefront.c:	sprintf (card->longname + strlen (card->longname), 
./sound/isa/wavefront/wavefront.c:	if (snd_wavefront_pnp (dev, card->private_data, pcard, pid) < 0) {
./sound/isa/wavefront/wavefront.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/wavefront/wavefront_fx.c:	if (!try_module_get(hw->card->module))
./sound/isa/wavefront/wavefront_fx.c:	module_put(hw->card->module);
./sound/isa/wavefront/wavefront_fx.c:	if (snd_BUG_ON(!card->private_data))
./sound/isa/wavefront/wavefront_fx.c:	acard = card->private_data;
./sound/isa/wavefront/wavefront_fx.c:	dev = &acard->wavefront;
./sound/isa/wavefront/wavefront_fx.c:			       dev->card->dev);
./sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_t *dev = &acard->wavefront;
./sound/isa/wavefront/wavefront_synth.c:	if (!try_module_get(hw->card->module))
./sound/isa/wavefront/wavefront_synth.c:	module_put(hw->card->module);
./sound/isa/wavefront/wavefront_synth.c:	if (snd_BUG_ON(!card->private_data))
./sound/isa/wavefront/wavefront_synth.c:	acard = card->private_data;
./sound/isa/wavefront/wavefront_synth.c:	dev = &acard->wavefront;
./sound/isa/wavefront/wavefront_synth.c:/*  WaveFront: interface for card-level wavefront module               */
./sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_t *dev = &card->wavefront;
./sound/isa/wavefront/wavefront_synth.c:	err = request_firmware(&firmware, path, dev->card->dev);
./sound/isa/wavefront/wavefront_synth.c:	snd_wavefront_t *dev = &card->wavefront;
./sound/isa/adlib.c:	release_and_free_resource(card->private_data);
./sound/isa/adlib.c:	card->private_data = request_region(port[n], 4, CRD_NAME);
./sound/isa/adlib.c:	if (!card->private_data) {
./sound/isa/adlib.c:	card->private_free = snd_adlib_free;
./sound/isa/adlib.c:	strcpy(card->driver, DEV_NAME);
./sound/isa/adlib.c:	strcpy(card->shortname, CRD_NAME);
./sound/isa/adlib.c:	sprintf(card->longname, CRD_NAME " at %#lx", port[n]);
./sound/isa/sscape.c:	ret = request_firmware(&init_fw, "scope.cod", card->dev);
./sound/isa/sscape.c:	err = request_firmware(&init_fw, name, card->dev);
./sound/isa/sscape.c:	strcpy(card->driver, "SoundScape");
./sound/isa/sscape.c:	strcpy(card->shortname, name);
./sound/isa/sscape.c:	snprintf(card->longname, sizeof(card->longname),
./sound/isa/sscape.c:	card->private_free = soundscape_free;
./sound/isa/sscape.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/azt2320.c:    card-azt2320.c - driver for Aztech Systems AZT2320 based soundcards.
./sound/isa/azt2320.c:#define	DRIVER_NAME	"snd-card-azt2320"
./sound/isa/azt2320.c:	acard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/azt2320.c:	if (acard->dev == NULL)
./sound/isa/azt2320.c:	acard->devmpu = pnp_request_card_device(card, id->devs[1].id, NULL);
./sound/isa/azt2320.c:	pdev = acard->dev;
./sound/isa/azt2320.c:	pdev = acard->devmpu;
./sound/isa/azt2320.c:	     	acard->devmpu = NULL;
./sound/isa/azt2320.c:	acard = card->private_data;
./sound/isa/azt2320.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/azt2320.c:	strcpy(card->driver, "AZT2320");
./sound/isa/azt2320.c:	strcpy(card->shortname, "Aztech AZT2320");
./sound/isa/azt2320.c:	sprintf(card->longname, "%s, WSS at 0x%lx, irq %i, dma %i&%i",
./sound/isa/azt2320.c:		card->shortname, chip->port, irq[dev], dma1[dev], dma2[dev]);
./sound/isa/azt2320.c:	struct snd_card_azt2320 *acard = card->private_data;
./sound/isa/azt2320.c:	struct snd_wss *chip = acard->chip;
./sound/isa/azt2320.c:	struct snd_card_azt2320 *acard = card->private_data;
./sound/isa/azt2320.c:	struct snd_wss *chip = acard->chip;
./sound/isa/gus/gus_mem.c:		      ultra_memory_free_size(card, &card->gf1.mem_alloc),
./sound/isa/gus/gus_mem.c:		  ultra_memory_free_block(card, &card->gf1.mem_alloc, 0),
./sound/isa/gus/gus_mem.c:		 ultra_memory_free_block(card, &card->gf1.mem_alloc, 1));
./sound/isa/gus/gusextreme.c:	es1688 = card->private_data;
./sound/isa/gus/gusextreme.c:	sprintf(card->longname, "Gravis UltraSound Extreme at 0x%lx, "
./sound/isa/gus/gusmax.c:		if (inb(maxcard->gus_status_reg)) {
./sound/isa/gus/gusmax.c:			snd_gus_interrupt(irq, maxcard->gus);
./sound/isa/gus/gusmax.c:		if (inb(maxcard->pcm_status_reg) & 0x01) { /* IRQ bit is set? */
./sound/isa/gus/gusmax.c:			snd_wss_interrupt(irq, maxcard->wss);
./sound/isa/gus/gusmax.c:	struct snd_gusmax *maxcard = card->private_data;
./sound/isa/gus/gusmax.c:	if (maxcard->irq >= 0)
./sound/isa/gus/gusmax.c:		free_irq(maxcard->irq, (void *)maxcard);
./sound/isa/gus/gusmax.c:	card->private_free = snd_gusmax_free;
./sound/isa/gus/gusmax.c:	maxcard = card->private_data;
./sound/isa/gus/gusmax.c:	maxcard->card = card;
./sound/isa/gus/gusmax.c:	maxcard->irq = -1;
./sound/isa/gus/gusmax.c:	maxcard->gus_status_reg = gus->gf1.reg_irqstat;
./sound/isa/gus/gusmax.c:	maxcard->pcm_status_reg = gus->gf1.port + 0x10c + 2;
./sound/isa/gus/gusmax.c:	maxcard->irq = xirq;
./sound/isa/gus/gusmax.c:	sprintf(card->longname + strlen(card->longname), " at 0x%lx, irq %i, dma %i", gus->gf1.port, xirq, xdma1);
./sound/isa/gus/gusmax.c:		sprintf(card->longname + strlen(card->longname), "&%i", xdma2);
./sound/isa/gus/gusmax.c:	maxcard->gus = gus;
./sound/isa/gus/gusmax.c:	maxcard->wss = wss;
./sound/isa/gus/interwave.c:	struct snd_card *card = iwcard->card;
./sound/isa/gus/interwave.c:			if ((iwcard->i2c_res = request_region(port, 1, "InterWave (I2C bus)")) != NULL)
./sound/isa/gus/interwave.c:		iwcard->i2c_res = request_region(port, 1, "InterWave (I2C bus)");
./sound/isa/gus/interwave.c:	if (iwcard->i2c_res == NULL) {
./sound/isa/gus/interwave.c:	sprintf(name, "InterWave-%i", card->number);
./sound/isa/gus/interwave.c:		strcpy(gus->card->shortname, "AMD InterWave");
./sound/isa/gus/interwave.c:		if (inb(iwcard->gus_status_reg)) {
./sound/isa/gus/interwave.c:			snd_gus_interrupt(irq, iwcard->gus);
./sound/isa/gus/interwave.c:		if (inb(iwcard->pcm_status_reg) & 0x01) {	/* IRQ bit is set? */
./sound/isa/gus/interwave.c:			snd_wss_interrupt(irq, iwcard->wss);
./sound/isa/gus/interwave.c:			gus->card->type = SNDRV_CARD_TYPE_IW_DYNASONIC;
./sound/isa/gus/interwave.c:	iwcard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/gus/interwave.c:	if (iwcard->dev == NULL)
./sound/isa/gus/interwave.c:	iwcard->devtc = pnp_request_card_device(card, id->devs[1].id, NULL);
./sound/isa/gus/interwave.c:	if (iwcard->devtc == NULL)
./sound/isa/gus/interwave.c:	pdev = iwcard->dev;
./sound/isa/gus/interwave.c:	pdev = iwcard->devtc;
./sound/isa/gus/interwave.c:	struct snd_interwave *iwcard = card->private_data;
./sound/isa/gus/interwave.c:	release_and_free_resource(iwcard->i2c_res);
./sound/isa/gus/interwave.c:	if (iwcard->irq >= 0)
./sound/isa/gus/interwave.c:		free_irq(iwcard->irq, (void *)iwcard);
./sound/isa/gus/interwave.c:	iwcard = card->private_data;
./sound/isa/gus/interwave.c:	iwcard->card = card;
./sound/isa/gus/interwave.c:	iwcard->irq = -1;
./sound/isa/gus/interwave.c:	card->private_free = snd_interwave_free;
./sound/isa/gus/interwave.c:	struct snd_interwave *iwcard = card->private_data;
./sound/isa/gus/interwave.c:	iwcard->gus_status_reg = gus->gf1.reg_irqstat;
./sound/isa/gus/interwave.c:	iwcard->pcm_status_reg = gus->gf1.port + 0x10c + 2;
./sound/isa/gus/interwave.c:	iwcard->irq = xirq;
./sound/isa/gus/interwave.c:	strcpy(card->driver, str);
./sound/isa/gus/interwave.c:	strcpy(card->shortname, str);
./sound/isa/gus/interwave.c:	sprintf(card->longname, "%s at 0x%lx, irq %i, dma %d",
./sound/isa/gus/interwave.c:		sprintf(card->longname + strlen(card->longname), "&%d", xdma2);
./sound/isa/gus/interwave.c:	iwcard->wss = wss;
./sound/isa/gus/interwave.c:	iwcard->gus = gus;
./sound/isa/gus/interwave.c:	if ((res = snd_interwave_pnp(dev, card->private_data, pcard, pid)) < 0) {
./sound/isa/gus/interwave.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/gus/gus_timer.c:	tid.card = gus->card->number;
./sound/isa/gus/gusclassic.c:	sprintf(card->longname + strlen(card->longname),
./sound/isa/gus/gusclassic.c:		sprintf(card->longname + strlen(card->longname),
./sound/isa/gus/gus_main.c:	if (!try_module_get(gus->card->module))
./sound/isa/gus/gus_main.c:	module_put(gus->card->module);
./sound/isa/gus/gus_main.c:	card->mixer.mix_ctrl_reg |= 0x10;
./sound/isa/gus/gus_main.c:	strcpy(card->driver, "GUS");
./sound/isa/gus/gus_main.c:	strcpy(card->longname, "Gravis UltraSound Classic (2.4)");
./sound/isa/gus/gus_main.c:			card->longname[27] = '3';
./sound/isa/gus/gus_main.c:			card->longname[29] = rev == 5 ? '5' : '7';
./sound/isa/gus/gus_main.c:				strcpy(card->driver, "GUS MAX");
./sound/isa/gus/gus_main.c:				strcpy(card->longname, "Gravis UltraSound MAX");
./sound/isa/gus/gus_main.c:				strcpy(card->driver, "GUS ACE");
./sound/isa/gus/gus_main.c:				strcpy(card->longname, "Gravis UltraSound Ace");
./sound/isa/gus/gus_main.c:				strcpy(card->driver, "GUS Extreme");
./sound/isa/gus/gus_main.c:				strcpy(card->longname, "Gravis UltraSound Extreme");
./sound/isa/gus/gus_main.c:	strcpy(card->shortname, card->longname);
./sound/isa/gus/gus_mixer.c:	if (card->mixername[0] == '\0') {
./sound/isa/gus/gus_mixer.c:		strcpy(card->mixername, gus->ics_flag ? "GF1,ICS2101" : "GF1");
./sound/isa/gus/gus_mixer.c:			strcat(card->mixername, ",ICS2101");
./sound/isa/gus/gus_mixer.c:		strcat(card->mixername, ",GF1");
./sound/isa/ad1816a/ad1816a_lib.c:	tid.card = chip->card->number;
./sound/isa/ad1816a/ad1816a_lib.c:	strcpy(card->mixername, snd_ad1816a_chip_id(chip));
./sound/isa/ad1816a/ad1816a.c:    card-ad1816a.c - driver for ADI SoundPort AD1816A based soundcards.
./sound/isa/ad1816a/ad1816a.c:#define	DRIVER_NAME	"snd-card-ad1816a"
./sound/isa/ad1816a/ad1816a.c:	acard->dev = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/ad1816a/ad1816a.c:	if (acard->dev == NULL)
./sound/isa/ad1816a/ad1816a.c:	acard->devmpu = pnp_request_card_device(card, id->devs[1].id, NULL);
./sound/isa/ad1816a/ad1816a.c:	if (acard->devmpu == NULL) {
./sound/isa/ad1816a/ad1816a.c:	pdev = acard->dev;
./sound/isa/ad1816a/ad1816a.c:	if (acard->devmpu == NULL)
./sound/isa/ad1816a/ad1816a.c:	pdev = acard->devmpu;
./sound/isa/ad1816a/ad1816a.c:		acard->devmpu = NULL;
./sound/isa/ad1816a/ad1816a.c:	acard = card->private_data;
./sound/isa/ad1816a/ad1816a.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/ad1816a/ad1816a.c:	strcpy(card->driver, "AD1816A");
./sound/isa/ad1816a/ad1816a.c:	strcpy(card->shortname, "ADI SoundPort AD1816A");
./sound/isa/ad1816a/ad1816a.c:	sprintf(card->longname, "%s, SS at 0x%lx, irq %d, dma %d&%d",
./sound/isa/ad1816a/ad1816a.c:		card->shortname, chip->port, irq[dev], dma1[dev], dma2[dev]);
./sound/isa/wss/wss_lib.c:		return chip->card->shortname;
./sound/isa/wss/wss_lib.c:	tid.card = chip->card->number;
./sound/isa/wss/wss_lib.c:	if (!strcmp(chip->card->driver, "GUS MAX"))
./sound/isa/wss/wss_lib.c:	strcpy(card->mixername, chip->pcm->name);
./sound/isa/cs423x/cs4231.c:	card->private_data = chip;
./sound/isa/cs423x/cs4231.c:	strcpy(card->driver, "CS4231");
./sound/isa/cs423x/cs4231.c:	strcpy(card->shortname, pcm->name);
./sound/isa/cs423x/cs4231.c:	sprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",
./sound/isa/cs423x/cs4231.c:		sprintf(card->longname + strlen(card->longname), "&%d", dma2[n]);
./sound/isa/cs423x/cs4231.c:	struct snd_wss *chip = card->private_data;
./sound/isa/cs423x/cs4231.c:	struct snd_wss *chip = card->private_data;
./sound/isa/cs423x/cs4236.c:	acard->wss = pdev;
./sound/isa/cs423x/cs4236.c:	if (snd_cs423x_pnp_init_wss(dev, acard->wss) < 0)
./sound/isa/cs423x/cs4236.c:	acard->wss = pnp_request_card_device(card, id->devs[0].id, NULL);
./sound/isa/cs423x/cs4236.c:	if (acard->wss == NULL)
./sound/isa/cs423x/cs4236.c:	acard->ctrl = pnp_request_card_device(card, id->devs[1].id, NULL);
./sound/isa/cs423x/cs4236.c:	if (acard->ctrl == NULL)
./sound/isa/cs423x/cs4236.c:		acard->mpu = pnp_request_card_device(card, id->devs[2].id, NULL);
./sound/isa/cs423x/cs4236.c:		if (acard->mpu == NULL)
./sound/isa/cs423x/cs4236.c:	if (snd_cs423x_pnp_init_wss(dev, acard->wss) < 0)
./sound/isa/cs423x/cs4236.c:	if (acard->ctrl && cport[dev] > 0) {
./sound/isa/cs423x/cs4236.c:		if (snd_cs423x_pnp_init_ctrl(dev, acard->ctrl) < 0)
./sound/isa/cs423x/cs4236.c:	if (acard->mpu && mpu_port[dev] > 0) {
./sound/isa/cs423x/cs4236.c:		if (snd_cs423x_pnp_init_mpu(dev, acard->mpu) < 0)
./sound/isa/cs423x/cs4236.c:	struct snd_card_cs4236 *acard = card->private_data;
./sound/isa/cs423x/cs4236.c:	release_and_free_resource(acard->res_sb_port);
./sound/isa/cs423x/cs4236.c:	card->private_free = snd_card_cs4236_free;
./sound/isa/cs423x/cs4236.c:	acard = card->private_data;
./sound/isa/cs423x/cs4236.c:		if ((acard->res_sb_port = request_region(sb_port[dev], 16, IDENT " SB")) == NULL) {
./sound/isa/cs423x/cs4236.c:	acard->chip = chip;
./sound/isa/cs423x/cs4236.c:	strcpy(card->driver, pcm->name);
./sound/isa/cs423x/cs4236.c:	strcpy(card->shortname, pcm->name);
./sound/isa/cs423x/cs4236.c:	sprintf(card->longname, "%s at 0x%lx, irq %i, dma %i",
./sound/isa/cs423x/cs4236.c:		sprintf(card->longname + strlen(card->longname), "&%d", dma2[dev]);
./sound/isa/cs423x/cs4236.c:	struct snd_card_cs4236 *acard = card->private_data;
./sound/isa/cs423x/cs4236.c:	acard->chip->suspend(acard->chip);
./sound/isa/cs423x/cs4236.c:	struct snd_card_cs4236 *acard = card->private_data;
./sound/isa/cs423x/cs4236.c:	acard->chip->resume(acard->chip);
./sound/isa/cs423x/cs4236.c:	err = snd_card_cs423x_pnp(dev, card->private_data, pdev, cdev);
./sound/isa/cs423x/cs4236.c:	if ((res = snd_card_cs423x_pnpc(dev, card->private_data, pcard, pid)) < 0) {
./sound/isa/cs423x/cs4236.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/cs423x/cs4236_lib.c:	strcpy(card->mixername, snd_wss_chip_id(chip));
./sound/isa/sc6000.c:	vport = card->private_data;
./sound/isa/sc6000.c:	strcpy(card->driver, DRV_NAME);
./sound/isa/sc6000.c:	strcpy(card->shortname, "SC-6000");
./sound/isa/sc6000.c:	sprintf(card->longname, "Gallant SC-6000 at 0x%lx, irq %d, dma %d",
./sound/isa/sc6000.c:	char __iomem **vport = card->private_data;
./sound/isa/ad1848/ad1848.c: *  Based on card-4232.c by Jaroslav Kysela <perex@perex.cz>
./sound/isa/ad1848/ad1848.c:	card->private_data = chip;
./sound/isa/ad1848/ad1848.c:	strcpy(card->driver, "AD1848");
./sound/isa/ad1848/ad1848.c:	strcpy(card->shortname, pcm->name);
./sound/isa/ad1848/ad1848.c:	sprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",
./sound/isa/ad1848/ad1848.c:		strcat(card->longname, " [Thinkpad]");
./sound/isa/ad1848/ad1848.c:	struct snd_wss *chip = card->private_data;
./sound/isa/ad1848/ad1848.c:	struct snd_wss *chip = card->private_data;
./sound/isa/opl3sa2.c:	struct snd_opl3sa2 *chip = card->private_data;
./sound/isa/opl3sa2.c:	strcat(card->shortname, str);
./sound/isa/opl3sa2.c:	chip = card->private_data;
./sound/isa/opl3sa2.c:	struct snd_opl3sa2 *chip = card->private_data;
./sound/isa/opl3sa2.c:		struct snd_opl3sa2 *chip = card->private_data;
./sound/isa/opl3sa2.c:	chip = card->private_data;
./sound/isa/opl3sa2.c:	struct snd_opl3sa2 *chip = card->private_data;
./sound/isa/opl3sa2.c:	strcpy(card->driver, "OPL3SA2");
./sound/isa/opl3sa2.c:	strcpy(card->shortname, "Yamaha OPL3-SA");
./sound/isa/opl3sa2.c:	chip = card->private_data;
./sound/isa/opl3sa2.c:	card->private_free = snd_opl3sa2_free;
./sound/isa/opl3sa2.c:	chip = card->private_data;
./sound/isa/opl3sa2.c:	sprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",
./sound/isa/opl3sa2.c:		card->shortname, chip->port, xirq, xdma1);
./sound/isa/opl3sa2.c:		sprintf(card->longname + strlen(card->longname), "&%d", xdma2);
./sound/isa/opl3sa2.c:	if ((err = snd_opl3sa2_pnp(dev, card->private_data, pdev)) < 0) {
./sound/isa/opl3sa2.c:	if ((err = snd_opl3sa2_pnp(dev, card->private_data, pdev)) < 0) {
./sound/isa/opti9xx/miro.c:		strcpy(card->mixername, "ACI & OPTi924");
./sound/isa/opti9xx/miro.c:		strcpy(card->mixername, "ACI & OPTi929");
./sound/isa/opti9xx/miro.c:	struct snd_miro *miro = card->private_data;
./sound/isa/opti9xx/miro.c:	struct snd_miro *miro = card->private_data;
./sound/isa/opti9xx/miro.c:			sprintf(card->shortname, 
./sound/isa/opti9xx/miro.c:			sprintf(card->shortname, 
./sound/isa/opti9xx/miro.c:			sprintf(card->shortname, 
./sound/isa/opti9xx/miro.c:			sprintf(card->shortname, 
./sound/isa/opti9xx/miro.c:		sprintf(card->shortname, "unknown Cardinal Technologies");
./sound/isa/opti9xx/miro.c:	strcpy(card->driver, "miro");
./sound/isa/opti9xx/miro.c:	sprintf(card->longname, "%s: OPTi%s, %s at 0x%lx, irq %d, dma %d&%d",
./sound/isa/opti9xx/miro.c:		card->shortname, miro->name, pcm->name, miro->wss_base + 4,
./sound/isa/opti9xx/miro.c:	card->private_free = snd_card_miro_free;
./sound/isa/opti9xx/miro.c:	miro = card->private_data;
./sound/isa/opti9xx/miro.c:	card->private_free = snd_card_miro_free;
./sound/isa/opti9xx/miro.c:	miro = card->private_data;
./sound/isa/opti9xx/miro.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/opti9xx/opti92x-ad1848.c:    card-opti92x-ad1848.c - driver for OPTi 82c92x based soundcards.
./sound/isa/opti9xx/opti92x-ad1848.c:	strcpy(card->mixername, chip->pcm->name);
./sound/isa/opti9xx/opti92x-ad1848.c:	struct snd_opti9xx *chip = card->private_data;
./sound/isa/opti9xx/opti92x-ad1848.c:	struct snd_opti9xx *chip = card->private_data;
./sound/isa/opti9xx/opti92x-ad1848.c:	strcpy(card->driver, chip->name);
./sound/isa/opti9xx/opti92x-ad1848.c:	sprintf(card->shortname, "OPTi %s", card->driver);
./sound/isa/opti9xx/opti92x-ad1848.c:	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d&%d",
./sound/isa/opti9xx/opti92x-ad1848.c:		card->shortname, pcm->name,
./sound/isa/opti9xx/opti92x-ad1848.c:	sprintf(card->longname, "%s, %s at 0x%lx, irq %d, dma %d",
./sound/isa/opti9xx/opti92x-ad1848.c:		card->shortname, pcm->name, chip->wss_base + 4, irq, dma1);
./sound/isa/opti9xx/opti92x-ad1848.c:	card->private_free = snd_card_opti9xx_free;
./sound/isa/opti9xx/opti92x-ad1848.c:	if ((error = snd_card_opti9xx_detect(card, card->private_data)) < 0) {
./sound/isa/opti9xx/opti92x-ad1848.c:	chip = card->private_data;
./sound/isa/opti9xx/opti92x-ad1848.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	strcpy(card->mixername, chip->pcm->name);
./sound/isa/es18xx.c:	/* ok. hack using Vendor-Defined Card-Level registers */
./sound/isa/es18xx.c:	struct snd_es18xx *chip = card->private_data;
./sound/isa/es18xx.c:	sprintf(card->driver, "ES%x", chip->version);
./sound/isa/es18xx.c:	sprintf(card->shortname, "ESS AudioDrive ES%x", chip->version);
./sound/isa/es18xx.c:		sprintf(card->longname, "%s at 0x%lx, irq %d, dma1 %d, dma2 %d",
./sound/isa/es18xx.c:			card->shortname,
./sound/isa/es18xx.c:		sprintf(card->longname, "%s at 0x%lx, irq %d, dma %d",
./sound/isa/es18xx.c:			card->shortname,
./sound/isa/es18xx.c:	if ((err = snd_audiodrive_pnp(dev, card->private_data, pdev)) < 0) {
./sound/isa/es18xx.c:	if ((res = snd_audiodrive_pnpc(dev, card->private_data, pcard, pid)) < 0) {
./sound/isa/es18xx.c:	snd_card_set_dev(card, &pcard->card->dev);
./sound/ppc/pmac.c:	err = snd_pcm_new(chip->card, chip->card->driver, 0, 1, num_captures, &pcm);
./sound/ppc/pmac.c:	strcpy(pcm->name, chip->card->shortname);
./sound/ppc/awacs.c:	strcpy(chip->card->mixername, "PowerMac AWACS");
./sound/ppc/tumbler.c:	sprintf(chip->card->mixername, "PowerMac %s", chipname);
./sound/ppc/powermac.c:	card->private_data = chip;
./sound/ppc/powermac.c:		strcpy(card->driver, "PMac Burgundy");
./sound/ppc/powermac.c:		strcpy(card->shortname, "PowerMac Burgundy");
./sound/ppc/powermac.c:		sprintf(card->longname, "%s (Dev %d) Sub-frame %d",
./sound/ppc/powermac.c:			card->shortname, chip->device_id, chip->subframe);
./sound/ppc/powermac.c:		strcpy(card->driver, "PMac DACA");
./sound/ppc/powermac.c:		strcpy(card->shortname, "PowerMac DACA");
./sound/ppc/powermac.c:		sprintf(card->longname, "%s (Dev %d) Sub-frame %d",
./sound/ppc/powermac.c:			card->shortname, chip->device_id, chip->subframe);
./sound/ppc/powermac.c:		sprintf(card->driver, "PMac %s", name_ext);
./sound/ppc/powermac.c:		sprintf(card->shortname, "PowerMac %s", name_ext);
./sound/ppc/powermac.c:		sprintf(card->longname, "%s (Dev %d) Sub-frame %d",
./sound/ppc/powermac.c:			card->shortname, chip->device_id, chip->subframe);
./sound/ppc/powermac.c:		sprintf(card->driver, "PMac %s", name_ext);
./sound/ppc/powermac.c:		sprintf(card->shortname, "PowerMac %s", name_ext);
./sound/ppc/powermac.c:		sprintf(card->longname, "%s%s Rev %d",
./sound/ppc/powermac.c:			card->shortname, name_ext, chip->revision);
./sound/ppc/powermac.c:	snd_pmac_suspend(card->private_data);
./sound/ppc/powermac.c:	snd_pmac_resume(card->private_data);
./sound/ppc/burgundy.c:	strcpy(chip->card->mixername, "PowerMac Burgundy");
./sound/ppc/daca.c:	strcpy(chip->card->mixername, "PowerMac DACA");
./sound/ppc/snd_ps3.c: * NOTE: caller should reset card->running before call.
./sound/ppc/snd_ps3.c:	return card->dma_start_bus_addr[ch] +
./sound/ppc/snd_ps3.c:		(paddr - card->dma_start_vaddr[ch]);
./sound/ppc/snd_ps3.c:		card->dma_last_transfer_vaddr[ch] =
./sound/ppc/snd_ps3.c:			card->dma_next_transfer_vaddr[ch];
./sound/ppc/snd_ps3.c:	card->dma_next_transfer_vaddr[ch] += byte_count;
./sound/ppc/snd_ps3.c:	if ((card->dma_start_vaddr[ch] + (card->dma_buffer_size / 2)) <=
./sound/ppc/snd_ps3.c:	    card->dma_next_transfer_vaddr[ch]) {
./sound/ppc/snd_ps3.c:		card->dma_next_transfer_vaddr[ch] = card->dma_start_vaddr[ch];
./sound/ppc/snd_ps3.c:	spin_lock_irqsave(&card->dma_lock, irqsave);
./sound/ppc/snd_ps3.c:		start_vaddr = card->dma_next_transfer_vaddr[0];
./sound/ppc/snd_ps3.c:				dma_addr = card->null_buffer_start_dma_addr;
./sound/ppc/snd_ps3.c:					 card->dma_next_transfer_vaddr[ch],
./sound/ppc/snd_ps3.c:	spin_unlock_irqrestore(&card->dma_lock, irqsave);
./sound/ppc/snd_ps3.c:	if (!card->running) {
./sound/ppc/snd_ps3.c:		if (card->silent) {
./sound/ppc/snd_ps3.c:			card->silent--;
./sound/ppc/snd_ps3.c:			snd_pcm_period_elapsed(card->substream);
./sound/ppc/snd_ps3.c:	ret = ps3av_set_audio_mode(card->avs.avs_audio_ch,
./sound/ppc/snd_ps3.c:				  card->avs.avs_audio_rate,
./sound/ppc/snd_ps3.c:				  card->avs.avs_audio_width,
./sound/ppc/snd_ps3.c:				  card->avs.avs_audio_format,
./sound/ppc/snd_ps3.c:				  card->avs.avs_audio_source);
./sound/ppc/snd_ps3.c:	avs = card->avs;
./sound/ppc/snd_ps3.c:		 card->avs.avs_audio_rate, card->avs.avs_audio_width);
./sound/ppc/snd_ps3.c:	if (memcmp(&card->avs, &avs, sizeof(avs))) {
./sound/ppc/snd_ps3.c:			 card->avs.avs_audio_rate, card->avs.avs_audio_width);
./sound/ppc/snd_ps3.c:		card->avs = avs;
./sound/ppc/snd_ps3.c:	card->substream = substream;
./sound/ppc/snd_ps3.c:	card->start_delay = snd_ps3_start_delay;
./sound/ppc/snd_ps3.c:		card->silent = snd_ps3_delay_to_bytes(substream,
./sound/ppc/snd_ps3.c:						      card->start_delay) /
./sound/ppc/snd_ps3.c:	spin_lock_irqsave(&card->dma_lock, irqsave);
./sound/ppc/snd_ps3.c:		card->dma_buffer_size = runtime->dma_bytes;
./sound/ppc/snd_ps3.c:		card->dma_last_transfer_vaddr[SND_PS3_CH_L] =
./sound/ppc/snd_ps3.c:			card->dma_next_transfer_vaddr[SND_PS3_CH_L] =
./sound/ppc/snd_ps3.c:			card->dma_start_vaddr[SND_PS3_CH_L] =
./sound/ppc/snd_ps3.c:		card->dma_start_bus_addr[SND_PS3_CH_L] = runtime->dma_addr;
./sound/ppc/snd_ps3.c:		card->dma_last_transfer_vaddr[SND_PS3_CH_R] =
./sound/ppc/snd_ps3.c:			card->dma_next_transfer_vaddr[SND_PS3_CH_R] =
./sound/ppc/snd_ps3.c:			card->dma_start_vaddr[SND_PS3_CH_R] =
./sound/ppc/snd_ps3.c:		card->dma_start_bus_addr[SND_PS3_CH_R] =
./sound/ppc/snd_ps3.c:			 card->dma_start_vaddr[SND_PS3_CH_L],
./sound/ppc/snd_ps3.c:			 card->dma_start_bus_addr[SND_PS3_CH_L]);
./sound/ppc/snd_ps3.c:	spin_unlock_irqrestore(&card->dma_lock, irqsave);
./sound/ppc/snd_ps3.c:		spin_lock(&card->dma_lock);
./sound/ppc/snd_ps3.c:			card->running = 1;
./sound/ppc/snd_ps3.c:		spin_unlock(&card->dma_lock);
./sound/ppc/snd_ps3.c:		spin_lock(&card->dma_lock);
./sound/ppc/snd_ps3.c:			card->running = 0;
./sound/ppc/snd_ps3.c:		spin_unlock(&card->dma_lock);
./sound/ppc/snd_ps3.c:	spin_lock(&card->dma_lock);
./sound/ppc/snd_ps3.c:		bytes = (size_t)(card->dma_last_transfer_vaddr[SND_PS3_CH_L] -
./sound/ppc/snd_ps3.c:				 card->dma_start_vaddr[SND_PS3_CH_L]);
./sound/ppc/snd_ps3.c:	spin_unlock(&card->dma_lock);
./sound/ppc/snd_ps3.c:	card->avs.avs_audio_ch = PS3AV_CMD_AUDIO_NUM_OF_CH_2;
./sound/ppc/snd_ps3.c:	card->avs.avs_audio_rate = PS3AV_CMD_AUDIO_FS_48K;
./sound/ppc/snd_ps3.c:	card->avs.avs_audio_width = PS3AV_CMD_AUDIO_WORD_BITS_16;
./sound/ppc/snd_ps3.c:	card->avs.avs_audio_format = PS3AV_CMD_AUDIO_FORMAT_PCM;
./sound/ppc/snd_ps3.c:	card->avs.avs_audio_source = PS3AV_CMD_AUDIO_SOURCE_SERIAL;
./sound/ppc/snd_ps3.c:	memcpy(card->avs.avs_cs_info, ps3av_mode_cs_info, 8);
./sound/ppc/snd_ps3.c:	strcpy(the_card.card->driver, "PS3");
./sound/ppc/snd_ps3.c:	strcpy(the_card.card->shortname, "PS3");
./sound/ppc/snd_ps3.c:	strcpy(the_card.card->longname, "PS3 sound");
./sound/ppc/snd_ps3.c:		the_card.card->longname, the_card.start_delay);
./sound/sh/sh_dac_audio.c:	strcpy(card->driver, "snd_sh_dac");
./sound/sh/sh_dac_audio.c:	strcpy(card->shortname, "SuperH DAC audio driver");
./sound/sh/sh_dac_audio.c:	printk(KERN_INFO "%s %s", card->longname, card->shortname);
./sound/sh/aica.c:	period_offset = dreamcastcard->clicks;
./sound/sh/aica.c:		    dreamcastcard->channel, sizeof(struct aica_channel));
./sound/sh/aica.c:	runtime = dreamcastcard->substream->runtime;
./sound/sh/aica.c:	if (unlikely(dreamcastcard->dma_check == 0)) {
./sound/sh/aica.c:			dreamcastcard->channel->flags |= 0x01;
./sound/sh/aica.c:				  dreamcastcard->substream);
./sound/sh/aica.c:		dreamcastcard->clicks =
./sound/sh/aica.c:				  dreamcastcard->substream);
./sound/sh/aica.c:		snd_pcm_period_elapsed(dreamcastcard->substream);
./sound/sh/aica.c:		dreamcastcard->clicks++;
./sound/sh/aica.c:		if (unlikely(dreamcastcard->clicks >= AICA_PERIOD_NUMBER))
./sound/sh/aica.c:			dreamcastcard->clicks %= AICA_PERIOD_NUMBER;
./sound/sh/aica.c:		mod_timer(&dreamcastcard->timer, jiffies + 1);
./sound/sh/aica.c:	if (play_period == dreamcastcard->current_period) {
./sound/sh/aica.c:		mod_timer(&(dreamcastcard->timer), jiffies + 1);
./sound/sh/aica.c:		dreamcastcard->current_period = play_period;
./sound/sh/aica.c:	if (unlikely(dreamcastcard->dma_check == 0))
./sound/sh/aica.c:		dreamcastcard->dma_check = 1;
./sound/sh/aica.c:	queue_work(aica_queue, &(dreamcastcard->spu_dma_work));
./sound/sh/aica.c:	queue_work(aica_queue, &(dreamcastcard->spu_dma_work));
./sound/sh/aica.c:	if (unlikely(dreamcastcard->timer.data)) {
./sound/sh/aica.c:		mod_timer(&dreamcastcard->timer, jiffies + 4);
./sound/sh/aica.c:	init_timer(&(dreamcastcard->timer));
./sound/sh/aica.c:	dreamcastcard->timer.data = (unsigned long) substream;
./sound/sh/aica.c:	dreamcastcard->timer.function = aica_period_elapsed;
./sound/sh/aica.c:	dreamcastcard->timer.expires = jiffies + 4;
./sound/sh/aica.c:	add_timer(&(dreamcastcard->timer));
./sound/sh/aica.c:	channel->vol = dreamcastcard->master_volume;
./sound/sh/aica.c:	dreamcastcard->channel = channel;
./sound/sh/aica.c:	dreamcastcard->clicks = 0;
./sound/sh/aica.c:	dreamcastcard->current_period = 0;
./sound/sh/aica.c:	dreamcastcard->dma_check = 0;
./sound/sh/aica.c:	if (dreamcastcard->timer.data)
./sound/sh/aica.c:		del_timer(&dreamcastcard->timer);
./sound/sh/aica.c:	kfree(dreamcastcard->channel);
./sound/sh/aica.c:		dreamcastcard->channel->sfmt = SM_16BIT;
./sound/sh/aica.c:	dreamcastcard->channel->freq = substream->runtime->rate;
./sound/sh/aica.c:	dreamcastcard->substream = substream;
./sound/sh/aica.c:	    snd_pcm_new(dreamcastcard->card, "AICA PCM", pcm_index, 1, 0,
./sound/sh/aica.c:	if (unlikely(!dreamcastcard->channel))
./sound/sh/aica.c:	ucontrol->value.integer.value[0] = dreamcastcard->channel->vol;
./sound/sh/aica.c:	if (unlikely(!dreamcastcard->channel))
./sound/sh/aica.c:	if (unlikely(dreamcastcard->channel->vol == vol))
./sound/sh/aica.c:	dreamcastcard->channel->vol = ucontrol->value.integer.value[0];
./sound/sh/aica.c:	dreamcastcard->master_volume = ucontrol->value.integer.value[0];
./sound/sh/aica.c:		    dreamcastcard->channel, sizeof(struct aica_channel));
./sound/sh/aica.c:	    (dreamcastcard->card,
./sound/sh/aica.c:	    (dreamcastcard->card,
./sound/sh/aica.c:	snd_card_free(dreamcastcard->card);
./sound/sh/aica.c:			      &dreamcastcard->card);
./sound/sh/aica.c:	strcpy(dreamcastcard->card->driver, "snd_aica");
./sound/sh/aica.c:	strcpy(dreamcastcard->card->shortname, SND_AICA_DRIVER);
./sound/sh/aica.c:	strcpy(dreamcastcard->card->longname,
./sound/sh/aica.c:	INIT_WORK(&(dreamcastcard->spu_dma_work), run_spu_dma);
./sound/sh/aica.c:	snd_card_set_dev(dreamcastcard->card, &devptr->dev);
./sound/sh/aica.c:	dreamcastcard->timer.data = 0;
./sound/sh/aica.c:	dreamcastcard->channel = NULL;
./sound/sh/aica.c:	err = snd_card_register(dreamcastcard->card);
./sound/sh/aica.c:	snd_card_free(dreamcastcard->card);
./sound/firewire/amdtp.c:		(fw_parent_device(s->unit)->card->node_id & 0x3f) << 24;
./sound/firewire/isight.c:	struct isight *isight = card->private_data;
./sound/firewire/isight.c:	isight = card->private_data;
./sound/firewire/isight.c:	card->private_free = isight_card_free;
./sound/firewire/isight.c:	strcpy(card->driver, "iSight");
./sound/firewire/isight.c:	strcpy(card->shortname, "Apple iSight");
./sound/firewire/isight.c:	snprintf(card->longname, sizeof(card->longname),
./sound/firewire/isight.c:	strcpy(card->mixername, "iSight");
./sound/firewire/iso-resources.c:	return card->gap_count < 63 ? card->gap_count * 97 / 10 + 89 : 512;
./sound/firewire/iso-resources.c:		s64 delay = (card->reset_jiffies + HZ) - get_jiffies_64();
./sound/firewire/iso-resources.c:	spin_lock_irq(&card->lock);
./sound/firewire/iso-resources.c:	r->generation = card->generation;
./sound/firewire/iso-resources.c:	spin_unlock_irq(&card->lock);
./sound/firewire/iso-resources.c:	spin_lock_irq(&card->lock);
./sound/firewire/iso-resources.c:	r->generation = card->generation;
./sound/firewire/iso-resources.c:	spin_unlock_irq(&card->lock);
./sound/firewire/speakers.c:	struct fwspk *fwspk = card->private_data;
./sound/firewire/speakers.c:	fwspk = card->private_data;
./sound/firewire/speakers.c:	card->private_free = fwspk_card_free;
./sound/firewire/speakers.c:	strcpy(card->driver, fwspk->device_info->driver_name);
./sound/firewire/speakers.c:	strcpy(card->shortname, fwspk->device_info->short_name);
./sound/firewire/speakers.c:	snprintf(card->longname, sizeof(card->longname),
./sound/firewire/speakers.c:	strcpy(card->mixername, "OXFW970");
./sound/core/control_compat.c:	down_read(&card->controls_rwsem);
./sound/core/control_compat.c:		up_read(&card->controls_rwsem);
./sound/core/control_compat.c:		up_read(&card->controls_rwsem);
./sound/core/control_compat.c:	up_read(&card->controls_rwsem);
./sound/core/pcm.c:		else if (pcm->card->number > card->number)
./sound/core/pcm.c:		if (pcm->card->number > newpcm->card->number ||
./sound/core/pcm.c:	if ((entry = snd_info_create_card_entry(pcm->card, name, pcm->card->proc_root)) == NULL)
./sound/core/pcm.c:	read_lock(&card->ctl_files_rwlock);
./sound/core/pcm.c:	list_for_each_entry(kctl, &card->ctl_files, list) {
./sound/core/pcm.c:	read_unlock(&card->ctl_files_rwlock);
./sound/core/pcm.c:			sprintf(str, "pcmC%iD%ip", pcm->card->number, pcm->device);
./sound/core/pcm.c:			sprintf(str, "pcmC%iD%ic", pcm->card->number, pcm->device);
./sound/core/pcm.c:			    pcm->card->number, pcm->device, pcm->id, pcm->name);
./sound/core/init.c:	snd_iprintf(buffer, "%s\n", entry->card->id);
./sound/core/init.c:	if ((entry = snd_info_create_card_entry(card, "id", card->proc_root)) == NULL) {
./sound/core/init.c:	card->proc_id = entry;
./sound/core/init.c:		strlcpy(card->id, xid, sizeof(card->id));
./sound/core/init.c:	card->number = idx;
./sound/core/init.c:	card->module = module;
./sound/core/init.c:	INIT_LIST_HEAD(&card->devices);
./sound/core/init.c:	init_rwsem(&card->controls_rwsem);
./sound/core/init.c:	rwlock_init(&card->ctl_files_rwlock);
./sound/core/init.c:	INIT_LIST_HEAD(&card->controls);
./sound/core/init.c:	INIT_LIST_HEAD(&card->ctl_files);
./sound/core/init.c:	spin_lock_init(&card->files_lock);
./sound/core/init.c:	INIT_LIST_HEAD(&card->files_list);
./sound/core/init.c:	init_waitqueue_head(&card->shutdown_sleep);
./sound/core/init.c:	atomic_set(&card->refcount, 0);
./sound/core/init.c:	mutex_init(&card->power_lock);
./sound/core/init.c:	init_waitqueue_head(&card->power_sleep);
./sound/core/init.c:		card->private_data = (char *)card + sizeof(struct snd_card);
./sound/core/init.c:	spin_lock(&card->files_lock);
./sound/core/init.c:	if (card->shutdown) {
./sound/core/init.c:		spin_unlock(&card->files_lock);
./sound/core/init.c:	card->shutdown = 1;
./sound/core/init.c:	spin_unlock(&card->files_lock);
./sound/core/init.c:	snd_cards[card->number] = NULL;
./sound/core/init.c:	snd_cards_lock &= ~(1 << card->number);
./sound/core/init.c:	spin_lock(&card->files_lock);
./sound/core/init.c:	list_for_each_entry(mfile, &card->files_list, list) {
./sound/core/init.c:	spin_unlock(&card->files_lock);	
./sound/core/init.c:		snd_printk(KERN_ERR "not all devices for card %i can be disconnected\n", card->number);
./sound/core/init.c:	if (card->card_dev) {
./sound/core/init.c:		device_unregister(card->card_dev);
./sound/core/init.c:		card->card_dev = NULL;
./sound/core/init.c:	wake_up(&card->power_sleep);
./sound/core/init.c:	if (card->private_free)
./sound/core/init.c:		card->private_free(card);
./sound/core/init.c:	snd_info_free_entry(card->proc_id);
./sound/core/init.c:	if (atomic_dec_and_test(&card->refcount)) {
./sound/core/init.c:		wake_up(&card->shutdown_sleep);
./sound/core/init.c:		if (card->free_on_last_close)
./sound/core/init.c:	atomic_inc(&card->refcount);
./sound/core/init.c:		atomic_dec(&card->refcount);
./sound/core/init.c:	card->free_on_last_close = 1;
./sound/core/init.c:	if (atomic_dec_and_test(&card->refcount))
./sound/core/init.c:	wait_event(card->shutdown_sleep, !atomic_read(&card->refcount));
./sound/core/init.c:		id = card->shortname;
./sound/core/init.c:	id = card->id;
./sound/core/init.c:	while (*spos != '\0' && (size_t)(id - card->id) < sizeof(card->id) - 1) {
./sound/core/init.c:	id = card->id;
./sound/core/init.c:      			strcpy(card->id, card->proc_root->name);
./sound/core/init.c:		} else if ((size_t)len <= sizeof(card->id) - 3) {
./sound/core/init.c:			if ((size_t)len <= sizeof(card->id) - 2)
./sound/core/init.c:	/* check if user specified own card->id */
./sound/core/init.c:	if (card->id[0] != '\0')
./sound/core/init.c:	return snprintf(buf, PAGE_SIZE, "%s\n", card ? card->id : "(null)");
./sound/core/init.c:	char buf1[sizeof(card->id)];
./sound/core/init.c:	size_t copy = count > sizeof(card->id) - 1 ?
./sound/core/init.c:					sizeof(card->id) - 1 : count;
./sound/core/init.c:	strcpy(card->id, buf1);
./sound/core/init.c:	return snprintf(buf, PAGE_SIZE, "%i\n", card ? card->number : -1);
./sound/core/init.c:	if (!card->card_dev) {
./sound/core/init.c:		card->card_dev = device_create(sound_class, card->dev,
./sound/core/init.c:					       "card%i", card->number);
./sound/core/init.c:		if (IS_ERR(card->card_dev))
./sound/core/init.c:			card->card_dev = NULL;
./sound/core/init.c:	if (snd_cards[card->number]) {
./sound/core/init.c:	snd_card_set_id_no_lock(card, card->id[0] == '\0' ? NULL : card->id);
./sound/core/init.c:	snd_cards[card->number] = card;
./sound/core/init.c:	if (card->card_dev) {
./sound/core/init.c:		err = device_create_file(card->card_dev, &card_id_attrs);
./sound/core/init.c:		err = device_create_file(card->card_dev, &card_number_attrs);
./sound/core/init.c:					card->id,
./sound/core/init.c:					card->driver,
./sound/core/init.c:					card->shortname);
./sound/core/init.c:					card->longname);
./sound/core/init.c:			snd_iprintf(buffer, "%s\n", card->longname);
./sound/core/init.c:				    idx, card->module->name);
./sound/core/init.c:	ptr = strstr(card->components, component);
./sound/core/init.c:	if (strlen(card->components) + 1 + len + 1 > sizeof(card->components)) {
./sound/core/init.c:	if (card->components[0] != '\0')
./sound/core/init.c:		strcat(card->components, " ");
./sound/core/init.c:	strcat(card->components, component);
./sound/core/init.c:	spin_lock(&card->files_lock);
./sound/core/init.c:	if (card->shutdown) {
./sound/core/init.c:		spin_unlock(&card->files_lock);
./sound/core/init.c:	list_add(&mfile->list, &card->files_list);
./sound/core/init.c:	atomic_inc(&card->refcount);
./sound/core/init.c:	spin_unlock(&card->files_lock);
./sound/core/init.c:	spin_lock(&card->files_lock);
./sound/core/init.c:	list_for_each_entry(mfile, &card->files_list, list) {
./sound/core/init.c:	spin_unlock(&card->files_lock);
./sound/core/init.c:	add_wait_queue(&card->power_sleep, &wait);
./sound/core/init.c:		if (card->shutdown) {
./sound/core/init.c:	remove_wait_queue(&card->power_sleep, &wait);
./sound/core/jack.c:		 card->shortname, jack->id);
./sound/core/oss/pcm_oss.c:	if (!try_module_get(pcm->card->module)) {
./sound/core/oss/pcm_oss.c:		if (pcm->card->shutdown) {
./sound/core/oss/pcm_oss.c:     	module_put(pcm->card->module);
./sound/core/oss/pcm_oss.c:	if (!pcm->card->shutdown)
./sound/core/oss/pcm_oss.c:	module_put(pcm->card->module);
./sound/core/oss/pcm_oss.c:	sprintf(name, "dsp%i%i", pcm->card->number, pcm->device);
./sound/core/oss/pcm_oss.c:			   pcm->card->number, pcm->device);
./sound/core/oss/pcm_oss.c:	if (dsp_map[pcm->card->number] == (int)pcm->device) {
./sound/core/oss/pcm_oss.c:				      pcm->card->number,
./sound/core/oss/pcm_oss.c:	if (adsp_map[pcm->card->number] == (int)pcm->device) {
./sound/core/oss/pcm_oss.c:		if (dsp_map[pcm->card->number] == (int)pcm->device) {
./sound/core/oss/pcm_oss.c:			snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_AUDIO, pcm->card->number);
./sound/core/oss/mixer_oss.c:	if (card->mixer_oss == NULL) {
./sound/core/oss/mixer_oss.c:	fmixer->mixer = card->mixer_oss;
./sound/core/oss/mixer_oss.c:	if (!try_module_get(card->module)) {
./sound/core/oss/mixer_oss.c:		module_put(fmixer->card->module);
./sound/core/oss/mixer_oss.c:	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
./sound/core/oss/mixer_oss.c:	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
./sound/core/oss/mixer_oss.c:	info.modify_counter = card->mixer_oss_change_count;
./sound/core/oss/mixer_oss.c:	strlcpy(info.id, mixer && mixer->id[0] ? mixer->id : card->driver, sizeof(info.id));
./sound/core/oss/mixer_oss.c:	strlcpy(info.name, mixer && mixer->name[0] ? mixer->name : card->mixername, sizeof(info.name));
./sound/core/oss/mixer_oss.c:	if (card->mixer_oss == NULL)
./sound/core/oss/mixer_oss.c:	fmixer.mixer = card->mixer_oss;
./sound/core/oss/mixer_oss.c:	struct snd_mixer_oss *mixer = card->mixer_oss;
./sound/core/oss/mixer_oss.c:	struct snd_mixer_oss *mixer = card->mixer_oss;
./sound/core/oss/mixer_oss.c:	down_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:		up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	down_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:		up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	down_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:		up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	down_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:		up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	down_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:     	up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	down_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	down_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:		up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:		up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:		up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	up_read(&card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	down_read(&mixer->card->controls_rwsem);
./sound/core/oss/mixer_oss.c:			up_read(&mixer->card->controls_rwsem);
./sound/core/oss/mixer_oss.c:			up_read(&mixer->card->controls_rwsem);
./sound/core/oss/mixer_oss.c:					up_read(&mixer->card->controls_rwsem);
./sound/core/oss/mixer_oss.c:	up_read(&mixer->card->controls_rwsem);
./sound/core/oss/mixer_oss.c:					   mixer->card->proc_root);
./sound/core/oss/mixer_oss.c:	if (snd_BUG_ON(mixer != card->mixer_oss))
./sound/core/oss/mixer_oss.c:	card->mixer_oss = NULL;
./sound/core/oss/mixer_oss.c:		sprintf(name, "mixer%i%i", card->number, 0);
./sound/core/oss/mixer_oss.c:				   card->number, 0);
./sound/core/oss/mixer_oss.c:		if (*card->mixername)
./sound/core/oss/mixer_oss.c:			strlcpy(mixer->name, card->mixername, sizeof(mixer->name));
./sound/core/oss/mixer_oss.c:				      card->number,
./sound/core/oss/mixer_oss.c:		card->mixer_oss = mixer;
./sound/core/oss/mixer_oss.c:		mixer = card->mixer_oss;
./sound/core/oss/mixer_oss.c:			snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIXERS, mixer->card->number);
./sound/core/seq/seq_midi.c:	client = synths[card->number];
./sound/core/seq/seq_midi.c:				card, 0, "%s", card->shortname[0] ?
./sound/core/seq/seq_midi.c:				(const char *)card->shortname : "External MIDI");
./sound/core/seq/seq_midi.c:					sprintf(port->name, "MIDI %d-%d-%d", card->number, device, p);
./sound/core/seq/seq_midi.c:					sprintf(port->name, "MIDI %d-%d", card->number, device);
./sound/core/seq/seq_midi.c:		synths[card->number] = client;
./sound/core/seq/seq_midi.c:	client = synths[card->number];
./sound/core/seq/seq_midi.c:		synths[card->number] = NULL;
./sound/core/seq/seq_clientmgr.c:			+ card->number * SNDRV_SEQ_CLIENTS_PER_CARD;
./sound/core/seq/seq_virmidi.c:	if (!try_module_get(rdev->card->module))
./sound/core/seq/seq_virmidi.c:	module_put(rdev->card->module);
./sound/core/seq/seq_virmidi.c:	if (!try_module_get(rdev->card->module))
./sound/core/seq/seq_virmidi.c:	module_put(rdev->card->module);
./sound/core/seq/seq_virmidi.c:					      rdev->card->number,
./sound/core/seq/seq_virmidi.c:	sprintf(pinfo->name, "VirMIDI %d-%d", rdev->card->number, rdev->device);
./sound/core/pcm_lib.c:		 substream->pcm->card->number,
./sound/core/pcm_lib.c:	runtime->sync.id32[0] = substream->pcm->card->number;
./sound/core/sound_oss.c:		minor = SNDRV_MINOR_OSS(card->number, (dev ? SNDRV_MINOR_OSS_MIXER1 : SNDRV_MINOR_OSS_MIXER));
./sound/core/sound_oss.c:		minor = SNDRV_MINOR_OSS(card->number, (dev ? SNDRV_MINOR_OSS_PCM1 : SNDRV_MINOR_OSS_PCM));
./sound/core/sound_oss.c:		minor = SNDRV_MINOR_OSS(card->number, (dev ? SNDRV_MINOR_OSS_MIDI1 : SNDRV_MINOR_OSS_MIDI));
./sound/core/sound_oss.c:		minor = SNDRV_MINOR_OSS(card->number, SNDRV_MINOR_OSS_DMFM);
./sound/core/sound_oss.c:	if (card && card->number >= 8)
./sound/core/sound_oss.c:	preg->card = card ? card->number : -1;
./sound/core/sound_oss.c:	if (card && card->number >= 8)
./sound/core/hwdep.c:	if (!try_module_get(hw->card->module)) {
./sound/core/hwdep.c:		if (hw->card->shutdown) {
./sound/core/hwdep.c:		module_put(hw->card->module);
./sound/core/hwdep.c:	struct module *mod = hw->card->module;
./sound/core/hwdep.c:	info.card = hw->card->number;
./sound/core/hwdep.c:	sprintf(name, "hwC%iD%i", hwdep->card->number, hwdep->device);
./sound/core/hwdep.c:			   hwdep->card->number, hwdep->device);
./sound/core/hwdep.c:					   hwdep->card->number, hwdep->device);
./sound/core/hwdep.c:			    hwdep->card->number, hwdep->device, hwdep->name);
./sound/core/pcm_timer.c:	tid.card = substream->pcm->card->number;
./sound/core/timer_compat.c:	info.card = t->card ? t->card->number : -1;
./sound/core/timer.c:		     timer->card->number != tid->card))
./sound/core/timer.c:			request_module("snd-card-%i", tid->card);
./sound/core/timer.c:		timer->module = card->module;
./sound/core/timer.c:			if (timer1->card->number > timer->card->number)
./sound/core/timer.c:			if (timer1->card->number < timer->card->number)
./sound/core/timer.c:				    timer->card->number, timer->tmr_device);
./sound/core/timer.c:			snd_iprintf(buffer, "P%i-%i-%i: ", timer->card->number,
./sound/core/timer.c:				    timer->card ? timer->card->number : -1,
./sound/core/timer.c:	id->card = timer->card ? timer->card->number : -1;
./sound/core/timer.c:				if (timer->card->number > id.card) {
./sound/core/timer.c:				if (timer->card->number < id.card)
./sound/core/timer.c:		ginfo->card = t->card ? t->card->number : -1;
./sound/core/timer.c:	info->card = t->card ? t->card->number : -1;
./sound/core/pcm_native.c:	info->card = pcm->card->number;
./sound/core/pcm_native.c:		if (card->shutdown) {
./sound/core/pcm_native.c:	if (!try_module_get(pcm->card->module)) {
./sound/core/pcm_native.c:		if (pcm->card->shutdown) {
./sound/core/pcm_native.c:	module_put(pcm->card->module);
./sound/core/pcm_native.c:	module_put(pcm->card->module);
./sound/core/sound.c: * Tries to load the module "snd-card-X" for the given card number
./sound/core/sound.c:	request_module("snd-card-%i", card);
./sound/core/sound.c:		minor = SNDRV_MINOR(card->number, type);
./sound/core/sound.c:		minor = SNDRV_MINOR(card->number, type + dev);
./sound/core/sound.c:	preg->card = card ? card->number : -1;
./sound/core/sound.c:	cardnum = card ? card->number : -1;
./sound/core/rawmidi.c:	if (!try_module_get(rmidi->card->module)) {
./sound/core/rawmidi.c:		module_put(rmidi->card->module);
./sound/core/rawmidi.c:	if (!try_module_get(rmidi->card->module)) {
./sound/core/rawmidi.c:		read_lock(&card->ctl_files_rwlock);
./sound/core/rawmidi.c:		list_for_each_entry(kctl, &card->ctl_files, list) {
./sound/core/rawmidi.c:		read_unlock(&card->ctl_files_rwlock);
./sound/core/rawmidi.c:		if (rmidi->card->shutdown) {
./sound/core/rawmidi.c:	module_put(rmidi->card->module);
./sound/core/rawmidi.c:	module_put(rmidi->card->module);
./sound/core/rawmidi.c:	module = rmidi->card->module;
./sound/core/rawmidi.c:	info->card = rmidi->card->number;
./sound/core/rawmidi.c:			if (rfile->rmidi->card->shutdown)
./sound/core/rawmidi.c:			if (rfile->rmidi->card->shutdown)
./sound/core/rawmidi.c:	sprintf(name, "midiC%iD%i", rmidi->card->number, rmidi->device);
./sound/core/rawmidi.c:		snd_printk(KERN_ERR "unable to register rawmidi device %i:%i\n", rmidi->card->number, rmidi->device);
./sound/core/rawmidi.c:	if ((int)rmidi->device == midi_map[rmidi->card->number]) {
./sound/core/rawmidi.c:			snd_printk(KERN_ERR "unable to register OSS rawmidi device %i:%i\n", rmidi->card->number, 0);
./sound/core/rawmidi.c:			snd_oss_info_register(SNDRV_OSS_INFO_DEV_MIDI, rmidi->card->number, rmidi->name);
./sound/core/rawmidi.c:	if ((int)rmidi->device == amidi_map[rmidi->card->number]) {
./sound/core/rawmidi.c:			snd_printk(KERN_ERR "unable to register OSS rawmidi device %i:%i\n", rmidi->card->number, 1);
./sound/core/rawmidi.c:	entry = snd_info_create_card_entry(rmidi->card, name, rmidi->card->proc_root);
./sound/core/rawmidi.c:			sprintf(rmidi->seq_dev->name, "MIDI %d-%d", rmidi->card->number, rmidi->device);
./sound/core/rawmidi.c:		if ((int)rmidi->device == midi_map[rmidi->card->number]) {
./sound/core/rawmidi.c:			snd_oss_info_unregister(SNDRV_OSS_INFO_DEV_MIDI, rmidi->card->number);
./sound/core/rawmidi.c:		if ((int)rmidi->device == amidi_map[rmidi->card->number])
./sound/core/device.c:	list_add(&dev->list, &card->devices);	/* add to the head of list */
./sound/core/device.c:	list_for_each_entry(dev, &card->devices, list) {
./sound/core/device.c:	list_for_each_entry(dev, &card->devices, list) {
./sound/core/device.c:	list_for_each_entry(dev, &card->devices, list) {
./sound/core/device.c:	list_for_each_entry(dev, &card->devices, list) {
./sound/core/device.c:	list_for_each_entry(dev, &card->devices, list) {
./sound/core/device.c:	list_for_each_entry(dev, &card->devices, list) {
./sound/core/info.c:	sprintf(str, "card%i", card->number);
./sound/core/info.c:	if ((entry = snd_info_create_module_entry(card->module, str, NULL)) == NULL)
./sound/core/info.c:	card->proc_root = entry;
./sound/core/info.c:	if (!strcmp(card->id, card->proc_root->name))
./sound/core/info.c:	p = proc_symlink(card->id, snd_proc_root, card->proc_root->name);
./sound/core/info.c:	card->proc_root_link = p;
./sound/core/info.c: * called on card->id change
./sound/core/info.c:	if (card->proc_root_link) {
./sound/core/info.c:		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
./sound/core/info.c:		card->proc_root_link = NULL;
./sound/core/info.c:	if (strcmp(card->id, card->proc_root->name))
./sound/core/info.c:		card->proc_root_link = proc_symlink(card->id,
./sound/core/info.c:						    card->proc_root->name);
./sound/core/info.c:	if (card->proc_root_link) {
./sound/core/info.c:		snd_remove_proc_entry(snd_proc_root, card->proc_root_link);
./sound/core/info.c:		card->proc_root_link = NULL;
./sound/core/info.c:	if (card->proc_root)
./sound/core/info.c:		snd_info_disconnect(card->proc_root);
./sound/core/info.c:	snd_info_free_entry(card->proc_root);
./sound/core/info.c:	card->proc_root = NULL;
./sound/core/info.c:		entry->module = card->module;
./sound/core/info.c: * The parent is assumed as card->proc_root.
./sound/core/info.c:	entry = snd_info_create_card_entry(card, name, card->proc_root);
./sound/core/control.c:	if (!try_module_get(card->module)) {
./sound/core/control.c:	write_lock_irqsave(&card->ctl_files_rwlock, flags);
./sound/core/control.c:	list_add_tail(&ctl->list, &card->ctl_files);
./sound/core/control.c:	write_unlock_irqrestore(&card->ctl_files_rwlock, flags);
./sound/core/control.c:	module_put(card->module);
./sound/core/control.c:	write_lock_irqsave(&card->ctl_files_rwlock, flags);
./sound/core/control.c:	write_unlock_irqrestore(&card->ctl_files_rwlock, flags);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	list_for_each_entry(control, &card->controls, list)
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	module_put(card->module);
./sound/core/control.c:	read_lock(&card->ctl_files_rwlock);
./sound/core/control.c:	card->mixer_oss_change_count++;
./sound/core/control.c:	list_for_each_entry(ctl, &card->ctl_files, list) {
./sound/core/control.c:	read_unlock(&card->ctl_files_rwlock);
./sound/core/control.c:	list_for_each_entry(kctl, &card->controls, list) {
./sound/core/control.c:		if (kctl->id.numid < card->last_numid + 1 + count &&
./sound/core/control.c:		    kctl->id.numid + kctl->count > card->last_numid + 1) {
./sound/core/control.c:		    	card->last_numid = kctl->id.numid + kctl->count - 1;
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:		up_write(&card->controls_rwsem);
./sound/core/control.c:		up_write(&card->controls_rwsem);
./sound/core/control.c:	list_add_tail(&kcontrol->list, &card->controls);
./sound/core/control.c:	card->controls_count += kcontrol->count;
./sound/core/control.c:	kcontrol->id.numid = card->last_numid + 1;
./sound/core/control.c:	card->last_numid += kcontrol->count;
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:		up_write(&card->controls_rwsem);
./sound/core/control.c:		up_write(&card->controls_rwsem);
./sound/core/control.c:		up_write(&card->controls_rwsem);
./sound/core/control.c:	list_add_tail(&kcontrol->list, &card->controls);
./sound/core/control.c:	card->controls_count += kcontrol->count;
./sound/core/control.c:	kcontrol->id.numid = card->last_numid + 1;
./sound/core/control.c:	card->last_numid += kcontrol->count;
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c: * the write lock - down_write(&card->controls_rwsem).
./sound/core/control.c:	card->controls_count -= kcontrol->count;
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:		up_write(&card->controls_rwsem);
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	card->user_ctl_count--;
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:		up_write(&card->controls_rwsem);
./sound/core/control.c:	kctl->id.numid = card->last_numid + 1;
./sound/core/control.c:	card->last_numid += kctl->count;
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c: * The caller must down card->controls_rwsem before calling this function
./sound/core/control.c:	list_for_each_entry(kctl, &card->controls, list) {
./sound/core/control.c: * The caller must down card->controls_rwsem before calling this function
./sound/core/control.c:	list_for_each_entry(kctl, &card->controls, list) {
./sound/core/control.c:	info->card = card->number;
./sound/core/control.c:	strlcpy(info->id, card->id, sizeof(info->id));
./sound/core/control.c:	strlcpy(info->driver, card->driver, sizeof(info->driver));
./sound/core/control.c:	strlcpy(info->name, card->shortname, sizeof(info->name));
./sound/core/control.c:	strlcpy(info->longname, card->longname, sizeof(info->longname));
./sound/core/control.c:	strlcpy(info->mixername, card->mixername, sizeof(info->mixername));
./sound/core/control.c:	strlcpy(info->components, card->components, sizeof(info->components));
./sound/core/control.c:		down_read(&card->controls_rwsem);
./sound/core/control.c:		list.count = card->controls_count;
./sound/core/control.c:		plist = card->controls.next;
./sound/core/control.c:		while (plist != &card->controls) {
./sound/core/control.c:		while (space > 0 && plist != &card->controls) {
./sound/core/control.c:		up_read(&card->controls_rwsem);
./sound/core/control.c:		down_read(&card->controls_rwsem);
./sound/core/control.c:		list.count = card->controls_count;
./sound/core/control.c:		up_read(&card->controls_rwsem);
./sound/core/control.c:	down_read(&card->controls_rwsem);
./sound/core/control.c:		up_read(&card->controls_rwsem);
./sound/core/control.c:	up_read(&card->controls_rwsem);
./sound/core/control.c:	down_read(&card->controls_rwsem);
./sound/core/control.c:	up_read(&card->controls_rwsem);
./sound/core/control.c:	down_read(&card->controls_rwsem);
./sound/core/control.c:			up_read(&card->controls_rwsem);
./sound/core/control.c:	up_read(&card->controls_rwsem);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	if (card->user_ctl_count >= MAX_USER_CONTROLS)
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	card->user_ctl_count++;
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/core/control.c:	down_read(&card->controls_rwsem);
./sound/core/control.c:			up_read(&card->controls_rwsem);
./sound/core/control.c:	up_read(&card->controls_rwsem);
./sound/core/control.c:		return put_user(card->power_state, ip) ? -EFAULT : 0;
./sound/core/control.c:			if (ctl->card->shutdown)
./sound/core/control.c:	cardnum = card->number;
./sound/core/control.c:	cardnum = card->number;
./sound/core/control.c:	read_lock(&card->ctl_files_rwlock);
./sound/core/control.c:	list_for_each_entry(ctl, &card->ctl_files, list) {
./sound/core/control.c:	read_unlock(&card->ctl_files_rwlock);
./sound/core/control.c:	down_write(&card->controls_rwsem);
./sound/core/control.c:	while (!list_empty(&card->controls)) {
./sound/core/control.c:		control = snd_kcontrol(card->controls.next);
./sound/core/control.c:	up_write(&card->controls_rwsem);
./sound/pcmcia/pdaudiocf/pdaudiocf_pcm.c:	strcpy(pcm->name, chip->card->shortname);
./sound/pcmcia/pdaudiocf/pdaudiocf_core.c:	card->private_data = chip;
./sound/pcmcia/pdaudiocf/pdaudiocf.c:	strcpy(card->driver, "PDAudio-CF");
./sound/pcmcia/pdaudiocf/pdaudiocf.c:	sprintf(card->shortname, "Core Sound %s", card->driver);
./sound/pcmcia/pdaudiocf/pdaudiocf.c:	sprintf(card->longname, "%s at 0x%x, irq %i",
./sound/pcmcia/pdaudiocf/pdaudiocf.c:		card->shortname, port, irq);
./sound/pcmcia/vx/vxpocket.c:	sprintf(card->shortname, "Digigram %s", card->driver);
./sound/pcmcia/vx/vxpocket.c:	sprintf(card->longname, "%s at 0x%x, irq %i",
./sound/pcmcia/vx/vxpocket.c:		card->shortname, port, irq);
./sound/pcmcia/vx/vxpocket.c:		strcpy(chip->card->driver, vxp440_hw.name);
./sound/pcmcia/vx/vxpocket.c:	card->private_data = vxp;
./sound/mips/au1x00.c:	struct snd_au1000 *au1000 = card->private_data;
./sound/mips/au1x00.c:	card->private_free = snd_au1000_free;
./sound/mips/au1x00.c:	au1000 = card->private_data;
./sound/mips/au1x00.c:	strcpy(card->driver, "Au1000-AC97");
./sound/mips/au1x00.c:	strcpy(card->shortname, "AMD Au1000-AC97");
./sound/mips/au1x00.c:	sprintf(card->longname, "AMD Au1000--AC97 ALSA Driver");
./sound/mips/sgio2audio.c:	strcpy(card->driver, "SGI O2 Audio");
./sound/mips/sgio2audio.c:	strcpy(card->shortname, "SGI O2 Audio");
./sound/mips/sgio2audio.c:	sprintf(card->longname, "%s irq %i-%i",
./sound/mips/sgio2audio.c:		card->shortname,
./sound/mips/hal2.c:	strcpy(card->driver, "SGI HAL2 Audio");
./sound/mips/hal2.c:	strcpy(card->shortname, "SGI HAL2 Audio");
./sound/mips/hal2.c:	sprintf(card->longname, "%s irq %i",
./sound/mips/hal2.c:		card->shortname,
./sound/arm/pxa2xx-pcm-lib.c:		dma_alloc_writecombine(substream->pcm->card->dev, PAGE_SIZE,
./sound/arm/pxa2xx-pcm-lib.c:	dma_free_writecombine(substream->pcm->card->dev, PAGE_SIZE,
./sound/arm/pxa2xx-pcm-lib.c:	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
./sound/arm/pxa2xx-pcm-lib.c:	buf->dev.dev = pcm->card->dev;
./sound/arm/pxa2xx-pcm-lib.c:	buf->area = dma_alloc_writecombine(pcm->card->dev, size,
./sound/arm/pxa2xx-pcm-lib.c:		dma_free_writecombine(pcm->card->dev, buf->bytes,
./sound/arm/pxa2xx-pcm.c:	if (!card->dev->dma_mask)
./sound/arm/pxa2xx-pcm.c:		card->dev->dma_mask = &pxa2xx_pcm_dmamask;
./sound/arm/pxa2xx-pcm.c:	if (!card->dev->coherent_dma_mask)
./sound/arm/pxa2xx-pcm.c:		card->dev->coherent_dma_mask = 0xffffffff;
./sound/arm/aaci.c:	struct aaci *aaci = card->private_data;
./sound/arm/aaci.c:	struct aaci *aaci = card->private_data;
./sound/arm/aaci.c:	card->private_free = aaci_free_card;
./sound/arm/aaci.c:	strlcpy(card->driver, DRIVER_NAME, sizeof(card->driver));
./sound/arm/aaci.c:	strlcpy(card->shortname, "ARM AC'97 Interface", sizeof(card->shortname));
./sound/arm/aaci.c:	snprintf(card->longname, sizeof(card->longname),
./sound/arm/aaci.c:		 card->shortname, amba_part(dev), amba_rev(dev),
./sound/arm/aaci.c:	aaci = card->private_data;
./sound/arm/aaci.c:		dev_info(&dev->dev, "%s\n", aaci->card->longname);
./sound/arm/aaci.c:		struct aaci *aaci = card->private_data;
./sound/arm/pxa2xx-ac97.c:       	platform_ops = substream->pcm->card->dev->platform_data;
./sound/arm/pxa2xx-ac97.c:       	platform_ops = substream->pcm->card->dev->platform_data;
./sound/arm/pxa2xx-ac97.c:	pxa2xx_audio_ops_t *platform_ops = card->dev->platform_data;
./sound/arm/pxa2xx-ac97.c:	pxa2xx_audio_ops_t *platform_ops = card->dev->platform_data;
./sound/arm/pxa2xx-ac97.c:	card->dev = &dev->dev;
./sound/arm/pxa2xx-ac97.c:	strncpy(card->driver, dev->dev.driver->name, sizeof(card->driver));
./sound/arm/pxa2xx-ac97.c:	snprintf(card->shortname, sizeof(card->shortname),
./sound/arm/pxa2xx-ac97.c:	snprintf(card->longname, sizeof(card->longname),
./sound/arm/pxa2xx-ac97.c:		 "%s (%s)", dev->dev.driver->name, card->mixername);
./sound/usb/midi.c:		 name_format, umidi->card->shortname, number + 1);
./sound/usb/midi.c:	strcpy(rmidi->name, umidi->card->shortname);
./sound/usb/misc/ua101.c:	struct ua101 *ua = card->private_data;
./sound/usb/misc/ua101.c:	card->private_free = ua101_card_free;
./sound/usb/misc/ua101.c:	ua = card->private_data;
./sound/usb/misc/ua101.c:	strcpy(card->driver, "UA-101");
./sound/usb/misc/ua101.c:	strcpy(card->shortname, name);
./sound/usb/misc/ua101.c:	snprintf(ua->card->longname, sizeof(ua->card->longname),
./sound/usb/card.c:	strcpy(card->driver, "USB-Audio");
./sound/usb/card.c:		strlcpy(card->shortname, quirk->product_name, sizeof(card->shortname));
./sound/usb/card.c:		    card->shortname, sizeof(card->shortname)) <= 0) {
./sound/usb/card.c:			sprintf(card->shortname, "USB Device %#04x:%#04x",
./sound/usb/card.c:	remove_trailing_spaces(card->shortname);
./sound/usb/card.c:		len = strlcpy(card->longname, quirk->vendor_name, sizeof(card->longname));
./sound/usb/card.c:					 card->longname, sizeof(card->longname));
./sound/usb/card.c:		remove_trailing_spaces(card->longname);
./sound/usb/card.c:		if (*card->longname)
./sound/usb/card.c:			strlcat(card->longname, " ", sizeof(card->longname));
./sound/usb/card.c:	strlcat(card->longname, card->shortname, sizeof(card->longname));
./sound/usb/card.c:	len = strlcat(card->longname, " at ", sizeof(card->longname));
./sound/usb/card.c:	if (len < sizeof(card->longname))
./sound/usb/card.c:		usb_make_path(dev, card->longname + len, sizeof(card->longname) - len);
./sound/usb/card.c:		strlcat(card->longname, ", low speed", sizeof(card->longname));
./sound/usb/card.c:		strlcat(card->longname, ", full speed", sizeof(card->longname));
./sound/usb/card.c:		strlcat(card->longname, ", high speed", sizeof(card->longname));
./sound/usb/card.c:		strlcat(card->longname, ", super speed", sizeof(card->longname));
./sound/usb/proc.c:	snd_iprintf(buffer, "%s : %s\n", stream->chip->card->longname, stream->pcm->name);
./sound/usb/caiaq/device.c:	strlcpy(card->driver, MODNAME, sizeof(card->driver));
./sound/usb/caiaq/device.c:	strlcpy(card->shortname, dev->product_name, sizeof(card->shortname));
./sound/usb/caiaq/device.c:	strlcpy(card->mixername, dev->product_name, sizeof(card->mixername));
./sound/usb/caiaq/device.c:	if (*card->id == '\0') {
./sound/usb/caiaq/device.c:		char id[sizeof(card->id)];
./sound/usb/caiaq/device.c:		for (c = card->shortname, len = 0;
./sound/usb/caiaq/device.c:			*c && len < sizeof(card->id); c++)
./sound/usb/caiaq/device.c:	snprintf(card->longname, sizeof(card->longname),
./sound/usb/mixer_quirks.c:		 "%s remote control", mixer->chip->card->shortname);
./sound/usb/mixer_quirks.c:	snd_iprintf(buffer, "%s jacks\n\n", mixer->chip->card->shortname);
./sound/usb/6fire/chip.c:	strcpy(card->driver, "6FireUSB");
./sound/usb/6fire/chip.c:	strcpy(card->shortname, "TerraTec DMX6FireUSB");
./sound/usb/6fire/chip.c:	sprintf(card->longname, "%s at %d:%d", card->shortname,
./sound/usb/6fire/chip.c:	chip = card->private_data;
./sound/usb/6fire/firmware.c: * iff an error occurred, false will be returned and record->error will be true.
./sound/usb/6fire/firmware.c:	record->error = false;
./sound/usb/6fire/firmware.c:	while (record->txt_offset < record->txt_length
./sound/usb/6fire/firmware.c:			&& record->txt_data[record->txt_offset] != ':')
./sound/usb/6fire/firmware.c:		record->txt_offset++;
./sound/usb/6fire/firmware.c:	if (record->txt_offset == record->txt_length)
./sound/usb/6fire/firmware.c:	record->txt_offset++;
./sound/usb/6fire/firmware.c:	if (record->txt_offset + 8 > record->txt_length) {
./sound/usb/6fire/firmware.c:		record->error = true;
./sound/usb/6fire/firmware.c:	record->len = usb6fire_fw_ihex_hex(record->txt_data +
./sound/usb/6fire/firmware.c:			record->txt_offset, &crc);
./sound/usb/6fire/firmware.c:	record->txt_offset += 2;
./sound/usb/6fire/firmware.c:	record->address = usb6fire_fw_ihex_hex(record->txt_data +
./sound/usb/6fire/firmware.c:			record->txt_offset, &crc) << 8;
./sound/usb/6fire/firmware.c:	record->txt_offset += 2;
./sound/usb/6fire/firmware.c:	record->address |= usb6fire_fw_ihex_hex(record->txt_data +
./sound/usb/6fire/firmware.c:			record->txt_offset, &crc);
./sound/usb/6fire/firmware.c:	record->txt_offset += 2;
./sound/usb/6fire/firmware.c:	type = usb6fire_fw_ihex_hex(record->txt_data +
./sound/usb/6fire/firmware.c:			record->txt_offset, &crc);
./sound/usb/6fire/firmware.c:	record->txt_offset += 2;
./sound/usb/6fire/firmware.c:	if (record->txt_offset + 2 * (record->len + 1) > record->txt_length) {
./sound/usb/6fire/firmware.c:		record->error = true;
./sound/usb/6fire/firmware.c:	for (i = 0; i < record->len; i++) {
./sound/usb/6fire/firmware.c:		record->data[i] = usb6fire_fw_ihex_hex(record->txt_data
./sound/usb/6fire/firmware.c:				+ record->txt_offset, &crc);
./sound/usb/6fire/firmware.c:		record->txt_offset += 2;
./sound/usb/6fire/firmware.c:	usb6fire_fw_ihex_hex(record->txt_data + record->txt_offset, &crc);
./sound/usb/6fire/firmware.c:		record->error = true;
./sound/usb/6fire/firmware.c:	if (type == 1 || !record->len) /* eof */
./sound/usb/6fire/firmware.c:		record->error = true;
./sound/usb/6fire/firmware.c:	record->txt_data = fw->data;
./sound/usb/6fire/firmware.c:	record->txt_length = fw->size;
./sound/usb/6fire/firmware.c:	record->txt_offset = 0;
./sound/usb/6fire/firmware.c:	record->max_len = 0;
./sound/usb/6fire/firmware.c:	/* read all records, if loop ends, record->error indicates,
./sound/usb/6fire/firmware.c:		record->max_len = max(record->len, record->max_len);
./sound/usb/6fire/firmware.c:	if (record->error)
./sound/usb/6fire/firmware.c:	record->txt_offset = 0;
./sound/usb/mixer.c:			/* FIXME: hard-coded */
./sound/usb/mixer.c:		snd_iprintf(buffer, "Card: %s\n", chip->card->longname);
./sound/usb/mixer.c:	strcpy(chip->card->mixername, "USB Mixer");
./sound/usb/usx2y/usbusx2y.c:	card->private_free = snd_usX2Y_card_private_free;
./sound/usb/usx2y/usbusx2y.c:	strcpy(card->driver, "USB "NAME_ALLCAPS"");
./sound/usb/usx2y/usbusx2y.c:	sprintf(card->shortname, "TASCAM "NAME_ALLCAPS"");
./sound/usb/usx2y/usbusx2y.c:	sprintf(card->longname, "%s (%x:%x if %d at %03d/%03d)",
./sound/usb/usx2y/usbusx2y.c:		card->shortname, 
./sound/usb/usx2y/usx2yhwdeppcm.c:	list_for_each(list, &card->devices) {
./sound/usb/usx2y/usx2yhwdeppcm.c:	list_for_each(list, &card->devices) {
./sound/usb/usx2y/usx2yhwdeppcm.c:	list_for_each(list, &card->devices) {
./sound/usb/usx2y/us122l.c:	card->private_free = snd_us122l_free;
./sound/usb/usx2y/us122l.c:	strcpy(card->driver, "USB "NAME_ALLCAPS"");
./sound/usb/usx2y/us122l.c:	sprintf(card->shortname, "TASCAM "NAME_ALLCAPS"");
./sound/usb/usx2y/us122l.c:	sprintf(card->longname, "%s (%x:%x if %d at %03d/%03d)",
./sound/usb/usx2y/us122l.c:		card->shortname,
./sound/usb/usx2y/usbusx2yaudio.c:	list_for_each(list, &card->devices) {
./sound/drivers/opl3/opl3_lib.c:	tid.card = opl3->card->number;
./sound/drivers/opl3/opl3_lib.c:	tid.card = opl3->card->number;
./sound/drivers/opl3/opl3_lib.c:		sprintf(hw->oss_dev, "dmfm%i", card->number);
./sound/drivers/opl3/opl3_seq.c:	if (!try_module_get(opl3->card->module))
./sound/drivers/opl3/opl3_seq.c:	module_put(opl3->card->module);
./sound/drivers/portman2x4.c:	struct portman *pm = card->private_data;
./sound/drivers/portman2x4.c:	struct portman *pm = card->private_data;
./sound/drivers/portman2x4.c:	strcpy(card->driver, DRIVER_NAME);
./sound/drivers/portman2x4.c:	strcpy(card->shortname, CARD_NAME);
./sound/drivers/portman2x4.c:	sprintf(card->longname,  "%s at 0x%lx, irq %i", 
./sound/drivers/portman2x4.c:		card->shortname, p->base, p->irq);
./sound/drivers/portman2x4.c:	card->private_data = pm;
./sound/drivers/portman2x4.c:	card->private_free = snd_portman_card_private_free;
./sound/drivers/dummy.c:	strcpy(card->mixername, "Dummy Mixer");
./sound/drivers/dummy.c:	dummy = card->private_data;
./sound/drivers/dummy.c:				(*mdl)->name, card->number);
./sound/drivers/dummy.c:	strcpy(card->driver, "Dummy");
./sound/drivers/dummy.c:	strcpy(card->shortname, "Dummy");
./sound/drivers/dummy.c:	sprintf(card->longname, "Dummy %i", dev + 1);
./sound/drivers/dummy.c:	struct snd_dummy *dummy = card->private_data;
./sound/drivers/serial-u16550.c:	strcpy(card->driver, "Serial");
./sound/drivers/serial-u16550.c:	strcpy(card->shortname, "Serial MIDI (UART16550A)");
./sound/drivers/serial-u16550.c:	sprintf(card->longname, "%s [%s] at %#lx, irq %d",
./sound/drivers/serial-u16550.c:		card->shortname,
./sound/drivers/virmidi.c:	vmidi = card->private_data;
./sound/drivers/virmidi.c:	strcpy(card->driver, "VirMIDI");
./sound/drivers/virmidi.c:	strcpy(card->shortname, "VirMIDI");
./sound/drivers/virmidi.c:	sprintf(card->longname, "Virtual MIDI Card %i", dev + 1);
./sound/drivers/virmidi.c:		printk(KERN_ERR "Card-VirMIDI soundcard not found or device busy\n");
./sound/drivers/opl4/opl4_proc.c:	entry = snd_info_create_card_entry(opl4->card, "opl4-mem", opl4->card->proc_root);
./sound/drivers/opl4/opl4_seq.c:	if (!try_module_get(opl4->card->module))
./sound/drivers/opl4/opl4_seq.c:	module_put(opl4->card->module);
./sound/drivers/opl4/opl4_mixer.c:	strcat(card->mixername, ",OPL4");
./sound/drivers/ml403-ac97cr.c:	card->private_data = ml403_ac97cr;
./sound/drivers/ml403-ac97cr.c:	strcpy(card->driver, SND_ML403_AC97CR_DRIVER);
./sound/drivers/ml403-ac97cr.c:	strcpy(card->shortname, "ML403 AC97 Controller Reference");
./sound/drivers/ml403-ac97cr.c:	sprintf(card->longname, "%s %s at 0x%lx, irq %i & %i, device %i",
./sound/drivers/ml403-ac97cr.c:		card->shortname, card->driver,
./sound/drivers/vx/vx_hwdep.c:	sprintf(hw->name, "VX Loader (%s)", chip->card->driver);
./sound/drivers/vx/vx_core.c:	snd_iprintf(buffer, "%s\n", chip->card->longname);
./sound/drivers/vx/vx_core.c:	card->private_data = chip;
./sound/drivers/vx/vx_core.c:	strcpy(card->driver, hw->name);
./sound/drivers/vx/vx_core.c:	sprintf(card->shortname, "Digigram %s", hw->name);
./sound/drivers/vx/vx_pcm.c:	 * for word-transfer
./sound/drivers/vx/vx_pcm.c:		strcpy(pcm->name, chip->card->shortname);
./sound/drivers/vx/vx_mixer.c:	strcpy(card->mixername, card->driver);
./sound/drivers/mts64.c:	struct mts64 *mts = card->private_data;
./sound/drivers/mts64.c:	struct mts64 *mts = card->private_data;
./sound/drivers/mts64.c:	strcpy(card->driver, DRIVER_NAME);
./sound/drivers/mts64.c:	strcpy(card->shortname, "ESI " CARD_NAME);
./sound/drivers/mts64.c:	sprintf(card->longname,  "%s at 0x%lx, irq %i", 
./sound/drivers/mts64.c:		card->shortname, p->base, p->irq);
./sound/drivers/mts64.c:	card->private_data = mts;
./sound/drivers/mts64.c:	card->private_free = snd_mts64_card_private_free;
./sound/drivers/mpu401/mpu401.c:	strcpy(card->driver, "MPU-401 UART");
./sound/drivers/mpu401/mpu401.c:	strcpy(card->shortname, card->driver);
./sound/drivers/mpu401/mpu401.c:	sprintf(card->longname, "%s at %#lx, ", card->shortname, port[dev]);
./sound/drivers/mpu401/mpu401.c:		sprintf(card->longname + strlen(card->longname), "irq %d", irq[dev]);
./sound/drivers/mpu401/mpu401.c:		strcat(card->longname, "polled");
./sound/drivers/mpu401/mpu401_uart.c:	if (card->shortname[0])
./sound/drivers/mpu401/mpu401_uart.c:			 card->shortname);
./sound/drivers/mpu401/mpu401_uart.c:		sprintf(rmidi->name, "MPU-401 MIDI %d-%d",card->number, device);
./sound/drivers/aloop.c:	strcpy(card->mixername, "Loopback Mixer");
./sound/drivers/aloop.c:	loopback = card->private_data;
./sound/drivers/aloop.c:	strcpy(card->driver, "Loopback");
./sound/drivers/aloop.c:	strcpy(card->shortname, "Loopback");
./sound/drivers/aloop.c:	sprintf(card->longname, "Loopback %i", dev + 1);
./sound/drivers/aloop.c:	struct loopback *loopback = card->private_data;
./sound/drivers/pcsp/pcsp_mixer.c:	strcpy(card->mixername, "PC-Speaker");
./sound/drivers/pcsp/pcsp.c:	strcpy(card->driver, "PC-Speaker");
./sound/drivers/pcsp/pcsp.c:	strcpy(card->shortname, "pcsp");
./sound/drivers/pcsp/pcsp.c:	sprintf(card->longname, "Internal PC-Speaker at port 0x%x",
./sound/drivers/mtpav.c:	if (portp->hwport != mtp_card->outmidihwport) {
./sound/drivers/mtpav.c:		mtp_card->outmidihwport = portp->hwport;
./sound/drivers/mtpav.c:	struct mtpav_port *portp = &mtp_card->ports[substream->number];
./sound/drivers/mtpav.c:	spin_lock_irqsave(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	struct mtpav_port *portp = &mtp_card->ports[substream->number];
./sound/drivers/mtpav.c:	spin_lock_irqsave(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	if (mtp_card->share_irq++ == 0)
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	struct mtpav_port *portp = &mtp_card->ports[substream->number];
./sound/drivers/mtpav.c:	spin_lock_irqsave(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	if (--mtp_card->share_irq == 0)
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	struct mtpav_port *portp = &mtp_card->ports[substream->number];
./sound/drivers/mtpav.c:	spin_lock_irqsave(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	struct mtpav_port *portp = &mtp_card->ports[substream->number];
./sound/drivers/mtpav.c:	spin_lock_irqsave(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	struct mtpav_port *portp = &mtp_card->ports[substream->number];
./sound/drivers/mtpav.c:	spin_lock_irqsave(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	struct mtpav_port *portp = &mtp_card->ports[substream->number];
./sound/drivers/mtpav.c:	spin_lock_irqsave(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:			if (mtp_card->istimer++ == 0)
./sound/drivers/mtpav.c:		if (--mtp_card->istimer == 0)
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&mtp_card->spinlock, flags);
./sound/drivers/mtpav.c:	if ((int)mcrd->inmidiport > mcrd->num_ports * 2 + MTPAV_PIDX_BROADCAST)
./sound/drivers/mtpav.c:	portp = &mcrd->ports[mcrd->inmidiport];
./sound/drivers/mtpav.c:	if (mcrd->inmidistate == 0) {	// awaiting command
./sound/drivers/mtpav.c:			mcrd->inmidistate = 1;
./sound/drivers/mtpav.c:	} else if (mcrd->inmidistate) {
./sound/drivers/mtpav.c:		mcrd->inmidiport = translate_hwport_to_subdevice(mcrd, inbyte);
./sound/drivers/mtpav.c:		mcrd->inmidistate = 0;
./sound/drivers/mtpav.c:	spin_lock(&mcard->spinlock);
./sound/drivers/mtpav.c:	spin_unlock(&mcard->spinlock);
./sound/drivers/mtpav.c:	if ((mcard->res_port = request_region(port, 3, "MotuMTPAV MIDI")) == NULL) {
./sound/drivers/mtpav.c:	mcard->port = port;
./sound/drivers/mtpav.c:	mcard->irq = irq;
./sound/drivers/mtpav.c:	mcard->num_ports = hwports;
./sound/drivers/mtpav.c:	if ((rval = snd_rawmidi_new(mcard->card, "MotuMIDI", 0,
./sound/drivers/mtpav.c:				    mcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,
./sound/drivers/mtpav.c:				    mcard->num_ports * 2 + MTPAV_PIDX_BROADCAST + 1,
./sound/drivers/mtpav.c:				    &mcard->rmidi)) < 0)
./sound/drivers/mtpav.c:	rawmidi = mcard->rmidi;
./sound/drivers/mtpav.c:		mcard->ports[substream->number].hwport = translate_subdevice_to_hwport(mcard, substream->number);
./sound/drivers/mtpav.c:	struct mtpav *crd = card->private_data;
./sound/drivers/mtpav.c:	spin_lock_irqsave(&crd->spinlock, flags);
./sound/drivers/mtpav.c:	if (crd->istimer > 0)
./sound/drivers/mtpav.c:	spin_unlock_irqrestore(&crd->spinlock, flags);
./sound/drivers/mtpav.c:	if (crd->irq >= 0)
./sound/drivers/mtpav.c:		free_irq(crd->irq, (void *)crd);
./sound/drivers/mtpav.c:	release_and_free_resource(crd->res_port);
./sound/drivers/mtpav.c:	mtp_card = card->private_data;
./sound/drivers/mtpav.c:	spin_lock_init(&mtp_card->spinlock);
./sound/drivers/mtpav.c:	init_timer(&mtp_card->timer);
./sound/drivers/mtpav.c:	mtp_card->card = card;
./sound/drivers/mtpav.c:	mtp_card->irq = -1;
./sound/drivers/mtpav.c:	mtp_card->share_irq = 0;
./sound/drivers/mtpav.c:	mtp_card->inmidistate = 0;
./sound/drivers/mtpav.c:	mtp_card->outmidihwport = 0xffffffff;
./sound/drivers/mtpav.c:	init_timer(&mtp_card->timer);
./sound/drivers/mtpav.c:	mtp_card->timer.function = snd_mtpav_output_timer;
./sound/drivers/mtpav.c:	mtp_card->timer.data = (unsigned long) mtp_card;
./sound/drivers/mtpav.c:	card->private_free = snd_mtpav_free;
./sound/drivers/mtpav.c:	mtp_card->inmidiport = mtp_card->num_ports + MTPAV_PIDX_BROADCAST;
./sound/drivers/mtpav.c:	strcpy(card->driver, "MTPAV");
./sound/drivers/mtpav.c:	strcpy(card->shortname, "MTPAV on parallel port");
./sound/drivers/mtpav.c:	snprintf(card->longname, sizeof(card->longname),
./sound/drivers/mtpav.c:	err = snd_card_register(mtp_card->card);
./sound/atmel/abdac.c:	 * non-halfword-aligned buffers or lengths.
./sound/atmel/abdac.c:	retval = snd_pcm_new(dac->card, dac->card->shortname,
./sound/atmel/abdac.c:	strcpy(pcm->name, dac->card->shortname);
./sound/atmel/abdac.c:	strcpy(card->driver, "Atmel ABDAC");
./sound/atmel/abdac.c:	strcpy(card->shortname, "Atmel ABDAC");
./sound/atmel/abdac.c:	sprintf(card->longname, "Atmel Audio Bitstream DAC");
./sound/atmel/abdac.c:	struct atmel_abdac *dac = card->private_data;
./sound/atmel/abdac.c:	struct atmel_abdac *dac = card->private_data;
./sound/atmel/ac97c.c:	 * non-halfword-aligned buffers or lengths.
./sound/atmel/ac97c.c:	retval = snd_pcm_new(chip->card, chip->card->shortname,
./sound/atmel/ac97c.c:	strcpy(pcm->name, chip->card->shortname);
./sound/atmel/ac97c.c:	strcpy(card->driver, "Atmel AC97C");
./sound/atmel/ac97c.c:	strcpy(card->shortname, "Atmel AC97C");
./sound/atmel/ac97c.c:	sprintf(card->longname, "Atmel AC97 controller");
./sound/atmel/ac97c.c:	struct atmel_ac97c *chip = card->private_data;
./sound/atmel/ac97c.c:	struct atmel_ac97c *chip = card->private_data;
./sound/i2c/tea6330t.c:	strcat(card->mixername, ",TEA6330T");
./sound/aoa/fabrics/layout.c: * we think is connected. This information is hard-
./sound/aoa/core/alsa.c:	aoa_card = alsa_card->private_data;
./sound/aoa/core/alsa.c:	aoa_card->alsa_card = alsa_card;
./sound/aoa/core/alsa.c:	alsa_card->dev = dev;
./sound/aoa/core/alsa.c:	strlcpy(alsa_card->driver, "AppleOnbdAudio", sizeof(alsa_card->driver));
./sound/aoa/core/alsa.c:	strlcpy(alsa_card->shortname, name, sizeof(alsa_card->shortname));
./sound/aoa/core/alsa.c:	strlcpy(alsa_card->longname, name, sizeof(alsa_card->longname));
./sound/aoa/core/alsa.c:	strlcpy(alsa_card->mixername, name, sizeof(alsa_card->mixername));
./sound/aoa/core/alsa.c:	err = snd_card_register(aoa_card->alsa_card);
./sound/aoa/core/alsa.c:		snd_card_free(aoa_card->alsa_card);
./sound/aoa/core/alsa.c:		return aoa_card->alsa_card;
./sound/aoa/core/alsa.c:		snd_card_free(aoa_card->alsa_card);
./sound/aoa/core/alsa.c:	err = snd_ctl_add(aoa_card->alsa_card, control);
./sound/synth/emux/emux_proc.c:	entry = snd_info_create_card_entry(card, name, card->proc_root);
./sound/synth/emux/emux_seq.c:	if (!try_module_get(emu->card->module)) {
./sound/synth/emux/emux_seq.c:	module_put(emu->card->module);
./net/ipx/ipx_route.c:	intrfc = ipxitf_find_using_net(rd->ipx_router_network);
./net/ipx/ipx_route.c:	rc = ipxrtr_add_route(rd->ipx_network, intrfc, rd->ipx_router_node);
./net/9p/trans_fd.c:	if (!ts->rd->f_op || !ts->rd->f_op->poll)
./net/9p/trans_fd.c:	ret = ts->rd->f_op->poll(ts->rd, pt);
./net/9p/trans_fd.c:	if (!(ts->rd->f_flags & O_NONBLOCK))
./net/9p/trans_fd.c:	ret = kernel_read(ts->rd, ts->rd->f_pos, v, len);
./net/9p/trans_fd.c:	p->rd->f_flags |= O_NONBLOCK;
./net/batman-adv/routing.c:#include "hard-interface.h"
./net/batman-adv/gateway_client.c:#include "hard-interface.h"
./net/batman-adv/originator.c:#include "hard-interface.h"
./net/batman-adv/unicast.c:#include "hard-interface.h"
./net/batman-adv/bat_debugfs.c:#include "hard-interface.h"
./net/batman-adv/soft-interface.c:#include "hard-interface.h"
./net/batman-adv/aggregation.c:#include "hard-interface.h"
./net/batman-adv/bat_sysfs.c:#include "hard-interface.h"
./net/batman-adv/icmp_socket.c:#include "hard-interface.h"
./net/batman-adv/main.c:#include "hard-interface.h"
./net/batman-adv/hard-interface.c:#include "hard-interface.h"
./net/batman-adv/vis.c:#include "hard-interface.h"
./net/batman-adv/translation-table.c:#include "hard-interface.h"
./net/batman-adv/send.c:#include "hard-interface.h"
./net/rxrpc/ar-ack.c: * discard hard-ACK'd packets from the Tx window
./net/rxrpc/ar-ack.c:				_debug("hard-ACK'd packet %d not transmitted"
./net/rxrpc/ar-ack.c:	/* if all the packets we sent are hard-ACK'd, then we can discard
./net/rxrpc/ar-skbuff.c: * - advance the hard-ACK state of the parent call (done here in case something
./net/ipv6/exthdrs_core.c: * seeing an unknown discard-with-error flavour TLV option if it's a
./net/wireless/nl80211.c:	rd->n_reg_rules = num_rules;
./net/wireless/nl80211.c:	rd->alpha2[0] = alpha2[0];
./net/wireless/nl80211.c:	rd->alpha2[1] = alpha2[1];
./net/wireless/nl80211.c:		r = parse_reg_rule(tb, &rd->reg_rules[rule_idx]);
./net/wireless/reg.c:	if (!rd->n_reg_rules)
./net/wireless/reg.c:	if (WARN_ON(rd->n_reg_rules > NL80211_MAX_SUPP_REG_RULES))
./net/wireless/reg.c:	for (i = 0; i < rd->n_reg_rules; i++) {
./net/wireless/reg.c:		reg_rule = &rd->reg_rules[i];
./net/wireless/reg.c:			intersected_rule = &rd->reg_rules[rule_idx];
./net/wireless/reg.c:	rd->n_reg_rules = num_rules;
./net/wireless/reg.c:	rd->alpha2[0] = '9';
./net/wireless/reg.c:	rd->alpha2[1] = '8';
./net/wireless/reg.c:	for (i = 0; i < rd->n_reg_rules; i++) {
./net/wireless/reg.c:		reg_rule = &rd->reg_rules[i];
./net/wireless/reg.c:	if (is_intersected_alpha2(rd->alpha2)) {
./net/wireless/reg.c:	} else if (is_world_regdom(rd->alpha2))
./net/wireless/reg.c:		if (is_unknown_alpha2(rd->alpha2))
./net/wireless/reg.c:				rd->alpha2[0], rd->alpha2[1]);
./net/wireless/reg.c:	pr_info("Regulatory domain: %c%c\n", rd->alpha2[0], rd->alpha2[1]);
./net/wireless/reg.c:	if (is_world_regdom(rd->alpha2)) {
./net/wireless/reg.c:		if (WARN_ON(!reg_is_valid_request(rd->alpha2)))
./net/wireless/reg.c:	if (!is_alpha2_set(rd->alpha2) && !is_an_alpha2(rd->alpha2) &&
./net/wireless/reg.c:			!is_unknown_alpha2(rd->alpha2))
./net/wireless/reg.c:		if (!regdom_changes(rd->alpha2))
./net/wireless/reg.c:	if (WARN_ON(!reg_is_valid_request(rd->alpha2)))
./net/wireless/reg.c:	rdev->country_ie_alpha2[0] = rd->alpha2[0];
./net/wireless/reg.c:	rdev->country_ie_alpha2[1] = rd->alpha2[1];
./net/netfilter/nf_conntrack_h323_types.c:	{FNAME("hrd-B") INT, CONS, 0, 0, SKIP | OPT, 0, NULL},
./net/netfilter/nf_conntrack_h323_main.c:/* If the calling party is on the same side of the forward-to party,
./net/netfilter/nf_conntrack_h323_main.c:	/* If the calling party is on the same side of the forward-to party,
./net/netfilter/nf_conntrack_sip.c:	/* We don't support third-party registrations */
./net/netfilter/nf_conntrack_sip.c:		/* We don't support third-party registrations */
./net/sunrpc/cache.c:		discard->revisit(discard, 1);
./net/sctp/sm_make_chunk.c:	 * only if ADD-IP is turned on and we are not backward-compatible
./kernel/acct.c:	/* backward-compatible 16 bit fields */
./kernel/lockdep.c:	 * forward-recursing into the graph starting at <next>, and
./kernel/sched_rt.c:	return atomic_read(&rq->rd->rto_count);
./kernel/sched_rt.c:	cpumask_set_cpu(rq->cpu, rq->rd->rto_mask);
./kernel/sched_rt.c:	atomic_inc(&rq->rd->rto_count);
./kernel/sched_rt.c:	atomic_dec(&rq->rd->rto_count);
./kernel/sched_rt.c:	cpumask_clear_cpu(rq->cpu, rq->rd->rto_mask);
./kernel/sched_rt.c:	return cpu_rq(smp_processor_id())->rd->span;
./kernel/sched_rt.c:	weight = cpumask_weight(rd->span);
./kernel/sched_rt.c:	for_each_cpu(i, rd->span) {
./kernel/sched_rt.c:		for_each_cpu(i, rd->span) {
./kernel/sched_rt.c:			cpupri_set(&rq->rd->cpupri, rq->cpu, prio);
./kernel/sched_rt.c:		cpupri_set(&rq->rd->cpupri, rq->cpu, rt_rq->highest_prio.curr);
./kernel/sched_rt.c:	    && cpupri_find(&rq->rd->cpupri, p, NULL))
./kernel/sched_rt.c:	if (!cpupri_find(&rq->rd->cpupri, rq->curr, NULL))
./kernel/sched_rt.c:	if (!cpupri_find(&task_rq(task)->rd->cpupri, task, lowest_mask))
./kernel/sched_rt.c:	for_each_cpu(cpu, this_rq->rd->rto_mask) {
./kernel/sched_rt.c:	cpupri_set(&rq->rd->cpupri, rq->cpu, rq->rt.highest_prio.curr);
./kernel/sched_rt.c:	cpupri_set(&rq->rd->cpupri, rq->cpu, CPUPRI_INVALID);
./kernel/trace/trace.c:	"record-cmd",
./kernel/power/main.c: *	show() returns what states are supported, which is hard-coded to
./kernel/debug/kdb/kdb_main.c:	addr &= ~(bytesperword-1);
./kernel/watchdog.c: * Should we panic when a soft-lockup or hard-lockup occurs:
./kernel/watchdog.c: * Hard-lockup warnings should be triggered after just a few seconds. Soft-
./kernel/sched.c:		cpumask_set_cpu(rq->cpu, rq->rd->online);
./kernel/sched.c:		cpumask_clear_cpu(rq->cpu, rq->rd->online);
./kernel/sched.c:			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
./kernel/sched.c:			BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
./kernel/sched.c:	cpupri_cleanup(&rd->cpupri);
./kernel/sched.c:	free_cpumask_var(rd->rto_mask);
./kernel/sched.c:	free_cpumask_var(rd->online);
./kernel/sched.c:	free_cpumask_var(rd->span);
./kernel/sched.c:		if (cpumask_test_cpu(rq->cpu, old_rd->online))
./kernel/sched.c:		cpumask_clear_cpu(rq->cpu, old_rd->span);
./kernel/sched.c:		if (!atomic_dec_and_test(&old_rd->refcount))
./kernel/sched.c:	atomic_inc(&rd->refcount);
./kernel/sched.c:	cpumask_set_cpu(rq->cpu, rd->span);
./kernel/sched.c:		call_rcu_sched(&old_rd->rcu, free_rootdomain);
./kernel/sched.c:	if (!alloc_cpumask_var(&rd->span, GFP_KERNEL))
./kernel/sched.c:	if (!alloc_cpumask_var(&rd->online, GFP_KERNEL))
./kernel/sched.c:	if (!alloc_cpumask_var(&rd->rto_mask, GFP_KERNEL))
./kernel/sched.c:	if (cpupri_init(&rd->cpupri) != 0)
./kernel/sched.c:	free_cpumask_var(rd->rto_mask);
./kernel/sched.c:	free_cpumask_var(rd->online);
./kernel/sched.c:	free_cpumask_var(rd->span);
./kernel/sched.c:		if (!atomic_read(&d->rd->refcount))
./kernel/sched.c:			free_rootdomain(&d->rd->rcu); /* fall through */
./samples/kfifo/record-example.c:#define	PROC_FIFO	"record-fifo"
./drivers/pnp/isapnp/proc.c:	isapnp_cfg_begin(dev->card->number, dev->number);
./drivers/pnp/isapnp/compat.c:		if (compare_pnp_id(card->id, id) || (memcmp(id, any, 7) == 0))
./drivers/pnp/isapnp/compat.c:		list = card->devices.next;
./drivers/pnp/isapnp/compat.c:		while (list != &card->devices) {
./drivers/pnp/isapnp/core.c:				"ignored\n", type, card->number);
./drivers/pnp/isapnp/core.c:			card->pnpver = tmp[0];
./drivers/pnp/isapnp/core.c:			card->productver = tmp[1];
./drivers/pnp/isapnp/core.c:			isapnp_parse_name(card->name, sizeof(card->name),
./drivers/pnp/isapnp/core.c:			dev_err(&card->dev, "unknown tag %#x, ignored\n",
./drivers/pnp/isapnp/core.c:		dev_info(&card->dev,
./drivers/pnp/isapnp/core.c:		dev_info(&card->dev, "checksum = %#x\n", checksum);
./drivers/pnp/isapnp/core.c:		INIT_LIST_HEAD(&card->devices);
./drivers/pnp/isapnp/core.c:		card->serial =
./drivers/pnp/isapnp/core.c:			dev_err(&card->dev, "invalid checksum %#x\n",
./drivers/pnp/isapnp/core.c:		card->checksum = isapnp_checksum_value;
./drivers/pnp/isapnp/core.c:		if (card->protocol == &isapnp_protocol)
./drivers/pnp/isapnp/core.c:	isapnp_cfg_begin(dev->card->number, dev->number);
./drivers/pnp/isapnp/core.c:	isapnp_cfg_begin(dev->card->number, dev->number);
./drivers/pnp/isapnp/core.c:	isapnp_cfg_begin(dev->card->number, dev->number);
./drivers/pnp/isapnp/core.c:			dev_info(&card->dev, "card '%s'\n",
./drivers/pnp/isapnp/core.c:			       card->name[0] ? card->name : "unknown");
./drivers/pnp/isapnp/core.c:				dev_info(&card->dev, "device '%s'\n",
./drivers/pnp/interface.c:		pnp_printf(buffer, " word-count");
./drivers/pnp/card.c:		if (compare_pnp_id(card->id, drv_id->id)) {
./drivers/pnp/card.c:	ptr = card->id;
./drivers/pnp/card.c:		card->id = dev_id;
./drivers/pnp/card.c:	id = card->id;
./drivers/pnp/card.c:	card->protocol = protocol;
./drivers/pnp/card.c:	card->number = id;
./drivers/pnp/card.c:	card->dev.parent = &card->protocol->dev;
./drivers/pnp/card.c:	dev_set_name(&card->dev, "%02x:%02x", card->protocol->number, card->number);
./drivers/pnp/card.c:	card->dev.coherent_dma_mask = DMA_BIT_MASK(24);
./drivers/pnp/card.c:	card->dev.dma_mask = &card->dev.coherent_dma_mask;
./drivers/pnp/card.c:	str += sprintf(str, "%s\n", card->name);
./drivers/pnp/card.c:	struct pnp_id *pos = card->id;
./drivers/pnp/card.c:	int rc = device_create_file(&card->dev, &dev_attr_name);
./drivers/pnp/card.c:	rc = device_create_file(&card->dev, &dev_attr_card_id);
./drivers/pnp/card.c:	device_remove_file(&card->dev, &dev_attr_name);
./drivers/pnp/card.c:	card->dev.bus = NULL;
./drivers/pnp/card.c:	card->dev.release = &pnp_release_card;
./drivers/pnp/card.c:	error = device_register(&card->dev);
./drivers/pnp/card.c:		dev_err(&card->dev, "could not register (err=%d)\n", error);
./drivers/pnp/card.c:	list_add_tail(&card->global_list, &pnp_cards);
./drivers/pnp/card.c:	list_add_tail(&card->protocol_list, &card->protocol->cards);
./drivers/pnp/card.c:	list_for_each(pos, &card->devices) {
./drivers/pnp/card.c:	device_unregister(&card->dev);
./drivers/pnp/card.c:	list_del(&card->global_list);
./drivers/pnp/card.c:	list_del(&card->protocol_list);
./drivers/pnp/card.c:	list_for_each_safe(pos, temp, &card->devices) {
./drivers/pnp/card.c:	dev->dev.parent = &card->dev;
./drivers/pnp/card.c:		     dev->protocol->number, card->number, dev->number);
./drivers/pnp/card.c:	list_add_tail(&dev->card_list, &card->devices);
./drivers/pnp/card.c:		pos = card->devices.next;
./drivers/pnp/card.c:	while (pos != &card->devices) {
./drivers/memstick/core/mspro_block.c:	*mrq = &card->current_mrq;
./drivers/memstick/core/mspro_block.c:	card->next_request = msb->mrq_handler;
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "wait for ced: value %x\n", (*mrq)->data[0]);
./drivers/memstick/core/mspro_block.c:			card->next_request = h_mspro_block_default;
./drivers/memstick/core/mspro_block.c:					card->next_request
./drivers/memstick/core/mspro_block.c:	card->next_request = h_mspro_block_req_init;
./drivers/memstick/core/mspro_block.c:	memstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG,
./drivers/memstick/core/mspro_block.c:		memstick_new_req(card->host);
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "blk_fetch\n");
./drivers/memstick/core/mspro_block.c:		dev_dbg(&card->dev, "issue end\n");
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "trying again\n");
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "complete %d, %d\n", msb->has_request ? 1 : 0,
./drivers/memstick/core/mspro_block.c:		if (error || (card->current_mrq.tpc == MSPRO_CMD_STOP)) {
./drivers/memstick/core/mspro_block.c:		dev_dbg(&card->dev, "transferred %x (%d)\n", t_len, error);
./drivers/memstick/core/mspro_block.c:	card->next_request = h_mspro_block_default_bad;
./drivers/memstick/core/mspro_block.c:	complete_all(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:		wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:	card->next_request = h_mspro_block_req_init;
./drivers/memstick/core/mspro_block.c:	memstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);
./drivers/memstick/core/mspro_block.c:	memstick_new_req(card->host);
./drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:	return card->current_mrq.error;
./drivers/memstick/core/mspro_block.c:	struct memstick_host *host = card->host;
./drivers/memstick/core/mspro_block.c:	card->next_request = h_mspro_block_req_init;
./drivers/memstick/core/mspro_block.c:	memstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG, &param,
./drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:	return card->current_mrq.error;
./drivers/memstick/core/mspro_block.c:	struct memstick_host *host = card->host;
./drivers/memstick/core/mspro_block.c:		       dev_name(&card->dev), rc);
./drivers/memstick/core/mspro_block.c:	       dev_name(&card->dev));
./drivers/memstick/core/mspro_block.c:			       dev_name(&card->dev));
./drivers/memstick/core/mspro_block.c:			       dev_name(&card->dev), rc);
./drivers/memstick/core/mspro_block.c:	card->next_request = h_mspro_block_req_init;
./drivers/memstick/core/mspro_block.c:	memstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);
./drivers/memstick/core/mspro_block.c:	memstick_new_req(card->host);
./drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:	rc = card->current_mrq.error;
./drivers/memstick/core/mspro_block.c:		       dev_name(&card->dev));
./drivers/memstick/core/mspro_block.c:	memstick_new_req(card->host);
./drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:	if (card->current_mrq.error) {
./drivers/memstick/core/mspro_block.c:		rc = card->current_mrq.error;
./drivers/memstick/core/mspro_block.c:		       dev_name(&card->dev), be16_to_cpu(attr->signature));
./drivers/memstick/core/mspro_block.c:		       dev_name(&card->dev));
./drivers/memstick/core/mspro_block.c:		dev_dbg(&card->dev, "adding attribute %d: id %x, address %x, "
./drivers/memstick/core/mspro_block.c:		dev_dbg(&card->dev, "reading attribute range %x, %x\n",
./drivers/memstick/core/mspro_block.c:		memstick_new_req(card->host);
./drivers/memstick/core/mspro_block.c:		wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:		if (card->current_mrq.error) {
./drivers/memstick/core/mspro_block.c:			rc = card->current_mrq.error;
./drivers/memstick/core/mspro_block.c:	struct memstick_host *host = card->host;
./drivers/memstick/core/mspro_block.c:	card->reg_addr.r_offset = offsetof(struct mspro_register, status);
./drivers/memstick/core/mspro_block.c:	card->reg_addr.r_length = sizeof(struct ms_status_register);
./drivers/memstick/core/mspro_block.c:	card->reg_addr.w_offset = offsetof(struct mspro_register, param);
./drivers/memstick/core/mspro_block.c:	card->reg_addr.w_length = sizeof(struct mspro_param_register);
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "card activated\n");
./drivers/memstick/core/mspro_block.c:	card->next_request = h_mspro_block_req_init;
./drivers/memstick/core/mspro_block.c:	memstick_init_req(&card->current_mrq, MS_TPC_READ_REG, NULL,
./drivers/memstick/core/mspro_block.c:	memstick_new_req(card->host);
./drivers/memstick/core/mspro_block.c:	wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/mspro_block.c:	if (card->current_mrq.error)
./drivers/memstick/core/mspro_block.c:		return card->current_mrq.error;
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "card r/w status %d\n", msb->read_only ? 0 : 1);
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "attributes loaded\n");
./drivers/memstick/core/mspro_block.c:	struct memstick_host *host = card->host;
./drivers/memstick/core/mspro_block.c:	msb->disk->driverfs_dev = &card->dev;
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "capacity set %ld\n", capacity);
./drivers/memstick/core/mspro_block.c:	rc = sysfs_create_group(&card->dev.kobj, &msb->attr_group);
./drivers/memstick/core/mspro_block.c:		card->check = mspro_block_check_card;
./drivers/memstick/core/mspro_block.c:		card->stop = mspro_block_stop;
./drivers/memstick/core/mspro_block.c:		card->start = mspro_block_start;
./drivers/memstick/core/mspro_block.c:	sysfs_remove_group(&card->dev.kobj, &msb->attr_group);
./drivers/memstick/core/mspro_block.c:	dev_dbg(&card->dev, "mspro block remove\n");
./drivers/memstick/core/mspro_block.c:	sysfs_remove_group(&card->dev.kobj, &msb->attr_group);
./drivers/memstick/core/mspro_block.c:	struct memstick_host *host = card->host;
./drivers/memstick/core/memstick.c:		if ((id->type == card->id.type)
./drivers/memstick/core/memstick.c:		    && (id->category == card->id.category)
./drivers/memstick/core/memstick.c:		    && (id->class == card->id.class))
./drivers/memstick/core/memstick.c:	if (add_uevent_var(env, "MEMSTICK_TYPE=%02X", card->id.type))
./drivers/memstick/core/memstick.c:	if (add_uevent_var(env, "MEMSTICK_CATEGORY=%02X", card->id.category))
./drivers/memstick/core/memstick.c:	if (add_uevent_var(env, "MEMSTICK_CLASS=%02X", card->id.class))
./drivers/memstick/core/memstick.c:		card->dev.driver = NULL;
./drivers/memstick/core/memstick.c:	return sprintf(buf, format, card->id.name);                           \
./drivers/memstick/core/memstick.c:	if (host->card && host->card->next_request)
./drivers/memstick/core/memstick.c:		rc = host->card->next_request(host->card, mrq);
./drivers/memstick/core/memstick.c:		INIT_COMPLETION(host->card->mrq_complete);
./drivers/memstick/core/memstick.c:		memstick_init_req(&card->current_mrq, MS_TPC_READ_REG, NULL,
./drivers/memstick/core/memstick.c:		*mrq = &card->current_mrq;
./drivers/memstick/core/memstick.c:			card->id.match_flags = MEMSTICK_MATCH_ALL;
./drivers/memstick/core/memstick.c:			card->id.type = id_reg.type;
./drivers/memstick/core/memstick.c:			card->id.category = id_reg.category;
./drivers/memstick/core/memstick.c:			card->id.class = id_reg.class;
./drivers/memstick/core/memstick.c:			dev_dbg(&card->dev, "if_mode = %02x\n", id_reg.if_mode);
./drivers/memstick/core/memstick.c:		complete(&card->mrq_complete);
./drivers/memstick/core/memstick.c:		memstick_init_req(&card->current_mrq, MS_TPC_SET_RW_REG_ADRS,
./drivers/memstick/core/memstick.c:				  (char *)&card->reg_addr,
./drivers/memstick/core/memstick.c:				  sizeof(card->reg_addr));
./drivers/memstick/core/memstick.c:		*mrq = &card->current_mrq;
./drivers/memstick/core/memstick.c:		complete(&card->mrq_complete);
./drivers/memstick/core/memstick.c:	card->next_request = h_memstick_set_rw_addr;
./drivers/memstick/core/memstick.c:	memstick_new_req(card->host);
./drivers/memstick/core/memstick.c:	wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/memstick.c:	return card->current_mrq.error;
./drivers/memstick/core/memstick.c:		card->host = host;
./drivers/memstick/core/memstick.c:		dev_set_name(&card->dev, "%s", dev_name(&host->dev));
./drivers/memstick/core/memstick.c:		card->dev.parent = &host->dev;
./drivers/memstick/core/memstick.c:		card->dev.bus = &memstick_bus_type;
./drivers/memstick/core/memstick.c:		card->dev.release = memstick_free_card;
./drivers/memstick/core/memstick.c:		card->check = memstick_dummy_check;
./drivers/memstick/core/memstick.c:		card->reg_addr.r_offset = offsetof(struct ms_register, id);
./drivers/memstick/core/memstick.c:		card->reg_addr.r_length = sizeof(id_reg);
./drivers/memstick/core/memstick.c:		card->reg_addr.w_offset = offsetof(struct ms_register, id);
./drivers/memstick/core/memstick.c:		card->reg_addr.w_length = sizeof(id_reg);
./drivers/memstick/core/memstick.c:		init_completion(&card->mrq_complete);
./drivers/memstick/core/memstick.c:		card->next_request = h_memstick_read_dev_id;
./drivers/memstick/core/memstick.c:		wait_for_completion(&card->mrq_complete);
./drivers/memstick/core/memstick.c:		if (card->current_mrq.error)
./drivers/memstick/core/memstick.c:	} else if (host->card->stop)
./drivers/memstick/core/memstick.c:		host->card->stop(host->card);
./drivers/memstick/core/memstick.c:			device_unregister(&host->card->dev);
./drivers/memstick/core/memstick.c:			card->id.type, card->id.category, card->id.class);
./drivers/memstick/core/memstick.c:			    || !memstick_dev_match(host->card, &card->id)
./drivers/memstick/core/memstick.c:			    || !(host->card->check(host->card))) {
./drivers/memstick/core/memstick.c:				device_unregister(&host->card->dev);
./drivers/memstick/core/memstick.c:			} else if (host->card->start)
./drivers/memstick/core/memstick.c:				host->card->start(host->card);
./drivers/memstick/core/memstick.c:			if (device_register(&card->dev)) {
./drivers/memstick/core/memstick.c:				put_device(&card->dev);
./drivers/memstick/core/memstick.c:		device_unregister(&host->card->dev);
./drivers/firmware/google/memconsole.c:	 * note: signature is not necessarily dword-aligned
./drivers/spi/spi.c: * would make them board-specific.  Similarly with SPI master drivers.
./drivers/spi/spi.c: * Device registration normally goes into like arch/.../mach.../board-YYY.c
./drivers/spi/spi.c: * after board init creates the hard-wired devices.  Some development
./drivers/spi/spi.c: * Board-specific early init code calls this (probably during arch_initcall)
./drivers/spi/spi.c: * not make Linux forget about these hard-wired devices.
./drivers/spi/spi.c: * and board-specific addressing for SPI devices combines those numbers
./drivers/spi/spi_topcliff_pch.c:		if (!board->irq_reg_sts) {
./drivers/spi/spi_topcliff_pch.c:			retval = request_irq(board->pdev->irq, pch_spi_handler,
./drivers/spi/spi_topcliff_pch.c:			board->irq_reg_sts = true;
./drivers/spi/spi_topcliff_pch.c:			pch_spi_reset(board->data->master);
./drivers/spi/spi_topcliff_pch.c:			pch_spi_set_master_mode(board->data->master);
./drivers/spi/spi_topcliff_pch.c:			board->suspend_sts = false;
./drivers/spi/spi_bitbang.c: * FIRST PART (OPTIONAL):  word-at-a-time spi_transfer support.
./drivers/spi/spi_bitbang.c: * Drivers can provide word-at-a-time i/o primitives, or provide
./drivers/spi/spi_bitbang.c:		 * word-at-a-time bitbang code, and presumably chipselect()
./drivers/spi/spi_lm70llp.c:/*---------------------- LM70 LLP eval board-specific inlines follow */
./drivers/rtc/rtc-omap.c: * Board-specific wiring options include using split power mode with
./drivers/parisc/dino.c:**	The different between Built-in Dino and Card-Mode
./drivers/parisc/dino.c:**	Linux drivers can only use Card-Mode Dino if pci devices I/O port
./drivers/parisc/dino.c:	** REVISIT: card-mode PCI-PCI expansion chassis do exist.
./drivers/parisc/dino.c:		panic("Card-Mode Dino: PCI-PCI Bridge not supported\n");
./drivers/parisc/dino.c:	** Program INT_LINE for card-mode devices.
./drivers/parisc/dino.c:	/* Firmware doesn't set up card-mode dino, so we have to */
./drivers/parisc/dino.c:** If so, initialize the chip appropriately (card-mode vs bridge mode).
./drivers/parisc/dino.c: * For card-mode Dino, most machines report an sversion of 9D.  But 715
./drivers/parisc/dino.c:	{ HPHW_A_DMA, HVERSION_REV_ANY_ID, 0x004, 0x0009D },/* Card-mode Dino */
./drivers/parisc/hppb.c:	while(card->next) {
./drivers/parisc/hppb.c:		card = card->next;
./drivers/parisc/hppb.c:	if(card->hpa) {
./drivers/parisc/hppb.c:		card->next = kzalloc(sizeof(struct hppb_card), GFP_KERNEL);
./drivers/parisc/hppb.c:		if(!card->next) {
./drivers/parisc/hppb.c:		card = card->next;
./drivers/parisc/hppb.c:	card->hpa = dev->hpa.start;
./drivers/parisc/hppb.c:	card->mmio_region.name = "HP-PB Bus";
./drivers/parisc/hppb.c:	card->mmio_region.flags = IORESOURCE_MEM;
./drivers/parisc/hppb.c:	card->mmio_region.start = gsc_readl(dev->hpa.start + IO_IO_LOW);
./drivers/parisc/hppb.c:	card->mmio_region.end = gsc_readl(dev->hpa.start + IO_IO_HIGH) - 1;
./drivers/parisc/hppb.c:	status = ccio_request_resource(dev, &card->mmio_region);
./drivers/parisc/hppb.c:			__FILE__, (unsigned long long) card->mmio_region.start,
./drivers/parisc/hppb.c:			(unsigned long long) card->mmio_region.end);
./drivers/gpu/drm/i915/intel_display.c:		/* Force use of hard-coded filter coefficients
./drivers/gpu/drm/radeon/atom.c:	struct radeon_device *rdev = ctx->card->dev->dev_private;
./drivers/gpu/drm/radeon/atom.c:			temp = ctx->card->ioreg_read(ctx->card, CU16(base + 1));
./drivers/gpu/drm/radeon/atom.c:				(void)ctx->card->ioreg_read(ctx->card, CU16(base + 1));
./drivers/gpu/drm/radeon/atom.c:			ctx->card->ioreg_write(ctx->card, CU16(base + 1), temp);
./drivers/gpu/drm/radeon/atom.c:			val = gctx->card->reg_read(gctx->card, idx);
./drivers/gpu/drm/radeon/atom.c:		val = gctx->card->pll_read(gctx->card, idx);
./drivers/gpu/drm/radeon/atom.c:		val = gctx->card->mc_read(gctx->card, idx);
./drivers/gpu/drm/radeon/atom.c:				gctx->card->reg_write(gctx->card, idx,
./drivers/gpu/drm/radeon/atom.c:				gctx->card->reg_write(gctx->card, idx, val);
./drivers/gpu/drm/radeon/atom.c:		gctx->card->pll_write(gctx->card, idx, val);
./drivers/gpu/drm/radeon/atom.c:		gctx->card->mc_write(gctx->card, idx, val);
./drivers/gpu/drm/radeon/atom.c:	struct radeon_device *rdev = ctx->card->dev->dev_private;
./drivers/gpu/drm/radeon/radeon_atombios.c:							while (record->ucRecordSize > 0 &&
./drivers/gpu/drm/radeon/radeon_atombios.c:							       record->ucRecordType > 0 &&
./drivers/gpu/drm/radeon/radeon_atombios.c:							       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {
./drivers/gpu/drm/radeon/radeon_atombios.c:								switch (record->ucRecordType) {
./drivers/gpu/drm/radeon/radeon_atombios.c:									caps = le16_to_cpu(cap_record->usEncoderCap);
./drivers/gpu/drm/radeon/radeon_atombios.c:									((char *)record + record->ucRecordSize);
./drivers/gpu/drm/radeon/radeon_atombios.c:							while (record->ucRecordSize > 0 &&
./drivers/gpu/drm/radeon/radeon_atombios.c:							       record->ucRecordType > 0 &&
./drivers/gpu/drm/radeon/radeon_atombios.c:							       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {
./drivers/gpu/drm/radeon/radeon_atombios.c:								switch (record->ucRecordType) {
./drivers/gpu/drm/radeon/radeon_atombios.c:										&i2c_record->sucI2cId;
./drivers/gpu/drm/radeon/radeon_atombios.c:									router.i2c_addr = i2c_record->ucI2CAddr >> 1;
./drivers/gpu/drm/radeon/radeon_atombios.c:									((char *)record + record->ucRecordSize);
./drivers/gpu/drm/radeon/radeon_atombios.c:						while (record->ucRecordSize > 0 &&
./drivers/gpu/drm/radeon/radeon_atombios.c:						       record->ucRecordType > 0 &&
./drivers/gpu/drm/radeon/radeon_atombios.c:						       record->ucRecordType <= ATOM_MAX_OBJECT_RECORD_NUMBER) {
./drivers/gpu/drm/radeon/radeon_atombios.c:							switch (record->ucRecordType) {
./drivers/gpu/drm/radeon/radeon_atombios.c:									&i2c_record->sucI2cId;
./drivers/gpu/drm/radeon/radeon_atombios.c:											  hpd_record->ucHPDIntGPIOID);
./drivers/gpu/drm/radeon/radeon_atombios.c:								hpd.plugged_state = hpd_record->ucPlugged_PinState;
./drivers/gpu/drm/radeon/radeon_atombios.c:								 record->
./drivers/gpu/drm/radeon/radeon_atombios.c:					if (fake_edid_record->ucFakeEDIDLength) {
./drivers/gpu/drm/radeon/radeon_atombios.c:							max((int)EDID_LENGTH, (int)fake_edid_record->ucFakeEDIDLength);
./drivers/gpu/drm/radeon/radeon_atombios.c:							memcpy((u8 *)edid, (u8 *)&fake_edid_record->ucFakeEDIDString[0],
./drivers/gpu/drm/radeon/radeon_atombios.c:							       fake_edid_record->ucFakeEDIDLength);
./drivers/gpu/drm/radeon/radeon_atombios.c:					lvds->native_mode.width_mm = panel_res_record->usHSize;
./drivers/gpu/drm/radeon/radeon_atombios.c:					lvds->native_mode.height_mm = panel_res_record->usVSize;
./drivers/gpu/drm/radeon/radeon_cp.c:	 * longer clear the depth buffer with a 3D rectangle.  Hard-code
./drivers/gpu/drm/nouveau/nv04_dfp.c:	 * always hard-wired to a reasonable configuration using straps,
./drivers/gpu/pvr/mm.c:    psRecord->eAllocType = eAllocType;
./drivers/gpu/pvr/mm.c:    psRecord->pvKey = pvKey;
./drivers/gpu/pvr/mm.c:    psRecord->pvCpuVAddr = pvCpuVAddr;
./drivers/gpu/pvr/mm.c:    psRecord->ulCpuPAddr = ulCpuPAddr;
./drivers/gpu/pvr/mm.c:    psRecord->pvPrivateData = pvPrivateData;
./drivers/gpu/pvr/mm.c:    psRecord->pid = OSGetCurrentProcessIDKM();
./drivers/gpu/pvr/mm.c:    psRecord->ui32Bytes = ui32Bytes;
./drivers/gpu/pvr/mm.c:    psRecord->pszFileName = pszFileName;
./drivers/gpu/pvr/mm.c:    psRecord->ui32Line = ui32Line;
./drivers/gpu/pvr/mm.c:	if (psCurrentRecord->eAllocType == eAllocType
./drivers/gpu/pvr/mm.c:		&& psCurrentRecord->pvKey == pvKey)
./drivers/gpu/pvr/mm.c:		eAllocType = psCurrentRecord->eAllocType;
./drivers/gpu/pvr/mm.c:		g_WaterMarkData[eAllocType] -= psCurrentRecord->ui32Bytes;
./drivers/gpu/pvr/mm.c:			g_SysRAMWaterMark -= psCurrentRecord->ui32Bytes;
./drivers/gpu/pvr/mm.c:			g_IOMemWaterMark -= psCurrentRecord->ui32Bytes;
./drivers/gpu/pvr/mm.c:        DebugLinuxMemAreaRecordAdd(psLinuxMemArea, psParentRecord->ui32Flags);
./drivers/gpu/pvr/mm.c:        psNewRecord->psLinuxMemArea = psLinuxMemArea;
./drivers/gpu/pvr/mm.c:        psNewRecord->ui32Flags = ui32Flags;
./drivers/gpu/pvr/mm.c:        psNewRecord->pid = OSGetCurrentProcessIDKM();
./drivers/gpu/pvr/mm.c:	if (psCurrentRecord->psLinuxMemArea == psLinuxMemArea)
./drivers/gpu/pvr/mm.c:                       psRecord->psLinuxMemArea,
./drivers/gpu/pvr/mm.c:                       LinuxMemAreaTypeToString(psRecord->psLinuxMemArea->eAreaType),
./drivers/gpu/pvr/mm.c:                       LinuxMemAreaToCpuVAddr(psRecord->psLinuxMemArea),
./drivers/gpu/pvr/mm.c:                       LinuxMemAreaToCpuPAddr(psRecord->psLinuxMemArea,0).uiAddr,
./drivers/gpu/pvr/mm.c:                       psRecord->psLinuxMemArea->ui32ByteSize,
./drivers/gpu/pvr/mm.c:                       psRecord->pid,
./drivers/gpu/pvr/mm.c:                       psRecord->ui32Flags,
./drivers/gpu/pvr/mm.c:                       HAPFlagsToString(psRecord->ui32Flags)
./drivers/gpu/pvr/mm.c:    if (psRecord->eAllocType != DEBUG_MEM_ALLOC_TYPE_KMEM_CACHE)
./drivers/gpu/pvr/mm.c:                           DebugMemAllocRecordTypeToString(psRecord->eAllocType),
./drivers/gpu/pvr/mm.c:                           psRecord->pvCpuVAddr,
./drivers/gpu/pvr/mm.c:                           psRecord->ulCpuPAddr,
./drivers/gpu/pvr/mm.c:                           psRecord->ui32Bytes,
./drivers/gpu/pvr/mm.c:                           psRecord->pid,
./drivers/gpu/pvr/mm.c:                           psRecord->pszFileName,
./drivers/gpu/pvr/mm.c:                           psRecord->ui32Line);
./drivers/gpu/pvr/mm.c:                           DebugMemAllocRecordTypeToString(psRecord->eAllocType),
./drivers/gpu/pvr/mm.c:                           psRecord->pvCpuVAddr,
./drivers/gpu/pvr/mm.c:                           psRecord->ulCpuPAddr,
./drivers/gpu/pvr/mm.c:                           psRecord->ui32Bytes,
./drivers/gpu/pvr/mm.c:                           psRecord->pid,
./drivers/gpu/pvr/mm.c:                           KMemCacheNameWrapper(psRecord->pvPrivateData),
./drivers/gpu/pvr/mm.c:                           psRecord->pszFileName,
./drivers/gpu/pvr/mm.c:                           psRecord->ui32Line);
./drivers/gpu/pvr/mm.c:	psLinuxMemArea = psCurrentRecord->psLinuxMemArea;
./drivers/gpu/pvr/mm.c:				psCurrentRecord->psLinuxMemArea,
./drivers/gpu/pvr/mm.c:				LinuxMemAreaTypeToString(psCurrentRecord->psLinuxMemArea->eAreaType),
./drivers/gpu/pvr/mm.c:				psCurrentRecord->psLinuxMemArea->ui32ByteSize));
./drivers/gpu/pvr/mm.c:			DebugMemAllocRecordTypeToString(psCurrentRecord->eAllocType),
./drivers/gpu/pvr/mm.c:			psCurrentRecord->pvCpuVAddr,
./drivers/gpu/pvr/mm.c:			psCurrentRecord->ulCpuPAddr,
./drivers/gpu/pvr/mm.c:			psCurrentRecord->pszFileName,
./drivers/gpu/pvr/mm.c:			psCurrentRecord->ui32Line));
./drivers/gpu/pvr/mm.c:	switch (psCurrentRecord->eAllocType)
./drivers/gpu/pvr/mm.c:			KFreeWrapper(psCurrentRecord->pvCpuVAddr);
./drivers/gpu/pvr/mm.c:			IOUnmapWrapper(psCurrentRecord->pvCpuVAddr);
./drivers/gpu/pvr/mm.c:			DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_IO, psCurrentRecord->pvKey, __FILE__, __LINE__);
./drivers/gpu/pvr/mm.c:			VFreeWrapper(psCurrentRecord->pvCpuVAddr);
./drivers/gpu/pvr/mm.c:			DebugMemAllocRecordRemove(DEBUG_MEM_ALLOC_TYPE_ALLOC_PAGES, psCurrentRecord->pvKey, __FILE__, __LINE__);
./drivers/gpu/pvr/mm.c:			KMemCacheFreeWrapper(psCurrentRecord->pvPrivateData, psCurrentRecord->pvCpuVAddr);
./drivers/gpu/pvr/mm.c:			VUnmapWrapper(psCurrentRecord->pvCpuVAddr);
./drivers/base/power/clock_ops.c:	mutex_lock(&prd->lock);
./drivers/base/power/clock_ops.c:	list_add_tail(&ce->node, &prd->clock_list);
./drivers/base/power/clock_ops.c:	mutex_unlock(&prd->lock);
./drivers/base/power/clock_ops.c:	mutex_lock(&prd->lock);
./drivers/base/power/clock_ops.c:	list_for_each_entry(ce, &prd->clock_list, node) {
./drivers/base/power/clock_ops.c:	mutex_unlock(&prd->lock);
./drivers/base/power/clock_ops.c:	INIT_LIST_HEAD(&prd->clock_list);
./drivers/base/power/clock_ops.c:	mutex_init(&prd->lock);
./drivers/base/power/clock_ops.c:	mutex_lock(&prd->lock);
./drivers/base/power/clock_ops.c:	list_for_each_entry_safe_reverse(ce, c, &prd->clock_list, node)
./drivers/base/power/clock_ops.c:	mutex_unlock(&prd->lock);
./drivers/base/power/clock_ops.c:	mutex_lock(&prd->lock);
./drivers/base/power/clock_ops.c:	list_for_each_entry_reverse(ce, &prd->clock_list, node) {
./drivers/base/power/clock_ops.c:	mutex_unlock(&prd->lock);
./drivers/base/power/clock_ops.c:	mutex_lock(&prd->lock);
./drivers/base/power/clock_ops.c:	list_for_each_entry(ce, &prd->clock_list, node) {
./drivers/base/power/clock_ops.c:	mutex_unlock(&prd->lock);
./drivers/mtd/maps/vmu-flash.c:	if (src_ofs >= card->parts[partition].numblocks * card->blocklen)
./drivers/mtd/maps/vmu-flash.c:	num = src_ofs / card->blocklen;
./drivers/mtd/maps/vmu-flash.c:	if (num > card->parts[partition].numblocks)
./drivers/mtd/maps/vmu-flash.c:	vblock->ofs = src_ofs % card->blocklen;
./drivers/mtd/maps/vmu-flash.c:	if (unlikely(!card->blockread))
./drivers/mtd/maps/vmu-flash.c:	memcpy(card->blockread, mq->recvbuf->buf + 12,
./drivers/mtd/maps/vmu-flash.c:		card->blocklen/card->readcnt);
./drivers/mtd/maps/vmu-flash.c:	pcache = card->parts[partition].pcache;
./drivers/mtd/maps/vmu-flash.c:		pcache->buffer = kmalloc(card->blocklen, GFP_KERNEL);
./drivers/mtd/maps/vmu-flash.c:	for (x = 0; x < card->readcnt; x++) {
./drivers/mtd/maps/vmu-flash.c:		blockread = kmalloc(card->blocklen/card->readcnt, GFP_KERNEL);
./drivers/mtd/maps/vmu-flash.c:		card->blockread = blockread;
./drivers/mtd/maps/vmu-flash.c:			card->blockread = NULL;
./drivers/mtd/maps/vmu-flash.c:			card->blockread = NULL;
./drivers/mtd/maps/vmu-flash.c:		memcpy(buf + (card->blocklen/card->readcnt) * x, blockread,
./drivers/mtd/maps/vmu-flash.c:			card->blocklen/card->readcnt);
./drivers/mtd/maps/vmu-flash.c:		memcpy(pcache->buffer + (card->blocklen/card->readcnt) * x,
./drivers/mtd/maps/vmu-flash.c:			card->blockread, card->blocklen/card->readcnt);
./drivers/mtd/maps/vmu-flash.c:		card->blockread = NULL;
./drivers/mtd/maps/vmu-flash.c:	phaselen = card->blocklen/card->writecnt;
./drivers/mtd/maps/vmu-flash.c:	for (x = 0; x < card->writecnt; x++) {
./drivers/mtd/maps/vmu-flash.c:	return card->blocklen;
./drivers/mtd/maps/vmu-flash.c:	buf = kmalloc(card->blocklen, GFP_KERNEL);
./drivers/mtd/maps/vmu-flash.c:	numblocks = card->parts[partition].numblocks;
./drivers/mtd/maps/vmu-flash.c:	if (from + len > numblocks * card->blocklen)
./drivers/mtd/maps/vmu-flash.c:		len = numblocks * card->blocklen - from;
./drivers/mtd/maps/vmu-flash.c:	pcache = card->parts[partition].pcache;
./drivers/mtd/maps/vmu-flash.c:			leftover = card->blocklen - vblock->ofs;
./drivers/mtd/maps/vmu-flash.c:			if (vblock->ofs + len - index < card->blocklen) {
./drivers/mtd/maps/vmu-flash.c:	numblocks = card->parts[partition].numblocks;
./drivers/mtd/maps/vmu-flash.c:	if (to + len > numblocks * card->blocklen)
./drivers/mtd/maps/vmu-flash.c:		len = numblocks * card->blocklen - to;
./drivers/mtd/maps/vmu-flash.c:	buffer = kmalloc(card->blocklen, GFP_KERNEL);
./drivers/mtd/maps/vmu-flash.c:		} while (vblock->ofs < card->blocklen);
./drivers/mtd/maps/vmu-flash.c:		pcache = card->parts[partition].pcache;
./drivers/mtd/maps/vmu-flash.c:		if (error != card->blocklen)
./drivers/mtd/maps/vmu-flash.c:	card->tempA = res[12];
./drivers/mtd/maps/vmu-flash.c:	card->tempB = res[6];
./drivers/mtd/maps/vmu-flash.c:		"blocks with a root block at %d\n", card->partition,
./drivers/mtd/maps/vmu-flash.c:		card->tempA, card->tempB);
./drivers/mtd/maps/vmu-flash.c:	part_cur = &card->parts[card->partition];
./drivers/mtd/maps/vmu-flash.c:	part_cur->user_blocks = card->tempA;
./drivers/mtd/maps/vmu-flash.c:	part_cur->root_block = card->tempB;
./drivers/mtd/maps/vmu-flash.c:	part_cur->numblocks = card->tempB + 1;
./drivers/mtd/maps/vmu-flash.c:		mdev->port, mdev->unit, card->partition);
./drivers/mtd/maps/vmu-flash.c:	mtd_cur = &card->mtd[card->partition];
./drivers/mtd/maps/vmu-flash.c:	mtd_cur->size = part_cur->numblocks * card->blocklen;
./drivers/mtd/maps/vmu-flash.c:	mtd_cur->erasesize = card->blocklen;
./drivers/mtd/maps/vmu-flash.c:	mtd_cur->writesize = card->blocklen;
./drivers/mtd/maps/vmu-flash.c:	mpart->partition = card->partition;
./drivers/mtd/maps/vmu-flash.c:	if (++card->partition < card->partitions) {
./drivers/mtd/maps/vmu-flash.c:		partnum = cpu_to_be32(card->partition << 24);
./drivers/mtd/maps/vmu-flash.c:	for (error = 0; error <= card->partition; error++) {
./drivers/mtd/maps/vmu-flash.c:		kfree(((card->parts)[error]).pcache);
./drivers/mtd/maps/vmu-flash.c:		((card->parts)[error]).pcache = NULL;
./drivers/mtd/maps/vmu-flash.c:	for (error = 0; error <= card->partition; error++) {
./drivers/mtd/maps/vmu-flash.c:		kfree(((card->mtd)[error]).priv);
./drivers/mtd/maps/vmu-flash.c:		((card->mtd)[error]).priv = NULL;
./drivers/mtd/maps/vmu-flash.c:	card->partitions = (basic_flash_data >> 24 & 0xFF) + 1;
./drivers/mtd/maps/vmu-flash.c:	card->blocklen = ((basic_flash_data >> 16 & 0xFF) + 1) << 5;
./drivers/mtd/maps/vmu-flash.c:	card->writecnt = basic_flash_data >> 12 & 0xF;
./drivers/mtd/maps/vmu-flash.c:	card->readcnt = basic_flash_data >> 8 & 0xF;
./drivers/mtd/maps/vmu-flash.c:	card->removeable = basic_flash_data >> 7 & 1;
./drivers/mtd/maps/vmu-flash.c:	card->partition = 0;
./drivers/mtd/maps/vmu-flash.c:	card->parts = kmalloc(sizeof(struct vmupart) * card->partitions,
./drivers/mtd/maps/vmu-flash.c:	if (!card->parts) {
./drivers/mtd/maps/vmu-flash.c:	card->mtd = kmalloc(sizeof(struct mtd_info) * card->partitions,
./drivers/mtd/maps/vmu-flash.c:	if (!card->mtd) {
./drivers/mtd/maps/vmu-flash.c:	kfree(card->mtd);
./drivers/mtd/maps/vmu-flash.c:	kfree(card->parts);
./drivers/mtd/maps/vmu-flash.c:	for (x = 0; x < card->partitions; x++) {
./drivers/mtd/maps/vmu-flash.c:		mpart = ((card->mtd)[x]).priv;
./drivers/mtd/maps/vmu-flash.c:		mtd_device_unregister(&((card->mtd)[x]));
./drivers/mtd/maps/vmu-flash.c:		kfree(((card->parts)[x]).name);
./drivers/mtd/maps/vmu-flash.c:	kfree(card->parts);
./drivers/mtd/maps/vmu-flash.c:	kfree(card->mtd);
./drivers/mtd/maps/vmu-flash.c:	for (x = 0; x < card->partitions; x++) {
./drivers/mtd/maps/vmu-flash.c:		mtd = &((card->mtd)[x]);
./drivers/mtd/maps/ixp4xx.c: * platform level code in arch/arm/mach-ixp4xx/board-setup.c
./drivers/mtd/maps/bfin-async-flash.c: * for example.  All board-specific configuration goes in your
./drivers/mtd/nand/atmel_nand.c:	if (host->board->enable_pin)
./drivers/mtd/nand/atmel_nand.c:		gpio_set_value(host->board->enable_pin, 0);
./drivers/mtd/nand/atmel_nand.c:	if (host->board->enable_pin)
./drivers/mtd/nand/atmel_nand.c:		gpio_set_value(host->board->enable_pin, 1);
./drivers/mtd/nand/atmel_nand.c:		writeb(cmd, host->io_base + (1 << host->board->cle));
./drivers/mtd/nand/atmel_nand.c:		writeb(cmd, host->io_base + (1 << host->board->ale));
./drivers/mtd/nand/atmel_nand.c:	return gpio_get_value(host->board->rdy_pin) ^
./drivers/mtd/nand/atmel_nand.c:                !!host->board->rdy_pin_active_low;
./drivers/mtd/nand/atmel_nand.c:	if (host->board->bus_width_16)
./drivers/mtd/nand/atmel_nand.c:	if (host->board->bus_width_16)
./drivers/mtd/nand/atmel_nand.c:	if (host->board->rdy_pin)
./drivers/mtd/nand/atmel_nand.c:	if (host->board->bus_width_16)	/* 16-bit bus width */
./drivers/mtd/nand/atmel_nand.c:	if (host->board->det_pin) {
./drivers/mtd/nand/atmel_nand.c:		if (gpio_get_value(host->board->det_pin)) {
./drivers/mtd/nand/atmel_nand.c:	if (num_partitions <= 0 && host->board->partition_info)
./drivers/mtd/nand/atmel_nand.c:		partitions = host->board->partition_info(mtd->size,
./drivers/mtd/nand/alauda.c:	for (card = alauda_card_ids; card->id; card++)
./drivers/mtd/nand/alauda.c:		if (card->id == id)
./drivers/mtd/nand/alauda.c:	u32 pba = from >> al->card->blockshift;
./drivers/mtd/nand/alauda.c:	u32 page = (from >> al->card->pageshift) & al->pagemask;
./drivers/mtd/nand/alauda.c:	u32 pba = to >> al->card->blockshift;
./drivers/mtd/nand/alauda.c:	u32 page = (to >> al->card->pageshift) & al->pagemask;
./drivers/mtd/nand/alauda.c:	u32 pba = ofs >> al->card->blockshift;
./drivers/mtd/nand/alauda.c:		u32 page = (to >> al->card->pageshift) & al->pagemask;
./drivers/mtd/nand/alauda.c:			1<<card->pageshift, 1<<card->blockshift,
./drivers/mtd/nand/alauda.c:			1<<(card->chipshift-20));
./drivers/mtd/nand/alauda.c:	al->pagemask = (1 << (card->blockshift - card->pageshift)) - 1;
./drivers/mtd/nand/alauda.c:	al->bytemask = (1 << card->pageshift) - 1;
./drivers/mtd/nand/alauda.c:	al->blockmask = (1 << card->blockshift) - 1;
./drivers/mtd/nand/alauda.c:	mtd->size = 1<<card->chipshift;
./drivers/mtd/nand/alauda.c:	mtd->erasesize = 1<<card->blockshift;
./drivers/mtd/nand/alauda.c:	mtd->writesize = 1<<card->pageshift;
./drivers/mtd/nand/ams-delta.c:#include <plat/board-ams-delta.h>
./drivers/mtd/nand/spia.c:MODULE_DESCRIPTION("Board-specific glue layer for NAND flash on SPIA board");
./drivers/mtd/nand/davinci_nand.c:	/* insist on board-specific configuration */
./drivers/mtd/nand/davinci_nand.c:	/* Use board-specific ECC config */
./drivers/mtd/nand/orion_nand.c:		offs = (1 << board->cle);
./drivers/mtd/nand/orion_nand.c:		offs = (1 << board->ale);
./drivers/mtd/nand/orion_nand.c:	if (board->chip_delay)
./drivers/mtd/nand/orion_nand.c:		nc->chip_delay = board->chip_delay;
./drivers/mtd/nand/orion_nand.c:	if (board->width == 16)
./drivers/mtd/nand/orion_nand.c:	if (board->dev_ready)
./drivers/mtd/nand/orion_nand.c:		nc->dev_ready = board->dev_ready;
./drivers/mtd/nand/orion_nand.c:		num_part = board->nr_parts;
./drivers/mtd/nand/orion_nand.c:		partitions = board->parts;
./drivers/mtd/nand/rtc_from4.c:MODULE_DESCRIPTION("Board-specific glue layer for AG-AND flash on Renesas FROM_BOARD4");
./drivers/mtd/nand/pxa3xx_nand.c:	 * for indexing a word-oriented device
./drivers/mtd/nand/bcm_umi_nand.c:*   This routine does the necessary hardware (board-specific)
./drivers/mtd/nand/au1550nd.c:MODULE_DESCRIPTION("Board-specific glue layer for NAND flash on Pb1550 board");
./drivers/mtd/tests/mtd_pagetest.c:	/* Read 3rd-to-last page to pp1 */
./drivers/char/random.c:	 * We take into account the first, second and third-order deltas
./drivers/char/agp/amd-k7-agp.c:		if (gfxcard->vendor == PCI_VENDOR_ID_NVIDIA) {
./drivers/char/applicom.c:	IndexCard = adgl->num_card-1;
./drivers/video/pm3fb.c:	/* TODO: card-specific stuff, *before* accessing *any* FB memory */
./drivers/video/amba-clcd.c:	if (fb->board->disable)
./drivers/video/amba-clcd.c:		fb->board->disable(fb);
./drivers/video/amba-clcd.c:	if (fb->board->enable)
./drivers/video/amba-clcd.c:		fb->board->enable(fb);
./drivers/video/amba-clcd.c:	if (fb->panel->caps && fb->board->caps)
./drivers/video/amba-clcd.c:		caps = fb->panel->caps & fb->board->caps;
./drivers/video/amba-clcd.c:	if (fb->board->check)
./drivers/video/amba-clcd.c:		ret = fb->board->check(fb, var);
./drivers/video/amba-clcd.c:	fb->board->decode(fb, &regs);
./drivers/video/amba-clcd.c:	    fb->board->mmap)
./drivers/video/amba-clcd.c:		ret = fb->board->mmap(fb, vma);
./drivers/video/amba-clcd.c:	         fb->board->name, fb->panel->mode.name);
./drivers/video/amba-clcd.c:	ret = fb->board->setup(fb);
./drivers/video/amba-clcd.c:	fb->board->remove(fb);
./drivers/video/amba-clcd.c:	fb->board->remove(fb);
./drivers/video/aty/radeon_monitor.c: * models with broken OF probing by hard-coding known EDIDs for some Mac
./drivers/video/pvr2fb.c: * registration. It's expected that the board-specific init code has
./drivers/video/pvr2fb.c: * default from the modedb. For board-specific modelines, simply define
./drivers/video/pvr2fb.c:		if (!pvr_board->init)
./drivers/video/pvr2fb.c:		ret = pvr_board->init();
./drivers/video/pvr2fb.c:				pvr_board->name);
./drivers/video/pvr2fb.c:		if (pvr_board->exit)
./drivers/video/pvr2fb.c:			pvr_board->exit();
./drivers/video/hecubafb.c:	par->board->set_data(par, data);
./drivers/video/hecubafb.c:	par->board->set_ctl(par, HCB_DS_BIT, 0);
./drivers/video/hecubafb.c:	par->board->wait_for_ack(par, 0);
./drivers/video/hecubafb.c:	par->board->set_ctl(par, HCB_DS_BIT, 1);
./drivers/video/hecubafb.c:	par->board->wait_for_ack(par, 1);
./drivers/video/hecubafb.c:	par->board->set_ctl(par, HCB_CD_BIT, 1);
./drivers/video/hecubafb.c:	par->board->set_ctl(par, HCB_CD_BIT, 0);
./drivers/video/hecubafb.c:	if (!try_module_get(board->owner))
./drivers/video/hecubafb.c:	retval = par->board->init(par);
./drivers/video/hecubafb.c:	module_put(board->owner);
./drivers/video/hecubafb.c:		if (par->board->remove)
./drivers/video/hecubafb.c:			par->board->remove(par);
./drivers/video/hecubafb.c:		module_put(par->board->owner);
./drivers/video/omap/lcd_mipid.c:		mipid_write(md, rd->cmd, (u8 *)rd->wbuf, rd->wlen);
./drivers/video/omap/lcd_mipid.c:	mipid_read(md, rd->cmd, rbuf, 2);
./drivers/video/omap/lcd_mipid.c:		mipid_write(md, rd->cmd, (u8 *)rd->wbuf, rd->wlen);
./drivers/video/omap/lcd_ams_delta.c:#include <plat/board-ams-delta.h>
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_WR, 0);
./drivers/video/broadsheetfb.c:	par->board->set_hdb(par, data);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_WR, 1);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_DC, 0);
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 0);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_DC, 1);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 1);
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 0);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_DC, 1);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 1);
./drivers/video/broadsheetfb.c:	par->board->mmio_write(par, BS_MMIO_CMD, cmd);
./drivers/video/broadsheetfb.c:		par->board->mmio_write(par, BS_MMIO_DATA, argv[i]);
./drivers/video/broadsheetfb.c:	if (par->board->mmio_write)
./drivers/video/broadsheetfb.c:		par->board->mmio_write(par, BS_MMIO_CMD, data);
./drivers/video/broadsheetfb.c:	if (par->board->mmio_write)
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 0);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_DC, 1);
./drivers/video/broadsheetfb.c:		par->board->set_ctl(par, BS_WR, 0);
./drivers/video/broadsheetfb.c:		par->board->set_hdb(par, tmp);
./drivers/video/broadsheetfb.c:		par->board->set_ctl(par, BS_WR, 1);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 1);
./drivers/video/broadsheetfb.c:		par->board->mmio_write(par, BS_MMIO_DATA, tmp);
./drivers/video/broadsheetfb.c:	if (par->board->mmio_write)
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_DC, 1);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 0);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_WR, 0);
./drivers/video/broadsheetfb.c:	res = par->board->get_hdb(par);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_WR, 1);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 1);
./drivers/video/broadsheetfb.c:	if (par->board->mmio_read)
./drivers/video/broadsheetfb.c:		return par->board->mmio_read(par);
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 0);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_DC, 1);
./drivers/video/broadsheetfb.c:	par->board->set_ctl(par, BS_CS, 1);
./drivers/video/broadsheetfb.c:	par->board->mmio_write(par, BS_MMIO_CMD, BS_CMD_WR_REG);
./drivers/video/broadsheetfb.c:	par->board->mmio_write(par, BS_MMIO_DATA, reg);
./drivers/video/broadsheetfb.c:	par->board->mmio_write(par, BS_MMIO_DATA, data);
./drivers/video/broadsheetfb.c:	if (par->board->mmio_write)
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	par->board->wait_for_rdy(par);
./drivers/video/broadsheetfb.c:	if (!try_module_get(board->owner))
./drivers/video/broadsheetfb.c:	switch (board->get_panel_type()) {
./drivers/video/broadsheetfb.c:	retval = par->board->setup_irq(info);
./drivers/video/broadsheetfb.c:	retval = board->init(par);
./drivers/video/broadsheetfb.c:	board->cleanup(par);
./drivers/video/broadsheetfb.c:	module_put(board->owner);
./drivers/video/broadsheetfb.c:		par->board->cleanup(par);
./drivers/video/broadsheetfb.c:		module_put(par->board->owner);
./drivers/video/mx3fb.c:	/* This might be board-specific */
./drivers/video/metronomefb.c:	return par->board->met_wait_event_intr(par);
./drivers/video/metronomefb.c:	par->board->set_rst(par, 1);
./drivers/video/metronomefb.c:	par->board->set_stdby(par, 1);
./drivers/video/metronomefb.c:	return par->board->met_wait_event(par);
./drivers/video/metronomefb.c:	return par->board->met_wait_event(par);
./drivers/video/metronomefb.c:	return par->board->met_wait_event(par);
./drivers/video/metronomefb.c:	res = par->board->setup_io(par);
./drivers/video/metronomefb.c:	if (!try_module_get(board->owner))
./drivers/video/metronomefb.c:	panel_type = board->get_panel_type();
./drivers/video/metronomefb.c:	retval = board->setup_fb(par);
./drivers/video/metronomefb.c:	if (board->setup_irq(info))
./drivers/video/metronomefb.c:	board->cleanup(par);
./drivers/video/metronomefb.c:	module_put(board->owner);
./drivers/video/metronomefb.c:		par->board->cleanup(par);
./drivers/video/metronomefb.c:		module_put(par->board->owner);
./drivers/video/cirrusfb.c: * per-board-type information, used for enumerating and abstracting
./drivers/video/au1200fb.c:			 * "bs" for board-switch, or number/index */
./drivers/video/macfb.c:		unsigned long base = ndev->board->slot_addr;
./drivers/video/gxt4500.c:/* Card-specific information */
./drivers/pci/pci-label.c:		if (donboard && donboard->bus == bus &&
./drivers/pci/pci-label.c:					donboard->devfn == devfn) {
./drivers/pci/pci-label.c:							 donboard->instance);
./drivers/pci/quirks.c:	 * are dword-based
./drivers/pci/hotplug/acpi_pcihp.c:	union acpi_object *fields = record->package.elements;
./drivers/pci/hotplug/acpi_pcihp.c:		if (record->package.count != 6)
./drivers/pci/hotplug/acpi_pcihp.c:	union acpi_object *fields = record->package.elements;
./drivers/pci/hotplug/acpi_pcihp.c:		if (record->package.count != 5)
./drivers/pci/hotplug/acpi_pcihp.c:	union acpi_object *fields = record->package.elements;
./drivers/pci/hotplug/acpi_pcihp.c:		if (record->package.count != 18)
./drivers/pci/hotplug/acpi_pcihp.c:		if (record->type != ACPI_TYPE_PACKAGE) {
./drivers/pci/hotplug/acpi_pcihp.c:		fields = record->package.elements;
./drivers/hwmon/gl518sm.c:/* Registers 0x07 to 0x0c are word-sized, others are byte-sized
./drivers/hwmon/lm77.c:	   Word-sized registers are high-byte first. */
./drivers/hwmon/lm77.c:/* All registers are word-sized, except for the configuration register.
./drivers/hwmon/ds620.c: *  Temperature registers are word-sized.
./drivers/hwmon/it87.c:	u8 auto_pwm[3][4];	/* [nr][3] is hard-coded */
./drivers/hwmon/it87.c:		data->auto_pwm[i][3] = 0x7f;	/* Full speed, hard-coded */
./drivers/hwmon/dme1737.c:			res = 1; /* pwm[5-6] hard-wired to manual mode */
./drivers/hwmon/dme1737.c:		res = 255; /* hard-wired */
./drivers/hwmon/jc42.c:/* All registers are word-sized. */
./drivers/hwmon/ds1621.c:/* Temperature registers are word-sized.
./drivers/hwmon/ad7418.c:/* All registers are word-sized, except for the configuration registers.
./drivers/hwmon/lm75.c: * All registers are word-sized, except for the configuration register.
./drivers/hwmon/vt1211.c: * Note that the PWM auto points 0 & 3 are hard-wired in the VT1211 and can't
./drivers/hwmon/vt1211.c: * 0  0  : pwm1 off                   (pwm_auto_pwm[0][0], hard-wired to 0)
./drivers/hwmon/vt1211.c: * 0  3  : pwm1 full speed            (pwm_auto_pwm[0][3], hard-wired to 255)
./drivers/hwmon/vt1211.c: * 1  0  : pwm2 off                   (pwm_auto_pwm[1][0], hard-wired to 0)
./drivers/hwmon/vt1211.c: * 1  3  : pwm2 full speed            (pwm_auto_pwm[1][3], hard-wired to 255)
./drivers/hwmon/gl520sm.c:/* Registers 0x07 to 0x0c are word-sized, others are byte-sized
./drivers/hwmon/vt8231.c:**     for the thermistor curves are board-specific and must go in the
./drivers/block/paride/fit2.c:	3000 portable hard-drives.  As far as I can tell, this device
./drivers/block/paride/ktti.c:        portable hard-drives.  As far as I can tell, this device
./drivers/block/paride/fit3.c:	hard-drives, as well as CD-ROM, PD-CD and other devices.
./drivers/block/umem.c:	led = readb(card->csr_remap + MEMCTRLCMD_LEDCTRL);
./drivers/block/umem.c:	led = readb(card->csr_remap + MEMCTRLCMD_LEDCTRL);
./drivers/block/umem.c:	writeb(led, card->csr_remap + MEMCTRLCMD_LEDCTRL);
./drivers/block/umem.c:	led = readb(card->csr_remap + MEMCTRLCMD_LEDCTRL);
./drivers/block/umem.c:	writeb(led, card->csr_remap + MEMCTRLCMD_LEDCTRL);
./drivers/block/umem.c:	p = card->csr_remap;
./drivers/block/umem.c:	dev_printk(KERN_DEBUG, &card->dev->dev, "DMAstat - ");
./drivers/block/umem.c:	 * no IO active, and we know that card->Active
./drivers/block/umem.c:	page = &card->mm_pages[card->Active];
./drivers/block/umem.c:		card->Active, page->headcnt, page->cnt - 1);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_PCI_ADDR);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_PCI_ADDR + 4);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_LOCAL_ADDR);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_LOCAL_ADDR + 4);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_TRANSFER_SIZE);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_TRANSFER_SIZE + 4);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_SEMAPHORE_ADDR);
./drivers/block/umem.c:	writel(0, card->csr_remap + DMA_SEMAPHORE_ADDR + 4);
./drivers/block/umem.c:	       card->csr_remap + DMA_DESCRIPTOR_ADDR);
./drivers/block/umem.c:	       card->csr_remap + DMA_DESCRIPTOR_ADDR + 4);
./drivers/block/umem.c:	       card->csr_remap + DMA_STATUS_CTRL);
./drivers/block/umem.c:		if (card->Active == -1 &&
./drivers/block/umem.c:		    card->mm_pages[card->Ready].cnt > 0) {
./drivers/block/umem.c:			card->Active = card->Ready;
./drivers/block/umem.c:			card->Ready = 1-card->Ready;
./drivers/block/umem.c:	} while (card->Active == -1 && add_bio(card));
./drivers/block/umem.c:	bio = card->currentbio;
./drivers/block/umem.c:	if (!bio && card->bio) {
./drivers/block/umem.c:		card->currentbio = card->bio;
./drivers/block/umem.c:		card->current_idx = card->bio->bi_idx;
./drivers/block/umem.c:		card->current_sector = card->bio->bi_sector;
./drivers/block/umem.c:		card->bio = card->bio->bi_next;
./drivers/block/umem.c:		if (card->bio == NULL)
./drivers/block/umem.c:			card->biotail = &card->bio;
./drivers/block/umem.c:		card->currentbio->bi_next = NULL;
./drivers/block/umem.c:	idx = card->current_idx;
./drivers/block/umem.c:	if (card->mm_pages[card->Ready].cnt >= DESC_PER_PAGE)
./drivers/block/umem.c:	dma_handle = pci_map_page(card->dev,
./drivers/block/umem.c:	p = &card->mm_pages[card->Ready];
./drivers/block/umem.c:	desc->local_addr = cpu_to_le64(card->current_sector << 9);
./drivers/block/umem.c:	card->current_sector += (len >> 9);
./drivers/block/umem.c:	card->current_idx = idx;
./drivers/block/umem.c:		card->currentbio = NULL;
./drivers/block/umem.c:	unsigned int dma_status = card->dma_status;
./drivers/block/umem.c:	spin_lock_bh(&card->lock);
./drivers/block/umem.c:	if (card->Active < 0)
./drivers/block/umem.c:	page = &card->mm_pages[card->Active];
./drivers/block/umem.c:		pci_unmap_page(card->dev, desc->data_dma_handle,
./drivers/block/umem.c:			dev_printk(KERN_WARNING, &card->dev->dev,
./drivers/block/umem.c:				card->init_size) {
./drivers/block/umem.c:			card->init_size += le32_to_cpu(desc->transfer_size) >> 9;
./drivers/block/umem.c:			if (card->init_size >> 1 >= card->mm_size) {
./drivers/block/umem.c:				dev_printk(KERN_INFO, &card->dev->dev,
./drivers/block/umem.c:	if (card->check_batteries) {
./drivers/block/umem.c:		card->check_batteries = 0;
./drivers/block/umem.c:		card->Active = -1;
./drivers/block/umem.c:	spin_unlock_bh(&card->lock);
./drivers/block/umem.c:	spin_lock_irq(&mmcb->card->lock);
./drivers/block/umem.c:	spin_unlock_irq(&mmcb->card->lock);
./drivers/block/umem.c:	spin_lock_irq(&card->lock);
./drivers/block/umem.c:	*card->biotail = bio;
./drivers/block/umem.c:	card->biotail = &bio->bi_next;
./drivers/block/umem.c:	spin_unlock_irq(&card->lock);
./drivers/block/umem.c:	dma_status = le32_to_cpu(readl(card->csr_remap + DMA_STATUS_CTRL));
./drivers/block/umem.c:	if (card->flags & UM_FLAG_NO_BYTE_STATUS)
./drivers/block/umem.c:		       card->csr_remap + DMA_STATUS_CTRL);
./drivers/block/umem.c:		       card->csr_remap + DMA_STATUS_CTRL + 2);
./drivers/block/umem.c:		stat = readb(card->csr_remap + MEMCTRLCMD_ERRSTATUS);
./drivers/block/umem.c:		data_log1 = le32_to_cpu(readl(card->csr_remap +
./drivers/block/umem.c:		data_log2 = le32_to_cpu(readl(card->csr_remap +
./drivers/block/umem.c:		addr_log1 = le32_to_cpu(readl(card->csr_remap +
./drivers/block/umem.c:		addr_log2 = readb(card->csr_remap + ERROR_ADDR_LOG + 4);
./drivers/block/umem.c:		count = readb(card->csr_remap + ERROR_COUNT);
./drivers/block/umem.c:		syndrome = readb(card->csr_remap + ERROR_SYNDROME);
./drivers/block/umem.c:		check = readb(card->csr_remap + ERROR_CHECK);
./drivers/block/umem.c:			dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:			dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:		writeb(0, card->csr_remap + ERROR_COUNT);
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./drivers/block/umem.c:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./drivers/block/umem.c:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev, "SYSTEM ERROR\n");
./drivers/block/umem.c:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./drivers/block/umem.c:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev, "TARGET ABORT\n");
./drivers/block/umem.c:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./drivers/block/umem.c:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev, "MASTER ABORT\n");
./drivers/block/umem.c:		pci_read_config_word(card->dev, PCI_STATUS, &cfg_status);
./drivers/block/umem.c:		pci_write_config_word(card->dev, PCI_STATUS, cfg_status);
./drivers/block/umem.c:	card->dma_status = dma_status;
./drivers/block/umem.c:	tasklet_schedule(&card->tasklet);
./drivers/block/umem.c:	if (card->battery[0].good && card->battery[1].good)
./drivers/block/umem.c:	else if (card->battery[0].warned || card->battery[1].warned)
./drivers/block/umem.c:	else if (!card->battery[0].good && !card->battery[1].good)
./drivers/block/umem.c:	if (status != card->battery[battery].good) {
./drivers/block/umem.c:		card->battery[battery].good = !card->battery[battery].good;
./drivers/block/umem.c:		card->battery[battery].last_change = jiffies;
./drivers/block/umem.c:		if (card->battery[battery].good) {
./drivers/block/umem.c:			dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:			card->battery[battery].warned = 0;
./drivers/block/umem.c:			dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:	} else if (!card->battery[battery].good &&
./drivers/block/umem.c:		   !card->battery[battery].warned &&
./drivers/block/umem.c:		   time_after_eq(jiffies, card->battery[battery].last_change +
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:		card->battery[battery].warned = 1;
./drivers/block/umem.c:	status = readb(card->csr_remap + MEMCTRLSTATUS_BATTERY);
./drivers/block/umem.c:		dev_printk(KERN_DEBUG, &card->dev->dev,
./drivers/block/umem.c:			spin_lock_bh(&card->lock);
./drivers/block/umem.c:			if (card->Active >= 0)
./drivers/block/umem.c:				card->check_batteries = 1;
./drivers/block/umem.c:			spin_unlock_bh(&card->lock);
./drivers/block/umem.c:	set_capacity(disk, card->mm_size << 1);
./drivers/block/umem.c:	int size = card->mm_size * (1024 / MM_HARDSECT);
./drivers/block/umem.c:	card->dev         = dev;
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:	card->csr_remap = ioremap_nocache(csr_base, csr_len);
./drivers/block/umem.c:	if (!card->csr_remap) {
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:	dev_printk(KERN_INFO, &card->dev->dev,
./drivers/block/umem.c:	       csr_base, card->csr_remap, csr_len);
./drivers/block/umem.c:	switch (card->dev->device) {
./drivers/block/umem.c:		card->flags |= UM_FLAG_NO_BYTE_STATUS | UM_FLAG_NO_BATTREG;
./drivers/block/umem.c:		card->flags |= UM_FLAG_NO_BYTE_STATUS;
./drivers/block/umem.c:		card->flags |= UM_FLAG_NO_BYTE_STATUS |
./drivers/block/umem.c:	if (readb(card->csr_remap + MEMCTRLSTATUS_MAGIC) != magic_number) {
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev, "Magic number invalid\n");
./drivers/block/umem.c:	card->mm_pages[0].desc = pci_alloc_consistent(card->dev,
./drivers/block/umem.c:						&card->mm_pages[0].page_dma);
./drivers/block/umem.c:	card->mm_pages[1].desc = pci_alloc_consistent(card->dev,
./drivers/block/umem.c:						&card->mm_pages[1].page_dma);
./drivers/block/umem.c:	if (card->mm_pages[0].desc == NULL ||
./drivers/block/umem.c:	    card->mm_pages[1].desc == NULL) {
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev, "alloc failed\n");
./drivers/block/umem.c:	reset_page(&card->mm_pages[0]);
./drivers/block/umem.c:	reset_page(&card->mm_pages[1]);
./drivers/block/umem.c:	card->Ready = 0;	/* page 0 is ready */
./drivers/block/umem.c:	card->Active = -1;	/* no page is active */
./drivers/block/umem.c:	card->bio = NULL;
./drivers/block/umem.c:	card->biotail = &card->bio;
./drivers/block/umem.c:	card->queue = blk_alloc_queue(GFP_KERNEL);
./drivers/block/umem.c:	if (!card->queue)
./drivers/block/umem.c:	blk_queue_make_request(card->queue, mm_make_request);
./drivers/block/umem.c:	card->queue->queue_lock = &card->lock;
./drivers/block/umem.c:	card->queue->queuedata = card;
./drivers/block/umem.c:	tasklet_init(&card->tasklet, process_page, (unsigned long)card);
./drivers/block/umem.c:	card->check_batteries = 0;
./drivers/block/umem.c:	mem_present = readb(card->csr_remap + MEMCTRLSTATUS_MEMORY);
./drivers/block/umem.c:		card->mm_size = 1024 * 128;
./drivers/block/umem.c:		card->mm_size = 1024 * 256;
./drivers/block/umem.c:		card->mm_size = 1024 * 512;
./drivers/block/umem.c:		card->mm_size = 1024 * 1024;
./drivers/block/umem.c:		card->mm_size = 1024 * 2048;
./drivers/block/umem.c:		card->mm_size = 0;
./drivers/block/umem.c:	batt_status = readb(card->csr_remap + MEMCTRLSTATUS_BATTERY);
./drivers/block/umem.c:	card->battery[0].good = !(batt_status & BATTERY_1_FAILURE);
./drivers/block/umem.c:	card->battery[1].good = !(batt_status & BATTERY_2_FAILURE);
./drivers/block/umem.c:	card->battery[0].last_change = card->battery[1].last_change = jiffies;
./drivers/block/umem.c:	if (card->flags & UM_FLAG_NO_BATT)
./drivers/block/umem.c:		dev_printk(KERN_INFO, &card->dev->dev,
./drivers/block/umem.c:			"Size %d KB\n", card->mm_size);
./drivers/block/umem.c:		dev_printk(KERN_INFO, &card->dev->dev,
./drivers/block/umem.c:		       card->mm_size,
./drivers/block/umem.c:		       card->battery[0].good ? "OK" : "FAILURE",
./drivers/block/umem.c:		       card->battery[1].good ? "OK" : "FAILURE");
./drivers/block/umem.c:		dev_printk(KERN_ERR, &card->dev->dev,
./drivers/block/umem.c:	dev_printk(KERN_INFO, &card->dev->dev,
./drivers/block/umem.c:	spin_lock_init(&card->lock);
./drivers/block/umem.c:		dev_printk(KERN_INFO, &card->dev->dev,
./drivers/block/umem.c:		card->init_size = 0;
./drivers/block/umem.c:		dev_printk(KERN_INFO, &card->dev->dev,
./drivers/block/umem.c:		card->init_size = card->mm_size;
./drivers/block/umem.c:	writeb(EDC_STORE_CORRECT, card->csr_remap + MEMCTRLCMD_ERRCTRL);
./drivers/block/umem.c:	if (card->mm_pages[0].desc)
./drivers/block/umem.c:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./drivers/block/umem.c:				    card->mm_pages[0].desc,
./drivers/block/umem.c:				    card->mm_pages[0].page_dma);
./drivers/block/umem.c:	if (card->mm_pages[1].desc)
./drivers/block/umem.c:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./drivers/block/umem.c:				    card->mm_pages[1].desc,
./drivers/block/umem.c:				    card->mm_pages[1].page_dma);
./drivers/block/umem.c:	iounmap(card->csr_remap);
./drivers/block/umem.c:	tasklet_kill(&card->tasklet);
./drivers/block/umem.c:	iounmap(card->csr_remap);
./drivers/block/umem.c:	if (card->mm_pages[0].desc)
./drivers/block/umem.c:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./drivers/block/umem.c:				    card->mm_pages[0].desc,
./drivers/block/umem.c:				    card->mm_pages[0].page_dma);
./drivers/block/umem.c:	if (card->mm_pages[1].desc)
./drivers/block/umem.c:		pci_free_consistent(card->dev, PAGE_SIZE*2,
./drivers/block/umem.c:				    card->mm_pages[1].desc,
./drivers/block/umem.c:				    card->mm_pages[1].page_dma);
./drivers/block/umem.c:	blk_cleanup_queue(card->queue);
./drivers/block/brd.c:	page = radix_tree_lookup(&brd->brd_pages, idx);
./drivers/block/brd.c:	spin_lock(&brd->brd_lock);
./drivers/block/brd.c:	if (radix_tree_insert(&brd->brd_pages, idx, page)) {
./drivers/block/brd.c:		page = radix_tree_lookup(&brd->brd_pages, idx);
./drivers/block/brd.c:	spin_unlock(&brd->brd_lock);
./drivers/block/brd.c:	spin_lock(&brd->brd_lock);
./drivers/block/brd.c:	page = radix_tree_delete(&brd->brd_pages, idx);
./drivers/block/brd.c:	spin_unlock(&brd->brd_lock);
./drivers/block/brd.c:		nr_pages = radix_tree_gang_lookup(&brd->brd_pages,
./drivers/block/brd.c:			ret = radix_tree_delete(&brd->brd_pages, pos);
./drivers/block/brd.c:	brd->brd_number		= i;
./drivers/block/brd.c:	spin_lock_init(&brd->brd_lock);
./drivers/block/brd.c:	INIT_RADIX_TREE(&brd->brd_pages, GFP_ATOMIC);
./drivers/block/brd.c:	brd->brd_queue = blk_alloc_queue(GFP_KERNEL);
./drivers/block/brd.c:	if (!brd->brd_queue)
./drivers/block/brd.c:	blk_queue_make_request(brd->brd_queue, brd_make_request);
./drivers/block/brd.c:	blk_queue_max_hw_sectors(brd->brd_queue, 1024);
./drivers/block/brd.c:	blk_queue_bounce_limit(brd->brd_queue, BLK_BOUNCE_ANY);
./drivers/block/brd.c:	brd->brd_queue->limits.discard_granularity = PAGE_SIZE;
./drivers/block/brd.c:	brd->brd_queue->limits.max_discard_sectors = UINT_MAX;
./drivers/block/brd.c:	brd->brd_queue->limits.discard_zeroes_data = 1;
./drivers/block/brd.c:	queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, brd->brd_queue);
./drivers/block/brd.c:	disk = brd->brd_disk = alloc_disk(1 << part_shift);
./drivers/block/brd.c:	disk->queue		= brd->brd_queue;
./drivers/block/brd.c:	blk_cleanup_queue(brd->brd_queue);
./drivers/block/brd.c:	put_disk(brd->brd_disk);
./drivers/block/brd.c:	blk_cleanup_queue(brd->brd_queue);
./drivers/block/brd.c:		if (brd->brd_number == i)
./drivers/block/brd.c:		add_disk(brd->brd_disk);
./drivers/block/brd.c:		list_add_tail(&brd->brd_list, &brd_devices);
./drivers/block/brd.c:	list_del(&brd->brd_list);
./drivers/block/brd.c:	del_gendisk(brd->brd_disk);
./drivers/block/brd.c:	kobj = brd ? get_disk(brd->brd_disk) : ERR_PTR(-ENOMEM);
./drivers/block/brd.c:		list_add_tail(&brd->brd_list, &brd_devices);
./drivers/block/brd.c:		add_disk(brd->brd_disk);
./drivers/block/brd.c:		list_del(&brd->brd_list);
./drivers/block/drbd/drbd_receiver.c:		     "Using discard-least-changes instead\n");
./drivers/block/drbd/drbd_main.c:		if (ord-- == 0) {
./drivers/block/amiflop.c:	unsigned char gap1[22];     /* for longword-alignedness (0x4e) */
./drivers/misc/atmel_pwm.c: * matching board-specific setup code.  Returns zero or negative errno.
./drivers/misc/eeprom/at24.c: * Accordingly, explicit board-specific configuration data should be used
./drivers/misc/eeprom/at24.c: * told what devices exist. That may be in arch/X/mach-Y/board-Z.c or
./drivers/misc/eeprom/at24.c: * might hold a board's Ethernet address, or board-specific calibration
./drivers/misc/eeprom/at25.c:	 * address, or board-specific calibration data generated on the
./drivers/misc/eeprom/at25.c:	 * security codes, board-specific manufacturing calibrations, etc.
./drivers/misc/ti-st/st_kim.c: *	board-xx.c file.
./drivers/misc/ti-st/st_kim.c: * board-*.c file
./drivers/parport/parport_pc.c:		/* change to reverse-idle phase (must be in forward-idle) */
./drivers/parport/parport_serial.c:	if (card->preinit_hook &&
./drivers/parport/parport_serial.c:	    card->preinit_hook (dev, card, PARPORT_IRQ_NONE, PARPORT_DMA_NONE))
./drivers/parport/parport_serial.c:	for (n = 0; n < card->numports; n++) {
./drivers/parport/parport_serial.c:		int lo = card->addr[n].lo;
./drivers/parport/parport_serial.c:		int hi = card->addr[n].hi;
./drivers/parport/parport_serial.c:				ARRAY_SIZE(priv->port), card->numports);
./drivers/parport/parport_serial.c:	if (card->postinit_hook)
./drivers/parport/parport_serial.c:		card->postinit_hook (dev, card, !success);
./drivers/parport/daisy.c:/* Forward-declaration of lower-level functions. */
./drivers/telephony/ixj.c: * Added card-specific DTMF prescaler initialisation
./drivers/telephony/ixj.c:				j->serial = dev->card->serial;
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:	if (record->element.port_num != priv->port)
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:	ipoib_dbg(priv, "Event %d on device %s port %d\n", record->event,
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:		  record->device->name, record->element.port_num);
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:	if (record->event == IB_EVENT_SM_CHANGE ||
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:	    record->event == IB_EVENT_CLIENT_REREGISTER) {
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:	} else if (record->event == IB_EVENT_PORT_ERR ||
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:		   record->event == IB_EVENT_PORT_ACTIVE ||
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:		   record->event == IB_EVENT_LID_CHANGE) {
./drivers/infiniband/ulp/ipoib/ipoib_verbs.c:	} else if (record->event == IB_EVENT_PKEY_CHANGE) {
./drivers/infiniband/hw/ipath/ipath_stats.c:	 * exceeding a threshold, so we need to check the word-counts
./drivers/infiniband/hw/ipath/ipath_driver.c: * and the board-dependent routine being called from interrupts.
./drivers/infiniband/hw/ipath/ipath_eeprom.c:		 * elsewhere for backward-compatibility.
./drivers/infiniband/hw/qib/qib_iba6120.c:	 * exceeding a threshold, so we need to check the word-counts
./drivers/infiniband/hw/qib/qib_driver.c: * and the board-dependent routine being called from interrupts.
./drivers/infiniband/hw/qib/qib_eeprom.c:		 * elsewhere for backward-compatibility.
./drivers/infiniband/hw/qib/qib_iba7220.c:	 * exceeding a threshold, so we need to check the word-counts
./drivers/infiniband/hw/qib/qib_iba7220.c: * It has a number of hard-coded fields, since the hope is to rewrite this
./drivers/infiniband/hw/qib/qib_twsi.c: * variety of other uses, most board-specific, so the bit-boffing
./drivers/infiniband/hw/qib/qib_iba7322.c:	/* Will need enumeration of board-types here */
./drivers/infiniband/hw/qib/qib_iba7322.c:		 * exceeding a threshold, so we need to check the word-counts
./drivers/infiniband/hw/qib/qib_iba7322.c: * It has a number of hard-coded fields, since the hope is to rewrite this
./drivers/watchdog/bfin_wdt.c:	/* Since this is an on-chip device and needs no board-specific
./drivers/bluetooth/btmrvl_sdio.c:	reg = sdio_readb(card->func, card->reg->card_rx_unit, &ret);
./drivers/bluetooth/btmrvl_sdio.c:		card->rx_unit = reg;
./drivers/bluetooth/btmrvl_sdio.c:	fws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	fws1 = sdio_readb(card->func, card->reg->card_fw_status1, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	reg = sdio_readb(card->func, card->reg->card_rx_len, &ret);
./drivers/bluetooth/btmrvl_sdio.c:		*dat = (u16) reg << card->rx_unit;
./drivers/bluetooth/btmrvl_sdio.c:	sdio_writeb(card->func, mask, card->reg->host_int_mask, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	host_int_mask = sdio_readb(card->func, card->reg->host_int_mask, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	sdio_writeb(card->func, host_int_mask, card->reg->host_int_mask, &ret);
./drivers/bluetooth/btmrvl_sdio.c:		status = sdio_readb(card->func, card->reg->card_status,	&ret);
./drivers/bluetooth/btmrvl_sdio.c:	ret = request_firmware(&fw_helper, card->helper,
./drivers/bluetooth/btmrvl_sdio.c:						&card->func->dev);
./drivers/bluetooth/btmrvl_sdio.c:		ret = sdio_writesb(card->func, card->ioport, helperbuf,
./drivers/bluetooth/btmrvl_sdio.c:	ret = sdio_writesb(card->func, card->ioport, helperbuf,
./drivers/bluetooth/btmrvl_sdio.c:	u16 len, blksz_dl = card->sd_blksz_fw_dl;
./drivers/bluetooth/btmrvl_sdio.c:	ret = request_firmware(&fw_firmware, card->firmware,
./drivers/bluetooth/btmrvl_sdio.c:							&card->func->dev);
./drivers/bluetooth/btmrvl_sdio.c:			base0 = sdio_readb(card->func,
./drivers/bluetooth/btmrvl_sdio.c:					card->reg->sq_read_base_addr_a0, &ret);
./drivers/bluetooth/btmrvl_sdio.c:			base1 = sdio_readb(card->func,
./drivers/bluetooth/btmrvl_sdio.c:					card->reg->sq_read_base_addr_a1, &ret);
./drivers/bluetooth/btmrvl_sdio.c:		ret = sdio_writesb(card->func, card->ioport, fwbuf,
./drivers/bluetooth/btmrvl_sdio.c:			sdio_writeb(card->func, HOST_CMD53_FIN,
./drivers/bluetooth/btmrvl_sdio.c:						card->reg->cfg, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->func) {
./drivers/bluetooth/btmrvl_sdio.c:	ret = sdio_readsb(card->func, payload, card->ioport,
./drivers/bluetooth/btmrvl_sdio.c:	sdio_claim_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	sdio_release_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->priv) {
./drivers/bluetooth/btmrvl_sdio.c:	priv = card->priv;
./drivers/bluetooth/btmrvl_sdio.c:	ireg = sdio_readb(card->func, card->reg->host_intstatus, &ret);
./drivers/bluetooth/btmrvl_sdio.c:		sdio_writeb(card->func, ~(ireg) & (DN_LD_HOST_INT_STATUS |
./drivers/bluetooth/btmrvl_sdio.c:				card->reg->host_intstatus, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->func) {
./drivers/bluetooth/btmrvl_sdio.c:	func = card->func;
./drivers/bluetooth/btmrvl_sdio.c:	ret = sdio_set_block_size(card->func, SDIO_BLOCK_SIZE);
./drivers/bluetooth/btmrvl_sdio.c:	reg = sdio_readb(func, card->reg->io_port_0, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	card->ioport = reg;
./drivers/bluetooth/btmrvl_sdio.c:	reg = sdio_readb(func, card->reg->io_port_1, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	card->ioport |= (reg << 8);
./drivers/bluetooth/btmrvl_sdio.c:	reg = sdio_readb(func, card->reg->io_port_2, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	card->ioport |= (reg << 16);
./drivers/bluetooth/btmrvl_sdio.c:	BT_DBG("SDIO FUNC%d IO port: 0x%x", func->num, card->ioport);
./drivers/bluetooth/btmrvl_sdio.c:	if (card && card->func) {
./drivers/bluetooth/btmrvl_sdio.c:		sdio_claim_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:		sdio_release_irq(card->func);
./drivers/bluetooth/btmrvl_sdio.c:		sdio_disable_func(card->func);
./drivers/bluetooth/btmrvl_sdio.c:		sdio_release_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:		sdio_set_drvdata(card->func, NULL);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->func)
./drivers/bluetooth/btmrvl_sdio.c:	sdio_claim_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	sdio_release_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->func)
./drivers/bluetooth/btmrvl_sdio.c:	sdio_claim_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	sdio_release_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->func) {
./drivers/bluetooth/btmrvl_sdio.c:	sdio_claim_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:		ret = sdio_writesb(card->func, card->ioport, buf,
./drivers/bluetooth/btmrvl_sdio.c:	sdio_release_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->func) {
./drivers/bluetooth/btmrvl_sdio.c:	sdio_claim_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	fws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);
./drivers/bluetooth/btmrvl_sdio.c:		if (card->helper) {
./drivers/bluetooth/btmrvl_sdio.c:	sdio_release_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	if (!card || !card->func) {
./drivers/bluetooth/btmrvl_sdio.c:	sdio_claim_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	sdio_writeb(card->func, HOST_POWER_UP, card->reg->cfg, &ret);
./drivers/bluetooth/btmrvl_sdio.c:	sdio_release_host(card->func);
./drivers/bluetooth/btmrvl_sdio.c:	card->func = func;
./drivers/bluetooth/btmrvl_sdio.c:		card->helper = data->helper;
./drivers/bluetooth/btmrvl_sdio.c:		card->firmware = data->firmware;
./drivers/bluetooth/btmrvl_sdio.c:		card->reg = data->reg;
./drivers/bluetooth/btmrvl_sdio.c:		card->sd_blksz_fw_dl = data->sd_blksz_fw_dl;
./drivers/bluetooth/btmrvl_sdio.c:	card->priv = priv;
./drivers/bluetooth/btmrvl_sdio.c:				btmrvl_send_module_cfg_cmd(card->priv,
./drivers/bluetooth/btmrvl_sdio.c:			btmrvl_remove_card(card->priv);
./drivers/acpi/apei/erst.c:	if (memcmp(record->signature, CPER_SIG_RECORD, CPER_SIG_SIZE))
./drivers/acpi/apei/erst.c:	if (record->record_length > erst_erange.size)
./drivers/acpi/apei/erst.c:	memcpy(erst_erange.vaddr, record, record->record_length);
./drivers/nubus/nubus.c:	dir->ptr = dir->base = board->directory;
./drivers/nubus/nubus.c:	dir->mask = board->lanes;
./drivers/nubus/nubus.c:	dir->mask = dev->board->lanes;
./drivers/nubus/nubus.c:	dir->ptr = dir->base = board->directory;
./drivers/nubus/nubus.c:	dir->mask = board->lanes;
./drivers/nubus/nubus.c:		if (itor->board->slot == slot)
./drivers/nubus/nubus.c:			nubus_get_rsrc_str(board->name, &ent, 64);
./drivers/nubus/nubus.c:			printk(KERN_INFO "    name: %s\n", board->name);
./drivers/nubus/nubus.c:	rp = board->fblock;
./drivers/nubus/nubus.c:	nubus_rewind(&rp, 4, board->lanes);
./drivers/nubus/nubus.c:	if (nubus_get_rom(&rp, 4, board->lanes) != NUBUS_TEST_PATTERN) {
./drivers/nubus/nubus.c:		board->directory = board->fblock;
./drivers/nubus/nubus.c:		nubus_move(&board->directory,
./drivers/nubus/nubus.c:			   nubus_expand32(board->doffset),
./drivers/nubus/nubus.c:			   board->lanes);
./drivers/nubus/nubus.c:	romdir = nubus_rom_addr(board->slot);
./drivers/nubus/nubus.c:	nubus_rewind(&romdir, ROM_DIR_OFFSET, board->lanes);
./drivers/nubus/nubus.c:	dir.mask = board->lanes;
./drivers/nubus/nubus.c:	board->directory = dir.base;
./drivers/nubus/nubus.c:	board->directory = board->fblock;
./drivers/nubus/nubus.c:	nubus_move(&board->directory, nubus_expand32(board->doffset), board->lanes);
./drivers/nubus/nubus.c:	board->fblock = rp;
./drivers/nubus/nubus.c:		rp = board->fblock;
./drivers/nubus/nubus.c:	board->slot = slot;
./drivers/nubus/nubus.c:	board->slot_addr = (unsigned long) nubus_slot_addr(slot);
./drivers/nubus/nubus.c:	board->doffset = nubus_get_rom(&rp, 4, bytelanes);
./drivers/nubus/nubus.c:	board->rom_length = nubus_get_rom(&rp, 4, bytelanes);
./drivers/nubus/nubus.c:	board->crc = nubus_get_rom(&rp, 4, bytelanes);
./drivers/nubus/nubus.c:	board->rev = nubus_get_rom(&rp, 1, bytelanes);
./drivers/nubus/nubus.c:	board->format = nubus_get_rom(&rp,1, bytelanes);
./drivers/nubus/nubus.c:	board->lanes = bytelanes;
./drivers/nubus/nubus.c:	if(!(board->doffset & 0x00FF0000))
./drivers/nubus/nubus.c:		if (board->first_dev == NULL)
./drivers/nubus/nubus.c:			board->first_dev = dev;
./drivers/nubus/nubus.c:	board->next = NULL;
./drivers/nubus/nubus.c:		board->slot, board->name);
./drivers/nubus/nubus.c:	for (board = nubus_boards; board != NULL; board = board->next)
./drivers/nubus/proc.c:			      dev->board->slot,
./drivers/nubus/proc.c:		seq_printf(m, "\t%08lx\n", dev->board->slot_addr);
./drivers/nubus/proc.c:			       dev->board->slot, ent.type);
./drivers/nubus/proc.c:	sprintf(name, "%x", dev->board->slot);
./drivers/regulator/tps65023-regulator.c:	 * coming from the board-evm file.
./drivers/regulator/tps6507x-regulator.c:	 * coming from the board-evm file.
./drivers/regulator/tps6507x-regulator.c:	 * coming from the board-evm file.
./drivers/regulator/tps6507x-regulator.c:	init_data = tps_board->tps6507x_pmic_init_data;
./drivers/regulator/twl-regulator.c:	/* Constrain board-specific capabilities according to what
./drivers/regulator/core.c: * need to provide board-specific regulator names as platform data.
./drivers/power/isp1704_charger.c:	if (board->set_power)
./drivers/power/isp1704_charger.c:		board->set_power(on);
./drivers/scsi/advansys.c:	asc_dvc->overrun_dma = dma_map_single(board->dev, asc_dvc->overrun_buf,
./drivers/scsi/advansys.c:	if (dma_mapping_error(board->dev, asc_dvc->overrun_dma)) {
./drivers/scsi/advansys.c:	dma_unmap_single(board->dev, asc_dvc->overrun_dma,
./drivers/scsi/advansys.c:	scp->SCp.dma_handle = dma_map_single(board->dev, scp->sense_buffer,
./drivers/scsi/advansys.c:	dma_cache_sync(board->dev, scp->sense_buffer,
./drivers/scsi/advansys.c:	ASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;
./drivers/scsi/advansys.c:	ASC_DVC_VAR *asc_dvc = &board->dvc_var.asc_dvc_var;
./drivers/scsi/advansys.c:	ADV_DVC_VAR *asc_dvc = &board->dvc_var.adv_dvc_var;
./drivers/scsi/advansys.c:	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
./drivers/scsi/advansys.c:	board->adv_sgblkp = NULL;
./drivers/scsi/advansys.c:		sgp->next_sgblkp = board->adv_sgblkp;
./drivers/scsi/advansys.c:		board->adv_sgblkp = sgp;
./drivers/scsi/advansys.c:	if (!board->adv_sgblkp)
./drivers/scsi/advansys.c:	board->adv_reqp = &reqp[0];
./drivers/scsi/advansys.c:	struct adv_dvc_var *adv_dvc = &board->dvc_var.adv_dvc_var;
./drivers/scsi/advansys.c:	adv_dvc->orig_reqp = board->adv_reqp = NULL;
./drivers/scsi/advansys.c:	while (board->adv_sgblkp) {
./drivers/scsi/advansys.c:		adv_sgblk_t *sgp = board->adv_sgblkp;
./drivers/scsi/advansys.c:		board->adv_sgblkp = sgp->next_sgblkp;
./drivers/scsi/advansys.c:	free_irq(board->irq, shost);
./drivers/scsi/advansys.c:		dma_unmap_single(board->dev,
./drivers/scsi/advansys.c:					board->dvc_var.asc_dvc_var.overrun_dma,
./drivers/scsi/advansys.c:		kfree(board->dvc_var.asc_dvc_var.overrun_buf);
./drivers/scsi/advansys.c:		iounmap(board->ioremap_addr);
./drivers/scsi/advansys.c:	kfree(board->prtbuf);
./drivers/scsi/advansys.c:	board->irq = advansys_isa_irq_no(iop_base);
./drivers/scsi/advansys.c:	board->dev = dev;
./drivers/scsi/advansys.c:	board->irq = advansys_vlb_irq_no(iop_base);
./drivers/scsi/advansys.c:	board->dev = dev;
./drivers/scsi/advansys.c:		board->irq = irq;
./drivers/scsi/advansys.c:		board->dev = dev;
./drivers/scsi/advansys.c:	board->irq = pdev->irq;
./drivers/scsi/advansys.c:	board->dev = &pdev->dev;
./drivers/scsi/advansys.c:		board->flags |= ASC_IS_WIDE_BOARD;
./drivers/scsi/mvsas/mv_94xx.c:		buf_prd->addr = cpu_to_le64(sg_dma_address(sg));
./drivers/scsi/mvsas/mv_94xx.c:		buf_prd->im_len.len = cpu_to_le32(sg_dma_len(sg));
./drivers/scsi/mvsas/mv_94xx.c:		buf_prd->addr = cpu_to_le64(buf_dma);
./drivers/scsi/mvsas/mv_94xx.c:		buf_prd->im_len.len = cpu_to_le32(buf_len);
./drivers/scsi/mvsas/mv_64xx.c:		buf_prd->addr = cpu_to_le64(sg_dma_address(sg));
./drivers/scsi/mvsas/mv_64xx.c:		buf_prd->len = cpu_to_le32(sg_dma_len(sg));
./drivers/scsi/mvsas/mv_64xx.c:		buf_prd->addr = cpu_to_le64(buf_dma);
./drivers/scsi/mvsas/mv_64xx.c:		buf_prd->len = cpu_to_le32(buf_len);
./drivers/scsi/FlashPoint.c:					if (CurrCard->ioPort ==
./drivers/scsi/FlashPoint.c:						CurrCard->pNvRamInfo =
./drivers/scsi/FlashPoint.c:			CurrCard->cardIndex = thisCard;
./drivers/scsi/FlashPoint.c:			CurrCard->cardInfo = pCardInfo;
./drivers/scsi/FlashPoint.c:	pCurrNvRam = CurrCard->pNvRamInfo;
./drivers/scsi/FlashPoint.c:	CurrCard->ourId = pCardInfo->si_id;
./drivers/scsi/FlashPoint.c:		CurrCard->globalFlags |= F_NO_FILTER;
./drivers/scsi/FlashPoint.c:			CurrCard->globalFlags |= F_GREEN_PC;
./drivers/scsi/FlashPoint.c:			CurrCard->globalFlags |= F_GREEN_PC;
./drivers/scsi/FlashPoint.c:			CurrCard->globalFlags |= F_DO_RENEGO;
./drivers/scsi/FlashPoint.c:			CurrCard->globalFlags |= F_DO_RENEGO;
./drivers/scsi/FlashPoint.c:			CurrCard->globalFlags |= F_CONLUN_IO;
./drivers/scsi/FlashPoint.c:			CurrCard->globalFlags |= F_CONLUN_IO;
./drivers/scsi/FlashPoint.c:		if (pCurrCard->globalFlags & F_HOST_XFER_ACT) {
./drivers/scsi/FlashPoint.c:					      pCurrCard->currentSCCB);
./drivers/scsi/FlashPoint.c:		if (pCurrCard->currentSCCB != NULL) {
./drivers/scsi/FlashPoint.c:			if (!pCurrCard->currentSCCB->HostStatus)
./drivers/scsi/FlashPoint.c:				pCurrCard->currentSCCB->HostStatus =
./drivers/scsi/FlashPoint.c:		if (pCurrCard->currentSCCB != NULL) {
./drivers/scsi/FlashPoint.c:			if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
./drivers/scsi/FlashPoint.c:						      pCurrCard->currentSCCB);
./drivers/scsi/FlashPoint.c:		pCurrNvRam = pCurrCard->pNvRamInfo;
./drivers/scsi/FlashPoint.c:		FPT_scini(p_card, pCurrCard->ourId, 0);
./drivers/scsi/FlashPoint.c:		if (pCurrCard->currentSCCB != NULL)
./drivers/scsi/FlashPoint.c:		pCurrCard->currentSCCB->HostStatus = SCCB_SELECTION_TIMEOUT;
./drivers/scsi/FlashPoint.c:		    &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
./drivers/scsi/FlashPoint.c:		if ((pCurrCard->globalFlags & F_CONLUN_IO)
./drivers/scsi/FlashPoint.c:			currTar_Info->TarLUNBusy[pCurrCard->currentSCCB->Lun] =
./drivers/scsi/FlashPoint.c:		FPT_sssyncv(p_port, pCurrCard->currentSCCB->TargID, NARROW_SCSI,
./drivers/scsi/FlashPoint.c:		FPT_queueCmdComplete(pCurrCard, pCurrCard->currentSCCB, p_card);
./drivers/scsi/FlashPoint.c:	pCurrCard->scanIndex = 0x00;
./drivers/scsi/FlashPoint.c:	pCurrCard->currentSCCB = NULL;
./drivers/scsi/FlashPoint.c:	pCurrCard->globalFlags = 0x00;
./drivers/scsi/FlashPoint.c:	pCurrCard->cmdCounter = 0x00;
./drivers/scsi/FlashPoint.c:	pCurrCard->tagQ_Lst = 0x01;
./drivers/scsi/FlashPoint.c:	pCurrCard->discQCount = 0;
./drivers/scsi/FlashPoint.c:	currSCCB = CurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:	lastTag = CurrCard->tagQ_Lst;
./drivers/scsi/FlashPoint.c:	if (((CurrCard->globalFlags & F_CONLUN_IO) &&
./drivers/scsi/FlashPoint.c:	if (CurrCard->globalFlags & F_TAG_STARTED) {
./drivers/scsi/FlashPoint.c:	if ((((CurrCard->globalFlags & F_CONLUN_IO) &&
./drivers/scsi/FlashPoint.c:		if (CurrCard->discQCount >= QUEUE_DEPTH) {
./drivers/scsi/FlashPoint.c:			if (CurrCard->discQ_Tbl[lastTag] == NULL) {
./drivers/scsi/FlashPoint.c:				CurrCard->tagQ_Lst = lastTag;
./drivers/scsi/FlashPoint.c:				CurrCard->discQ_Tbl[lastTag] = currSCCB;
./drivers/scsi/FlashPoint.c:				CurrCard->discQCount++;
./drivers/scsi/FlashPoint.c:			CurrCard->globalFlags |= F_TAG_STARTED;
./drivers/scsi/FlashPoint.c:					if (CurrCard->discQ_Tbl[lastTag] ==
./drivers/scsi/FlashPoint.c:						CurrCard->tagQ_Lst = lastTag;
./drivers/scsi/FlashPoint.c:						CurrCard->discQ_Tbl[lastTag] =
./drivers/scsi/FlashPoint.c:						CurrCard->discQCount++;
./drivers/scsi/FlashPoint.c:	if (pCurrCard->currentSCCB != NULL) {
./drivers/scsi/FlashPoint.c:		    &FPT_sccbMgrTbl[p_card][pCurrCard->currentSCCB->TargID];
./drivers/scsi/FlashPoint.c:		currSCCB = pCurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:		if (((pCurrCard->globalFlags & F_CONLUN_IO) &&
./drivers/scsi/FlashPoint.c:				pCurrCard->discQCount--;
./drivers/scsi/FlashPoint.c:				pCurrCard->discQ_Tbl[currTar_Info->
./drivers/scsi/FlashPoint.c:					pCurrCard->discQCount--;
./drivers/scsi/FlashPoint.c:					pCurrCard->discQ_Tbl[currSCCB->
./drivers/scsi/FlashPoint.c:					pCurrCard->discQCount--;
./drivers/scsi/FlashPoint.c:					pCurrCard->discQ_Tbl[currTar_Info->
./drivers/scsi/FlashPoint.c:			message = FPT_sfm(port, pCurrCard->currentSCCB);
./drivers/scsi/FlashPoint.c:								     pCurrCard->
./drivers/scsi/FlashPoint.c:									     pCurrCard->
./drivers/scsi/FlashPoint.c:	if (((pCurrCard->globalFlags & F_CONLUN_IO) &&
./drivers/scsi/FlashPoint.c:		pCurrCard->currentSCCB =
./drivers/scsi/FlashPoint.c:		    pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[lun]];
./drivers/scsi/FlashPoint.c:		if (pCurrCard->currentSCCB != NULL) {
./drivers/scsi/FlashPoint.c:			if (pCurrCard->discQ_Tbl[tag] != NULL) {
./drivers/scsi/FlashPoint.c:				pCurrCard->currentSCCB =
./drivers/scsi/FlashPoint.c:				    pCurrCard->discQ_Tbl[tag];
./drivers/scsi/FlashPoint.c:			pCurrCard->currentSCCB =
./drivers/scsi/FlashPoint.c:			    pCurrCard->discQ_Tbl[currTar_Info->LunDiscQ_Idx[0]];
./drivers/scsi/FlashPoint.c:			if (pCurrCard->currentSCCB != NULL) {
./drivers/scsi/FlashPoint.c:	if (pCurrCard->currentSCCB != NULL) {
./drivers/scsi/FlashPoint.c:		if (pCurrCard->currentSCCB->Sccb_scsistat == ABORT_ST) {
./drivers/scsi/FlashPoint.c:			FPT_queueFindSccb(pCurrCard->currentSCCB, p_card);
./drivers/scsi/FlashPoint.c:	currSCCB = CurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:					CurrCard->discQCount--;
./drivers/scsi/FlashPoint.c:					CurrCard->discQ_Tbl[currSCCB->
./drivers/scsi/FlashPoint.c:					CurrCard->globalFlags |= F_NEW_SCCB_CMD;
./drivers/scsi/FlashPoint.c:				if ((CurrCard->globalFlags & F_CONLUN_IO) &&
./drivers/scsi/FlashPoint.c:	currSCCB = pCurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:	currSCCB = pCurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:		if (pCurrCard->globalFlags & F_HOST_XFER_ACT)
./drivers/scsi/FlashPoint.c:		pCurrCard->globalFlags |= F_HOST_XFER_ACT;
./drivers/scsi/FlashPoint.c:		if (!(pCurrCard->globalFlags & F_HOST_XFER_ACT)) {
./drivers/scsi/FlashPoint.c:			pCurrCard->globalFlags |= F_HOST_XFER_ACT;
./drivers/scsi/FlashPoint.c:	p_port = currCard->ioPort;
./drivers/scsi/FlashPoint.c:	pCurrNvRam = currCard->pNvRamInfo;
./drivers/scsi/FlashPoint.c:								currCard->
./drivers/scsi/FlashPoint.c:							currCard->ourId =
./drivers/scsi/FlashPoint.c:							FPT_scamInfo[currCard->
./drivers/scsi/FlashPoint.c:							FPT_scamInfo[currCard->
./drivers/scsi/FlashPoint.c:		if (currCard->globalFlags & F_UPDATE_EEPROM) {
./drivers/scsi/FlashPoint.c:			currCard->globalFlags &= ~F_UPDATE_EEPROM;
./drivers/scsi/FlashPoint.c:      currCard->globalFlags |= F_SINGLE_DEVICE;
./drivers/scsi/FlashPoint.c:      currCard->globalFlags &= ~F_SINGLE_DEVICE;
./drivers/scsi/FlashPoint.c:	scan_ptr = pCurrCard->scanIndex;
./drivers/scsi/FlashPoint.c:		if ((pCurrCard->globalFlags & F_CONLUN_IO) &&
./drivers/scsi/FlashPoint.c:						pCurrCard->currentSCCB =
./drivers/scsi/FlashPoint.c:						while ((pCurrCard->
./drivers/scsi/FlashPoint.c:							   pCurrCard->
./drivers/scsi/FlashPoint.c:							    pCurrCard->
./drivers/scsi/FlashPoint.c:							pCurrCard->currentSCCB =
./drivers/scsi/FlashPoint.c:							     *)(pCurrCard->
./drivers/scsi/FlashPoint.c:						if (pCurrCard->currentSCCB ==
./drivers/scsi/FlashPoint.c:							     *)(pCurrCard->
./drivers/scsi/FlashPoint.c:							     *)(pCurrCard->
./drivers/scsi/FlashPoint.c:							     *)(pCurrCard->
./drivers/scsi/FlashPoint.c:						pCurrCard->scanIndex = scan_ptr;
./drivers/scsi/FlashPoint.c:						pCurrCard->globalFlags |=
./drivers/scsi/FlashPoint.c:				pCurrCard->currentSCCB =
./drivers/scsi/FlashPoint.c:				    (struct sccb *)(pCurrCard->currentSCCB)->
./drivers/scsi/FlashPoint.c:				pCurrCard->scanIndex = scan_ptr;
./drivers/scsi/FlashPoint.c:				pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
./drivers/scsi/FlashPoint.c:	} while (scan_ptr != pCurrCard->scanIndex);
./drivers/scsi/FlashPoint.c:	if (pCurrCard->currentSCCB != NULL) {
./drivers/scsi/FlashPoint.c:		    (unsigned char)(((struct sccb *)(pCurrCard->currentSCCB))->
./drivers/scsi/FlashPoint.c:		pCurrCard->currentSCCB->Sccb_backlink = (struct sccb *)NULL;
./drivers/scsi/FlashPoint.c:		pCurrCard->currentSCCB->Sccb_forwardlink =
./drivers/scsi/FlashPoint.c:			currTar_Info->TarSelQ_Tail = pCurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:			    pCurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:		currTar_Info->TarSelQ_Head = pCurrCard->currentSCCB;
./drivers/scsi/FlashPoint.c:		pCurrCard->currentSCCB = NULL;
./drivers/scsi/FlashPoint.c:			    (pCurrCard->globalFlags & F_NO_FILTER)
./drivers/scsi/FlashPoint.c:	pCurrCard->cmdCounter--;
./drivers/scsi/FlashPoint.c:	if (!pCurrCard->cmdCounter) {
./drivers/scsi/FlashPoint.c:		if (pCurrCard->globalFlags & F_GREEN_PC) {
./drivers/scsi/FlashPoint.c:			WR_HARPOON(pCurrCard->ioPort + hp_clkctrl_0,
./drivers/scsi/FlashPoint.c:			WR_HARPOON(pCurrCard->ioPort + hp_sys_ctrl, STOP_CLK);
./drivers/scsi/FlashPoint.c:		WR_HARPOON(pCurrCard->ioPort + hp_semaphore,
./drivers/scsi/FlashPoint.c:			   (RD_HARPOON(pCurrCard->ioPort + hp_semaphore) &
./drivers/scsi/FlashPoint.c:	if (pCurrCard->discQCount != 0) {
./drivers/scsi/FlashPoint.c:		if (((pCurrCard->globalFlags & F_CONLUN_IO) &&
./drivers/scsi/FlashPoint.c:			pCurrCard->discQCount--;
./drivers/scsi/FlashPoint.c:			pCurrCard->discQ_Tbl[currTar_Info->
./drivers/scsi/FlashPoint.c:				pCurrCard->discQCount--;
./drivers/scsi/FlashPoint.c:				pCurrCard->discQ_Tbl[p_sccb->Sccb_tag] = NULL;
./drivers/scsi/FlashPoint.c:				pCurrCard->discQCount--;
./drivers/scsi/FlashPoint.c:				pCurrCard->discQ_Tbl[currTar_Info->
./drivers/scsi/FlashPoint.c:	pCurrCard->globalFlags |= F_NEW_SCCB_CMD;
./drivers/scsi/FlashPoint.c:	pCurrCard->currentSCCB = NULL;
./drivers/scsi/pmcraid.c:		 * goes through hard-reset
./drivers/scsi/pmcraid.c:		 * hard-reset.
./drivers/scsi/arm/fas216.c:	 * For each attached hard-reset device, clear out
./drivers/scsi/lpfc/lpfc_sli.c: * @ulpWord4: ULP word-4 in IOCB command field.
./drivers/scsi/lpfc/lpfc_sli.c:	fcf_record->max_rcv_size = LPFC_FCOE_MAX_RCV_SIZE;
./drivers/scsi/lpfc/lpfc_sli.c:	fcf_record->fka_adv_period = LPFC_FCOE_FKA_ADV_PER;
./drivers/scsi/lpfc/lpfc_sli.c:	fcf_record->fip_priority = LPFC_FCOE_FIP_PRIORITY;
./drivers/scsi/lpfc/lpfc_sli.c:		fcf_record->vlan_bitmap[phba->vlan_id / 8]
./drivers/scsi/lpfc/lpfc_hbadisc.c:	fcf_rec->priority = new_fcf_record->fip_priority;
./drivers/scsi/lpfc/lpfc_hbadisc.c:		if (new_fcf_record->vlan_bitmap[i]) {
./drivers/scsi/lpfc/lpfc_hbadisc.c:			while (!((new_fcf_record->vlan_bitmap[i] >> j) & 1)) {
./drivers/scsi/lpfc/lpfc_hbadisc.c:			if (!(new_fcf_record->vlan_bitmap
./drivers/scsi/lpfc/lpfc_hbadisc.c:	new_fcf_record->word137 = le32_to_cpu(new_fcf_record->word137);
./drivers/scsi/lpfc/lpfc_hbadisc.c:	new_fcf_record->word138 = le32_to_cpu(new_fcf_record->word138);
./drivers/scsi/lpfc/lpfc_hbadisc.c:			fcf_record->fip_priority,
./drivers/scsi/lpfc/lpfc_hbadisc.c:		if (new_fcf_record->fip_priority < fcf_rec->priority) {
./drivers/scsi/lpfc/lpfc_hbadisc.c:		} else if (new_fcf_record->fip_priority == fcf_rec->priority) {
./drivers/scsi/gvp11.c:	 * code as the SCSI controllers. Therefore if the board-size
./drivers/scsi/raid_class.c:	INIT_LIST_HEAD(&rd->component_list);
./drivers/scsi/raid_class.c:	list_for_each_entry_safe(rc, next, &rd->component_list, node) {
./drivers/scsi/raid_class.c:	name = raid_##states##_name(rd->attr);				\
./drivers/scsi/raid_class.c:raid_attr_show_internal(attr, %d, rd->attr, code)			\
./drivers/scsi/raid_class.c:	rc->num = rd->component_count++;
./drivers/scsi/raid_class.c:	list_add_tail(&rc->node, &rd->component_list);
./drivers/scsi/raid_class.c:	rd->component_count--;
./drivers/scsi/pm8001/pm8001_hwi.c:		buf_prd->addr = cpu_to_le64(sg_dma_address(sg));
./drivers/scsi/pm8001/pm8001_hwi.c:		buf_prd->im_len.len = cpu_to_le32(sg_dma_len(sg));
./drivers/scsi/pm8001/pm8001_hwi.c:		buf_prd->im_len.e = 0;
./drivers/staging/ste_rmi4/synaptics_i2c_rmi4.c:				if (pdata->board->x_flip)
./drivers/staging/ste_rmi4/synaptics_i2c_rmi4.c:				if (pdata->board->y_flip)
./drivers/staging/tidspbridge/rmgr/drv.c:	/* These are hard-coded values */
./drivers/staging/tidspbridge/rmgr/drv.c:			/* These are hard-coded values */
./drivers/staging/ft1000/ft1000-usb/ft1000_download.c:			   tempword--;
./drivers/staging/ft1000/ft1000-usb/ft1000_download.c:						pprov_record->pprov_data =
./drivers/staging/ft1000/ft1000-usb/ft1000_download.c:						list_add_tail(&pprov_record->
./drivers/staging/ft1000/ft1000-pcmcia/ft1000_dnld.c:						pprov_record->pprov_data =
./drivers/staging/ft1000/ft1000-pcmcia/ft1000_dnld.c:						list_add_tail(&pprov_record->
./drivers/staging/comedi/drivers/s626.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/s626.c:	s->n_chan = thisboard->ai_chans;
./drivers/staging/comedi/drivers/s626.c:	s->len_chanlist = thisboard->ai_chans;	/* This is the maximum chanlist
./drivers/staging/comedi/drivers/s626.c:	s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/s626.c:	s->n_chan = thisboard->enc_chans;
./drivers/staging/comedi/drivers/serial2002.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/dt2811.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/dt2811.c:		s->range_table = this_board->bip_5;
./drivers/staging/comedi/drivers/dt2811.c:		s->range_table = this_board->bip_2_5;
./drivers/staging/comedi/drivers/dt2811.c:		s->range_table = this_board->unip_5;
./drivers/staging/comedi/drivers/s526.c:	if (!iobase || !request_region(iobase, S526_IOSIZE, thisboard->name)) {
./drivers/staging/comedi/drivers/s526.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/s526.c:	s->n_chan = thisboard->gpct_chans;
./drivers/staging/comedi/drivers/s526.c:	if (thisboard->have_dio) {
./drivers/staging/comedi/drivers/pcl812.c:		if (cmd->convert_arg < this_board->ai_ns_min) {
./drivers/staging/comedi/drivers/pcl812.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/pcl812.c:		cmd->chanlist_len = this_board->n_aichan;
./drivers/staging/comedi/drivers/pcl812.c:		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
./drivers/staging/comedi/drivers/pcl812.c:		if (cmd->convert_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/pcl812.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/pcl812.c:		if (cmd->convert_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/pcl812.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/pcl812.c:		i8253_cascade_ns_to_timer(this_board->i8254_osc_base,
./drivers/staging/comedi/drivers/pcl812.c:		release_region(dev->iobase, this_board->io_range);
./drivers/staging/comedi/drivers/pcl812.c:	switch (this_board->board_type) {
./drivers/staging/comedi/drivers/pcl812.c:	       dev->minor, this_board->name, iobase);
./drivers/staging/comedi/drivers/pcl812.c:	if (!request_region(iobase, this_board->io_range, "pcl812")) {
./drivers/staging/comedi/drivers/pcl812.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->IRQbits != 0) {	/* board support IRQ */
./drivers/staging/comedi/drivers/pcl812.c:			if (((1 << irq) & this_board->IRQbits) == 0) {
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->DMAbits != 0) {	/* board support DMA */
./drivers/staging/comedi/drivers/pcl812.c:		if (((1 << dma) & this_board->DMAbits) == 0) {
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_aichan > 0)
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_aochan > 0)
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_dichan > 0)
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_dochan > 0)
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_aichan > 0) {
./drivers/staging/comedi/drivers/pcl812.c:		switch (this_board->board_type) {
./drivers/staging/comedi/drivers/pcl812.c:				s->n_chan = this_board->n_aichan_diff;
./drivers/staging/comedi/drivers/pcl812.c:				s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/pcl812.c:				s->n_chan = this_board->n_aichan_diff;
./drivers/staging/comedi/drivers/pcl812.c:				s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/pcl812.c:			s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/pcl812.c:		s->maxdata = this_board->ai_maxdata;
./drivers/staging/comedi/drivers/pcl812.c:		s->range_table = this_board->rangelist_ai;
./drivers/staging/comedi/drivers/pcl812.c:		if (this_board->board_type == boardACL8216)
./drivers/staging/comedi/drivers/pcl812.c:		devpriv->use_MPC = this_board->haveMPC508;
./drivers/staging/comedi/drivers/pcl812.c:		switch (this_board->board_type) {
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_aochan > 0) {
./drivers/staging/comedi/drivers/pcl812.c:		s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/pcl812.c:		s->range_table = this_board->rangelist_ao;
./drivers/staging/comedi/drivers/pcl812.c:		switch (this_board->board_type) {
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_dichan > 0) {
./drivers/staging/comedi/drivers/pcl812.c:		s->n_chan = this_board->n_dichan;
./drivers/staging/comedi/drivers/pcl812.c:		s->len_chanlist = this_board->n_dichan;
./drivers/staging/comedi/drivers/pcl812.c:	if (this_board->n_dochan > 0) {
./drivers/staging/comedi/drivers/pcl812.c:		s->n_chan = this_board->n_dochan;
./drivers/staging/comedi/drivers/pcl812.c:		s->len_chanlist = this_board->n_dochan;
./drivers/staging/comedi/drivers/pcl812.c:	switch (this_board->board_type) {
./drivers/staging/comedi/drivers/adv_pci1723.c:						dev->minor, this_board->name);
./drivers/staging/comedi/drivers/adv_pci1723.c:				       this_board->device_id, pcidev))) {
./drivers/staging/comedi/drivers/adv_pci1723.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/adv_pci1723.c:	if (this_board->n_aochan)
./drivers/staging/comedi/drivers/adv_pci1723.c:	if (this_board->n_diochan)
./drivers/staging/comedi/drivers/adv_pci1723.c:	if (this_board->n_aochan) {
./drivers/staging/comedi/drivers/adv_pci1723.c:		s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/adv_pci1723.c:		s->maxdata = this_board->ao_maxdata;
./drivers/staging/comedi/drivers/adv_pci1723.c:		s->len_chanlist = this_board->n_aochan;
./drivers/staging/comedi/drivers/adv_pci1723.c:		s->range_table = this_board->rangelist_ao;
./drivers/staging/comedi/drivers/adv_pci1723.c:	if (this_board->n_diochan) {
./drivers/staging/comedi/drivers/adv_pci1723.c:		s->n_chan = this_board->n_diochan;
./drivers/staging/comedi/drivers/adv_pci1723.c:		s->len_chanlist = this_board->n_diochan;
./drivers/staging/comedi/drivers/rtd520.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/rtd520.c:	s->n_chan = thisboard->aiChans;
./drivers/staging/comedi/drivers/rtd520.c:	s->maxdata = (1 << thisboard->aiBits) - 1;
./drivers/staging/comedi/drivers/rtd520.c:	if (thisboard->aiMaxGain <= 32)
./drivers/staging/comedi/drivers/rtd520.c:	s->maxdata = (1 << thisboard->aiBits) - 1;
./drivers/staging/comedi/drivers/rtd520.c:	if (range < thisboard->range10Start) {	/* first batch are +-5 */
./drivers/staging/comedi/drivers/rtd520.c:	} else if (range < thisboard->rangeUniStart) {	/* second batch are +-10 */
./drivers/staging/comedi/drivers/rtd520.c:		r |= ((range - thisboard->range10Start) & 0x7) << 4;	/* gain */
./drivers/staging/comedi/drivers/rtd520.c:		r |= ((range - thisboard->rangeUniStart) & 0x7) << 4;	/* gain */
./drivers/staging/comedi/drivers/pcl818.c:		if (cmd->convert_arg < this_board->ns_min) {
./drivers/staging/comedi/drivers/pcl818.c:			cmd->convert_arg = this_board->ns_min;
./drivers/staging/comedi/drivers/pcl818.c:		if (cmd->convert_arg < this_board->ns_min)
./drivers/staging/comedi/drivers/pcl818.c:			cmd->convert_arg = this_board->ns_min;
./drivers/staging/comedi/drivers/pcl818.c:	if (this_board->is_818) {
./drivers/staging/comedi/drivers/pcl818.c:	       dev->minor, this_board->name, iobase);
./drivers/staging/comedi/drivers/pcl818.c:	devpriv->io_range = this_board->io_range;
./drivers/staging/comedi/drivers/pcl818.c:	if ((this_board->fifo) && (it->options[2] == -1)) {	/*  we've board with FIFO and we want to use FIFO */
./drivers/staging/comedi/drivers/pcl818.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcl818.c:	if (this_board->IRQbits != 0) {	/* board support IRQ */
./drivers/staging/comedi/drivers/pcl818.c:			if (((1 << irq) & this_board->IRQbits) == 0) {
./drivers/staging/comedi/drivers/pcl818.c:	if (this_board->DMAbits != 0) {	/* board support DMA */
./drivers/staging/comedi/drivers/pcl818.c:		if (((1 << dma) & this_board->DMAbits) == 0) {
./drivers/staging/comedi/drivers/pcl818.c:	if (!this_board->n_aichan_se) {
./drivers/staging/comedi/drivers/pcl818.c:			s->n_chan = this_board->n_aichan_se;
./drivers/staging/comedi/drivers/pcl818.c:			s->n_chan = this_board->n_aichan_diff;
./drivers/staging/comedi/drivers/pcl818.c:		s->maxdata = this_board->ai_maxdata;
./drivers/staging/comedi/drivers/pcl818.c:		s->range_table = this_board->ai_range_type;
./drivers/staging/comedi/drivers/pcl818.c:		if (this_board->is_818) {
./drivers/staging/comedi/drivers/pcl818.c:	if (!this_board->n_aochan) {
./drivers/staging/comedi/drivers/pcl818.c:		s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/pcl818.c:		s->maxdata = this_board->ao_maxdata;
./drivers/staging/comedi/drivers/pcl818.c:		s->len_chanlist = this_board->n_aochan;
./drivers/staging/comedi/drivers/pcl818.c:		s->range_table = this_board->ao_range_type;
./drivers/staging/comedi/drivers/pcl818.c:		if (this_board->is_818) {
./drivers/staging/comedi/drivers/pcl818.c:	if (!this_board->n_dichan) {
./drivers/staging/comedi/drivers/pcl818.c:		s->n_chan = this_board->n_dichan;
./drivers/staging/comedi/drivers/pcl818.c:		s->len_chanlist = this_board->n_dichan;
./drivers/staging/comedi/drivers/pcl818.c:	if (!this_board->n_dochan) {
./drivers/staging/comedi/drivers/pcl818.c:		s->n_chan = this_board->n_dochan;
./drivers/staging/comedi/drivers/pcl818.c:		s->len_chanlist = this_board->n_dochan;
./drivers/staging/comedi/drivers/pcl818.c:	devpriv->ns_min = this_board->ns_min;
./drivers/staging/comedi/drivers/pcl818.c:	if (!this_board->is_818) {
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (cmd->scan_begin_arg < this_board->ai_ns_min) {
./drivers/staging/comedi/drivers/adl_pci9118.c:			cmd->scan_begin_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (cmd->convert_arg < this_board->ai_ns_min) {
./drivers/staging/comedi/drivers/adl_pci9118.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:	if (cmd->chanlist_len > this_board->n_aichanlist) {
./drivers/staging/comedi/drivers/adl_pci9118.c:		cmd->chanlist_len = this_board->n_aichanlist;
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (cmd->scan_begin_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/adl_pci9118.c:			cmd->scan_begin_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (cmd->convert_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/adl_pci9118.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:				    this_board->ai_ns_min *
./drivers/staging/comedi/drivers/adl_pci9118.c:					    this_board->ai_ns_min *
./drivers/staging/comedi/drivers/adl_pci9118.c:	if (devpriv->ai_n_scanlen < this_board->half_fifo_size) {
./drivers/staging/comedi/drivers/adl_pci9118.c:		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
./drivers/staging/comedi/drivers/adl_pci9118.c:		    (this_board->half_fifo_size / devpriv->ai_n_scanlen +
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (cmd->convert_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/adl_pci9118.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:			    (CR_CHAN(chanlist[i]) >= this_board->n_aichand)) {
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (*tim2 < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/adl_pci9118.c:			*tim2 = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (*tim2 < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/adl_pci9118.c:			*tim2 = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:		if (*div1 < this_board->ai_pacer_min)
./drivers/staging/comedi/drivers/adl_pci9118.c:			*div1 = this_board->ai_pacer_min;
./drivers/staging/comedi/drivers/adl_pci9118.c:	printk("comedi%d: adl_pci9118: board=%s", dev->minor, this_board->name);
./drivers/staging/comedi/drivers/adl_pci9118.c:						this_board->device_id,
./drivers/staging/comedi/drivers/adl_pci9118.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/adl_pci9118.c:		s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/adl_pci9118.c:	s->maxdata = this_board->ai_maxdata;
./drivers/staging/comedi/drivers/adl_pci9118.c:	s->len_chanlist = this_board->n_aichanlist;
./drivers/staging/comedi/drivers/adl_pci9118.c:	s->range_table = this_board->rangelist_ai;
./drivers/staging/comedi/drivers/adl_pci9118.c:	s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/adl_pci9118.c:	s->maxdata = this_board->ao_maxdata;
./drivers/staging/comedi/drivers/adl_pci9118.c:	s->len_chanlist = this_board->n_aochan;
./drivers/staging/comedi/drivers/adl_pci9118.c:	s->range_table = this_board->rangelist_ao;
./drivers/staging/comedi/drivers/adl_pci9118.c:	switch (this_board->ai_maxdata) {
./drivers/staging/comedi/drivers/ni_daq_dio24.c:	 .name = "daqcard-dio24",
./drivers/staging/comedi/drivers/ni_daq_dio24.c:	switch (thisboard->bustype) {
./drivers/staging/comedi/drivers/ni_daq_dio24.c:	       thisboard->name, iobase);
./drivers/staging/comedi/drivers/ni_daq_dio24.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ni_daq_dio24.c:	if (thisboard->bustype != pcmcia_bustype && dev->iobase)
./drivers/staging/comedi/drivers/ni_daq_dio24.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x475c),	/* daqcard-dio24 */
./drivers/staging/comedi/drivers/pcm3724.c:	iorange = this_board->io_range;
./drivers/staging/comedi/drivers/pcm3724.c:	       this_board->name, iobase);
./drivers/staging/comedi/drivers/pcm3724.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcm3724.c:	n_subdevices = this_board->numofports;
./drivers/staging/comedi/drivers/pcm3724.c:		release_region(dev->iobase, this_board->io_range);
./drivers/staging/comedi/drivers/rti800.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/rti800.c:	if (this_board->has_ao) {
./drivers/staging/comedi/drivers/das16m1.c:		if (cmd->convert_arg < thisboard->ai_speed) {
./drivers/staging/comedi/drivers/das16m1.c:			cmd->convert_arg = thisboard->ai_speed;
./drivers/staging/comedi/drivers/das16m1.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->memory_mapped_io)
./drivers/staging/comedi/drivers/ni_labpc.c:								thisboard->name,
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->bustype == isa_bustype) {
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->memory_mapped_io) {
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout) {
./drivers/staging/comedi/drivers/ni_labpc.c:		if (thisboard->bustype == pci_bustype
./drivers/staging/comedi/drivers/ni_labpc.c:		    || thisboard->bustype == pcmcia_bustype)
./drivers/staging/comedi/drivers/ni_labpc.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ni_labpc.c:	s->range_table = thisboard->ai_range_table;
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->has_ao) {
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->memory_mapped_io)
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout) {
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout) {
./drivers/staging/comedi/drivers/ni_labpc.c:	switch (thisboard->bustype) {
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->bustype == isa_bustype && dev->iobase)
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout)
./drivers/staging/comedi/drivers/ni_labpc.c:		if (cmd->convert_arg < thisboard->ai_speed) {
./drivers/staging/comedi/drivers/ni_labpc.c:			cmd->convert_arg = thisboard->ai_speed;
./drivers/staging/comedi/drivers/ni_labpc.c:		    thisboard->ai_speed * cmd->chanlist_len) {
./drivers/staging/comedi/drivers/ni_labpc.c:			    thisboard->ai_speed * cmd->chanlist_len;
./drivers/staging/comedi/drivers/ni_labpc.c:	    thisboard->bustype == isa_bustype) {
./drivers/staging/comedi/drivers/ni_labpc.c:	} else if (thisboard->register_layout == labpc_1200_layout &&
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout) {
./drivers/staging/comedi/drivers/ni_labpc.c:		if (thisboard->ai_range_is_unipolar[range])
./drivers/staging/comedi/drivers/ni_labpc.c:	devpriv->command1_bits |= thisboard->ai_range_code[range];
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout)
./drivers/staging/comedi/drivers/ni_labpc.c:		    (thisboard->register_layout == labpc_1200_layout
./drivers/staging/comedi/drivers/ni_labpc.c:	devpriv->command1_bits |= thisboard->ai_range_code[range];
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout) {
./drivers/staging/comedi/drivers/ni_labpc.c:		if (thisboard->ai_range_is_unipolar[range])
./drivers/staging/comedi/drivers/ni_labpc.c:	/* note: hardware bug in daqcard-1200 means pacing cannot
./drivers/staging/comedi/drivers/ni_labpc.c:	if (thisboard->register_layout == labpc_1200_layout) {
./drivers/staging/comedi/drivers/aio_aio12_8.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/das1800.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/das1800.c:	if (thisboard->ao_ability == 2) {
./drivers/staging/comedi/drivers/das1800.c:	if (thisboard->common)
./drivers/staging/comedi/drivers/das1800.c:	s->n_chan = thisboard->qram_len;
./drivers/staging/comedi/drivers/das1800.c:	s->len_chanlist = thisboard->qram_len;
./drivers/staging/comedi/drivers/das1800.c:	s->maxdata = (1 << thisboard->resolution) - 1;
./drivers/staging/comedi/drivers/das1800.c:	s->range_table = thisboard->range_ai;
./drivers/staging/comedi/drivers/das1800.c:	if (thisboard->ao_ability == 1) {
./drivers/staging/comedi/drivers/das1800.c:		s->n_chan = thisboard->ao_n_chan;
./drivers/staging/comedi/drivers/das1800.c:		s->maxdata = (1 << thisboard->resolution) - 1;
./drivers/staging/comedi/drivers/das1800.c:	s->n_chan = thisboard->do_n_chan;
./drivers/staging/comedi/drivers/das1800.c:	if (thisboard->ao_ability == 1) {
./drivers/staging/comedi/drivers/das1800.c:		outb(DAC(thisboard->ao_n_chan - 1),
./drivers/staging/comedi/drivers/das1800.c:	sample += 1 << (thisboard->resolution - 1);
./drivers/staging/comedi/drivers/das1800.c:		if (cmd->convert_arg < thisboard->ai_speed) {
./drivers/staging/comedi/drivers/das1800.c:			cmd->convert_arg = thisboard->ai_speed;
./drivers/staging/comedi/drivers/das1800.c:			dpnt += 1 << (thisboard->resolution - 1);
./drivers/staging/comedi/drivers/das1800.c:	int update_chan = thisboard->ao_n_chan - 1;
./drivers/staging/comedi/drivers/das1800.c:	output = data[0] - (1 << (thisboard->resolution - 1));
./drivers/staging/comedi/drivers/pcl711.c:		if (this_board->is_8112)
./drivers/staging/comedi/drivers/pcl711.c:	if (this_board->is_8112) {
./drivers/staging/comedi/drivers/pcl711.c:		if (!this_board->is_8112)
./drivers/staging/comedi/drivers/pcl711.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcl711.c:	if (irq > this_board->maxirq) {
./drivers/staging/comedi/drivers/pcl711.c:	s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/pcl711.c:	s->range_table = this_board->ai_range_type;
./drivers/staging/comedi/drivers/pcl711.c:	s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/pcl711.c:	if (this_board->is_pcl711b)
./drivers/staging/comedi/drivers/amplc_pc236.c:		if (thisboard->model == anypci_model) {
./drivers/staging/comedi/drivers/amplc_pc236.c:			if (pci_dev->device != thisboard->devid)
./drivers/staging/comedi/drivers/amplc_pc236.c:		       dev->minor, thisboard->name, bus, slot);
./drivers/staging/comedi/drivers/amplc_pc236.c:		       dev->minor, thisboard->name);
./drivers/staging/comedi/drivers/amplc_pc236.c:	switch (thisboard->bustype) {
./drivers/staging/comedi/drivers/amplc_pc236.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/amplc_pc236.c:	if (thisboard->bustype == isa_bustype) {
./drivers/staging/comedi/drivers/skel.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/skel.c:	s->n_chan = thisboard->ai_chans;
./drivers/staging/comedi/drivers/skel.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/skel.c:	if (thisboard->have_dio) {
./drivers/staging/comedi/drivers/skel.c:		d ^= 1 << (thisboard->ai_bits - 1);
./drivers/staging/comedi/drivers/ni_670x.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ni_670x.c:	s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/dt3000.c:		if (cmd->scan_begin_arg < this_board->ai_speed) {
./drivers/staging/comedi/drivers/dt3000.c:			cmd->scan_begin_arg = this_board->ai_speed;
./drivers/staging/comedi/drivers/dt3000.c:		if (cmd->convert_arg < this_board->ai_speed) {
./drivers/staging/comedi/drivers/dt3000.c:			cmd->convert_arg = this_board->ai_speed;
./drivers/staging/comedi/drivers/dt3000.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/dt3000.c:	s->n_chan = this_board->adchan;
./drivers/staging/comedi/drivers/dt3000.c:	s->maxdata = (1 << this_board->adbits) - 1;
./drivers/staging/comedi/drivers/dt3000.c:	s->maxdata = (1 << this_board->dabits) - 1;
./drivers/staging/comedi/drivers/cb_pcidda.c:	printk("Found %s at requested position\n", thisboard->name);
./drivers/staging/comedi/drivers/cb_pcidda.c:	if (comedi_pci_enable(pcidev, thisboard->name)) {
./drivers/staging/comedi/drivers/cb_pcidda.c:	if (thisboard->status == 2)
./drivers/staging/comedi/drivers/cb_pcidda.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/cb_pcidda.c:	s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/cb_pcidda.c:	s->maxdata = (1 << thisboard->ao_bits) - 1;
./drivers/staging/comedi/drivers/cb_pcidda.c:	s->range_table = thisboard->ranges;
./drivers/staging/comedi/drivers/cb_pcidda.c:	for (index = 0; index < thisboard->ao_chans; index++)
./drivers/staging/comedi/drivers/poc.c:	       this_board->name, iobase);
./drivers/staging/comedi/drivers/poc.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/poc.c:	iosize = this_board->iosize;
./drivers/staging/comedi/drivers/poc.c:	if (alloc_private(dev, sizeof(unsigned int) * this_board->n_chan) < 0)
./drivers/staging/comedi/drivers/poc.c:	s->type = this_board->type;
./drivers/staging/comedi/drivers/poc.c:	s->n_chan = this_board->n_chan;
./drivers/staging/comedi/drivers/poc.c:	s->maxdata = (1 << this_board->n_bits) - 1;
./drivers/staging/comedi/drivers/poc.c:	s->range_table = this_board->range;
./drivers/staging/comedi/drivers/poc.c:	s->insn_write = this_board->winsn;
./drivers/staging/comedi/drivers/poc.c:	s->insn_read = this_board->rinsn;
./drivers/staging/comedi/drivers/poc.c:	s->insn_bits = this_board->insnbits;
./drivers/staging/comedi/drivers/poc.c:		release_region(dev->iobase, this_board->iosize);
./drivers/staging/comedi/drivers/cb_pcidas64.c:	DAC_WRITE_POLARITY_BIT = 0x800,	/* board-dependent setting */
./drivers/staging/comedi/drivers/cb_pcidas64.c:	DAC_UPDATE_POLARITY_BIT = 0x40,	/* board-dependent setting */
./drivers/staging/comedi/drivers/cb_pcidas64.c:	if (board->layout == LAYOUT_4020)
./drivers/staging/comedi/drivers/cb_pcidas64.c:	return board->ao_nchan && board->layout != LAYOUT_4020;
./drivers/staging/comedi/drivers/pcl730.c:	iorange = this_board->io_range;
./drivers/staging/comedi/drivers/pcl730.c:	       this_board->name, iobase);
./drivers/staging/comedi/drivers/pcl730.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcl730.c:		release_region(dev->iobase, this_board->io_range);
./drivers/staging/comedi/drivers/cb_pcimdas.c:	switch (thisboard->device_id) {
./drivers/staging/comedi/drivers/cb_pcimdas.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/cb_pcimdas.c:	s->n_chan = thisboard->ai_se_chans;
./drivers/staging/comedi/drivers/cb_pcimdas.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/cb_pcimdas.c:	s->n_chan = thisboard->ao_nchan;
./drivers/staging/comedi/drivers/cb_pcimdas.c:	s->maxdata = 1 << thisboard->ao_bits;
./drivers/staging/comedi/drivers/cb_pcimdas.c:	if (thisboard->has_dio)
./drivers/staging/comedi/drivers/cb_pcimdas.c:		maxchans = thisboard->ai_diff_chans;
./drivers/staging/comedi/drivers/cb_pcimdas.c:		maxchans = thisboard->ai_se_chans;
./drivers/staging/comedi/drivers/cb_pcimdas.c:		/* d ^= 1<<(thisboard->ai_bits-1); // 16 bit data from ADC, so no mangle needed. */
./drivers/staging/comedi/drivers/adl_pci6208.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/adl_pci6208.c:	s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/adl_pci6208.c:	/* switch(board->device_id) */
./drivers/staging/comedi/drivers/das08.c:  requires hard-wiring for async ai
./drivers/staging/comedi/drivers/das08.c:		if (thisboard->ai_nbits == 16)
./drivers/staging/comedi/drivers/das08.c:		if (thisboard->ai_encoding == das08_encode12) {
./drivers/staging/comedi/drivers/das08.c:		} else if (thisboard->ai_encoding == das08_pcm_encode12) {
./drivers/staging/comedi/drivers/das08.c:		} else if (thisboard->ai_encoding == das08_encode16) {
./drivers/staging/comedi/drivers/das08.c:	if ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {
./drivers/staging/comedi/drivers/das08.c:		if (!request_region(iobase, thisboard->iosize, DRV_NAME)) {
./drivers/staging/comedi/drivers/das08.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/das08.c:	if (thisboard->ai) {
./drivers/staging/comedi/drivers/das08.c:		s->maxdata = (1 << thisboard->ai_nbits) - 1;
./drivers/staging/comedi/drivers/das08.c:		s->range_table = das08_ai_lranges[thisboard->ai_pg];
./drivers/staging/comedi/drivers/das08.c:		s->insn_read = thisboard->ai;
./drivers/staging/comedi/drivers/das08.c:		devpriv->pg_gainlist = das08_gainlists[thisboard->ai_pg];
./drivers/staging/comedi/drivers/das08.c:	if (thisboard->ao) {
./drivers/staging/comedi/drivers/das08.c:		s->maxdata = (1 << thisboard->ao_nbits) - 1;
./drivers/staging/comedi/drivers/das08.c:		s->insn_write = thisboard->ao;
./drivers/staging/comedi/drivers/das08.c:	if (thisboard->di) {
./drivers/staging/comedi/drivers/das08.c:		s->n_chan = (thisboard->di == das08_di_rbits) ? 3 : 8;
./drivers/staging/comedi/drivers/das08.c:		s->insn_bits = thisboard->di;
./drivers/staging/comedi/drivers/das08.c:	if (thisboard->do_) {
./drivers/staging/comedi/drivers/das08.c:		s->n_chan = thisboard->do_nchan;
./drivers/staging/comedi/drivers/das08.c:		s->insn_bits = thisboard->do_;
./drivers/staging/comedi/drivers/das08.c:	if (thisboard->i8255_offset != 0) {
./drivers/staging/comedi/drivers/das08.c:							       thisboard->
./drivers/staging/comedi/drivers/das08.c:	if (thisboard->i8254_offset != 0) {
./drivers/staging/comedi/drivers/das08.c:		devpriv->i8254.iobase = iobase + thisboard->i8254_offset;
./drivers/staging/comedi/drivers/das08.c:	if (thisboard->bustype == pci) {
./drivers/staging/comedi/drivers/das08.c:	if ((thisboard->bustype != pcmcia) && (thisboard->bustype != pci)) {
./drivers/staging/comedi/drivers/das08.c:			release_region(dev->iobase, thisboard->iosize);
./drivers/staging/comedi/drivers/ni_pcidio.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/ni_pcidio.c:	if (this_board->uses_firmware) {
./drivers/staging/comedi/drivers/ni_pcidio.c:	if (!this_board->is_diodaq)
./drivers/staging/comedi/drivers/ni_pcidio.c:		n_subdevices = this_board->n_8255;
./drivers/staging/comedi/drivers/ni_pcidio.c:	if (!this_board->is_diodaq) {
./drivers/staging/comedi/drivers/ni_pcidio.c:		for (i = 0; i < this_board->n_8255; i++) {
./drivers/staging/comedi/drivers/ni_pcidio.c:	if (this_board && !this_board->is_diodaq) {
./drivers/staging/comedi/drivers/ni_pcidio.c:		for (i = 0; i < this_board->n_8255; i++)
./drivers/staging/comedi/drivers/adv_pci_dio.c:	switch (this_board->cardtype) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:	switch (this_board->io_access) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:	switch (this_board->io_access) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:	iobase = pci_resource_start(pcidev, this_board->main_pci_region);
./drivers/staging/comedi/drivers/adv_pci_dio.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/adv_pci_dio.c:	if (this_board->cardtype == TYPE_PCI1760) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:			if (this_board->sdi[i].chans)
./drivers/staging/comedi/drivers/adv_pci_dio.c:			if (this_board->sdo[i].chans)
./drivers/staging/comedi/drivers/adv_pci_dio.c:			n_subdevices += this_board->sdio[i].regs;
./drivers/staging/comedi/drivers/adv_pci_dio.c:		if (this_board->boardid.chans)
./drivers/staging/comedi/drivers/adv_pci_dio.c:			if (this_board->s8254[i].chans)
./drivers/staging/comedi/drivers/adv_pci_dio.c:		if (this_board->sdi[i].chans) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:			pci_dio_add_di(dev, s, &this_board->sdi[i], subdev);
./drivers/staging/comedi/drivers/adv_pci_dio.c:		if (this_board->sdo[i].chans) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:			pci_dio_add_do(dev, s, &this_board->sdo[i], subdev);
./drivers/staging/comedi/drivers/adv_pci_dio.c:		for (j = 0; j < this_board->sdio[i].regs; j++) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:					 this_board->sdio[i].addr +
./drivers/staging/comedi/drivers/adv_pci_dio.c:	if (this_board->boardid.chans) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:		pci_dio_add_di(dev, s, &this_board->boardid, subdev);
./drivers/staging/comedi/drivers/adv_pci_dio.c:		if (this_board->s8254[i].chans) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:			pci_dio_add_8254(dev, s, &this_board->s8254[i], subdev);
./drivers/staging/comedi/drivers/adv_pci_dio.c:	if (this_board->cardtype == TYPE_PCI1760)
./drivers/staging/comedi/drivers/adv_pci_dio.c:			if (this_board->sdi[i].chans)
./drivers/staging/comedi/drivers/adv_pci_dio.c:			if (this_board->sdo[i].chans)
./drivers/staging/comedi/drivers/adv_pci_dio.c:			for (j = 0; j < this_board->sdio[i].regs; j++) {
./drivers/staging/comedi/drivers/adv_pci_dio.c:		if (this_board->boardid.chans)
./drivers/staging/comedi/drivers/adv_pci_dio.c:			if (this_board->s8254[i].chans)
./drivers/staging/comedi/drivers/cb_pcimdda.c:#define REG_SZ (thisboard->reg_sz)
./drivers/staging/comedi/drivers/cb_pcimdda.c:#define REGS_BADRINDEX (thisboard->regs_badrindex)
./drivers/staging/comedi/drivers/cb_pcimdda.c:	printk("comedi%d: %s: ", dev->minor, thisboard->name);
./drivers/staging/comedi/drivers/cb_pcimdda.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/cb_pcimdda.c:	s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/cb_pcimdda.c:	s->maxdata = figure_out_maxdata(thisboard->ao_bits);
./drivers/staging/comedi/drivers/cb_pcimdda.c:	/* this is hard-coded here */
./drivers/staging/comedi/drivers/cb_pcimdda.c:	if (thisboard->dio_chans) {
./drivers/staging/comedi/drivers/cb_pcimdda.c:		switch (thisboard->dio_method) {
./drivers/staging/comedi/drivers/cb_pcimdda.c:			       thisboard->name);
./drivers/staging/comedi/drivers/cb_pcimdda.c:			if (comedi_pci_enable(pcidev, thisboard->name)) {
./drivers/staging/comedi/drivers/cb_pcimdda.c:			    = devpriv->registers + thisboard->dio_offset;
./drivers/staging/comedi/drivers/pcmmio.c:				       thisboard->total_iosize,
./drivers/staging/comedi/drivers/pcmmio.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/pcmmio.c:	chans_left = CHANS_PER_ASIC * thisboard->dio_num_asics;
./drivers/staging/comedi/drivers/pcmmio.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/pcmmio.c:	s->range_table = thisboard->ai_range_table;
./drivers/staging/comedi/drivers/pcmmio.c:	s->n_chan = thisboard->n_ai_chans;
./drivers/staging/comedi/drivers/pcmmio.c:	s->insn_read = thisboard->ai_rinsn;
./drivers/staging/comedi/drivers/pcmmio.c:	s->maxdata = (1 << thisboard->ao_bits) - 1;
./drivers/staging/comedi/drivers/pcmmio.c:	s->range_table = thisboard->ao_range_table;
./drivers/staging/comedi/drivers/pcmmio.c:	s->n_chan = thisboard->n_ao_chans;
./drivers/staging/comedi/drivers/pcmmio.c:	s->insn_read = thisboard->ao_rinsn;
./drivers/staging/comedi/drivers/pcmmio.c:	s->insn_write = thisboard->ao_winsn;
./drivers/staging/comedi/drivers/pcmmio.c:				   IRQF_SHARED, thisboard->name, dev)) {
./drivers/staging/comedi/drivers/pcmmio.c:		if (thisboard->dio_num_asics == 2 && irq[1])
./drivers/staging/comedi/drivers/pcmmio.c:		release_region(dev->iobase, thisboard->total_iosize);
./drivers/staging/comedi/drivers/pcmmio.c:	for (asic = 0; asic < thisboard->dio_num_asics; ++asic) {
./drivers/staging/comedi/drivers/pcmmio.c:	if (asic < 0 || asic >= thisboard->dio_num_asics)
./drivers/staging/comedi/drivers/pcmmio.c:	if (asic < 0 || asic >= thisboard->dio_num_asics)
./drivers/staging/comedi/drivers/pcmmio.c:	if (asic < 0 || asic >= thisboard->dio_num_asics)
./drivers/staging/comedi/drivers/ni_65xx.c:	return board->num_dio_ports + board->num_di_ports + board->num_do_ports;
./drivers/staging/comedi/drivers/me_daq.c:	dev->board_name = board->name;
./drivers/staging/comedi/drivers/me_daq.c:	if (board->device_id == ME2600_DEVICE_ID) {
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->n_chan = board->ai_channel_nbr;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->maxdata = board->ai_resolution_mask;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->len_chanlist = board->ai_channel_nbr;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->range_table = board->ai_range_list;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->n_chan = board->ao_channel_nbr;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->maxdata = board->ao_resolution_mask;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->len_chanlist = board->ao_channel_nbr;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->range_table = board->ao_range_list;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->n_chan = board->dio_channel_nbr;
./drivers/staging/comedi/drivers/me_daq.c:	subdevice->len_chanlist = board->dio_channel_nbr;
./drivers/staging/comedi/drivers/pcl726.c:	data[1] = inb(dev->iobase + this_board->di_lo) |
./drivers/staging/comedi/drivers/pcl726.c:	    (inb(dev->iobase + this_board->di_hi) << 8);
./drivers/staging/comedi/drivers/pcl726.c:		outb(s->state & 0xff, dev->iobase + this_board->do_lo);
./drivers/staging/comedi/drivers/pcl726.c:		outb((s->state >> 8), dev->iobase + this_board->do_hi);
./drivers/staging/comedi/drivers/pcl726.c:	iorange = this_board->io_range;
./drivers/staging/comedi/drivers/pcl726.c:	       this_board->name, iobase);
./drivers/staging/comedi/drivers/pcl726.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcl726.c:	s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/pcl726.c:	for (i = 0; i < this_board->n_aochan; i++) {
./drivers/staging/comedi/drivers/pcl726.c:		if ((j < 0) || (j >= this_board->num_of_ranges)) {
./drivers/staging/comedi/drivers/pcl726.c:			     i, j, this_board->num_of_ranges - 1);
./drivers/staging/comedi/drivers/pcl726.c:		devpriv->rangelist[i] = this_board->range_type_list[j];
./drivers/staging/comedi/drivers/pcl726.c:	if (!this_board->have_dio) {
./drivers/staging/comedi/drivers/pcl726.c:	if (!this_board->have_dio) {
./drivers/staging/comedi/drivers/pcl726.c:		release_region(dev->iobase, this_board->io_range);
./drivers/staging/comedi/drivers/jr3_pci.c:			switch (card->device) {
./drivers/staging/comedi/drivers/jr3_pci.c:				} else if (opt_bus == card->bus->number &&
./drivers/staging/comedi/drivers/jr3_pci.c:					   opt_slot == PCI_SLOT(card->devfn)) {
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c:		if ((this_board->b_AvailableConvertUnit & (1 << b_TimeBase)) !=
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c:							&& (this_board->i_NbrAiChannelDiff == 0))
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3xxx.c:			|| ((b_Channel < this_board->i_NbrAiChannelDiff)
./drivers/staging/comedi/drivers/addi-data/addi_eeprom.c:			if (!(strcmp(this_board->pc_DriverName, "apci3200")))
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci16xx.c:		(unsigned char) (this_board->i_NbrTTLChannel / 8);
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci16xx.c:		(unsigned char) (this_board->i_NbrTTLChannel / 8);
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci16xx.c:			(unsigned char) (this_board->i_NbrTTLChannel / 32);
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci16xx.c:			this_board->i_NbrTTLChannel) {
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci16xx.c:		(unsigned char) (this_board->i_NbrTTLChannel / 8);
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		v_pci_card_list_init(this_board->i_VendorId, 1);	/* 1 for displaying the list.. */
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	/* printk("comedi%d: "ADDIDATA_DRIVER_NAME": board=%s",dev->minor,this_board->pc_DriverName); */
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	if ((this_board->i_Dma) && (it->options[2] == 0)) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	card = ptr_select_and_alloc_pci_card(this_board->i_VendorId,
./drivers/staging/comedi/drivers/addi-data/addi_common.c:					     this_board->i_DeviceId,
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	if ((this_board->pc_EepromChip == NULL)
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		|| (strcmp(this_board->pc_EepromChip, ADDIDATA_9054) != 0)) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		if (this_board->i_IorangeBase1 != 0) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		dev->board_name = this_board->pc_DriverName;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		dev->board_name = this_board->pc_DriverName;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:					     this_board->i_IorangeBase3);
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_NbrAiChannel = this_board->i_NbrAiChannel;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_NbrAoChannel = this_board->i_NbrAoChannel;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_AiMaxdata = this_board->i_AiMaxdata;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_AoMaxdata = this_board->i_AoMaxdata;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_NbrDiChannel = this_board->i_NbrDiChannel;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_NbrDoChannel = this_board->i_NbrDoChannel;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_DoMaxdata = this_board->i_DoMaxdata;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_Dma = this_board->i_Dma;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	devpriv->s_EeParameters.i_Timer = this_board->i_Timer;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		this_board->ui_MinAcquisitiontimeNs;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		this_board->ui_MinDelaytimeNs;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->pc_DriverName, dev) < 0) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	if (this_board->i_PCIEeprom) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		if (!(strcmp(this_board->pc_EepromChip, "S5920"))) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			if (!(strcmp(this_board->pc_DriverName, "apci035"))) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		i_EepromReadMainHeader(io_addr[0], this_board->pc_EepromChip,
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	if (!strcmp(this_board->pc_DriverName, "apci1710")) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			|| (this_board->i_NbrAiChannelDiff)) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				s->n_chan = this_board->i_NbrAiChannelDiff;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->len_chanlist = this_board->i_AiChannelList;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->range_table = this_board->pr_AiRangelist;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnConfigAnalogInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_read = this_board->i_hwdrv_InsnReadAnalogInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnWriteAnalogInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_bits = this_board->i_hwdrv_InsnBitsAnalogInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_CommandTestAnalogInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->do_cmd = this_board->i_hwdrv_CommandAnalogInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->cancel = this_board->i_hwdrv_CancelAnalogInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->range_table = this_board->pr_AoRangelist;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnConfigAnalogOutput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnWriteAnalogOutput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnConfigDigitalInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_read = this_board->i_hwdrv_InsnReadDigitalInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnWriteDigitalInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_bits = this_board->i_hwdrv_InsnBitsDigitalInput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_config = this_board->i_hwdrv_InsnConfigDigitalOutput;	/* for digital output memory.. */
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnWriteDigitalOutput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnBitsDigitalOutput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:				this_board->i_hwdrv_InsnReadDigitalOutput;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_write = this_board->i_hwdrv_InsnWriteTimer;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_read = this_board->i_hwdrv_InsnReadTimer;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_config = this_board->i_hwdrv_InsnConfigTimer;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_bits = this_board->i_hwdrv_InsnBitsTimer;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		if (this_board->i_NbrTTLChannel) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->n_chan = this_board->i_NbrTTLChannel;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->len_chanlist = this_board->i_NbrTTLChannel;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_config = this_board->i_hwdr_ConfigInitTTLIO;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_bits = this_board->i_hwdr_ReadTTLIOBits;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_read = this_board->i_hwdr_ReadTTLIOAllPortValue;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			s->insn_write = this_board->i_hwdr_WriteTTLIOChlOnOff;
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		if (this_board->i_PCIEeprom) {
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		if ((this_board->pc_EepromChip == NULL)
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			|| (strcmp(this_board->pc_EepromChip,
./drivers/staging/comedi/drivers/addi-data/addi_common.c:			v_pci_card_list_cleanup(this_board->i_VendorId);
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	this_board->i_hwdrv_Reset(dev);
./drivers/staging/comedi/drivers/addi-data/addi_common.c:	this_board->v_hwdrv_Interrupt(irq, d);
./drivers/staging/comedi/drivers/addi-data/addi_common.c:		this_board->pc_EepromChip, 0x100 + (2 * w_Address));
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	/*  this_board->i_hwdrv_InsnReadAnalogInput(dev,us_ConvertTiming,insn->n,&insn->chanspec,data,insn->unused[0]); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:			|| !strcmp(this_board->pc_DriverName, "apci3001")) {
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	if (cmd->chanlist_len > this_board->i_AiChannelList) {
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:		cmd->chanlist_len = this_board->i_AiChannelList;
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:			/* return this_board->i_hwdrv_CommandAnalogInput(1,dev,s); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:		/* return this_board->i_hwdrv_CommandAnalogInput(2,dev,s); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:		|| !strcmp(this_board->pc_DriverName, "apci3001")) {
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	/* this_board->i_hwdrv_InsnConfigTimer(dev, ui_Timervalue2,(unsigned char)data[0]); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:		|| !strcmp(this_board->pc_DriverName, "apci3001")) {
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	/* this_board->i_hwdrv_InsnWriteTimer(dev,data[0],ui_Timervalue2); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:			|| !strcmp(this_board->pc_DriverName, "apci3001")) {
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	/* this_board->i_hwdrv_InsnReadTimer(dev,data); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	/* this_board->i_hwdrv_InsnReadDigitalInput(dev,ui_Chan,data); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	/* this_board->i_hwdrv_InsnBitsDigitalInput(dev,data); */
./drivers/staging/comedi/drivers/addi-data/hwdrv_apci3120.c:	/* this_board->i_hwdrv_InsnWriteAnalogOutput(dev, ui_Range, ui_Channel,data[0]); */
./drivers/staging/comedi/drivers/amplc_pc263.c:		if (thisboard->model == anypci_model) {
./drivers/staging/comedi/drivers/amplc_pc263.c:			if (pci_dev->device != thisboard->devid)
./drivers/staging/comedi/drivers/amplc_pc263.c:		       dev->minor, thisboard->name, bus, slot);
./drivers/staging/comedi/drivers/amplc_pc263.c:		       dev->minor, thisboard->name);
./drivers/staging/comedi/drivers/amplc_pc263.c:	switch (thisboard->bustype) {
./drivers/staging/comedi/drivers/amplc_pc263.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/amplc_pc263.c:	if (thisboard->bustype == isa_bustype) {
./drivers/staging/comedi/drivers/ni_6527.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size > 0x400)
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size > 0x400)
./drivers/staging/comedi/drivers/das16.c:		    thisboard->ai_speed * cmd->chanlist_len) {
./drivers/staging/comedi/drivers/das16.c:			    thisboard->ai_speed * cmd->chanlist_len;
./drivers/staging/comedi/drivers/das16.c:		if (cmd->convert_arg < thisboard->ai_speed) {
./drivers/staging/comedi/drivers/das16.c:			cmd->convert_arg = thisboard->ai_speed;
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size > 0x400)
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->ai_pg != das16_pg_none) {
./drivers/staging/comedi/drivers/das16.c:		outb((das16_gainlists[thisboard->ai_pg])[range],
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size > 0x400) {
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size > 0x400)
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size > 0x400)
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->ai_pg != das16_pg_none) {
./drivers/staging/comedi/drivers/das16.c:		outb((das16_gainlists[thisboard->ai_pg])[range],
./drivers/staging/comedi/drivers/das16.c:		if (thisboard->ai_nbits == 12)
./drivers/staging/comedi/drivers/das16.c:		if (thisboard->ao_nbits == 12) {
./drivers/staging/comedi/drivers/das16.c:		if (thisboard->size > 0x400 && devpriv->timer_mode == 0)
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->id != diobits) {
./drivers/staging/comedi/drivers/das16.c:		       thisboard->id);
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size < 0x400) {
./drivers/staging/comedi/drivers/das16.c:		printk(" 0x%04lx-0x%04lx\n", iobase, iobase + thisboard->size);
./drivers/staging/comedi/drivers/das16.c:		if (!request_region(iobase, thisboard->size, "das16")) {
./drivers/staging/comedi/drivers/das16.c:		       iobase + 0x400 + (thisboard->size & 0x3ff));
./drivers/staging/comedi/drivers/das16.c:		if (!request_region(iobase + 0x400, thisboard->size & 0x3ff,
./drivers/staging/comedi/drivers/das16.c:			       iobase + 0x400 + (thisboard->size & 0x3ff));
./drivers/staging/comedi/drivers/das16.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size < 0x400) {
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->ai_pg == das16_pg_none &&
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->ai) {
./drivers/staging/comedi/drivers/das16.c:		s->maxdata = (1 << thisboard->ai_nbits) - 1;
./drivers/staging/comedi/drivers/das16.c:			s->range_table = das16_ai_uni_lranges[thisboard->ai_pg];
./drivers/staging/comedi/drivers/das16.c:			s->range_table = das16_ai_bip_lranges[thisboard->ai_pg];
./drivers/staging/comedi/drivers/das16.c:		s->insn_read = thisboard->ai;
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->ao) {
./drivers/staging/comedi/drivers/das16.c:		s->maxdata = (1 << thisboard->ao_nbits) - 1;
./drivers/staging/comedi/drivers/das16.c:		s->insn_write = thisboard->ao;
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->di) {
./drivers/staging/comedi/drivers/das16.c:		s->insn_bits = thisboard->di;
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->do_) {
./drivers/staging/comedi/drivers/das16.c:		s->insn_bits = thisboard->do_;
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->i8255_offset != 0) {
./drivers/staging/comedi/drivers/das16.c:						thisboard->i8255_offset));
./drivers/staging/comedi/drivers/das16.c:	if (thisboard->size > 0x400) {
./drivers/staging/comedi/drivers/das16.c:		if (thisboard->size < 0x400) {
./drivers/staging/comedi/drivers/das16.c:			release_region(dev->iobase, thisboard->size);
./drivers/staging/comedi/drivers/das16.c:				       thisboard->size & 0x3ff);
./drivers/staging/comedi/drivers/das16.c:		if (thisboard->ai_nbits == 12)
./drivers/staging/comedi/drivers/ni_daq_700.c: *     Driver for DAQCard-700 DIO only
./drivers/staging/comedi/drivers/ni_daq_700.c:Description: National Instruments PCMCIA DAQCard-700 DIO only
./drivers/staging/comedi/drivers/ni_daq_700.c:Devices: [National Instruments] PCMCIA DAQ-Card-700 (ni_daq_700)
./drivers/staging/comedi/drivers/ni_daq_700.c:The daqcard-700 appears in Comedi as a single digital I/O subdevice with
./drivers/staging/comedi/drivers/ni_daq_700.c:16 channels.  The channel 0 corresponds to the daqcard-700's output
./drivers/staging/comedi/drivers/ni_daq_700.c:	int have_dio;		/*  have daqcard-700 dio */
./drivers/staging/comedi/drivers/ni_daq_700.c:	 .name = "daqcard-700",
./drivers/staging/comedi/drivers/ni_daq_700.c:	switch (thisboard->bustype) {
./drivers/staging/comedi/drivers/ni_daq_700.c:	       thisboard->name, iobase);
./drivers/staging/comedi/drivers/ni_daq_700.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ni_daq_700.c:	/* DAQCard-700 dio */
./drivers/staging/comedi/drivers/ni_daq_700.c:	if (thisboard->bustype != pcmcia_bustype && dev->iobase)
./drivers/staging/comedi/drivers/ni_daq_700.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x4743),	/* daqcard-700 */
./drivers/staging/comedi/drivers/ni_daq_700.c:		   "PCMCIA DAQCard-700 DIO");
./drivers/staging/comedi/drivers/ni_labpc_cs.c:    Driver for National Instruments daqcard-1200 boards
./drivers/staging/comedi/drivers/ni_labpc_cs.c:Devices: [National Instruments] DAQCard-1200 (daqcard-1200)
./drivers/staging/comedi/drivers/ni_labpc_cs.c:helping to debug daqcard-1200 support.
./drivers/staging/comedi/drivers/ni_labpc_cs.c:The daqcard-1200 has quirky chanlist requirements
./drivers/staging/comedi/drivers/ni_labpc_cs.c:340988a (daqcard-1200)
./drivers/staging/comedi/drivers/ni_labpc_cs.c:	 .name = "daqcard-1200",
./drivers/staging/comedi/drivers/ni_labpc_cs.c:	switch (thisboard->bustype) {
./drivers/staging/comedi/drivers/ni_labpc_cs.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x0103),	/* daqcard-1200 */
./drivers/staging/comedi/drivers/ni_labpc_cs.c:	.name = "daqcard-1200",
./drivers/staging/comedi/drivers/daqboard2000.c:			if (card->bus->number != bus ||
./drivers/staging/comedi/drivers/daqboard2000.c:			    PCI_SLOT(card->devfn) != slot) {
./drivers/staging/comedi/drivers/daqboard2000.c:		id = ((u32) card->
./drivers/staging/comedi/drivers/daqboard2000.c:		      subsystem_device << 16) | card->subsystem_vendor;
./drivers/staging/comedi/drivers/daqboard2000.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/ni_at_a2150.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ni_at_a2150.c:		if (cmd->convert_arg < thisboard->ai_speed) {
./drivers/staging/comedi/drivers/ni_at_a2150.c:			cmd->convert_arg = thisboard->ai_speed;
./drivers/staging/comedi/drivers/ni_at_a2150.c:	lub = thisboard->clock[lub_index] * (1 << lub_divisor_shift);
./drivers/staging/comedi/drivers/ni_at_a2150.c:	glb_index = thisboard->num_clocks - 1;
./drivers/staging/comedi/drivers/ni_at_a2150.c:	glb = thisboard->clock[glb_index] * (1 << glb_divisor_shift);
./drivers/staging/comedi/drivers/ni_at_a2150.c:		for (j = 0; j < thisboard->num_clocks; j++) {
./drivers/staging/comedi/drivers/ni_at_a2150.c:			temp = thisboard->clock[j] * (1 << i);
./drivers/staging/comedi/drivers/pcmad.c:			data[n] ^= (1 << (this_board->n_ai_bits - 1));
./drivers/staging/comedi/drivers/pcmad.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcmad.c:	s->maxdata = (1 << this_board->n_ai_bits) - 1;
./drivers/staging/comedi/drivers/mpc8260cpm.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/adq12b.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/adq12b.c:		s->n_chan = thisboard->ai_diff_chans;
./drivers/staging/comedi/drivers/adq12b.c:		s->n_chan = thisboard->ai_se_chans;
./drivers/staging/comedi/drivers/adq12b.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/adq12b.c:	s->n_chan = thisboard->di_chans;
./drivers/staging/comedi/drivers/adq12b.c:	s->n_chan = thisboard->do_chans;
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (this_board->cardtype != TYPE_PCI1713)
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (this_board->cardtype != TYPE_PCI1713)
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (this_board->cardtype != TYPE_PCI1713)
./drivers/staging/comedi/drivers/adv_pci1710.c:	samplesinbuf = this_board->fifo_half_size;
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (devpriv->ai_timer1 < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/adv_pci1710.c:			devpriv->ai_timer1 = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (cmd->convert_arg < this_board->ai_ns_min) {
./drivers/staging/comedi/drivers/adv_pci1710.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (cmd->convert_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/adv_pci1710.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/adv_pci1710.c:		range = this_board->rangecode_ai[CR_RANGE(chanlist[i])];
./drivers/staging/comedi/drivers/adv_pci1710.c:	switch (this_board->cardtype) {
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_aochan) {
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (this_board->n_aochan > 1) {
./drivers/staging/comedi/drivers/adv_pci1710.c:	switch (this_board->cardtype) {
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (strcmp(this_board->name, DRV_NAME) == 0) {
./drivers/staging/comedi/drivers/adv_pci1710.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_aichan)
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_aochan)
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_dichan)
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_dochan)
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_counter)
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->have_irq) {
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_aichan) {
./drivers/staging/comedi/drivers/adv_pci1710.c:		if (this_board->n_aichand)
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->maxdata = this_board->ai_maxdata;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->len_chanlist = this_board->n_aichan;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->range_table = this_board->rangelist_ai;
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_aochan) {
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->maxdata = this_board->ao_maxdata;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->len_chanlist = this_board->n_aochan;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->range_table = this_board->rangelist_ao;
./drivers/staging/comedi/drivers/adv_pci1710.c:		switch (this_board->cardtype) {
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_dichan) {
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->n_chan = this_board->n_dichan;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->len_chanlist = this_board->n_dichan;
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_dochan) {
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->n_chan = this_board->n_dochan;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->len_chanlist = this_board->n_dochan;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->io_bits = (1 << this_board->n_dochan) - 1;
./drivers/staging/comedi/drivers/adv_pci1710.c:	if (this_board->n_counter) {
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->n_chan = this_board->n_counter;
./drivers/staging/comedi/drivers/adv_pci1710.c:		s->len_chanlist = this_board->n_counter;
./drivers/staging/comedi/drivers/ii_pci20kc.c:						/* comedi-data -> board-data */
./drivers/staging/comedi/drivers/ii_pci20kc.c:		/* board-data -> comedi-data */
./drivers/staging/comedi/drivers/pcmuio.c:A driver for the relatively straightforward-to-program PCM-UIO48A and
./drivers/staging/comedi/drivers/pcmuio.c:				       thisboard->num_asics * ASIC_IOSIZE,
./drivers/staging/comedi/drivers/pcmuio.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/pcmuio.c:	chans_left = CHANS_PER_ASIC * thisboard->num_asics;
./drivers/staging/comedi/drivers/pcmuio.c:				   IRQF_SHARED, thisboard->name, dev)) {
./drivers/staging/comedi/drivers/pcmuio.c:		if (irq[1] && thisboard->num_asics == 2)
./drivers/staging/comedi/drivers/pcmuio.c:		release_region(dev->iobase, ASIC_IOSIZE * thisboard->num_asics);
./drivers/staging/comedi/drivers/pcmuio.c:	for (asic = 0; asic < thisboard->num_asics; ++asic) {
./drivers/staging/comedi/drivers/pcmuio.c:	if (asic < 0 || asic >= thisboard->num_asics)
./drivers/staging/comedi/drivers/pcmuio.c:	if (asic < 0 || asic >= thisboard->num_asics)
./drivers/staging/comedi/drivers/pcmuio.c:	if (asic < 0 || asic >= thisboard->num_asics)
./drivers/staging/comedi/drivers/acl7225b.c:	iorange = this_board->io_range;
./drivers/staging/comedi/drivers/acl7225b.c:	       this_board->name, iobase);
./drivers/staging/comedi/drivers/acl7225b.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/acl7225b.c:		release_region(dev->iobase, this_board->io_range);
./drivers/staging/comedi/drivers/amplc_pci230.c:	data = data >> (16 - thisboard->ai_bits);
./drivers/staging/comedi/drivers/amplc_pci230.c:		data ^= 1 << (thisboard->ai_bits - 1);
./drivers/staging/comedi/drivers/amplc_pci230.c:		datum ^= 1 << (thisboard->ao_bits - 1);
./drivers/staging/comedi/drivers/amplc_pci230.c:	datum <<= (16 - thisboard->ao_bits);
./drivers/staging/comedi/drivers/amplc_pci230.c:	       thisboard->name, it->options[0], it->options[1]);
./drivers/staging/comedi/drivers/amplc_pci230.c:		if (thisboard->id == PCI_DEVICE_ID_INVALID) {
./drivers/staging/comedi/drivers/amplc_pci230.c:			if (thisboard->id == pci_dev->device) {
./drivers/staging/comedi/drivers/amplc_pci230.c:				if (thisboard->min_hwver > 0) {
./drivers/staging/comedi/drivers/amplc_pci230.c:		       thisboard->name);
./drivers/staging/comedi/drivers/amplc_pci230.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/amplc_pci230.c:		if (devpriv->hwver < thisboard->min_hwver) {
./drivers/staging/comedi/drivers/amplc_pci230.c:			       thisboard->min_hwver);
./drivers/staging/comedi/drivers/amplc_pci230.c:			if (!thisboard->have_dio) {
./drivers/staging/comedi/drivers/amplc_pci230.c:			if ((thisboard->ao_chans > 0)
./drivers/staging/comedi/drivers/amplc_pci230.c:	s->n_chan = thisboard->ai_chans;
./drivers/staging/comedi/drivers/amplc_pci230.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/amplc_pci230.c:	if (thisboard->ao_chans > 0) {
./drivers/staging/comedi/drivers/amplc_pci230.c:		s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/amplc_pci230.c:		s->maxdata = (1 << thisboard->ao_bits) - 1;
./drivers/staging/comedi/drivers/amplc_pci230.c:		s->len_chanlist = thisboard->ao_chans;
./drivers/staging/comedi/drivers/amplc_pci230.c:	if (thisboard->have_dio) {
./drivers/staging/comedi/drivers/amplc_pci230.c:	if (dev->subdevices && thisboard->have_dio)
./drivers/staging/comedi/drivers/amplc_pci230.c:	if ((thisboard->min_hwver > 0) && (devpriv->hwver >= 2)) {
./drivers/staging/comedi/drivers/amplc_pci230.c:		 * version).  They should only depend on thisboard->min_hwver
./drivers/staging/comedi/drivers/amplc_pci230.c:	if ((thisboard->have_dio) || (thisboard->min_hwver > 0)) {
./drivers/staging/comedi/drivers/amplc_dio200.c:		if (thisboard->model == anypci_model) {
./drivers/staging/comedi/drivers/amplc_dio200.c:			if (pci_dev->device != thisboard->devid)
./drivers/staging/comedi/drivers/amplc_dio200.c:		       dev->minor, thisboard->name, bus, slot);
./drivers/staging/comedi/drivers/amplc_dio200.c:		       dev->minor, thisboard->name);
./drivers/staging/comedi/drivers/amplc_dio200.c:	switch (thisboard->bustype) {
./drivers/staging/comedi/drivers/amplc_dio200.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/amplc_dio200.c:	if (thisboard->bustype == isa_bustype) {
./drivers/staging/comedi/drivers/me4000.c:	if (thisboard->ai.count) {
./drivers/staging/comedi/drivers/me4000.c:		s->n_chan = thisboard->ai.count;
./drivers/staging/comedi/drivers/me4000.c:	if (thisboard->ao.count) {
./drivers/staging/comedi/drivers/me4000.c:		s->n_chan = thisboard->ao.count;
./drivers/staging/comedi/drivers/me4000.c:	if (thisboard->dio.count) {
./drivers/staging/comedi/drivers/me4000.c:		s->n_chan = thisboard->dio.count * 8;
./drivers/staging/comedi/drivers/me4000.c:	if (thisboard->cnt.count) {
./drivers/staging/comedi/drivers/me4000.c:		s->n_chan = thisboard->cnt.count;
./drivers/staging/comedi/drivers/me4000.c:	dev->board_name = board->name;
./drivers/staging/comedi/drivers/me4000.c:	for (i = 0; i < thisboard->ao.count; i++) {
./drivers/staging/comedi/drivers/me4000.c:		if (chan >= thisboard->ai.count) {
./drivers/staging/comedi/drivers/me4000.c:		if (chan >= thisboard->ai.diff_count) {
./drivers/staging/comedi/drivers/me4000.c:			    thisboard->ai.diff_count) {
./drivers/staging/comedi/drivers/me4000.c:			if (CR_CHAN(cmd->chanlist[i]) >= thisboard->ai.count) {
./drivers/staging/comedi/drivers/me4000.c:	if (chan >= thisboard->ao.count) {
./drivers/staging/comedi/drivers/cb_pcidio.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/cb_pcidio.c:	printk("Found %s on bus %i, slot %i\n", thisboard->name,
./drivers/staging/comedi/drivers/cb_pcidio.c:	if (comedi_pci_enable(pcidev, thisboard->name)) {
./drivers/staging/comedi/drivers/cb_pcidio.c:	if (alloc_subdevices(dev, thisboard->n_8255) < 0)
./drivers/staging/comedi/drivers/cb_pcidio.c:	for (i = 0; i < thisboard->n_8255; i++) {
./drivers/staging/comedi/drivers/cb_pcidio.c:		for (i = 0; i < thisboard->n_8255; i++)
./drivers/staging/comedi/drivers/adl_pci9111.c:	if (cmd->chanlist_len > board->ai_channel_nbr) {
./drivers/staging/comedi/drivers/adl_pci9111.c:		cmd->chanlist_len = board->ai_channel_nbr;
./drivers/staging/comedi/drivers/adl_pci9111.c:	    (cmd->convert_arg < board->ai_acquisition_period_min_ns)) {
./drivers/staging/comedi/drivers/adl_pci9111.c:		cmd->convert_arg = board->ai_acquisition_period_min_ns;
./drivers/staging/comedi/drivers/adl_pci9111.c:	    (cmd->scan_begin_arg < board->ai_acquisition_period_min_ns)) {
./drivers/staging/comedi/drivers/adl_pci9111.c:		cmd->scan_begin_arg = board->ai_acquisition_period_min_ns;
./drivers/staging/comedi/drivers/adl_pci9111.c:			     (board->ai_channel_nbr - 1))
./drivers/staging/comedi/drivers/adl_pci9111.c:	dev->board_name = board->name;
./drivers/staging/comedi/drivers/adl_pci9111.c:	/*     else { subdevice->n_chan = this_board->n_aichan; } */
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->n_chan = board->ai_channel_nbr;
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->maxdata = board->ai_resolution_mask;
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->len_chanlist = board->ai_channel_nbr;
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->range_table = board->ai_range_list;
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->n_chan = board->ao_channel_nbr;
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->maxdata = board->ao_resolution_mask;
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->len_chanlist = board->ao_channel_nbr;
./drivers/staging/comedi/drivers/adl_pci9111.c:	subdevice->range_table = board->ao_range_list;
./drivers/staging/comedi/drivers/pcmda12.c:A driver for the relatively straightforward-to-program PCM-D/A-12.
./drivers/staging/comedi/drivers/pcmda12.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ssv_dnp.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/pcl816.c:		if (cmd->convert_arg < this_board->ai_ns_min) {
./drivers/staging/comedi/drivers/pcl816.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/pcl816.c:		i8253_cascade_ns_to_timer(this_board->i8254_osc_base,
./drivers/staging/comedi/drivers/pcl816.c:		if (cmd->convert_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/pcl816.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/pcl816.c:		if (cmd->convert_arg < this_board->ai_ns_min)
./drivers/staging/comedi/drivers/pcl816.c:			cmd->convert_arg = this_board->ai_ns_min;
./drivers/staging/comedi/drivers/pcl816.c:		i8253_cascade_ns_to_timer(this_board->i8254_osc_base, &divisor1,
./drivers/staging/comedi/drivers/pcl816.c:		release_region(dev->iobase, this_board->io_range);
./drivers/staging/comedi/drivers/pcl816.c:	       this_board->name, iobase);
./drivers/staging/comedi/drivers/pcl816.c:	if (!request_region(iobase, this_board->io_range, "pcl816")) {
./drivers/staging/comedi/drivers/pcl816.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcl816.c:	if (this_board->IRQbits != 0) {	/* board support IRQ */
./drivers/staging/comedi/drivers/pcl816.c:			if (((1 << irq) & this_board->IRQbits) == 0) {
./drivers/staging/comedi/drivers/pcl816.c:	if (this_board->DMAbits != 0) {	/* board support DMA */
./drivers/staging/comedi/drivers/pcl816.c:		if (((1 << dma) & this_board->DMAbits) == 0) {
./drivers/staging/comedi/drivers/pcl816.c:/*  if (this_board->n_aochan > 0)
./drivers/staging/comedi/drivers/pcl816.c:  if (this_board->n_dichan > 0)
./drivers/staging/comedi/drivers/pcl816.c:  if (this_board->n_dochan > 0)
./drivers/staging/comedi/drivers/pcl816.c:	if (this_board->n_aichan > 0) {
./drivers/staging/comedi/drivers/pcl816.c:		s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/pcl816.c:		s->maxdata = this_board->ai_maxdata;
./drivers/staging/comedi/drivers/pcl816.c:		s->len_chanlist = this_board->ai_chanlist;
./drivers/staging/comedi/drivers/pcl816.c:		s->range_table = this_board->ai_range_type;
./drivers/staging/comedi/drivers/pcl816.c:	s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/pcl816.c:	s->maxdata = this_board->ao_maxdata;
./drivers/staging/comedi/drivers/pcl816.c:	s->len_chanlist = this_board->ao_chanlist;
./drivers/staging/comedi/drivers/pcl816.c:	s->range_table = this_board->ao_range_type;
./drivers/staging/comedi/drivers/pcl816.c:	s->n_chan = this_board->n_dichan;
./drivers/staging/comedi/drivers/pcl816.c:	s->len_chanlist = this_board->n_dichan;
./drivers/staging/comedi/drivers/pcl816.c:	s->n_chan = this_board->n_dochan;
./drivers/staging/comedi/drivers/pcl816.c:	s->len_chanlist = this_board->n_dochan;
./drivers/staging/comedi/drivers/das08_cs.c:	if (thisboard->bustype == pcmcia) {
./drivers/staging/comedi/drivers/contec_pci_dio.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/contec_pci_dio.c:		       dev->iobase + thisboard->out_offs);
./drivers/staging/comedi/drivers/contec_pci_dio.c:		outw(s->state, dev->iobase + thisboard->out_offs);
./drivers/staging/comedi/drivers/contec_pci_dio.c:	data[1] = inw(dev->iobase + thisboard->in_offs);
./drivers/staging/comedi/drivers/cb_pcidas.c:	if (thisboard->ao_nchan) {
./drivers/staging/comedi/drivers/cb_pcidas.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/cb_pcidas.c:	s->n_chan = thisboard->ai_se_chans;
./drivers/staging/comedi/drivers/cb_pcidas.c:	s->len_chanlist = thisboard->ai_se_chans;
./drivers/staging/comedi/drivers/cb_pcidas.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/cb_pcidas.c:	s->range_table = thisboard->ranges;
./drivers/staging/comedi/drivers/cb_pcidas.c:	if (thisboard->ao_nchan) {
./drivers/staging/comedi/drivers/cb_pcidas.c:		s->n_chan = thisboard->ao_nchan;
./drivers/staging/comedi/drivers/cb_pcidas.c:		s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/cb_pcidas.c:		if (thisboard->has_ao_fifo) {
./drivers/staging/comedi/drivers/cb_pcidas.c:	if (thisboard->trimpot == AD7376) {
./drivers/staging/comedi/drivers/cb_pcidas.c:	if (thisboard->has_dac08) {
./drivers/staging/comedi/drivers/cb_pcidas.c:	switch (thisboard->trimpot) {
./drivers/staging/comedi/drivers/cb_pcidas.c:		if (!thisboard->has_ai_trig_invert &&
./drivers/staging/comedi/drivers/cb_pcidas.c:		    thisboard->ai_speed * cmd->chanlist_len) {
./drivers/staging/comedi/drivers/cb_pcidas.c:			    thisboard->ai_speed * cmd->chanlist_len;
./drivers/staging/comedi/drivers/cb_pcidas.c:		if (cmd->convert_arg < thisboard->ai_speed) {
./drivers/staging/comedi/drivers/cb_pcidas.c:			cmd->convert_arg = thisboard->ai_speed;
./drivers/staging/comedi/drivers/cb_pcidas.c:		if (thisboard->has_ai_trig_invert
./drivers/staging/comedi/drivers/cb_pcidas.c:		if (thisboard->has_ai_trig_gated && (cmd->start_arg & CR_EDGE))
./drivers/staging/comedi/drivers/cb_pcidas.c:		if (cmd->scan_begin_arg < thisboard->ao_scan_speed) {
./drivers/staging/comedi/drivers/cb_pcidas.c:			cmd->scan_begin_arg = thisboard->ao_scan_speed;
./drivers/staging/comedi/drivers/cb_pcidas.c:	unsigned int num_bytes, num_points = thisboard->fifo_size;
./drivers/staging/comedi/drivers/cb_pcidas.c:	int half_fifo = thisboard->fifo_size / 2;
./drivers/staging/comedi/drivers/cb_pcidas.c:	unsigned int half_fifo = thisboard->fifo_size / 2;
./drivers/staging/comedi/drivers/comedi_test.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/comedi_test.c:	s->n_chan = thisboard->ai_chans;
./drivers/staging/comedi/drivers/comedi_test.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/comedi_test.c:	s->n_chan = thisboard->ai_chans;
./drivers/staging/comedi/drivers/comedi_test.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/pcl724.c:	iorange = this_board->io_range;
./drivers/staging/comedi/drivers/pcl724.c:	if ((this_board->can_have96) && ((it->options[1] == 1)
./drivers/staging/comedi/drivers/pcl724.c:	       this_board->name, iobase);
./drivers/staging/comedi/drivers/pcl724.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/pcl724.c:	if (this_board->IRQbits != 0) {	/* board support IRQ */
./drivers/staging/comedi/drivers/pcl724.c:			if (((1 << irq) & this_board->IRQbits) == 0) {
./drivers/staging/comedi/drivers/pcl724.c:	n_subdevices = this_board->numofports;
./drivers/staging/comedi/drivers/pcl724.c:	if ((this_board->can_have96) && ((it->options[1] == 1)
./drivers/staging/comedi/drivers/pcl724.c:		if (this_board->is_pet48) {
./drivers/staging/comedi/drivers/pcl724.c:	release_region(dev->iobase, this_board->io_range);
./drivers/staging/comedi/drivers/ke_counter.c:	       board->name, pci_device->bus->number,
./drivers/staging/comedi/drivers/ke_counter.c:	dev->board_name = board->name;
./drivers/staging/comedi/drivers/ke_counter.c:	subdevice->n_chan = board->cnt_channel_nbr;
./drivers/staging/comedi/drivers/ke_counter.c:	subdevice->maxdata = (1 << board->cnt_bits) - 1;
./drivers/staging/comedi/drivers/ni_mio_cs.c:Devices: [National Instruments] DAQCard-AI-16XE-50 (ni_mio_cs),
./drivers/staging/comedi/drivers/ni_mio_cs.c:  DAQCard-AI-16E-4, DAQCard-6062E, DAQCard-6024E, DAQCard-6036E
./drivers/staging/comedi/drivers/ni_mio_cs.c:	 .name = "DAQCard-ai-16xe-50",
./drivers/staging/comedi/drivers/ni_mio_cs.c:	 .name = "DAQCard-ai-16e-4",
./drivers/staging/comedi/drivers/ni_mio_cs.c:	 .name = "DAQCard-6062E",
./drivers/staging/comedi/drivers/ni_mio_cs.c:	 .name = "DAQCard-6024E",	/* specs incorrect! */
./drivers/staging/comedi/drivers/ni_mio_cs.c:	 .name = "DAQCard-6036E",	/* specs incorrect! */
./drivers/staging/comedi/drivers/ni_mio_cs.c:	 .name = "DAQCard-6715",
./drivers/staging/comedi/drivers/ni_mio_cs.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x010d),	/* DAQCard-ai-16xe-50 */
./drivers/staging/comedi/drivers/ni_mio_cs.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x010c),	/* DAQCard-ai-16e-4 */
./drivers/staging/comedi/drivers/ni_mio_cs.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x02c4),	/* DAQCard-6062E */
./drivers/staging/comedi/drivers/ni_mio_cs.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x075e),	/* DAQCard-6024E */
./drivers/staging/comedi/drivers/ni_mio_cs.c:	PCMCIA_DEVICE_MANF_CARD(0x010b, 0x0245),	/* DAQCard-6036E */
./drivers/staging/comedi/drivers/amplc_pci224.c:	mangled = (unsigned short)data << (16 - thisboard->ao_bits);
./drivers/staging/comedi/drivers/amplc_pci224.c:	shift = 16 - thisboard->ao_bits;
./drivers/staging/comedi/drivers/amplc_pci224.c:		if (thisboard->model == any_model) {
./drivers/staging/comedi/drivers/amplc_pci224.c:			if (thisboard->devid != pci_dev->device)
./drivers/staging/comedi/drivers/amplc_pci224.c:		       dev->minor, thisboard->name, bus, slot);
./drivers/staging/comedi/drivers/amplc_pci224.c:		       dev->minor, thisboard->name);
./drivers/staging/comedi/drivers/amplc_pci224.c:				       thisboard->ao_chans, GFP_KERNEL);
./drivers/staging/comedi/drivers/amplc_pci224.c:					thisboard->ao_chans, GFP_KERNEL);
./drivers/staging/comedi/drivers/amplc_pci224.c:					 thisboard->ao_chans, GFP_KERNEL);
./drivers/staging/comedi/drivers/amplc_pci224.c:	s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/amplc_pci224.c:	s->maxdata = (1 << thisboard->ao_bits) - 1;
./drivers/staging/comedi/drivers/amplc_pci224.c:	if (thisboard->model == pci234_model) {
./drivers/staging/comedi/drivers/amplc_pci224.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/aio_iiro_16.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/icp_multi.c:	devpriv->DacCmdStatus |= this_board->rangecode[range];
./drivers/staging/comedi/drivers/icp_multi.c:			if (CR_CHAN(chanlist[i]) > this_board->n_aichand) {
./drivers/staging/comedi/drivers/icp_multi.c:			if (CR_CHAN(chanlist[i]) > this_board->n_aichan) {
./drivers/staging/comedi/drivers/icp_multi.c:		range = this_board->rangecode[CR_RANGE(chanlist[i])];
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_aochan)
./drivers/staging/comedi/drivers/icp_multi.c:		for (i = 0; i < this_board->n_aochan; i++) {
./drivers/staging/comedi/drivers/icp_multi.c:	       this_board->name);
./drivers/staging/comedi/drivers/icp_multi.c:					 this_board->device_id, it->options[0],
./drivers/staging/comedi/drivers/icp_multi.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_aichan)
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_aochan)
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_dichan)
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_dochan)
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_ctrs)
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->have_irq) {
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_aichan) {
./drivers/staging/comedi/drivers/icp_multi.c:		if (this_board->n_aichand)
./drivers/staging/comedi/drivers/icp_multi.c:		s->n_chan = this_board->n_aichan;
./drivers/staging/comedi/drivers/icp_multi.c:		s->maxdata = this_board->ai_maxdata;
./drivers/staging/comedi/drivers/icp_multi.c:		s->len_chanlist = this_board->n_aichan;
./drivers/staging/comedi/drivers/icp_multi.c:		s->range_table = this_board->rangelist_ai;
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_aochan) {
./drivers/staging/comedi/drivers/icp_multi.c:		s->n_chan = this_board->n_aochan;
./drivers/staging/comedi/drivers/icp_multi.c:		s->maxdata = this_board->ao_maxdata;
./drivers/staging/comedi/drivers/icp_multi.c:		s->len_chanlist = this_board->n_aochan;
./drivers/staging/comedi/drivers/icp_multi.c:		s->range_table = this_board->rangelist_ao;
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_dichan) {
./drivers/staging/comedi/drivers/icp_multi.c:		s->n_chan = this_board->n_dichan;
./drivers/staging/comedi/drivers/icp_multi.c:		s->len_chanlist = this_board->n_dichan;
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_dochan) {
./drivers/staging/comedi/drivers/icp_multi.c:		s->n_chan = this_board->n_dochan;
./drivers/staging/comedi/drivers/icp_multi.c:		s->len_chanlist = this_board->n_dochan;
./drivers/staging/comedi/drivers/icp_multi.c:		s->io_bits = (1 << this_board->n_dochan) - 1;
./drivers/staging/comedi/drivers/icp_multi.c:	if (this_board->n_ctrs) {
./drivers/staging/comedi/drivers/icp_multi.c:		s->n_chan = this_board->n_ctrs;
./drivers/staging/comedi/drivers/icp_multi.c:		s->len_chanlist = this_board->n_ctrs;
./drivers/staging/comedi/drivers/ni_at_ao.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/ni_at_ao.c:	s->n_chan = thisboard->n_ao_chans;
./drivers/staging/comedi/drivers/cb_das16_cs.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/cb_das16_cs.c:	if (thisboard->n_ao_chans) {
./drivers/staging/comedi/drivers/cb_das16_cs.c:		s->n_chan = thisboard->n_ao_chans;
./drivers/staging/comedi/drivers/das800.c:		if (thisboard->resolution == 12) {
./drivers/staging/comedi/drivers/das800.c:		if (thisboard->resolution == 12)
./drivers/staging/comedi/drivers/das800.c:	if (thisboard->resolution == 12) {
./drivers/staging/comedi/drivers/das800.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/das800.c:	s->maxdata = (1 << thisboard->resolution) - 1;
./drivers/staging/comedi/drivers/das800.c:	s->range_table = thisboard->ai_range;
./drivers/staging/comedi/drivers/das800.c:	if (thisboard->resolution == 16)
./drivers/staging/comedi/drivers/das800.c:		if (cmd->convert_arg < thisboard->ai_speed) {
./drivers/staging/comedi/drivers/das800.c:			cmd->convert_arg = thisboard->ai_speed;
./drivers/staging/comedi/drivers/das800.c:	if (thisboard->resolution == 12 && gain > 0)
./drivers/staging/comedi/drivers/das800.c:	if (thisboard->resolution == 12 && range)
./drivers/staging/comedi/drivers/das800.c:		if (thisboard->resolution == 12) {
./drivers/staging/comedi/drivers/dt282x.c:	if (cmd->convert_arg < this_board->ai_speed) {
./drivers/staging/comedi/drivers/dt282x.c:		cmd->convert_arg = this_board->ai_speed;
./drivers/staging/comedi/drivers/dt282x.c:	if (cmd->convert_arg < this_board->ai_speed)
./drivers/staging/comedi/drivers/dt282x.c:		cmd->convert_arg = this_board->ai_speed;
./drivers/staging/comedi/drivers/dt282x.c:	dev->board_name = this_board->name;
./drivers/staging/comedi/drivers/dmm32at.c:	if (!request_region(iobase, DMM32AT_MEMSIZE, thisboard->name)) {
./drivers/staging/comedi/drivers/dmm32at.c:		ret = request_irq(irq, dmm32at_isr, 0, thisboard->name, dev);
./drivers/staging/comedi/drivers/dmm32at.c:	dev->board_name = thisboard->name;
./drivers/staging/comedi/drivers/dmm32at.c:	s->n_chan = thisboard->ai_chans;
./drivers/staging/comedi/drivers/dmm32at.c:	s->maxdata = (1 << thisboard->ai_bits) - 1;
./drivers/staging/comedi/drivers/dmm32at.c:	s->range_table = thisboard->ai_ranges;
./drivers/staging/comedi/drivers/dmm32at.c:	s->n_chan = thisboard->ao_chans;
./drivers/staging/comedi/drivers/dmm32at.c:	s->maxdata = (1 << thisboard->ao_bits) - 1;
./drivers/staging/comedi/drivers/dmm32at.c:	s->range_table = thisboard->ao_ranges;
./drivers/staging/comedi/drivers/dmm32at.c:	if (thisboard->have_dio) {
./drivers/staging/comedi/drivers/dmm32at.c:		s->n_chan = thisboard->dio_chans;
./drivers/staging/intel_sst/intel_sst_drv_interface.c:	if (!card || !card->module_name) {
./drivers/staging/intel_sst/intel_sst_drv_interface.c:		if ((strncmp(SST_CARD_NAMES, card->module_name,
./drivers/staging/intel_sst/intel_sst_drv_interface.c:			sst_drv_ctx->pmic_vendor = card->vendor_id;
./drivers/staging/intel_sst/intel_sst_drv_interface.c:			sst_drv_ctx->scard_ops =  card->scard_ops;
./drivers/staging/intel_sst/intel_sst_drv_interface.c:			sst_pmic_ops.module_name = card->module_name;
./drivers/staging/intel_sst/intel_sst_drv_interface.c:			card->pcm_control = sst_pmic_ops.pcm_control;
./drivers/staging/intel_sst/intel_sst_drv_interface.c:			pr_err("strcmp fail %s\n", card->module_name);
./drivers/staging/intel_sst/intel_sst_drv_interface.c: * unregister_sst_card- function for sound card to un-register
./drivers/staging/intel_sst/intel_sst_drv_interface.c:	if (sst_pmic_ops.pcm_control == card->pcm_control) {
./drivers/staging/intel_sst/intel_sst_drv_interface.c:		pr_debug("Unregistered %s\n", card->module_name);
./drivers/staging/intel_sst/intelmid.c:	strncpy(pcm->name, card->shortname, strlen(card->shortname));
./drivers/staging/intel_sst/intelmid.c:	strncpy(card->mixername, mixername, sizeof(card->mixername)-1);
./drivers/staging/intel_sst/intelmid.c:	strncpy(card->driver, INTEL_MAD, strlen(INTEL_MAD));
./drivers/staging/intel_sst/intelmid.c:	strncpy(card->shortname, INTEL_MAD, strlen(INTEL_MAD));
./drivers/staging/intel_sst/intelmid.c:	card->private_data = &intelmaddata;
./drivers/staging/intel_sst/intelmid.c:	card->private_data = NULL;
./drivers/staging/speakup/fakekey.c:	virt_keyboard->name = "Speakup";
./drivers/staging/speakup/fakekey.c:	virt_keyboard->id.bustype = BUS_VIRTUAL;
./drivers/staging/speakup/fakekey.c:	virt_keyboard->phys = "speakup/input0";
./drivers/staging/speakup/fakekey.c:	virt_keyboard->dev.parent = NULL;
./drivers/staging/speakup/fakekey.c:	__set_bit(EV_KEY, virt_keyboard->evbit);
./drivers/staging/speakup/fakekey.c:	__set_bit(KEY_DOWN, virt_keyboard->keybit);
./drivers/staging/cx25821/cx25821-alsa.c:	struct cx25821_audio_dev *chip = card->private_data;
./drivers/staging/cx25821/cx25821-alsa.c:	strcpy(card->driver, "cx25821");
./drivers/staging/cx25821/cx25821-alsa.c:	card->private_free = snd_cx25821_dev_free;
./drivers/staging/cx25821/cx25821-alsa.c:	chip = card->private_data;
./drivers/staging/cx25821/cx25821-alsa.c:	strcpy(card->shortname, "cx25821");
./drivers/staging/cx25821/cx25821-alsa.c:	sprintf(card->longname, "%s at 0x%lx irq %d", chip->dev->name,
./drivers/staging/cx25821/cx25821-alsa.c:	strcpy(card->mixername, "CX25821");
./drivers/staging/cx25821/cx25821-alsa.c:		card->driver, devno);
./drivers/staging/lirc/lirc_serial.c:/* twisty maze... need a forward-declaration here... */
./drivers/staging/line6/audio.c:	strcpy(card->id, line6->properties->id);
./drivers/staging/line6/audio.c:	strcpy(card->driver, DRIVER_NAME);
./drivers/staging/line6/audio.c:	strcpy(card->shortname, line6->properties->name);
./drivers/staging/line6/audio.c:	sprintf(card->longname, "Line6 %s at USB %s", line6->properties->name,
./drivers/staging/solo6x10/g723.c:	ret = snd_pcm_new(card, card->driver, 0, 0, solo_dev->nr_chans,
./drivers/staging/solo6x10/g723.c:	strcpy(pcm->name, card->shortname);
./drivers/staging/solo6x10/g723.c:	strcpy(card->driver, SOLO6X10_NAME);
./drivers/staging/solo6x10/g723.c:	strcpy(card->shortname, "SOLO-6x10 Audio");
./drivers/staging/solo6x10/g723.c:	sprintf(card->longname, "%s on %s IRQ %d", card->shortname,
./drivers/staging/solo6x10/g723.c:	strcpy(card->mixername, "SOLO-6x10");
./drivers/staging/slicoss/slicoss.c:	if ((adapter->card) && (card->config_set)) {
./drivers/staging/slicoss/slicoss.c:		       card->config.MacInfo[adapter->functionnumber].macaddrA,
./drivers/staging/slicoss/slicoss.c:	adapter->card->loadlevel_current = value;
./drivers/staging/slicoss/slicoss.c:	if (adapter->card->state == CARD_UP) {
./drivers/staging/slicoss/slicoss.c:	struct adapter *adapter = card->master;
./drivers/staging/slicoss/slicoss.c:	u32 load = card->events;
./drivers/staging/slicoss/slicoss.c:	    (card->state == CARD_UP) && (slic_global.dynamic_intagg)) {
./drivers/staging/slicoss/slicoss.c:			if (card->loadlevel_current != level) {
./drivers/staging/slicoss/slicoss.c:				card->loadlevel_current = level;
./drivers/staging/slicoss/slicoss.c:			if (card->loadlevel_current != level) {
./drivers/staging/slicoss/slicoss.c:				card->loadlevel_current = level;
./drivers/staging/slicoss/slicoss.c:	card->events = 0;
./drivers/staging/slicoss/slicoss.c:	card->loadtimer.expires = jiffies + (SLIC_LOADTIMER_PERIOD * HZ);
./drivers/staging/slicoss/slicoss.c:	add_timer(&card->loadtimer);
./drivers/staging/slicoss/slicoss.c:		card->pingstatus |= (isr & ISR_PINGDSMASK);
./drivers/staging/slicoss/slicoss.c:	struct slic_config *config = &card->config;
./drivers/staging/slicoss/slicoss.c:	unsigned char *fru = (unsigned char *)(&card->config.atk_fru);
./drivers/staging/slicoss/slicoss.c:	unsigned char *oemfru = (unsigned char *)(&card->config.OemFru);
./drivers/staging/slicoss/slicoss.c:	seq_printf(seq, "Bus    #                 : %d\n", card->busnumber);
./drivers/staging/slicoss/slicoss.c:	seq_printf(seq, "Device #                 : %d\n", card->slotnumber);
./drivers/staging/slicoss/slicoss.c:	seq_printf(seq, "Interfaces               : %d\n", card->card_size);
./drivers/staging/slicoss/slicoss.c:		    card->adapters_activated);
./drivers/staging/slicoss/slicoss.c:		    card->adapters_allocated);
./drivers/staging/slicoss/slicoss.c:	ASSERT(card->card_size <= SLIC_NBR_MACS);
./drivers/staging/slicoss/slicoss.c:	for (i = 0; i < card->card_size; i++) {
./drivers/staging/slicoss/slicoss.c:	for (i = 0; i < card->adapters_allocated; i++) {
./drivers/staging/slicoss/slicoss.c:		adapter = card->adapter[i];
./drivers/staging/slicoss/slicoss.c:	seq_printf(seq, "Generation #             : %4.4X\n", card->gennumber);
./drivers/staging/slicoss/slicoss.c:		    card->pingstatus);
./drivers/staging/slicoss/slicoss.c:		adapter->card->loadlevel_current);
./drivers/staging/slicoss/slicoss.c:	if (!card->debugfs_dir)
./drivers/staging/slicoss/slicoss.c:				card->debugfs_dir, adapter,
./drivers/staging/slicoss/slicoss.c:	snprintf(name, sizeof(name), "slic%d", card->cardnum);
./drivers/staging/slicoss/slicoss.c:		card->debugfs_dir = d;
./drivers/staging/slicoss/slicoss.c:			card->debugfs_cardinfo = d;
./drivers/staging/slicoss/slicoss.c:	for (i = 0; i < card->card_size; i++) {
./drivers/staging/slicoss/slicoss.c:		adapter = card->adapter[i];
./drivers/staging/slicoss/slicoss.c:	if (card->debugfs_cardinfo) {
./drivers/staging/slicoss/slicoss.c:		debugfs_remove(card->debugfs_cardinfo);
./drivers/staging/slicoss/slicoss.c:		card->debugfs_cardinfo = NULL;
./drivers/staging/slicoss/slicoss.c:	if (card->debugfs_dir) {
./drivers/staging/slicoss/slicoss.c:		debugfs_remove(card->debugfs_dir);
./drivers/staging/slicoss/slicoss.c:		card->debugfs_dir = NULL;
./drivers/staging/slicoss/slicoss.c:				SLIC_CARD_STATE(adapter->card->state),
./drivers/staging/slicoss/slicoss.c:				adapter->card->state);
./drivers/staging/slicoss/slicoss.c:		adapter->card->events++;
./drivers/staging/slicoss/slicoss.c:		adapter->card->events++;
./drivers/staging/slicoss/slicoss.c:		switch (adapter->card->state) {
./drivers/staging/slicoss/slicoss.c:	    (adapter->state != ADAPT_UP) || (card->state != CARD_UP)) {
./drivers/staging/slicoss/slicoss.c:	if (!card->loadtimerset) {
./drivers/staging/slicoss/slicoss.c:		init_timer(&card->loadtimer);
./drivers/staging/slicoss/slicoss.c:		card->loadtimer.expires =
./drivers/staging/slicoss/slicoss.c:		card->loadtimer.data = (ulong) card;
./drivers/staging/slicoss/slicoss.c:		card->loadtimer.function = &slic_timer_load_check;
./drivers/staging/slicoss/slicoss.c:		add_timer(&card->loadtimer);
./drivers/staging/slicoss/slicoss.c:		card->loadtimerset = 1;
./drivers/staging/slicoss/slicoss.c:		adapter->card->pingstatus = ISR_PINGMASK;
./drivers/staging/slicoss/slicoss.c:		card->adapters_activated++;
./drivers/staging/slicoss/slicoss.c:			card->adapters_activated--;
./drivers/staging/slicoss/slicoss.c:	if (!card->master)
./drivers/staging/slicoss/slicoss.c:		card->master = adapter;
./drivers/staging/slicoss/slicoss.c:	if (card->loadtimerset) {
./drivers/staging/slicoss/slicoss.c:		card->loadtimerset = 0;
./drivers/staging/slicoss/slicoss.c:		del_timer(&card->loadtimer);
./drivers/staging/slicoss/slicoss.c:	ASSERT(card->adapters_allocated);
./drivers/staging/slicoss/slicoss.c:	card->adapters_allocated--;
./drivers/staging/slicoss/slicoss.c:	if (!card->adapters_allocated) {
./drivers/staging/slicoss/slicoss.c:			slic_global.slic_card = card->next;
./drivers/staging/slicoss/slicoss.c:			while (curr_card->next != card)
./drivers/staging/slicoss/slicoss.c:				curr_card = curr_card->next;
./drivers/staging/slicoss/slicoss.c:			curr_card->next = card->next;
./drivers/staging/slicoss/slicoss.c:	ASSERT(card->adapter[adapter->cardindex] == adapter);
./drivers/staging/slicoss/slicoss.c:		card->adapters_activated--;
./drivers/staging/slicoss/slicoss.c:	if (!card->adapters_activated)
./drivers/staging/slicoss/slicoss.c:	uint macaddrs = card->card_size;
./drivers/staging/slicoss/slicoss.c:	if (!card->config_set) {
./drivers/staging/slicoss/slicoss.c:		card->config.EepromValid = false;
./drivers/staging/slicoss/slicoss.c:				card->config.EepromValid = true;
./drivers/staging/slicoss/slicoss.c:		card->config.DramSize = dramsize;
./drivers/staging/slicoss/slicoss.c:			memcpy(&card->config.MacInfo[i],
./drivers/staging/slicoss/slicoss.c:		card->config.FruFormat = fruformat;
./drivers/staging/slicoss/slicoss.c:		memcpy(&card->config.AtkFru, patkfru,
./drivers/staging/slicoss/slicoss.c:		if ((!card->config.EepromValid) &&
./drivers/staging/slicoss/slicoss.c:		card->config_set = 1;
./drivers/staging/slicoss/slicoss.c:	card->pingstatus = ISR_PINGMASK;
./drivers/staging/slicoss/slicoss.c:	card->state = CARD_UP;
./drivers/staging/slicoss/slicoss.c:	card->reset_in_progress = 0;
./drivers/staging/slicoss/slicoss.c:		card->next = slic_global.slic_card;
./drivers/staging/slicoss/slicoss.c:		card->busnumber = adapter->busnumber;
./drivers/staging/slicoss/slicoss.c:		card->slotnumber = adapter->slotnumber;
./drivers/staging/slicoss/slicoss.c:				card->cardnum = i;
./drivers/staging/slicoss/slicoss.c:			if (card->cardnum == card_hostid)
./drivers/staging/slicoss/slicoss.c:			card = card->next;
./drivers/staging/slicoss/slicoss.c:	ASSERT(card->adapter[adapter->port] == NULL);
./drivers/staging/slicoss/slicoss.c:	if (!card->adapter[adapter->port]) {
./drivers/staging/slicoss/slicoss.c:		card->adapter[adapter->port] = adapter;
./drivers/staging/slicoss/slicoss.c:	card->card_size = 1;	/* one port per *logical* card */
./drivers/staging/slicoss/slicoss.c:			if (!physcard->adapter[i])
./drivers/staging/slicoss/slicoss.c:		if (physcard->adapter[i]->slotnumber == adapter->slotnumber)
./drivers/staging/slicoss/slicoss.c:		physcard = physcard->next;
./drivers/staging/slicoss/slicoss.c:		physcard->next = slic_global.phys_card;
./drivers/staging/slicoss/slicoss.c:		physcard->adapters_allocd = 1;
./drivers/staging/slicoss/slicoss.c:		physcard->adapters_allocd++;
./drivers/staging/slicoss/slicoss.c:	adapter->physport = physcard->adapters_allocd - 1;
./drivers/staging/slicoss/slicoss.c:	ASSERT(physcard->adapter[adapter->physport] == NULL);
./drivers/staging/slicoss/slicoss.c:	physcard->adapter[adapter->physport] = adapter;
./drivers/staging/slicoss/slicoss.c:		card->adapters_allocated++;
./drivers/staging/slicoss/slicoss.c:		card->state = CARD_FAIL;
./drivers/staging/sbe-2t3e3/io.c: * protected via the card->bootrom_lock. */
./drivers/staging/sbe-2t3e3/io.c:/* priviate define to be used here only - must be protected by card->bootrom_lock */
./drivers/staging/sbe-2t3e3/io.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	unsigned long addr = channel->card->bootrom_addr;
./drivers/staging/sbe-2t3e3/io.c:	unsigned long addr = channel->card->bootrom_addr;
./drivers/staging/sbe-2t3e3/io.c:	unsigned long addr = channel->card->bootrom_addr;
./drivers/staging/sbe-2t3e3/io.c:	unsigned long addr = channel->card->bootrom_addr;
./drivers/staging/sbe-2t3e3/io.c:	unsigned long addr = channel->card->bootrom_addr;
./drivers/staging/sbe-2t3e3/io.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	unsigned long addr = channel->card->bootrom_addr, flags;
./drivers/staging/sbe-2t3e3/io.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	unsigned long addr = channel->card->bootrom_addr, flags;
./drivers/staging/sbe-2t3e3/io.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/io.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/module.c:	struct channel *channel0 = &card->channels[0];
./drivers/staging/sbe-2t3e3/module.c:		update_led(&card->channels[1], blinker);
./drivers/staging/sbe-2t3e3/module.c:	card->timer.expires = jiffies + HZ / 10;
./drivers/staging/sbe-2t3e3/module.c:	add_timer(&card->timer);
./drivers/staging/sbe-2t3e3/module.c:	del_timer(&card->timer);
./drivers/staging/sbe-2t3e3/module.c:		t3e3_remove_channel(&card->channels[1]);
./drivers/staging/sbe-2t3e3/module.c:		pci_dev_put(card->channels[1].pdev);
./drivers/staging/sbe-2t3e3/module.c:	spin_lock_init(&card->bootrom_lock);
./drivers/staging/sbe-2t3e3/module.c:	card->bootrom_addr = pci_resource_start(pdev, 0);
./drivers/staging/sbe-2t3e3/module.c:	err = t3e3_init_channel(&card->channels[0], pdev, card);
./drivers/staging/sbe-2t3e3/module.c:		err = t3e3_init_channel(&card->channels[1], pdev1, card);
./drivers/staging/sbe-2t3e3/module.c:			t3e3_remove_channel(&card->channels[0]);
./drivers/staging/sbe-2t3e3/module.c:	init_timer(&card->timer);
./drivers/staging/sbe-2t3e3/module.c:	card->timer.function = check_leds;
./drivers/staging/sbe-2t3e3/module.c:	card->timer.expires = jiffies + HZ / 10;
./drivers/staging/sbe-2t3e3/module.c:	card->timer.data = (unsigned long)card;
./drivers/staging/sbe-2t3e3/module.c:	add_timer(&card->timer);
./drivers/staging/sbe-2t3e3/cpld.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/cpld.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/cpld.c:	spin_lock_irqsave(&channel->card->bootrom_lock, flags);
./drivers/staging/sbe-2t3e3/cpld.c:	spin_unlock_irqrestore(&channel->card->bootrom_lock, flags);
./drivers/staging/generic_serial/generic_serial.c:		port->rd->enable_tx_interrupts (port);
./drivers/staging/generic_serial/generic_serial.c:	if (!port->rd->chars_in_buffer) return 0;
./drivers/staging/generic_serial/generic_serial.c:	return port->xmit_cnt + port->rd->chars_in_buffer (port);
./drivers/staging/generic_serial/generic_serial.c:	port->rd->enable_tx_interrupts (port);
./drivers/staging/generic_serial/generic_serial.c:		port->rd->disable_tx_interrupts (port);
./drivers/staging/generic_serial/generic_serial.c:		port->rd->enable_tx_interrupts (port);
./drivers/staging/generic_serial/generic_serial.c:	port->rd->shutdown_port (port);
./drivers/staging/generic_serial/generic_serial.c:		if (port->rd->hungup)
./drivers/staging/generic_serial/generic_serial.c:			port->rd->hungup (port);
./drivers/staging/generic_serial/generic_serial.c:	port->rd->disable_rx_interrupts (port);
./drivers/staging/generic_serial/generic_serial.c:	port->rd->close (port);
./drivers/staging/generic_serial/generic_serial.c:	port->rd->shutdown_port (port);
./drivers/staging/generic_serial/generic_serial.c:	rv = port->rd->set_real_termios(port);
./drivers/staging/generic_serial/generic_serial.c:	if (port->rd->getserial)
./drivers/staging/generic_serial/generic_serial.c:		port->rd->getserial (port, &sio);
./drivers/staging/generic_serial/sx.c: * a bit. Should also test the board in word-mode, however my card fails the
./drivers/staging/generic_serial/sx.c:	writeb(byte, board->base + offset);
./drivers/staging/generic_serial/sx.c:	return readb(board->base + offset);
./drivers/staging/generic_serial/sx.c:	writew(word, board->base + offset);
./drivers/staging/generic_serial/sx.c:	return readw(board->base + offset);
./drivers/staging/generic_serial/sx.c:		outb(board->irq << 4, board->eisa_base + 0xc02);
./drivers/staging/generic_serial/sx.c:		outb((board->irq << 4) | 4, board->eisa_base + 0xc02);
./drivers/staging/generic_serial/sx.c:	((board->flags & SX_ISA_BOARD) ? (board->irq << 4) : 0)
./drivers/staging/generic_serial/sx.c:	/* Don't call this with board->irq == 0 */
./drivers/staging/generic_serial/sx.c:		inb(board->eisa_base + 0xc03);
./drivers/staging/generic_serial/sx.c:		switch (board->irq) {
./drivers/staging/generic_serial/sx.c:					"interrupt %d.\n", board->irq);
./drivers/staging/generic_serial/sx.c:	if (port->board->ta_type == MOD_SXDC) {
./drivers/staging/generic_serial/sx.c:			if (port->board->ta_type == MOD_TA) {
./drivers/staging/generic_serial/sx.c:			if (port->board->ta_type == MOD_TA) {
./drivers/staging/generic_serial/sx.c:		memcpy_toio(port->board->base + CHAN_OFFSET(port, hi_txbuf) +
./drivers/staging/generic_serial/sx.c:		memcpy_fromio(rp, port->board->base +
./drivers/staging/generic_serial/sx.c:			board->irq);
./drivers/staging/generic_serial/sx.c:				free_irq(board->irq, board);
./drivers/staging/generic_serial/sx.c:						board->irq);
./drivers/staging/generic_serial/sx.c:	if (board->irq == irq) {
./drivers/staging/generic_serial/sx.c:			inb(board->eisa_base + 0xc03);
./drivers/staging/generic_serial/sx.c:	if (!(board->flags & SX_BOARD_INITIALIZED))
./drivers/staging/generic_serial/sx.c:	if (test_and_set_bit(SX_BOARD_INTR_LOCK, &board->locks)) {
./drivers/staging/generic_serial/sx.c:		printk(KERN_ERR "Recursive interrupt! (%d)\n", board->irq);
./drivers/staging/generic_serial/sx.c:	for (i = 0; i < board->nports; i++) {
./drivers/staging/generic_serial/sx.c:		port = &board->ports[i];
./drivers/staging/generic_serial/sx.c:	clear_bit(SX_BOARD_INTR_LOCK, &board->locks);
./drivers/staging/generic_serial/sx.c:			board->irq);
./drivers/staging/generic_serial/sx.c:	mod_timer(&board->timer, jiffies + sx_poll);
./drivers/staging/generic_serial/sx.c:		my_hd_io(port->board->base + port->ch_base, sizeof(*port));
./drivers/staging/generic_serial/sx.c:	if (board->flags & SX_BOARD_PRESENT) {
./drivers/staging/generic_serial/sx.c:				board->flags);
./drivers/staging/generic_serial/sx.c:				board->flags);
./drivers/staging/generic_serial/sx.c:				memcpy_toio(board->base2 + offset + i, tmp,
./drivers/staging/generic_serial/sx.c:	board->flags |= SX_BOARD_INITIALIZED;
./drivers/staging/generic_serial/sx.c:		my_hd_io(board->base, 0x10);
./drivers/staging/generic_serial/sx.c:		my_hd_io(board->base + 0x80, 0x30);
./drivers/staging/generic_serial/sx.c:		board->nports = 0;
./drivers/staging/generic_serial/sx.c:	/* board->ta_type = mod_compat_type (read_sx_byte (board, 0x80 + 0x08)); */
./drivers/staging/generic_serial/sx.c:	board->ta_type = mod_compat_type(sx_read_module_byte(board, 0x80,
./drivers/staging/generic_serial/sx.c:		if (mod_compat_type(type) != board->ta_type) {
./drivers/staging/generic_serial/sx.c:		if (board->irq > 0) {
./drivers/staging/generic_serial/sx.c:			if (sx_irqmask & (1 << board->irq)) {	/* may we use this irq? */
./drivers/staging/generic_serial/sx.c:				if (request_irq(board->irq, sx_interrupt,
./drivers/staging/generic_serial/sx.c:						"irq %d.\n", board->irq);
./drivers/staging/generic_serial/sx.c:					board->irq = 0;
./drivers/staging/generic_serial/sx.c:				board->irq = 0;
./drivers/staging/generic_serial/sx.c:		} else if (board->irq < 0 && sx_irqmask) {
./drivers/staging/generic_serial/sx.c:			board->irq = irqnr;
./drivers/staging/generic_serial/sx.c:			board->irq = 0;
./drivers/staging/generic_serial/sx.c:		if (board->irq) {
./drivers/staging/generic_serial/sx.c:					board->irq);
./drivers/staging/generic_serial/sx.c:			board->poll = sx_slowpoll;
./drivers/staging/generic_serial/sx.c:			board->flags |= SX_IRQ_ALLOCATED;
./drivers/staging/generic_serial/sx.c:			board->poll = sx_poll;
./drivers/staging/generic_serial/sx.c:					board->poll);
./drivers/staging/generic_serial/sx.c:		setup_timer(&board->timer, sx_pollfunc, (unsigned long)board);
./drivers/staging/generic_serial/sx.c:		if (board->poll)
./drivers/staging/generic_serial/sx.c:			mod_timer(&board->timer, jiffies + board->poll);
./drivers/staging/generic_serial/sx.c:		board->irq = 0;
./drivers/staging/generic_serial/sx.c:	board->nports = chans;
./drivers/staging/generic_serial/sx.c:	sx_dprintk(SX_DEBUG_INIT, "returning %d ports.", board->nports);
./drivers/staging/generic_serial/sx.c:				board->base + SX_VPD_ROM);
./drivers/staging/generic_serial/sx.c:			my_hd_io(board->base + SX_VPD_ROM, 0x40);
./drivers/staging/generic_serial/sx.c:			board->hw_base);
./drivers/staging/generic_serial/sx.c:			if (((unsigned long)board->hw_base) & 0x8000) {
./drivers/staging/generic_serial/sx.c:					"%lx.\n", board->hw_base);
./drivers/staging/generic_serial/sx.c:	board->nports = -1;
./drivers/staging/generic_serial/sx.c:		"%p.\n", board->hw_base, board->base + SI2_ISA_ID_BASE);
./drivers/staging/generic_serial/sx.c:		my_hd_io(board->base + SI2_ISA_ID_BASE, 0x8);
./drivers/staging/generic_serial/sx.c:	printk(KERN_DEBUG "sx: Found an SI board at %lx\n", board->hw_base);
./drivers/staging/generic_serial/sx.c:	board->nports = -1;
./drivers/staging/generic_serial/sx.c:		board->ports = port;
./drivers/staging/generic_serial/sx.c:		board->port_base = portno;
./drivers/staging/generic_serial/sx.c:				board->nports);
./drivers/staging/generic_serial/sx.c:		if (board->nports <= 0)
./drivers/staging/generic_serial/sx.c:		/* board->flags |= SX_BOARD_INITIALIZED; */
./drivers/staging/generic_serial/sx.c:	if (board->flags & SX_BOARD_INITIALIZED) {
./drivers/staging/generic_serial/sx.c:		if ((board->irq) && (board->flags & SX_IRQ_ALLOCATED))
./drivers/staging/generic_serial/sx.c:			free_irq(board->irq, board);
./drivers/staging/generic_serial/sx.c:		del_timer(&board->timer);
./drivers/staging/generic_serial/sx.c:			iounmap(board->base2);
./drivers/staging/generic_serial/sx.c:			iounmap(board->base);
./drivers/staging/generic_serial/sx.c:			release_region(board->hw_base, board->hw_len);
./drivers/staging/generic_serial/sx.c:		board->flags &= ~(SX_BOARD_INITIALIZED | SX_BOARD_PRESENT);
./drivers/staging/generic_serial/sx.c:	board->flags |= SX_BOARD_PRESENT;
./drivers/staging/generic_serial/sx.c:	board->eisa_base = eisa_slot;
./drivers/staging/generic_serial/sx.c:	board->flags &= ~SX_BOARD_TYPE;
./drivers/staging/generic_serial/sx.c:	board->flags |= SI_EISA_BOARD;
./drivers/staging/generic_serial/sx.c:	board->hw_base = ((inb(eisa_slot + 0xc01) << 8) +
./drivers/staging/generic_serial/sx.c:	board->hw_len = SI2_EISA_WINDOW_LEN;
./drivers/staging/generic_serial/sx.c:	if (!request_region(board->hw_base, board->hw_len, "sx")) {
./drivers/staging/generic_serial/sx.c:	board->base2 =
./drivers/staging/generic_serial/sx.c:	board->base = ioremap_nocache(board->hw_base, SI2_EISA_WINDOW_LEN);
./drivers/staging/generic_serial/sx.c:	if (!board->base) {
./drivers/staging/generic_serial/sx.c:	sx_dprintk(SX_DEBUG_PROBE, "IO hw_base address: %lx\n", board->hw_base);
./drivers/staging/generic_serial/sx.c:	sx_dprintk(SX_DEBUG_PROBE, "base: %p\n", board->base);
./drivers/staging/generic_serial/sx.c:	board->irq = inb(eisa_slot + 0xc02) >> 4;
./drivers/staging/generic_serial/sx.c:	sx_dprintk(SX_DEBUG_PROBE, "IRQ: %d\n", board->irq);
./drivers/staging/generic_serial/sx.c:	iounmap(board->base);
./drivers/staging/generic_serial/sx.c:	release_region(board->hw_base, board->hw_len);
./drivers/staging/generic_serial/sx.c:	board->flags &= ~SX_BOARD_PRESENT;
./drivers/staging/generic_serial/sx.c:	board->flags |= SX_BOARD_PRESENT;
./drivers/staging/generic_serial/sx.c:	board->flags &= ~SX_BOARD_TYPE;
./drivers/staging/generic_serial/sx.c:	board->flags |= (pdev->subsystem_vendor == 0x200) ? SX_PCI_BOARD :
./drivers/staging/generic_serial/sx.c:	board->hw_base = pci_resource_start(pdev, reg);
./drivers/staging/generic_serial/sx.c:	board->base2 =
./drivers/staging/generic_serial/sx.c:	board->base = ioremap_nocache(board->hw_base, WINDOW_LEN(board));
./drivers/staging/generic_serial/sx.c:	if (!board->base) {
./drivers/staging/generic_serial/sx.c:		board->base += 0x18000;
./drivers/staging/generic_serial/sx.c:	board->irq = pdev->irq;
./drivers/staging/generic_serial/sx.c:	dev_info(&pdev->dev, "Got a specialix card: %p(%d) %x.\n", board->base,
./drivers/staging/generic_serial/sx.c:		 board->irq, board->flags);
./drivers/staging/generic_serial/sx.c:	iounmap(board->base2);
./drivers/staging/generic_serial/sx.c:	board->flags &= ~SX_BOARD_PRESENT;
./drivers/staging/generic_serial/sx.c:		board->hw_base = sx_probe_addrs[i];
./drivers/staging/generic_serial/sx.c:		board->hw_len = SX_WINDOW_LEN;
./drivers/staging/generic_serial/sx.c:		if (!request_region(board->hw_base, board->hw_len, "sx"))
./drivers/staging/generic_serial/sx.c:		board->base2 =
./drivers/staging/generic_serial/sx.c:		board->base = ioremap_nocache(board->hw_base, board->hw_len);
./drivers/staging/generic_serial/sx.c:		if (!board->base)
./drivers/staging/generic_serial/sx.c:		board->flags &= ~SX_BOARD_TYPE;
./drivers/staging/generic_serial/sx.c:		board->flags |= SX_ISA_BOARD;
./drivers/staging/generic_serial/sx.c:		board->irq = sx_irqmask ? -1 : 0;
./drivers/staging/generic_serial/sx.c:			board->flags |= SX_BOARD_PRESENT;
./drivers/staging/generic_serial/sx.c:			iounmap(board->base);
./drivers/staging/generic_serial/sx.c:			release_region(board->hw_base, board->hw_len);
./drivers/staging/generic_serial/sx.c:		board->hw_base = si_probe_addrs[i];
./drivers/staging/generic_serial/sx.c:		board->hw_len = SI2_ISA_WINDOW_LEN;
./drivers/staging/generic_serial/sx.c:		if (!request_region(board->hw_base, board->hw_len, "sx"))
./drivers/staging/generic_serial/sx.c:		board->base2 =
./drivers/staging/generic_serial/sx.c:		board->base = ioremap_nocache(board->hw_base, board->hw_len);
./drivers/staging/generic_serial/sx.c:		if (!board->base)
./drivers/staging/generic_serial/sx.c:		board->flags &= ~SX_BOARD_TYPE;
./drivers/staging/generic_serial/sx.c:		board->flags |= SI_ISA_BOARD;
./drivers/staging/generic_serial/sx.c:		board->irq = sx_irqmask ? -1 : 0;
./drivers/staging/generic_serial/sx.c:			board->flags |= SX_BOARD_PRESENT;
./drivers/staging/generic_serial/sx.c:			iounmap(board->base);
./drivers/staging/generic_serial/sx.c:			release_region(board->hw_base, board->hw_len);
./drivers/staging/generic_serial/sx.c:		board->hw_base = si1_probe_addrs[i];
./drivers/staging/generic_serial/sx.c:		board->hw_len = SI1_ISA_WINDOW_LEN;
./drivers/staging/generic_serial/sx.c:		if (!request_region(board->hw_base, board->hw_len, "sx"))
./drivers/staging/generic_serial/sx.c:		board->base2 =
./drivers/staging/generic_serial/sx.c:		board->base = ioremap_nocache(board->hw_base, board->hw_len);
./drivers/staging/generic_serial/sx.c:		if (!board->base)
./drivers/staging/generic_serial/sx.c:		board->flags &= ~SX_BOARD_TYPE;
./drivers/staging/generic_serial/sx.c:		board->flags |= SI1_ISA_BOARD;
./drivers/staging/generic_serial/sx.c:		board->irq = sx_irqmask ? -1 : 0;
./drivers/staging/generic_serial/sx.c:			board->flags |= SX_BOARD_PRESENT;
./drivers/staging/generic_serial/sx.c:			iounmap(board->base);
./drivers/staging/generic_serial/sx.c:			release_region(board->hw_base, board->hw_len);
./drivers/staging/rtl8712/rtl871x_security.c:	/* Append the byte to our word-sized buffer */
./drivers/staging/go7007/go7007-usb.c:	if (usb->board->flags & GO7007_USB_EZUSB) {
./drivers/staging/go7007/go7007-usb.c:	if (usb->board->flags & GO7007_USB_EZUSB)
./drivers/staging/go7007/go7007-usb.c:	go = go7007_alloc(&board->main_info, &intf->dev);
./drivers/staging/go7007/go7007-usb.c:	if (board->flags & GO7007_USB_EZUSB)
./drivers/staging/go7007/go7007-usb.c:	if (board->flags & GO7007_USB_EZUSB_I2C) {
./drivers/staging/go7007/go7007-usb.c:				go->board_info = &board->main_info;
./drivers/staging/go7007/go7007-usb.c:				go->board_info = &board->main_info;
./drivers/staging/go7007/go7007-usb.c:	if ((board->flags & GO7007_USB_EZUSB) &&
./drivers/staging/go7007/go7007-usb.c:	if (board->flags & GO7007_USB_EZUSB) {
./drivers/staging/go7007/go7007-usb.c:	if ((board->flags & GO7007_USB_EZUSB) && go->audio_enabled)
./drivers/staging/go7007/snd-go7007.c:	strncpy(gosnd->card->driver, "go7007", sizeof(gosnd->card->driver));
./drivers/staging/go7007/snd-go7007.c:	strncpy(gosnd->card->shortname, go->name, sizeof(gosnd->card->driver));
./drivers/staging/go7007/snd-go7007.c:	strncpy(gosnd->card->longname, gosnd->card->shortname,
./drivers/staging/go7007/snd-go7007.c:			sizeof(gosnd->card->longname));
./drivers/staging/go7007/go7007-driver.c: * minimum initialization necessary, since the board-specific code may
./drivers/staging/go7007/go7007-driver.c: * pins and bus parameters, which are board-specific.  This assumes
./drivers/staging/go7007/go7007-driver.c:	if (board->sensor_flags & GO7007_SENSOR_TV) {
./drivers/staging/go7007/go7007-driver.c:		go->width = board->sensor_width;
./drivers/staging/go7007/go7007-driver.c:		go->height = board->sensor_height;
./drivers/staging/go7007/go7007-driver.c:		go->sensor_framerate = board->sensor_framerate;
./drivers/staging/go7007/go7007-driver.c:	go->encoder_v_offset = board->sensor_v_offset;
./drivers/staging/go7007/go7007-driver.c:	go->encoder_h_offset = board->sensor_h_offset;
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif_scatter.c:    mmc_wait_for_req(device->func->card->host, &mmcreq);
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif_scatter.c:        if (device->func->card->host->max_segs < MAX_SCATTER_ENTRIES_PER_REQ) {
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif_scatter.c:                    device->func->card->host->max_segs, MAX_SCATTER_ENTRIES_PER_REQ));
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:    host = func->card->host;
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:    host = card->host;
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:        if (card->host->caps & MMC_CAP_SD_HIGHSPEED) {
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:                card->state &= ~MMC_STATE_HIGHSPEED;
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:            clock = card->cis.max_dtr;
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:        if (card->host->caps & MMC_CAP_4_BIT_DATA) {
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:                struct mmc_host *host = func->card->host;
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:    return mmc_wait_for_cmd(card->host, &ioCmd, 0);
./drivers/staging/ath6kl/hif/sdio/linux_sdio/src/hif.c:    err = mmc_wait_for_cmd(card->host, &ioCmd, 0);
./drivers/staging/ath6kl/htc2/htc_recv.c:        if (pRecord->Length > Length) {
./drivers/staging/ath6kl/htc2/htc_recv.c:                        pRecord->Length, pRecord->RecordID, Length));
./drivers/staging/ath6kl/htc2/htc_recv.c:        switch (pRecord->RecordID) {
./drivers/staging/ath6kl/htc2/htc_recv.c:                AR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_CREDIT_REPORT));
./drivers/staging/ath6kl/htc2/htc_recv.c:                                    pRecord->Length / (sizeof(HTC_CREDIT_REPORT)),
./drivers/staging/ath6kl/htc2/htc_recv.c:                AR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_LOOKAHEAD_REPORT));
./drivers/staging/ath6kl/htc2/htc_recv.c:                AR_DEBUG_ASSERT(pRecord->Length >= sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT));
./drivers/staging/ath6kl/htc2/htc_recv.c:                if (pRecord->Length >= sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT) &&
./drivers/staging/ath6kl/htc2/htc_recv.c:                        DebugDumpBytes(pRecordBuf,pRecord->Length,"Bundle LookAhead");
./drivers/staging/ath6kl/htc2/htc_recv.c:                    if ((pRecord->Length / (sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT))) >
./drivers/staging/ath6kl/htc2/htc_recv.c:                    for (i = 0; i < (int)(pRecord->Length / (sizeof(HTC_BUNDLED_LOOKAHEAD_REPORT))); i++) {
./drivers/staging/ath6kl/htc2/htc_recv.c:                        pRecord->RecordID, pRecord->Length));
./drivers/staging/ath6kl/htc2/htc_recv.c:        pBuffer += pRecord->Length;
./drivers/staging/ath6kl/htc2/htc_recv.c:        Length -= pRecord->Length;
./drivers/staging/tm6000/tm6000-cards.c:	 * Board-specific initialization sequence. Handles all GPIO
./drivers/staging/tm6000/tm6000-cards.c:	 * initialization sequences that are board-specific.
./drivers/staging/tm6000/tm6000-cards.c:	 * the board-specific session.
./drivers/staging/tm6000/tm6000-cards.c:	 * reset, just add the code at the board-specific part
./drivers/staging/tm6000/tm6000-alsa.c:	strcpy(card->driver, "tm6000-alsa");
./drivers/staging/tm6000/tm6000-alsa.c:	strcpy(card->shortname, "TM5600/60x0");
./drivers/staging/tm6000/tm6000-alsa.c:	sprintf(card->longname, "TM5600/60x0 Audio at bus %d device %d",
./drivers/staging/tm6000/tm6000-alsa.c:	dprintk(1,"Registered audio driver for %s\n", card->longname);
./drivers/staging/tty/istallion.c:	"ONboard-MC",
./drivers/staging/tty/istallion.c:	"ONboard-EI",
./drivers/staging/tty/istallion.c:	"ONboard-MC",
./drivers/staging/tty/istallion.c:	"ONboard-MC",
./drivers/staging/tty/istallion.c:	{ "onboard-2", BRD_ONBOARD2 },
./drivers/staging/tty/istallion.c:	{ "onboard-mc", BRD_ONBOARD2 },
./drivers/staging/tty/istallion.c:	{ "onboard-mca", BRD_ONBOARD2 },
./drivers/staging/tty/istallion.c:	{ "onboard-e", BRD_ONBOARDE },
./drivers/staging/tty/istallion.c:	{ "onboard-ei", BRD_ONBOARDE },
./drivers/staging/tty/ip2/i2ellis.c:// Returns the word read from the data fifo specified by the board-structure
./drivers/staging/tty/ip2/i2ellis.c:// Returns the word read from the data fifo specified by the board-structure
./drivers/staging/tty/ip2/i2ellis.c:// Writes the word 'value' to the data fifo specified by the board-structure
./drivers/staging/tty/ip2/i2ellis.c:// Writes the word 'value' to the data fifo specified by the board-structure
./drivers/staging/tty/ip2/ip2main.c:	if ( pBrd->i2eValid != I2E_MAGIC ) {
./drivers/staging/tty/ip2/ip2main.c:	} else if ( pBrd->i2eChannelCnt < pCh->port_index ) {
./drivers/staging/tty/ip2/ip2main.c:	} else if (&((i2ChanStrPtr)pBrd->i2eChannelPtr)[pCh->port_index] != pCh) {
./drivers/staging/tty/ip2/ip2main.c:	tmp.type = pCh->pMyBord->channelBtypes.bid_value[(pCh->port_index & (IP2_PORTS_PER_BOARD-1))/16];
./drivers/staging/tty/ip2/ip2main.c:	tmp.port = pCh->pMyBord->i2eBase;
./drivers/staging/tty/ip2/ip2main.c:	    || ((int) ns.port      != ((int) (pCh->pMyBord->i2eBase)))
./drivers/staging/tty/epca.c:	ch->board->globalwinon(ch);
./drivers/staging/tty/epca.c:	ch->board->rxwinon(ch);
./drivers/staging/tty/epca.c:	ch->board->txwinon(ch);
./drivers/staging/tty/epca.c:	ch->board->memoff(ch);
./drivers/staging/tty/epca.c:	ch->board->assertgwinon(ch);
./drivers/staging/tty/epca.c:	ch->board->assertmemoff(ch);
./drivers/staging/tty/epca.c:	outb_p(FEPWIN, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(ch->rxwin, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(ch->txwin, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(0, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(FEPWIN, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(ch->rxwin, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(ch->txwin, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(0, (int)ch->board->port);
./drivers/staging/tty/epca.c:	outb_p(0, (int)ch->board->port + 1);
./drivers/staging/tty/epca.c:	outb_p(FEPMEM, ch->board->port);
./drivers/staging/tty/epca.c:	outb_p(FEPMEM, ch->board->port);
./drivers/staging/tty/epca.c:	outb_p(FEPMEM, ch->board->port);
./drivers/staging/tty/epca.c:	outb_p(0, ch->board->port);
./drivers/staging/tty/epca.c:	epcaassert(inb(ch->board->port) & FEPMEM, "Global memory off");
./drivers/staging/tty/epca.c:	epcaassert(!(inb(ch->board->port) & FEPMEM), "Memory on");
./drivers/staging/tty/epca.c:		card_ptr[crd] = card_ptr[crd-1] + boards[crd-1].numports;
./drivers/staging/tty/epca.c:	if (ch->board->status == DISABLED)
./drivers/staging/tty/epca.c:	memaddr = ch->board->re_map_membase;
./drivers/staging/wlan-ng/prism2fw.c:		len = be16_to_cpu(record->len);
./drivers/staging/wlan-ng/prism2fw.c:		addr = be32_to_cpu(record->addr);
./drivers/staging/wlan-ng/prism2fw.c:		ptr32 = (u32 *) record->data;
./drivers/staging/wlan-ng/prism2fw.c:		ptr16 = (u16 *) record->data;
./drivers/staging/wlan-ng/prism2fw.c:			s3data[ns3data].data = (uint8_t *) record->data;
./drivers/staging/easycap/easycap_sound.c:	peasycap = psnd_card->private_data;
./drivers/staging/easycap/easycap_sound.c:	sprintf(&psnd_card->id[0], "EasyALSA%i", peasycap->minor);
./drivers/staging/easycap/easycap_sound.c:	strcpy(&psnd_card->driver[0], EASYCAP_DRIVER_DESCRIPTION);
./drivers/staging/easycap/easycap_sound.c:	strcpy(&psnd_card->shortname[0], "easycap_alsa");
./drivers/staging/easycap/easycap_sound.c:	sprintf(&psnd_card->longname[0], "%s", &psnd_card->shortname[0]);
./drivers/staging/easycap/easycap_sound.c:	psnd_card->dev = &peasycap->pusb_device->dev;
./drivers/staging/easycap/easycap_sound.c:	psnd_card->private_data = peasycap;
./drivers/staging/easycap/easycap_sound.c:	strcpy(&psnd_pcm->name[0], &psnd_card->id[0]);
./drivers/staging/easycap/easycap_sound.c:	SAM("registered %s\n", &psnd_card->id[0]);
./drivers/staging/easycap/easycap_main.c:		while (0xFFFF != peasycap_standard->mask) {
./drivers/staging/easycap/easycap_main.c:			if (fmtidx == peasycap_standard->v4l2_standard.index) {
./drivers/staging/easycap/easycap_main.c:		if (0xFFFF == peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:	while (0xFFFF != peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:		if (std_id == peasycap_standard->v4l2_standard.id)
./drivers/staging/easycap/easycap_ioctl.c:	if (0xFFFF == peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:		while (0xFFFF != peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:			if (std_id & peasycap_standard->v4l2_standard.id)
./drivers/staging/easycap/easycap_ioctl.c:	if (0xFFFF == peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:	    &(peasycap_standard->v4l2_standard.name[0]));
./drivers/staging/easycap/easycap_ioctl.c:	peasycap->fps = peasycap_standard->v4l2_standard.frameperiod.denominator /
./drivers/staging/easycap/easycap_ioctl.c:			peasycap_standard->v4l2_standard.frameperiod.numerator;
./drivers/staging/easycap/easycap_ioctl.c:	if (0x8000 & peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:	switch (peasycap_standard->mask & 0x000F) {
./drivers/staging/easycap/easycap_ioctl.c:		if (peasycap_standard->mask & 0x0001)
./drivers/staging/easycap/easycap_ioctl.c:		if (peasycap_standard->mask & 0x0001)
./drivers/staging/easycap/easycap_ioctl.c:	if (peasycap_standard->mask & 0x0001)
./drivers/staging/easycap/easycap_ioctl.c:		while (0xFFFF != peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:		if (0xFFFF == peasycap_standard->mask) {
./drivers/staging/easycap/easycap_ioctl.c:		    &(peasycap_standard->v4l2_standard.name[0]));
./drivers/staging/easycap/easycap_ioctl.c:		memcpy(&v4l2_standard, &(peasycap_standard->v4l2_standard),
./drivers/staging/easycap/easycap_ioctl.c:		std_id = peasycap_standard->v4l2_standard.id;
./drivers/staging/easycap/easycap_ioctl.c:		    &peasycap_standard->v4l2_standard.name[0]);
./drivers/staging/vt6655/michael.c: *      s_vAppendByte - Append the byte to our word-sized buffer.
./drivers/staging/vt6655/michael.c:    // Append the byte to our word-sized buffer
./drivers/staging/panel/panel.c: * data output pins or to the ground. The combinations have to be hard-coded
./drivers/staging/rts_pstor/rtsx_card.c:		if (sd_card->seq_mode) {
./drivers/staging/rts_pstor/rtsx_card.c:			sd_card->cleanup_counter++;
./drivers/staging/rts_pstor/rtsx_card.c:			sd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/rtsx_card.c:		if (xd_card->delay_write.delay_write_flag) {
./drivers/staging/rts_pstor/rtsx_card.c:			xd_card->cleanup_counter++;
./drivers/staging/rts_pstor/rtsx_card.c:			xd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/rtsx_card.c:			if (ms_card->seq_mode) {
./drivers/staging/rts_pstor/rtsx_card.c:				ms_card->cleanup_counter++;
./drivers/staging/rts_pstor/rtsx_card.c:				ms_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/rtsx_card.c:			if (ms_card->delay_write.delay_write_flag) {
./drivers/staging/rts_pstor/rtsx_card.c:				ms_card->cleanup_counter++;
./drivers/staging/rts_pstor/rtsx_card.c:				ms_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/rtsx_card.c:	if (sd_card->cleanup_counter > POLLING_WAIT_CNT)
./drivers/staging/rts_pstor/rtsx_card.c:	if (xd_card->cleanup_counter > POLLING_WAIT_CNT)
./drivers/staging/rts_pstor/rtsx_card.c:	if (ms_card->cleanup_counter > POLLING_WAIT_CNT)
./drivers/staging/rts_pstor/xd.c:	xd_card->err_code = err_code;
./drivers/staging/rts_pstor/xd.c:	return (xd_card->err_code == err_code);
./drivers/staging/rts_pstor/xd.c:		xd_card->xd_clock = 47;
./drivers/staging/rts_pstor/xd.c:		xd_card->xd_clock = CLK_50;
./drivers/staging/rts_pstor/xd.c:	retval = switch_clock(chip, xd_card->xd_clock);
./drivers/staging/rts_pstor/xd.c:	retval = switch_clock(chip, xd_card->xd_clock);
./drivers/staging/rts_pstor/xd.c:				xd_card->addr_cycle | XD_CALC_ECC | XD_BA_NO_TRANSFORM);
./drivers/staging/rts_pstor/xd.c:				(xd_card->addr_cycle - 1) | XD_CALC_ECC | XD_BA_NO_TRANSFORM);
./drivers/staging/rts_pstor/xd.c:		xd_card->device_code = id_buf[1];
./drivers/staging/rts_pstor/xd.c:		switch (xd_card->device_code) {
./drivers/staging/rts_pstor/xd.c:			xd_card->block_shift = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->page_off = 0x0F;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 3;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 1;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 8000;
./drivers/staging/rts_pstor/xd.c:			xd_card->block_shift = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->page_off = 0x0F;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 3;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 1;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 16000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 3;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 1;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 32000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 3;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 2;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 64000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 128000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 8;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 256000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 16;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 512000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 32;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 1024000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 64;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 2048000;
./drivers/staging/rts_pstor/xd.c:			xd_card->addr_cycle = 4;
./drivers/staging/rts_pstor/xd.c:			xd_card->zone_cnt = 128;
./drivers/staging/rts_pstor/xd.c:			xd_card->capacity = 4096000;
./drivers/staging/rts_pstor/xd.c:			if (id_buf[1] != xd_card->device_code)
./drivers/staging/rts_pstor/xd.c:		xd_card->block_shift = 0;
./drivers/staging/rts_pstor/xd.c:		xd_card->page_off = 0;
./drivers/staging/rts_pstor/xd.c:		xd_card->addr_cycle = 0;
./drivers/staging/rts_pstor/xd.c:		xd_card->capacity = 0;
./drivers/staging/rts_pstor/xd.c:		page_addr = (u32)i << xd_card->block_shift;
./drivers/staging/rts_pstor/xd.c:				xd_card->cis_block = (u16)i;
./drivers/staging/rts_pstor/xd.c:	RTSX_DEBUGP("CIS block: 0x%x\n", xd_card->cis_block);
./drivers/staging/rts_pstor/xd.c:	if (xd_card->cis_block == 0xFFFF)
./drivers/staging/rts_pstor/xd.c:	chip->capacity[chip->card2lun[XD_CARD]] = xd_card->capacity;
./drivers/staging/rts_pstor/xd.c:	RTSX_DEBUGP("xd_init_l2p_tbl: zone_cnt = %d\n", xd_card->zone_cnt);
./drivers/staging/rts_pstor/xd.c:	if (xd_card->zone_cnt < 1)
./drivers/staging/rts_pstor/xd.c:	size = xd_card->zone_cnt * sizeof(struct zone_entry);
./drivers/staging/rts_pstor/xd.c:	xd_card->zone = (struct zone_entry *)vmalloc(size);
./drivers/staging/rts_pstor/xd.c:	if (!xd_card->zone)
./drivers/staging/rts_pstor/xd.c:	for (i = 0; i < xd_card->zone_cnt; i++) {
./drivers/staging/rts_pstor/xd.c:		xd_card->zone[i].build_flag = 0;
./drivers/staging/rts_pstor/xd.c:		xd_card->zone[i].l2p_table = NULL;
./drivers/staging/rts_pstor/xd.c:		xd_card->zone[i].free_table = NULL;
./drivers/staging/rts_pstor/xd.c:		xd_card->zone[i].get_index = 0;
./drivers/staging/rts_pstor/xd.c:		xd_card->zone[i].set_index = 0;
./drivers/staging/rts_pstor/xd.c:		xd_card->zone[i].unused_blk_cnt = 0;
./drivers/staging/rts_pstor/xd.c:	if (zone_no >= xd_card->zone_cnt) {
./drivers/staging/rts_pstor/xd.c:			zone_no, xd_card->zone_cnt);
./drivers/staging/rts_pstor/xd.c:	zone = &(xd_card->zone[zone_no]);
./drivers/staging/rts_pstor/xd.c:	if (zone_no >= xd_card->zone_cnt) {
./drivers/staging/rts_pstor/xd.c:			zone_no, xd_card->zone_cnt);
./drivers/staging/rts_pstor/xd.c:	zone = &(xd_card->zone[zone_no]);
./drivers/staging/rts_pstor/xd.c:	zone = &(xd_card->zone[zone_no]);
./drivers/staging/rts_pstor/xd.c:	zone = &(xd_card->zone[zone_no]);
./drivers/staging/rts_pstor/xd.c:			retval = xd_init_page(chip, phy_blk, log_off, 0, xd_card->page_off + 1);
./drivers/staging/rts_pstor/xd.c:	xd_card->block_shift = 0;
./drivers/staging/rts_pstor/xd.c:	xd_card->page_off = 0;
./drivers/staging/rts_pstor/xd.c:	xd_card->addr_cycle = 0;
./drivers/staging/rts_pstor/xd.c:	xd_card->capacity = 0;
./drivers/staging/rts_pstor/xd.c:	xd_card->zone_cnt = 0;
./drivers/staging/rts_pstor/xd.c:	xd_card->cis_block = 0xFFFF;
./drivers/staging/rts_pstor/xd.c:	xd_card->delay_write.delay_write_flag = 0;
./drivers/staging/rts_pstor/xd.c:	page_addr = phy_blk << xd_card->block_shift;
./drivers/staging/rts_pstor/xd.c:	rtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, xd_card->page_off + 1);
./drivers/staging/rts_pstor/xd.c:	page_addr = (phy_blk << xd_card->block_shift) + start_page;
./drivers/staging/rts_pstor/xd.c:	old_page = (old_blk << xd_card->block_shift) + start_page;
./drivers/staging/rts_pstor/xd.c:	new_page = (new_blk << xd_card->block_shift) + start_page;
./drivers/staging/rts_pstor/xd.c:	page_addr = phy_blk << xd_card->block_shift;
./drivers/staging/rts_pstor/xd.c:	if (xd_card->zone == NULL) {
./drivers/staging/rts_pstor/xd.c:	if (xd_card->zone[zone_no].build_flag) {
./drivers/staging/rts_pstor/xd.c:	zone = &(xd_card->zone[zone_no]);
./drivers/staging/rts_pstor/xd.c:		if (xd_card->cis_block == 0xFFFF)
./drivers/staging/rts_pstor/xd.c:			start = xd_card->cis_block + 1;
./drivers/staging/rts_pstor/xd.c:		u32 page_addr = i << xd_card->block_shift;
./drivers/staging/rts_pstor/xd.c:		page_addr = ((i + 1) << xd_card->block_shift) - 1;
./drivers/staging/rts_pstor/xd.c:			page_addr = ((phy_block + 1) << xd_card->block_shift) - 1;
./drivers/staging/rts_pstor/xd.c:			page_addr = ((u32)i) << xd_card->block_shift;
./drivers/staging/rts_pstor/xd.c:	page_addr = (phy_blk << xd_card->block_shift) + start_page;
./drivers/staging/rts_pstor/xd.c:		retval = xd_copy_page(chip, phy_blk, new_blk, 0, xd_card->page_off + 1);
./drivers/staging/rts_pstor/xd.c:	if (page_off > xd_card->page_off)
./drivers/staging/rts_pstor/xd.c:				page_off, xd_card->page_off + 1);
./drivers/staging/rts_pstor/xd.c:				page_off, xd_card->page_off + 1);
./drivers/staging/rts_pstor/xd.c:	page_addr = (new_blk << xd_card->block_shift) + start_page;
./drivers/staging/rts_pstor/xd.c:	if (end_page == (xd_card->page_off + 1)) {
./drivers/staging/rts_pstor/xd.c:		xd_card->delay_write.delay_write_flag = 0;
./drivers/staging/rts_pstor/xd.c:	struct xd_delay_write_tag *delay_write = &(xd_card->delay_write);
./drivers/staging/rts_pstor/xd.c:	struct xd_delay_write_tag *delay_write = &(xd_card->delay_write);
./drivers/staging/rts_pstor/xd.c:	xd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/xd.c:	log_blk = start_sector >> xd_card->block_shift;
./drivers/staging/rts_pstor/xd.c:	start_page = (u8)start_sector & xd_card->page_off;
./drivers/staging/rts_pstor/xd.c:	if (xd_card->zone[zone_no].build_flag == 0) {
./drivers/staging/rts_pstor/xd.c:		if ((start_page + total_sec_cnt) > (xd_card->page_off + 1))
./drivers/staging/rts_pstor/xd.c:			end_page = xd_card->page_off + 1;
./drivers/staging/rts_pstor/xd.c:		if (xd_card->zone[zone_no].build_flag == 0) {
./drivers/staging/rts_pstor/xd.c:			(end_page != (xd_card->page_off + 1))) {
./drivers/staging/rts_pstor/xd.c:	if (xd_card->zone != NULL) {
./drivers/staging/rts_pstor/xd.c:		for (i = 0; i < xd_card->zone_cnt; i++) {
./drivers/staging/rts_pstor/xd.c:			if (xd_card->zone[i].l2p_table != NULL) {
./drivers/staging/rts_pstor/xd.c:				vfree(xd_card->zone[i].l2p_table);
./drivers/staging/rts_pstor/xd.c:				xd_card->zone[i].l2p_table = NULL;
./drivers/staging/rts_pstor/xd.c:			if (xd_card->zone[i].free_table != NULL) {
./drivers/staging/rts_pstor/xd.c:				vfree(xd_card->zone[i].free_table);
./drivers/staging/rts_pstor/xd.c:				xd_card->zone[i].free_table = NULL;
./drivers/staging/rts_pstor/xd.c:		vfree(xd_card->zone);
./drivers/staging/rts_pstor/xd.c:		xd_card->zone = NULL;
./drivers/staging/rts_pstor/xd.c:	if (xd_card->delay_write.delay_write_flag) {
./drivers/staging/rts_pstor/xd.c:		xd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/xd.c:	xd_card->delay_write.delay_write_flag = 0;
./drivers/staging/rts_pstor/rtsx_scsi.c:		if (sd_card->sd_lock_notify) {
./drivers/staging/rts_pstor/rtsx_scsi.c:			sd_card->sd_lock_notify = 0;
./drivers/staging/rts_pstor/rtsx_scsi.c:		} else if (sd_card->sd_lock_status & SD_LOCKED) {
./drivers/staging/rts_pstor/rtsx_scsi.c:	if ((get_lun_card(chip, lun) == MS_CARD) && ms_card->pro_under_formatting) {
./drivers/staging/rts_pstor/rtsx_scsi.c:		if (ms_card->format_status == FORMAT_SUCCESS) {
./drivers/staging/rts_pstor/rtsx_scsi.c:			ms_card->pro_under_formatting = 0;
./drivers/staging/rts_pstor/rtsx_scsi.c:			ms_card->progress = 0;
./drivers/staging/rts_pstor/rtsx_scsi.c:		} else if (ms_card->format_status == FORMAT_IN_PROGRESS) {
./drivers/staging/rts_pstor/rtsx_scsi.c:					0, (u16)(ms_card->progress));
./drivers/staging/rts_pstor/rtsx_scsi.c:			ms_card->pro_under_formatting = 0;
./drivers/staging/rts_pstor/rtsx_scsi.c:			ms_card->progress = 0;
./drivers/staging/rts_pstor/rtsx_scsi.c:		memcpy(buf + sys_info_offset, ms_card->raw_sys_info, len);
./drivers/staging/rts_pstor/rtsx_scsi.c:	if (sd_card->sd_erase_status) {
./drivers/staging/rts_pstor/rtsx_scsi.c:		if (sd_card->sd_lock_status & SD_LOCKED) {
./drivers/staging/rts_pstor/rtsx_scsi.c:	rtsx_stor_set_xfer_buf(sd_card->raw_csd, scsi_bufflen(srb), srb);
./drivers/staging/rts_pstor/rtsx_scsi.c:			xd_card->xd_clock = srb->cmnd[5];
./drivers/staging/rts_pstor/rtsx_scsi.c:			sd_card->sd_clock = srb->cmnd[5];
./drivers/staging/rts_pstor/rtsx_scsi.c:			ms_card->ms_clock = srb->cmnd[5];
./drivers/staging/rts_pstor/rtsx_scsi.c:			tmp = (u8)(xd_card->xd_clock);
./drivers/staging/rts_pstor/rtsx_scsi.c:			tmp = (u8)(sd_card->sd_clock);
./drivers/staging/rts_pstor/rtsx_scsi.c:			tmp = (u8)(ms_card->ms_clock);
./drivers/staging/rts_pstor/rtsx_scsi.c:				if (sd_card->capacity > 0x4000000) {
./drivers/staging/rts_pstor/rtsx_scsi.c:		if (sd_card->sd_erase_status)
./drivers/staging/rts_pstor/rtsx_scsi.c:		if (sd_card->sd_lock_status & SD_LOCKED) {
./drivers/staging/rts_pstor/rtsx_scsi.c:		if (sd_card->sd_lock_status & SD_PWD_EXIST)
./drivers/staging/rts_pstor/rtsx_scsi.c:		memcpy(buf+i, ms_card->raw_sys_info, 96);
./drivers/staging/rts_pstor/rtsx_scsi.c:		memcpy(buf+i, ms_card->raw_model_name, 48);
./drivers/staging/rts_pstor/rtsx_scsi.c:		ms_card->mg_entry_num = srb->cmnd[5];
./drivers/staging/rts_pstor/rtsx_scsi.c:		ms_card->mg_entry_num = srb->cmnd[5];
./drivers/staging/rts_pstor/rtsx_scsi.c:	if (sd_card->sd_erase_status) {
./drivers/staging/rts_pstor/rtsx_scsi.c:			(ms_card->format_status == FORMAT_IN_PROGRESS)) {
./drivers/staging/rts_pstor/rtsx_scsi.c:					0, (u16)(ms_card->progress));
./drivers/staging/rts_pstor/rtsx.c:	sd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/rtsx.c:	xd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/rtsx.c:	ms_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/ms.c:	ms_card->err_code = err_code;
./drivers/staging/rts_pstor/ms.c:	return (ms_card->err_code == err_code);
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = chip->asic_ms_hg_clk;
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = chip->fpga_ms_hg_clk;
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = chip->asic_ms_4bit_clk;
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = chip->fpga_ms_4bit_clk;
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = chip->asic_ms_1bit_clk;
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = chip->fpga_ms_1bit_clk;
./drivers/staging/rts_pstor/ms.c:	retval = switch_clock(chip, ms_card->ms_clock);
./drivers/staging/rts_pstor/ms.c:	retval = switch_clock(chip, ms_card->ms_clock);
./drivers/staging/rts_pstor/ms.c:	ms_card->ms_type = 0;
./drivers/staging/rts_pstor/ms.c:	ms_card->check_ms_flow = 0;
./drivers/staging/rts_pstor/ms.c:	ms_card->switch_8bit_fail = 0;
./drivers/staging/rts_pstor/ms.c:	ms_card->delay_write.delay_write_flag = 0;
./drivers/staging/rts_pstor/ms.c:	ms_card->pro_under_formatting = 0;
./drivers/staging/rts_pstor/ms.c:			ms_card->check_ms_flow = 1;
./drivers/staging/rts_pstor/ms.c:		ms_card->check_ms_flow = 1;
./drivers/staging/rts_pstor/ms.c:		ms_card->check_ms_flow = 1;
./drivers/staging/rts_pstor/ms.c:	ms_card->ms_type |= TYPE_MSPRO;
./drivers/staging/rts_pstor/ms.c:		ms_card->ms_type &= 0x0F;
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_type |= MS_HG;
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_type &= 0x0F;
./drivers/staging/rts_pstor/ms.c:	ms_card->ms_type |= MS_8BIT;
./drivers/staging/rts_pstor/ms.c:			ms_card->switch_8bit_fail = 1;
./drivers/staging/rts_pstor/ms.c:				ms_card->ms_type |= MS_XC;
./drivers/staging/rts_pstor/ms.c:	memcpy(ms_card->raw_sys_info, buf + sys_info_addr, 96);
./drivers/staging/rts_pstor/ms.c:	memcpy(ms_card->raw_model_name, buf + model_name_addr, 48);
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = xc_total_blk * xc_blk_size;
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = total_blk * blk_size;
./drivers/staging/rts_pstor/ms.c:	chip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity = total_blk * blk_size;
./drivers/staging/rts_pstor/ms.c:		if (ms_card->switch_8bit_fail) {
./drivers/staging/rts_pstor/ms.c:			u8 power_class_mode = (ms_card->raw_sys_info[46] & 0x18) >> 3;
./drivers/staging/rts_pstor/ms.c:	ms_card->ms_type |= TYPE_MS;
./drivers/staging/rts_pstor/ms.c:				ms_card->boot_block = i;
./drivers/staging/rts_pstor/ms.c:		retval = ms_read_page(chip, ms_card->boot_block, j);
./drivers/staging/rts_pstor/ms.c:				i = ms_card->boot_block + 1;
./drivers/staging/rts_pstor/ms.c:	retval = ms_read_page(chip, ms_card->boot_block, 0);
./drivers/staging/rts_pstor/ms.c:	memcpy(ms_card->raw_sys_info, ptr, 96);
./drivers/staging/rts_pstor/ms.c:		i = ms_card->boot_block + 1;
./drivers/staging/rts_pstor/ms.c:		i = ms_card->boot_block + 1;
./drivers/staging/rts_pstor/ms.c:		ms_card->block_shift = 5;
./drivers/staging/rts_pstor/ms.c:		ms_card->page_off = 0x1F;
./drivers/staging/rts_pstor/ms.c:		ms_card->block_shift = 4;
./drivers/staging/rts_pstor/ms.c:		ms_card->page_off = 0x0F;
./drivers/staging/rts_pstor/ms.c:	ms_card->total_block = ((u16)ptr[8] << 8) | ptr[9];
./drivers/staging/rts_pstor/ms.c:	if (ms_card->block_shift == 4)  { /* 4MB or 8MB */
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = 0x1EE0;
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = 0x3DE0;
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = 0x7BC0;
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = 0xF7C0;
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = 0x1EF80;
./drivers/staging/rts_pstor/ms.c:			ms_card->capacity = 0x3DF00;
./drivers/staging/rts_pstor/ms.c:	ms_card->capacity = ((u32)eblock_cnt - 2) << ms_card->block_shift;
./drivers/staging/rts_pstor/ms.c:	chip->capacity[chip->card2lun[MS_CARD]] = ms_card->capacity;
./drivers/staging/rts_pstor/ms.c:		ms_card->ms_type |= MS_4BIT;
./drivers/staging/rts_pstor/ms.c:	ms_card->segment_cnt = ms_card->total_block >> 9;
./drivers/staging/rts_pstor/ms.c:	RTSX_DEBUGP("ms_card->segment_cnt = %d\n", ms_card->segment_cnt);
./drivers/staging/rts_pstor/ms.c:	size = ms_card->segment_cnt * sizeof(struct zone_entry);
./drivers/staging/rts_pstor/ms.c:	ms_card->segment = (struct zone_entry *)vmalloc(size);
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment == NULL) {
./drivers/staging/rts_pstor/ms.c:	memset(ms_card->segment, 0, size);
./drivers/staging/rts_pstor/ms.c:	retval = ms_read_page(chip, ms_card->boot_block, 1);
./drivers/staging/rts_pstor/ms.c:	for (i = 0; i < (((ms_card->total_block >> 9) * 10) + 1); i++) {
./drivers/staging/rts_pstor/ms.c:		ms_card->segment[seg_no].defect_list[ms_card->segment[seg_no].disable_count++] = defect_block;
./drivers/staging/rts_pstor/ms.c:	for (i = 0; i < ms_card->segment_cnt; i++) {
./drivers/staging/rts_pstor/ms.c:		ms_card->segment[i].build_flag = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->segment[i].l2p_table = NULL;
./drivers/staging/rts_pstor/ms.c:		ms_card->segment[i].free_table = NULL;
./drivers/staging/rts_pstor/ms.c:		ms_card->segment[i].get_index = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->segment[i].set_index = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->segment[i].unused_blk_cnt = 0;
./drivers/staging/rts_pstor/ms.c:					i, ms_card->segment[i].disable_count);
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment) {
./drivers/staging/rts_pstor/ms.c:		vfree(ms_card->segment);
./drivers/staging/rts_pstor/ms.c:		ms_card->segment = NULL;
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment == NULL)
./drivers/staging/rts_pstor/ms.c:	segment = &(ms_card->segment[seg_no]);
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment == NULL)
./drivers/staging/rts_pstor/ms.c:	segment = &(ms_card->segment[seg_no]);
./drivers/staging/rts_pstor/ms.c:	segment = &(ms_card->segment[seg_no]);
./drivers/staging/rts_pstor/ms.c:	segment = &(ms_card->segment[seg_no]);
./drivers/staging/rts_pstor/ms.c:	segment = &(ms_card->segment[seg_no]);
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment == NULL) {
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment[seg_no].build_flag) {
./drivers/staging/rts_pstor/ms.c:	segment = &(ms_card->segment[seg_no]);
./drivers/staging/rts_pstor/ms.c:		if (seg_no == ms_card->segment_cnt - 1) {
./drivers/staging/rts_pstor/ms.c:	if (seg_no == ms_card->segment_cnt - 1) {
./drivers/staging/rts_pstor/ms.c:			if (seg_no == ms_card->segment_cnt - 1) {
./drivers/staging/rts_pstor/ms.c:			if (tmp_blk < ms_card->boot_block) {
./drivers/staging/rts_pstor/ms.c:						log_blk, 0, ms_card->page_off + 1);
./drivers/staging/rts_pstor/ms.c:	ms_card->ms_type = 0;
./drivers/staging/rts_pstor/ms.c:		if (ms_card->check_ms_flow) {
./drivers/staging/rts_pstor/ms.c:		retval = ms_build_l2p_tbl(chip, ms_card->total_block / 512 - 1);
./drivers/staging/rts_pstor/ms.c:	RTSX_DEBUGP("ms_card->ms_type = 0x%x\n", ms_card->ms_type);
./drivers/staging/rts_pstor/ms.c:	if (ms_card->seq_mode) {
./drivers/staging/rts_pstor/ms.c:		ms_card->seq_mode = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->total_sec_cnt = 0;
./drivers/staging/rts_pstor/ms.c:		if (ms_card->ms_clock > 30) {
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock -= 20;
./drivers/staging/rts_pstor/ms.c:		if (ms_card->ms_clock == CLK_80) {
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = CLK_60;
./drivers/staging/rts_pstor/ms.c:		} else if (ms_card->ms_clock == CLK_60) {
./drivers/staging/rts_pstor/ms.c:			ms_card->ms_clock = CLK_40;
./drivers/staging/rts_pstor/ms.c:	ms_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/ms.c:	if (ms_card->seq_mode) {
./drivers/staging/rts_pstor/ms.c:		if ((ms_card->pre_dir != srb->sc_data_direction)
./drivers/staging/rts_pstor/ms.c:				|| ((ms_card->pre_sec_addr + ms_card->pre_sec_cnt) != start_sector)
./drivers/staging/rts_pstor/ms.c:				|| (mode_2k && (ms_card->seq_mode & MODE_512_SEQ))
./drivers/staging/rts_pstor/ms.c:				|| (!mode_2k && (ms_card->seq_mode & MODE_2K_SEQ))
./drivers/staging/rts_pstor/ms.c:				|| ((ms_card->total_sec_cnt + sector_cnt) > 0xFE00)) {
./drivers/staging/rts_pstor/ms.c:			ms_card->seq_mode = 0;
./drivers/staging/rts_pstor/ms.c:			ms_card->total_sec_cnt = 0;
./drivers/staging/rts_pstor/ms.c:	if (!ms_card->seq_mode) {
./drivers/staging/rts_pstor/ms.c:		ms_card->total_sec_cnt = 0;
./drivers/staging/rts_pstor/ms.c:			if ((ms_card->capacity - start_sector) > 0xFE00) {
./drivers/staging/rts_pstor/ms.c:				count = (u16)(ms_card->capacity - start_sector);
./drivers/staging/rts_pstor/ms.c:					ms_card->seq_mode |= MODE_2K_SEQ;
./drivers/staging/rts_pstor/ms.c:					ms_card->seq_mode |= MODE_512_SEQ;
./drivers/staging/rts_pstor/ms.c:			ms_card->seq_mode = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->seq_mode = 0;
./drivers/staging/rts_pstor/ms.c:	if (ms_card->seq_mode) {
./drivers/staging/rts_pstor/ms.c:		ms_card->pre_sec_addr = start_sector;
./drivers/staging/rts_pstor/ms.c:		ms_card->pre_sec_cnt = sector_cnt;
./drivers/staging/rts_pstor/ms.c:		ms_card->pre_dir = srb->sc_data_direction;
./drivers/staging/rts_pstor/ms.c:		ms_card->total_sec_cnt += sector_cnt;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:			ms_card->format_status = FORMAT_SUCCESS;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->progress = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->progress = (u16)ulltmp;
./drivers/staging/rts_pstor/ms.c:	RTSX_DEBUGP("progress = %d\n", ms_card->progress);
./drivers/staging/rts_pstor/ms.c:			ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_SUCCESS;
./drivers/staging/rts_pstor/ms.c:		ms_card->pro_under_formatting = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_IN_PROGRESS;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_FAIL;
./drivers/staging/rts_pstor/ms.c:		ms_card->pro_under_formatting = 0;
./drivers/staging/rts_pstor/ms.c:	if (ms_card->pro_under_formatting && (rtsx_get_stat(chip) != RTSX_STAT_SS)) {
./drivers/staging/rts_pstor/ms.c:			if (ms_card->format_status != FORMAT_IN_PROGRESS)
./drivers/staging/rts_pstor/ms.c:		ms_card->pro_under_formatting = 1;
./drivers/staging/rts_pstor/ms.c:		ms_card->progress = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_IN_PROGRESS;
./drivers/staging/rts_pstor/ms.c:		ms_card->pro_under_formatting = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->progress = 0;
./drivers/staging/rts_pstor/ms.c:		ms_card->format_status = FORMAT_SUCCESS;
./drivers/staging/rts_pstor/ms.c:			if ((page_addr == (end_page - 1)) || (page_addr == ms_card->page_off)) {
./drivers/staging/rts_pstor/ms.c:			page_off, ms_card->page_off + 1);
./drivers/staging/rts_pstor/ms.c:	struct ms_delay_write_tag *delay_write = &(ms_card->delay_write);
./drivers/staging/rts_pstor/ms.c:	struct ms_delay_write_tag *delay_write = &(ms_card->delay_write);
./drivers/staging/rts_pstor/ms.c:	ms_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/ms.c:	log_blk = (u16)(start_sector >> ms_card->block_shift);
./drivers/staging/rts_pstor/ms.c:	start_page = (u8)(start_sector & ms_card->page_off);
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment[seg_no].build_flag == 0) {
./drivers/staging/rts_pstor/ms.c:		if ((start_page + total_sec_cnt) > (ms_card->page_off + 1)) {
./drivers/staging/rts_pstor/ms.c:			end_page = ms_card->page_off + 1;
./drivers/staging/rts_pstor/ms.c:			if (end_page == (ms_card->page_off + 1)) {
./drivers/staging/rts_pstor/ms.c:		if (ms_card->segment[seg_no].build_flag == 0) {
./drivers/staging/rts_pstor/ms.c:		if (end_page < (ms_card->page_off + 1)) {
./drivers/staging/rts_pstor/ms.c:	if (ms_card->segment != NULL) {
./drivers/staging/rts_pstor/ms.c:		for (i = 0; i < ms_card->segment_cnt; i++) {
./drivers/staging/rts_pstor/ms.c:			if (ms_card->segment[i].l2p_table != NULL) {
./drivers/staging/rts_pstor/ms.c:				vfree(ms_card->segment[i].l2p_table);
./drivers/staging/rts_pstor/ms.c:				ms_card->segment[i].l2p_table = NULL;
./drivers/staging/rts_pstor/ms.c:			if (ms_card->segment[i].free_table != NULL) {
./drivers/staging/rts_pstor/ms.c:				vfree(ms_card->segment[i].free_table);
./drivers/staging/rts_pstor/ms.c:				ms_card->segment[i].free_table = NULL;
./drivers/staging/rts_pstor/ms.c:		vfree(ms_card->segment);
./drivers/staging/rts_pstor/ms.c:		ms_card->segment = NULL;
./drivers/staging/rts_pstor/ms.c:	memcpy(ms_card->magic_gate_id, buf, 16);
./drivers/staging/rts_pstor/ms.c:	ms_card->mg_auth = 0;
./drivers/staging/rts_pstor/ms.c:	memcpy(buf2 + 4, ms_card->magic_gate_id, 16);
./drivers/staging/rts_pstor/ms.c:	ms_card->mg_auth = 1;
./drivers/staging/rts_pstor/ms.c:	retval = mg_send_ex_cmd(chip, MG_GET_IBD, ms_card->mg_entry_num);
./drivers/staging/rts_pstor/ms.c:	retval = mg_send_ex_cmd(chip, MG_SET_IBD, ms_card->mg_entry_num);
./drivers/staging/rts_pstor/ms.c:		if (ms_card->mg_auth == 0) {
./drivers/staging/rts_pstor/ms.c:			if (ms_card->mg_auth == 0) {
./drivers/staging/rts_pstor/ms.c:		if (ms_card->mg_auth == 0) {
./drivers/staging/rts_pstor/ms.c:		if (ms_card->seq_mode) {
./drivers/staging/rts_pstor/ms.c:			ms_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/ms.c:	else if ((!CHK_MSPRO(ms_card)) && ms_card->delay_write.delay_write_flag) {
./drivers/staging/rts_pstor/ms.c:		ms_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/ms.c:	ms_card->delay_write.delay_write_flag = 0;
./drivers/staging/rts_pstor/ms.c:	ms_card->pro_under_formatting = 0;
./drivers/staging/rts_pstor/ms.c:	memset(ms_card->raw_sys_info, 0, 96);
./drivers/staging/rts_pstor/ms.c:	memset(ms_card->raw_model_name, 0, 48);
./drivers/staging/rts_pstor/sd.c:	sd_card->err_code |= err_code;
./drivers/staging/rts_pstor/sd.c:	sd_card->err_code = 0;
./drivers/staging/rts_pstor/sd.c:	return sd_card->err_code & err_code;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_data_buf_ready = 1;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_data_buf_ready = 0;
./drivers/staging/rts_pstor/sd.c:			sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:		retval = sd_send_cmd_get_rsp(chip, SEND_CSD, sd_card->sd_addr, SD_RSP_TYPE_R2, rsp, 16);
./drivers/staging/rts_pstor/sd.c:	memcpy(sd_card->raw_csd, rsp + 1, 15);
./drivers/staging/rts_pstor/sd.c:		RTSX_READ_REG(chip, REG_SD_CMD5, sd_card->raw_csd + 15);
./drivers/staging/rts_pstor/sd.c:	RTSX_DUMP(sd_card->raw_csd, 16);
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = 47;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = CLK_50;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = 39;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = CLK_40;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = 29;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = CLK_30;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = 23;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = CLK_20;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = 19;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_clock = CLK_20;
./drivers/staging/rts_pstor/sd.c:		sd_card->capacity = 0;
./drivers/staging/rts_pstor/sd.c:			sd_card->capacity = (((u32)(c_size + 1)) * (1 << (c_size_mult + 2))) << (blk_size - 9);
./drivers/staging/rts_pstor/sd.c:			sd_card->capacity = (total_sector + 1) << 10;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->asic_sd_sdr104_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->fpga_sd_sdr104_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->asic_sd_ddr50_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->fpga_sd_ddr50_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->asic_sd_sdr50_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->fpga_sd_sdr50_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->asic_sd_hs_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->fpga_sd_hs_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->asic_mmc_52m_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = chip->fpga_mmc_52m_clk;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = 48;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = CLK_50;
./drivers/staging/rts_pstor/sd.c:	retval = switch_clock(chip, sd_card->sd_clock);
./drivers/staging/rts_pstor/sd.c:		addr = sd_card->sd_addr;
./drivers/staging/rts_pstor/sd.c:	retval = sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr, SD_RSP_TYPE_R1, rsp, 5);
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_lock_status |= SD_LOCKED;
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_lock_status &= ~SD_LOCKED;
./drivers/staging/rts_pstor/sd.c:	RTSX_DEBUGP("sd_card->sd_lock_status = 0x%x\n", sd_card->sd_lock_status);
./drivers/staging/rts_pstor/sd.c:					     sd_card->sd_addr, SD_RSP_TYPE_R1, rsp, 5);
./drivers/staging/rts_pstor/sd.c:	retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	memcpy(sd_card->raw_scr, buf, 8);
./drivers/staging/rts_pstor/sd.c:		sd_card->func_group1_mask = buf[0x0D];
./drivers/staging/rts_pstor/sd.c:		sd_card->func_group2_mask = buf[0x0B];
./drivers/staging/rts_pstor/sd.c:		sd_card->func_group3_mask = buf[0x09];
./drivers/staging/rts_pstor/sd.c:		sd_card->func_group4_mask = buf[0x07];
./drivers/staging/rts_pstor/sd.c:	sd_card->func_group1_mask &= ~(sd_card->sd_switch_fail);
./drivers/staging/rts_pstor/sd.c:			if ((sd_card->func_group1_mask & SDR104_SUPPORT_MASK)
./drivers/staging/rts_pstor/sd.c:			if ((sd_card->func_group1_mask & DDR50_SUPPORT_MASK)
./drivers/staging/rts_pstor/sd.c:			if ((sd_card->func_group1_mask & SDR50_SUPPORT_MASK)
./drivers/staging/rts_pstor/sd.c:			if (sd_card->func_group1_mask & HS_SUPPORT_MASK) {
./drivers/staging/rts_pstor/sd.c:	if ((sd_card->sd_lock_status & SD_SDR_RST)
./drivers/staging/rts_pstor/sd.c:			&& (sd_card->func_group1_mask & SDR50_SUPPORT_MASK)) {
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_switch_fail = SDR104_SUPPORT_MASK;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_switch_fail =
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_switch_fail =
./drivers/staging/rts_pstor/sd.c:			if (sd_card->func_group4_mask & CURRENT_LIMIT_800_MASK) {
./drivers/staging/rts_pstor/sd.c:			if (sd_card->func_group4_mask & CURRENT_LIMIT_600_MASK) {
./drivers/staging/rts_pstor/sd.c:			if (sd_card->func_group4_mask & CURRENT_LIMIT_400_MASK) {
./drivers/staging/rts_pstor/sd.c:			if (sd_card->func_group4_mask & CURRENT_LIMIT_200_MASK) {
./drivers/staging/rts_pstor/sd.c:	retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	retval = sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:			cmd, 5, 16, 1, bus_width, sd_card->raw_csd, 16, 100);
./drivers/staging/rts_pstor/sd.c:	sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:		retval = sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:		if (sd_card->need_retune && (sd_card->sd_clock != chip->cur_clk)) {
./drivers/staging/rts_pstor/sd.c:			sd_card->need_retune = 0;
./drivers/staging/rts_pstor/sd.c:	retval = switch_clock(chip, sd_card->sd_clock);
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_clock = 29;
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_clock = CLK_30;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_type = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->seq_mode = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_data_buf_ready = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->capacity = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_lock_status = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_erase_status = 0;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:		sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON)
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_addr = (u32)rsp[1] << 24;
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_addr += (u32)rsp[2] << 16;
./drivers/staging/rts_pstor/sd.c:		if (sd_card->sd_addr) {
./drivers/staging/rts_pstor/sd.c:	if (sd_card->sd_lock_status & SD_LOCKED) {
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_lock_status |= (SD_LOCK_1BIT_MODE | SD_PWD_EXIST);
./drivers/staging/rts_pstor/sd.c:	} else if (!(sd_card->sd_lock_status & SD_UNLOCK_POW_ON)) {
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_lock_status &= ~SD_PWD_EXIST;
./drivers/staging/rts_pstor/sd.c:	retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:		retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	if (!(sd_card->raw_csd[4] & 0x40))
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_switch_fail = SDR104_SUPPORT_MASK |
./drivers/staging/rts_pstor/sd.c:		retval = sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_lock_status &= ~SD_LOCK_1BIT_MODE;
./drivers/staging/rts_pstor/sd.c:		sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON) {
./drivers/staging/rts_pstor/sd.c:			sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:		sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:		sd_card->capacity = ((u32)ptr[5] << 24) | ((u32)ptr[4] << 16) |
./drivers/staging/rts_pstor/sd.c:		if (!(sd_card->sd_lock_status & SD_SDR_RST) &&
./drivers/staging/rts_pstor/sd.c:	retval = switch_clock(chip, sd_card->sd_clock);
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_lock_status &= ~SD_LOCK_1BIT_MODE;
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_lock_status &= ~SD_LOCK_1BIT_MODE;
./drivers/staging/rts_pstor/sd.c:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON)
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_addr = 0x00100000;
./drivers/staging/rts_pstor/sd.c:	retval = sd_send_cmd_get_rsp(chip, SET_RELATIVE_ADDR, sd_card->sd_addr, SD_RSP_TYPE_R6, rsp, 5);
./drivers/staging/rts_pstor/sd.c:	spec_ver = (sd_card->raw_csd[0] & 0x3C) >> 2;
./drivers/staging/rts_pstor/sd.c:	if (!sd_card->mmc_dont_switch_bus) {
./drivers/staging/rts_pstor/sd.c:		if (CHK_MMC_SECTOR_MODE(sd_card) && (sd_card->capacity == 0)) {
./drivers/staging/rts_pstor/sd.c:	if (sd_card->sd_lock_status & SD_UNLOCK_POW_ON) {
./drivers/staging/rts_pstor/sd.c:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity;
./drivers/staging/rts_pstor/sd.c:	RTSX_DEBUGP("sd_card->sd_type = 0x%x\n", sd_card->sd_type);
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_type = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->seq_mode = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_data_buf_ready = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->capacity = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_switch_fail = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_lock_status = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_erase_status = 0;
./drivers/staging/rts_pstor/sd.c:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity = 0;
./drivers/staging/rts_pstor/sd.c:	chip->capacity[chip->card2lun[SD_CARD]] = sd_card->capacity;
./drivers/staging/rts_pstor/sd.c:	RTSX_DEBUGP("In reset_mmc_only, sd_card->sd_type = 0x%x\n", sd_card->sd_type);
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_data_buf_ready = 0;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:		if (sd_card->sd_data_buf_ready) {
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	if (sd_card->seq_mode) {
./drivers/staging/rts_pstor/sd.c:		sd_card->seq_mode = 0;
./drivers/staging/rts_pstor/sd.c:		if (sd_card->sd_clock > 30) {
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock -= 20;
./drivers/staging/rts_pstor/sd.c:		switch (sd_card->sd_clock) {
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = CLK_150;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = CLK_120;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = CLK_100;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = CLK_80;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = CLK_60;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_clock = CLK_50;
./drivers/staging/rts_pstor/sd.c:	sd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/sd.c:		sd_card->seq_mode = 0;
./drivers/staging/rts_pstor/sd.c:	if (sd_card->seq_mode && ((sd_card->pre_dir != srb->sc_data_direction)
./drivers/staging/rts_pstor/sd.c:			|| ((sd_card->pre_sec_addr + sd_card->pre_sec_cnt) != start_sector))) {
./drivers/staging/rts_pstor/sd.c:		if ((sd_card->pre_sec_cnt < 0x80)
./drivers/staging/rts_pstor/sd.c:				&& (sd_card->pre_dir == DMA_FROM_DEVICE)
./drivers/staging/rts_pstor/sd.c:					sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:		sd_card->seq_mode = 0;
./drivers/staging/rts_pstor/sd.c:		if ((sd_card->pre_sec_cnt < 0x80)
./drivers/staging/rts_pstor/sd.c:					sd_card->sd_addr, SD_RSP_TYPE_R1, NULL, 0);
./drivers/staging/rts_pstor/sd.c:	if (sd_card->seq_mode) {
./drivers/staging/rts_pstor/sd.c:		sd_card->seq_mode = 1;
./drivers/staging/rts_pstor/sd.c:		sd_card->seq_mode = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->pre_sec_addr = start_sector;
./drivers/staging/rts_pstor/sd.c:	sd_card->pre_sec_cnt = sector_cnt;
./drivers/staging/rts_pstor/sd.c:	sd_card->pre_dir = srb->sc_data_direction;
./drivers/staging/rts_pstor/sd.c:	sd_card->seq_mode = 0;
./drivers/staging/rts_pstor/sd.c:			sd_card->mmc_dont_switch_bus = 1;
./drivers/staging/rts_pstor/sd.c:			sd_card->mmc_dont_switch_bus = 0;
./drivers/staging/rts_pstor/sd.c:			sd_card->need_retune = 1;
./drivers/staging/rts_pstor/sd.c:	sd_card->pre_cmd_err = 0;
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_pass_thru_en = 0;
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_pass_thru_en = 1;
./drivers/staging/rts_pstor/sd.c:	buf[6] = (u8)(sd_card->sd_addr >> 16);
./drivers/staging/rts_pstor/sd.c:	buf[7] = (u8)(sd_card->sd_addr >> 24);
./drivers/staging/rts_pstor/sd.c:	if (!sd_card->sd_pass_thru_en) {
./drivers/staging/rts_pstor/sd.c:	if (sd_card->pre_cmd_err) {
./drivers/staging/rts_pstor/sd.c:		sd_card->pre_cmd_err = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->last_rsp_type = rsp_type;
./drivers/staging/rts_pstor/sd.c:	if ((sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) == 0) {
./drivers/staging/rts_pstor/sd.c:		retval = ext_sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:			sd_card->rsp, rsp_len, 0);
./drivers/staging/rts_pstor/sd.c:	sd_card->pre_cmd_err = 1;
./drivers/staging/rts_pstor/sd.c:	if (!sd_card->sd_pass_thru_en) {
./drivers/staging/rts_pstor/sd.c:	if (sd_card->pre_cmd_err) {
./drivers/staging/rts_pstor/sd.c:		sd_card->pre_cmd_err = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->last_rsp_type = rsp_type;
./drivers/staging/rts_pstor/sd.c:	if ((sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) == 0) {
./drivers/staging/rts_pstor/sd.c:		retval = ext_sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:	retval = ext_sd_get_rsp(chip, rsp_len, sd_card->rsp, rsp_type);
./drivers/staging/rts_pstor/sd.c:		retval = ext_sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:	sd_card->pre_cmd_err = 1;
./drivers/staging/rts_pstor/sd.c:	if (!sd_card->sd_pass_thru_en) {
./drivers/staging/rts_pstor/sd.c:	if (sd_card->pre_cmd_err) {
./drivers/staging/rts_pstor/sd.c:		sd_card->pre_cmd_err = 0;
./drivers/staging/rts_pstor/sd.c:		sd_lock_state = sd_card->sd_lock_status;
./drivers/staging/rts_pstor/sd.c:	sd_card->last_rsp_type = rsp_type;
./drivers/staging/rts_pstor/sd.c:	if ((sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) == 0) {
./drivers/staging/rts_pstor/sd.c:		retval = ext_sd_send_cmd_get_rsp(chip, APP_CMD, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:			sd_card->rsp, rsp_len, 0);
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_erase_status = SD_UNDER_ERASING;
./drivers/staging/rts_pstor/sd.c:		retval = ext_sd_send_cmd_get_rsp(chip, SEND_STATUS, sd_card->sd_addr,
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_lock_status &= ~SD_PWD_EXIST;
./drivers/staging/rts_pstor/sd.c:				sd_card->sd_lock_status |= SD_PWD_EXIST;
./drivers/staging/rts_pstor/sd.c:		RTSX_DEBUGP("sd_lock_state = 0x%x, sd_card->sd_lock_status = 0x%x\n",
./drivers/staging/rts_pstor/sd.c:			     sd_lock_state, sd_card->sd_lock_status);
./drivers/staging/rts_pstor/sd.c:		if (sd_lock_state ^ (sd_card->sd_lock_status & SD_LOCKED)) {
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_lock_notify = 1;
./drivers/staging/rts_pstor/sd.c:				if (sd_card->sd_lock_status & SD_LOCK_1BIT_MODE) {
./drivers/staging/rts_pstor/sd.c:					sd_card->sd_lock_status |= (SD_UNLOCK_POW_ON | SD_SDR_RST);
./drivers/staging/rts_pstor/sd.c:							sd_card->sd_lock_status &= ~(SD_UNLOCK_POW_ON | SD_SDR_RST);
./drivers/staging/rts_pstor/sd.c:					sd_card->sd_lock_status &= ~(SD_UNLOCK_POW_ON | SD_SDR_RST);
./drivers/staging/rts_pstor/sd.c:	sd_card->pre_cmd_err = 1;
./drivers/staging/rts_pstor/sd.c:	if (!sd_card->sd_pass_thru_en) {
./drivers/staging/rts_pstor/sd.c:	if (sd_card->pre_cmd_err) {
./drivers/staging/rts_pstor/sd.c:		sd_card->pre_cmd_err = 0;
./drivers/staging/rts_pstor/sd.c:	if (sd_card->last_rsp_type == SD_RSP_TYPE_R0) {
./drivers/staging/rts_pstor/sd.c:	} else if (sd_card->last_rsp_type == SD_RSP_TYPE_R2) {
./drivers/staging/rts_pstor/sd.c:	rtsx_stor_set_xfer_buf(sd_card->rsp, count, srb);
./drivers/staging/rts_pstor/sd.c:		sd_card->rsp[0], sd_card->rsp[1], sd_card->rsp[2], sd_card->rsp[3]);
./drivers/staging/rts_pstor/sd.c:	if (!sd_card->sd_pass_thru_en) {
./drivers/staging/rts_pstor/sd.c:	if (sd_card->pre_cmd_err) {
./drivers/staging/rts_pstor/sd.c:		sd_card->pre_cmd_err = 0;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_lock_status |= SD_SDR_RST;
./drivers/staging/rts_pstor/sd.c:			sd_card->sd_lock_status &= ~SD_SDR_RST;
./drivers/staging/rts_pstor/sd.c:			sd_card->pre_cmd_err = 1;
./drivers/staging/rts_pstor/sd.c:		sd_card->sd_lock_status &= ~SD_SDR_RST;
./drivers/staging/rts_pstor/sd.c:			sd_card->pre_cmd_err = 1;
./drivers/staging/rts_pstor/sd.c:	if (sd_card->seq_mode) {
./drivers/staging/rts_pstor/sd.c:		sd_card->cleanup_counter = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_lock_status = 0;
./drivers/staging/rts_pstor/sd.c:	sd_card->sd_erase_status = 0;
./drivers/staging/rts_pstor/sd.c:	memset(sd_card->raw_csd, 0, 16);
./drivers/staging/rts_pstor/sd.c:	memset(sd_card->raw_scr, 0, 8);
./drivers/staging/rts_pstor/rtsx_chip.c:	if (sd_card->sd_erase_status) {
./drivers/staging/rts_pstor/rtsx_chip.c:					sd_card->sd_erase_status = SD_NOT_ERASE;
./drivers/staging/rts_pstor/rtsx_chip.c:					sd_card->sd_lock_notify = 1;
./drivers/staging/rts_pstor/rtsx_chip.c:					sd_card->sd_erase_status = SD_NOT_ERASE;
./drivers/staging/rts_pstor/rtsx_chip.c:					sd_card->sd_lock_notify = 1;
./drivers/staging/rts_pstor/rtsx_chip.c:			sd_card->sd_erase_status = SD_NOT_ERASE;
./drivers/staging/vt6656/michael.c: *      s_vAppendByte - Append the byte to our word-sized buffer.
./drivers/staging/vt6656/michael.c:	/* Append the byte to our word-sized buffer */
./drivers/input/touchscreen/ads7846.c: * note. The strength of filtering can be set in the board-* specific
./drivers/input/touchscreen/ad7879-i2c.c:/* All registers are word-sized.
./drivers/input/touchscreen/wacom_w8001.c:	coord->rdy = data[0] & 0x20;
./drivers/input/touchscreen/wacom_w8001.c:	coord->tsw = data[0] & 0x01;
./drivers/input/touchscreen/wacom_w8001.c:	coord->f1 = data[0] & 0x02;
./drivers/input/touchscreen/wacom_w8001.c:	coord->f2 = data[0] & 0x04;
./drivers/input/touchscreen/wacom_w8001.c:	coord->x = (data[1] & 0x7F) << 9;
./drivers/input/touchscreen/wacom_w8001.c:	coord->x |= (data[2] & 0x7F) << 2;
./drivers/input/touchscreen/wacom_w8001.c:	coord->x |= (data[6] & 0x60) >> 5;
./drivers/input/touchscreen/wacom_w8001.c:	coord->y = (data[3] & 0x7F) << 9;
./drivers/input/touchscreen/wacom_w8001.c:	coord->y |= (data[4] & 0x7F) << 2;
./drivers/input/touchscreen/wacom_w8001.c:	coord->y |= (data[6] & 0x18) >> 3;
./drivers/input/touchscreen/wacom_w8001.c:	coord->pen_pressure = data[5] & 0x7F;
./drivers/input/touchscreen/wacom_w8001.c:	coord->pen_pressure |= (data[6] & 0x07) << 7 ;
./drivers/input/touchscreen/wacom_w8001.c:	coord->tilt_x = data[7] & 0x7F;
./drivers/input/touchscreen/wacom_w8001.c:	coord->tilt_y = data[8] & 0x7F;
./drivers/input/touchscreen/wacom_w8001.c:	coord->x = (data[1] << 7) | data[2];
./drivers/input/touchscreen/wacom_w8001.c:	coord->y = (data[3] << 7) | data[4];
./drivers/input/touchscreen/wacom_w8001.c:	coord->tsw = data[0] & 0x01;
./drivers/input/touchscreen/wacom_w8001.c:		if (!coord->f2) {
./drivers/input/touchscreen/wacom_w8001.c:		w8001->type = coord->f2 ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;
./drivers/input/touchscreen/wacom_w8001.c:		input_report_key(dev, BTN_STYLUS2, coord->f2);
./drivers/input/touchscreen/wacom_w8001.c:	input_report_abs(dev, ABS_X, coord->x);
./drivers/input/touchscreen/wacom_w8001.c:	input_report_abs(dev, ABS_Y, coord->y);
./drivers/input/touchscreen/wacom_w8001.c:	input_report_abs(dev, ABS_PRESSURE, coord->pen_pressure);
./drivers/input/touchscreen/wacom_w8001.c:	input_report_key(dev, BTN_TOUCH, coord->tsw);
./drivers/input/touchscreen/wacom_w8001.c:	input_report_key(dev, BTN_STYLUS, coord->f1);
./drivers/input/touchscreen/wacom_w8001.c:	input_report_key(dev, w8001->type, coord->rdy);
./drivers/input/touchscreen/wacom_w8001.c:	if (!coord->rdy)
./drivers/input/touchscreen/wacom_w8001.c:	unsigned int x = coord->x;
./drivers/input/touchscreen/wacom_w8001.c:	unsigned int y = coord->y;
./drivers/input/touchscreen/wacom_w8001.c:	input_report_key(dev, BTN_TOUCH, coord->tsw);
./drivers/input/touchscreen/wacom_w8001.c:	input_report_key(dev, BTN_TOOL_FINGER, coord->tsw);
./drivers/input/touchscreen/wacom_w8001.c:	w8001->type = coord->tsw ? BTN_TOOL_FINGER : KEY_RESERVED;
./drivers/input/touchscreen/tsc2005.c:	rd->spi_tx		   = (reg | TSC2005_REG_READ) << 16;
./drivers/input/touchscreen/tsc2005.c:	rd->spi_xfer.tx_buf	   = &rd->spi_tx;
./drivers/input/touchscreen/tsc2005.c:	rd->spi_xfer.rx_buf	   = &rd->spi_rx;
./drivers/input/touchscreen/tsc2005.c:	rd->spi_xfer.len	   = 4;
./drivers/input/touchscreen/tsc2005.c:	rd->spi_xfer.bits_per_word = 24;
./drivers/input/touchscreen/tsc2005.c:	rd->spi_xfer.cs_change	   = !last;
./drivers/input/touchscreen/ucb1400_ts.c: * hard-coded machine dependencies.
./drivers/input/touchscreen/tps6507x-ts.c:	 * coming from the board-evm file.
./drivers/input/touchscreen/tps6507x-ts.c:	 * coming from the board-evm file.
./drivers/input/touchscreen/tps6507x-ts.c:	init_data = tps_board->tps6507x_ts_init_data;
./drivers/input/misc/keychord.c:	if (keychord->count != kdev->key_down)
./drivers/input/misc/keychord.c:	for (i = 0; i < keychord->count; i++) {
./drivers/input/misc/keychord.c:		if (!test_bit(keychord->keycodes[i], kdev->keystate))
./drivers/input/misc/keychord.c:			kdev->buff[kdev->head] = keychord->id;
./drivers/input/misc/keychord.c:		if (keychord->count <= 0 || next > end) {
./drivers/input/misc/keychord.c:				keychord->count);
./drivers/input/misc/keychord.c:		if (keychord->version != KEYCHORD_VERSION) {
./drivers/input/misc/keychord.c:				keychord->version);
./drivers/input/misc/keychord.c:		for (i = 0; i < keychord->count; i++) {
./drivers/input/misc/keychord.c:			key = keychord->keycodes[i];
./drivers/input/serio/ams_delta_serio.c:#include <plat/board-ams-delta.h>
./drivers/input/keyboard/tc3589x-keypad.c:	u8 settle_time = keypad->board->settle_time;
./drivers/input/keyboard/tc3589x-keypad.c:	u8 dbounce_period = keypad->board->debounce_period;
./drivers/input/keyboard/tc3589x-keypad.c:	u8 rows = keypad->board->krow & 0xf;	/* mask out the nibble */
./drivers/input/keyboard/tc3589x-keypad.c:	u8 column = keypad->board->kcol & 0xf;	/* mask out the nibble */
./drivers/input/keyboard/tc3589x-keypad.c:	if (keypad->board->kcol > TC3589x_MAX_KPCOL ||
./drivers/input/keyboard/tc3589x-keypad.c:	    keypad->board->krow > TC3589x_MAX_KPROW ||
./drivers/input/keyboard/tc3589x-keypad.c:	    keypad->board->debounce_period > TC3589x_MAX_DEBOUNCE_SETTLE ||
./drivers/input/keyboard/tc3589x-keypad.c:	    keypad->board->settle_time > TC3589x_MAX_DEBOUNCE_SETTLE)
./drivers/input/keyboard/nomadik-ske-keypad.c:	value |= ((keypad->board->debounce_ms * 32000)/32768) << 8;
./drivers/input/keyboard/nomadik-ske-keypad.c:	value = (keypad->board->kcol - 1) << 3;
./drivers/input/keyboard/nomadik-ske-keypad.c:	if (keypad->board->init)
./drivers/input/keyboard/nomadik-ske-keypad.c:		keypad->board->init();
./drivers/input/keyboard/nomadik-ske-keypad.c:	if (keypad->board->exit)
./drivers/input/keyboard/nomadik-ske-keypad.c:		keypad->board->exit();
./drivers/platform/x86/thinkpad_acpi.c:	if (alsa_card && alsa_card->private_data) {
./drivers/platform/x86/thinkpad_acpi.c:		d = alsa_card->private_data;
./drivers/platform/x86/thinkpad_acpi.c:	BUG_ON(!card->private_data);
./drivers/platform/x86/thinkpad_acpi.c:	data = card->private_data;
./drivers/platform/x86/thinkpad_acpi.c:	strlcpy(card->driver, TPACPI_ALSA_DRVNAME,
./drivers/platform/x86/thinkpad_acpi.c:		sizeof(card->driver));
./drivers/platform/x86/thinkpad_acpi.c:	strlcpy(card->shortname, TPACPI_ALSA_SHRTNAME,
./drivers/platform/x86/thinkpad_acpi.c:		sizeof(card->shortname));
./drivers/platform/x86/thinkpad_acpi.c:	snprintf(card->mixername, sizeof(card->mixername), "ThinkPad EC %s",
./drivers/platform/x86/thinkpad_acpi.c:	snprintf(card->longname, sizeof(card->longname),
./drivers/platform/x86/thinkpad_acpi.c:		 "%s at EC reg 0x%02x, fw %s", card->shortname, TP_EC_AUDIO,
./drivers/mmc/core/mmc.c:	u32 *resp = card->raw_cid;
./drivers/mmc/core/mmc.c:	switch (card->csd.mmca_vsn) {
./drivers/mmc/core/mmc.c:		card->cid.manfid	= UNSTUFF_BITS(resp, 104, 24);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[6]	= UNSTUFF_BITS(resp, 48, 8);
./drivers/mmc/core/mmc.c:		card->cid.hwrev		= UNSTUFF_BITS(resp, 44, 4);
./drivers/mmc/core/mmc.c:		card->cid.fwrev		= UNSTUFF_BITS(resp, 40, 4);
./drivers/mmc/core/mmc.c:		card->cid.serial	= UNSTUFF_BITS(resp, 16, 24);
./drivers/mmc/core/mmc.c:		card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
./drivers/mmc/core/mmc.c:		card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
./drivers/mmc/core/mmc.c:		card->cid.manfid	= UNSTUFF_BITS(resp, 120, 8);
./drivers/mmc/core/mmc.c:		card->cid.oemid		= UNSTUFF_BITS(resp, 104, 16);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[0]	= UNSTUFF_BITS(resp, 96, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[1]	= UNSTUFF_BITS(resp, 88, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[2]	= UNSTUFF_BITS(resp, 80, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[3]	= UNSTUFF_BITS(resp, 72, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[4]	= UNSTUFF_BITS(resp, 64, 8);
./drivers/mmc/core/mmc.c:		card->cid.prod_name[5]	= UNSTUFF_BITS(resp, 56, 8);
./drivers/mmc/core/mmc.c:		card->cid.serial	= UNSTUFF_BITS(resp, 16, 32);
./drivers/mmc/core/mmc.c:		card->cid.month		= UNSTUFF_BITS(resp, 12, 4);
./drivers/mmc/core/mmc.c:		card->cid.year		= UNSTUFF_BITS(resp, 8, 4) + 1997;
./drivers/mmc/core/mmc.c:			mmc_hostname(card->host), card->csd.mmca_vsn);
./drivers/mmc/core/mmc.c:	if (card->ext_csd.erase_group_def & 1)
./drivers/mmc/core/mmc.c:		card->erase_size = card->ext_csd.hc_erase_size;
./drivers/mmc/core/mmc.c:		card->erase_size = card->csd.erase_size;
./drivers/mmc/core/mmc.c:	struct mmc_csd *csd = &card->csd;
./drivers/mmc/core/mmc.c:	u32 *resp = card->raw_csd;
./drivers/mmc/core/mmc.c:			mmc_hostname(card->host), csd->structure);
./drivers/mmc/core/mmc.c:	if (card->csd.mmca_vsn < CSD_SPEC_VER_4)
./drivers/mmc/core/mmc.c:			"receive the ext_csd.\n", mmc_hostname(card->host));
./drivers/mmc/core/mmc.c:		if (card->csd.capacity == (4096 * 512)) {
./drivers/mmc/core/mmc.c:				mmc_hostname(card->host));
./drivers/mmc/core/mmc.c:				mmc_hostname(card->host));
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_ext_csd_structure = ext_csd[EXT_CSD_STRUCTURE];
./drivers/mmc/core/mmc.c:	if (card->csd.structure == 3) {
./drivers/mmc/core/mmc.c:		if (card->ext_csd.raw_ext_csd_structure > 2) {
./drivers/mmc/core/mmc.c:				"version %d\n", mmc_hostname(card->host),
./drivers/mmc/core/mmc.c:					card->ext_csd.raw_ext_csd_structure);
./drivers/mmc/core/mmc.c:	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
./drivers/mmc/core/mmc.c:	if (card->ext_csd.rev > 5) {
./drivers/mmc/core/mmc.c:			mmc_hostname(card->host), card->ext_csd.rev);
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_sectors[0] = ext_csd[EXT_CSD_SEC_CNT + 0];
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_sectors[1] = ext_csd[EXT_CSD_SEC_CNT + 1];
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_sectors[2] = ext_csd[EXT_CSD_SEC_CNT + 2];
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_sectors[3] = ext_csd[EXT_CSD_SEC_CNT + 3];
./drivers/mmc/core/mmc.c:	if (card->ext_csd.rev >= 2) {
./drivers/mmc/core/mmc.c:		card->ext_csd.sectors =
./drivers/mmc/core/mmc.c:		if (card->ext_csd.sectors > (2u * 1024 * 1024 * 1024) / 512)
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_card_type = ext_csd[EXT_CSD_CARD_TYPE];
./drivers/mmc/core/mmc.c:		card->ext_csd.hs_max_dtr = 52000000;
./drivers/mmc/core/mmc.c:		card->ext_csd.card_type = EXT_CSD_CARD_TYPE_DDR_52;
./drivers/mmc/core/mmc.c:		card->ext_csd.hs_max_dtr = 52000000;
./drivers/mmc/core/mmc.c:		card->ext_csd.card_type = EXT_CSD_CARD_TYPE_DDR_1_2V;
./drivers/mmc/core/mmc.c:		card->ext_csd.hs_max_dtr = 52000000;
./drivers/mmc/core/mmc.c:		card->ext_csd.card_type = EXT_CSD_CARD_TYPE_DDR_1_8V;
./drivers/mmc/core/mmc.c:		card->ext_csd.hs_max_dtr = 52000000;
./drivers/mmc/core/mmc.c:		card->ext_csd.hs_max_dtr = 26000000;
./drivers/mmc/core/mmc.c:			mmc_hostname(card->host));
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_s_a_timeout = ext_csd[EXT_CSD_S_A_TIMEOUT];
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_erase_timeout_mult =
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_hc_erase_grp_size =
./drivers/mmc/core/mmc.c:	if (card->ext_csd.rev >= 3) {
./drivers/mmc/core/mmc.c:		card->ext_csd.part_config = ext_csd[EXT_CSD_PART_CONFIG];
./drivers/mmc/core/mmc.c:		card->ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];
./drivers/mmc/core/mmc.c:			card->ext_csd.sa_timeout =
./drivers/mmc/core/mmc.c:		card->ext_csd.erase_group_def =
./drivers/mmc/core/mmc.c:		card->ext_csd.hc_erase_timeout = 300 *
./drivers/mmc/core/mmc.c:		card->ext_csd.hc_erase_size =
./drivers/mmc/core/mmc.c:		card->ext_csd.rel_sectors = ext_csd[EXT_CSD_REL_WR_SEC_C];
./drivers/mmc/core/mmc.c:		card->ext_csd.boot_size = ext_csd[EXT_CSD_BOOT_MULT] << 17;
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_hc_erase_gap_size =
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_sec_trim_mult =
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_sec_erase_mult =
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_sec_feature_support =
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_trim_mult =
./drivers/mmc/core/mmc.c:	if (card->ext_csd.rev >= 4) {
./drivers/mmc/core/mmc.c:		card->ext_csd.raw_partition_support = ext_csd[EXT_CSD_PARTITION_SUPPORT];
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_en = 1;
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_offset =
./drivers/mmc/core/mmc.c:				card->ext_csd.enhanced_area_offset <<= 9;
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_size =
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_size *=
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_size <<= 9;
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_offset = -EINVAL;
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_size = -EINVAL;
./drivers/mmc/core/mmc.c:		card->ext_csd.sec_trim_mult =
./drivers/mmc/core/mmc.c:		card->ext_csd.sec_erase_mult =
./drivers/mmc/core/mmc.c:		card->ext_csd.sec_feature_support =
./drivers/mmc/core/mmc.c:		card->ext_csd.trim_timeout = 300 *
./drivers/mmc/core/mmc.c:	if (card->ext_csd.rev >= 5)
./drivers/mmc/core/mmc.c:		card->ext_csd.rel_param = ext_csd[EXT_CSD_WR_REL_PARAM];
./drivers/mmc/core/mmc.c:	card->ext_csd.raw_erased_mem_count = ext_csd[EXT_CSD_ERASED_MEM_CONT];
./drivers/mmc/core/mmc.c:		card->erased_byte = 0xFF;
./drivers/mmc/core/mmc.c:		card->erased_byte = 0x0;
./drivers/mmc/core/mmc.c:	err = (!(card->ext_csd.raw_partition_support ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_erased_mem_count ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.rev ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_ext_csd_structure ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_card_type ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_s_a_timeout ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_hc_erase_gap_size ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_erase_timeout_mult ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_hc_erase_grp_size ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_sec_trim_mult ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_sec_erase_mult ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_sec_feature_support ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_trim_mult ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_sectors[0] ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_sectors[1] ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_sectors[2] ==
./drivers/mmc/core/mmc.c:		(card->ext_csd.raw_sectors[3] ==
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
./drivers/mmc/core/mmc.c:	card->raw_cid[2], card->raw_cid[3]);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
./drivers/mmc/core/mmc.c:	card->raw_csd[2], card->raw_csd[3]);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(date, "%02d/%04d\n", card->cid.month, card->cid.year);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(erase_size, "%u\n", card->erase_size << 9);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(preferred_erase_size, "%u\n", card->pref_erase << 9);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(fwrev, "0x%x\n", card->cid.fwrev);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
./drivers/mmc/core/mmc.c:		card->ext_csd.enhanced_area_offset);
./drivers/mmc/core/mmc.c:MMC_DEV_ATTR(enhanced_area_size, "%u\n", card->ext_csd.enhanced_area_size);
./drivers/mmc/core/mmc.c:		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {
./drivers/mmc/core/mmc.c:		card->type = MMC_TYPE_MMC;
./drivers/mmc/core/mmc.c:		card->rca = 1;
./drivers/mmc/core/mmc.c:		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
./drivers/mmc/core/mmc.c:		err = mmc_send_csd(card, card->raw_csd);
./drivers/mmc/core/mmc.c:	if (card->ext_csd.enhanced_area_en) {
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_offset = -EINVAL;
./drivers/mmc/core/mmc.c:			card->ext_csd.enhanced_area_size = -EINVAL;
./drivers/mmc/core/mmc.c:			card->ext_csd.erase_group_def = 1;
./drivers/mmc/core/mmc.c:	if (card->ext_csd.part_config & EXT_CSD_PART_CONFIG_ACC_MASK) {
./drivers/mmc/core/mmc.c:		card->ext_csd.part_config &= ~EXT_CSD_PART_CONFIG_ACC_MASK;
./drivers/mmc/core/mmc.c:				 card->ext_csd.part_config,
./drivers/mmc/core/mmc.c:				 card->ext_csd.part_time);
./drivers/mmc/core/mmc.c:	if ((card->ext_csd.hs_max_dtr != 0) &&
./drivers/mmc/core/mmc.c:			       mmc_hostname(card->host));
./drivers/mmc/core/mmc.c:			mmc_set_timing(card->host, MMC_TIMING_MMC_HS);
./drivers/mmc/core/mmc.c:		if (max_dtr > card->ext_csd.hs_max_dtr)
./drivers/mmc/core/mmc.c:			max_dtr = card->ext_csd.hs_max_dtr;
./drivers/mmc/core/mmc.c:	} else if (max_dtr > card->csd.max_dtr) {
./drivers/mmc/core/mmc.c:		max_dtr = card->csd.max_dtr;
./drivers/mmc/core/mmc.c:		if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_8V)
./drivers/mmc/core/mmc.c:		else if ((card->ext_csd.card_type & EXT_CSD_CARD_TYPE_DDR_1_2V)
./drivers/mmc/core/mmc.c:	if ((card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
./drivers/mmc/core/mmc.c:				mmc_set_bus_width(card->host, bus_width);
./drivers/mmc/core/mmc.c:				"failed\n", mmc_hostname(card->host),
./drivers/mmc/core/mmc.c:			mmc_set_timing(card->host, MMC_TIMING_UHS_DDR50);
./drivers/mmc/core/mmc.c:			mmc_set_bus_width(card->host, bus_width);
./drivers/mmc/core/mmc.c:	host->card->state &= ~MMC_STATE_HIGHSPEED;
./drivers/mmc/core/mmc.c:	host->card->state &= ~MMC_STATE_HIGHSPEED;
./drivers/mmc/core/mmc.c:	if (card && card->ext_csd.rev >= 3) {
./drivers/mmc/core/mmc.c:	if (card && card->ext_csd.rev >= 3) {
./drivers/mmc/core/sdio.c:	if (!(card->quirks & MMC_QUIRK_NONSTD_SDIO)) {
./drivers/mmc/core/sdio.c:		func->vendor = func->card->cis.vendor;
./drivers/mmc/core/sdio.c:		func->device = func->card->cis.device;
./drivers/mmc/core/sdio.c:		func->max_blksize = func->card->cis.blksize;
./drivers/mmc/core/sdio.c:	card->sdio_func[fn - 1] = func;
./drivers/mmc/core/sdio.c:	memset(&card->cccr, 0, sizeof(struct sdio_cccr));
./drivers/mmc/core/sdio.c:			mmc_hostname(card->host), cccr_vsn);
./drivers/mmc/core/sdio.c:	card->cccr.sdio_vsn = (data & 0xf0) >> 4;
./drivers/mmc/core/sdio.c:		card->cccr.multi_block = 1;
./drivers/mmc/core/sdio.c:		card->cccr.low_speed = 1;
./drivers/mmc/core/sdio.c:		card->cccr.wide_bus = 1;
./drivers/mmc/core/sdio.c:			card->cccr.high_power = 1;
./drivers/mmc/core/sdio.c:			card->cccr.high_speed = 1;
./drivers/mmc/core/sdio.c:	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
./drivers/mmc/core/sdio.c:	if (card->cccr.low_speed && !card->cccr.wide_bus)
./drivers/mmc/core/sdio.c:	if (!(card->host->caps & MMC_CAP_4_BIT_DATA))
./drivers/mmc/core/sdio.c:	if (card->cccr.low_speed && !card->cccr.wide_bus)
./drivers/mmc/core/sdio.c:	mmc_set_bus_width(card->host, MMC_BUS_WIDTH_1);
./drivers/mmc/core/sdio.c:	if (card->type == MMC_TYPE_SDIO)
./drivers/mmc/core/sdio.c:	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
./drivers/mmc/core/sdio.c:		(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
./drivers/mmc/core/sdio.c:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
./drivers/mmc/core/sdio.c:	if (!card->cccr.high_speed)
./drivers/mmc/core/sdio.c:	if (ret <= 0 || card->type == MMC_TYPE_SDIO)
./drivers/mmc/core/sdio.c:		max_dtr = card->cis.max_dtr;
./drivers/mmc/core/sdio.c:	if (card->type == MMC_TYPE_SD_COMBO)
./drivers/mmc/core/sdio.c:	    mmc_sd_get_cid(host, host->ocr & ocr, card->raw_cid, NULL) == 0) {
./drivers/mmc/core/sdio.c:		card->type = MMC_TYPE_SD_COMBO;
./drivers/mmc/core/sdio.c:		if (oldcard && (oldcard->type != MMC_TYPE_SD_COMBO ||
./drivers/mmc/core/sdio.c:		    memcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {
./drivers/mmc/core/sdio.c:		card->type = MMC_TYPE_SDIO;
./drivers/mmc/core/sdio.c:		if (oldcard && oldcard->type != MMC_TYPE_SDIO) {
./drivers/mmc/core/sdio.c:		err = mmc_send_relative_addr(host, &card->rca);
./drivers/mmc/core/sdio.c:			oldcard->rca = card->rca;
./drivers/mmc/core/sdio.c:	if (!oldcard && card->type == MMC_TYPE_SD_COMBO) {
./drivers/mmc/core/sdio.c:	if (card->quirks & MMC_QUIRK_NONSTD_SDIO) {
./drivers/mmc/core/sdio.c:		mmc_set_clock(host, card->cis.max_dtr);
./drivers/mmc/core/sdio.c:		if (card->cccr.high_speed) {
./drivers/mmc/core/sdio.c:			mmc_set_timing(card->host, MMC_TIMING_SD_HS);
./drivers/mmc/core/sdio.c:		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
./drivers/mmc/core/sdio.c:		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
./drivers/mmc/core/sdio.c:		int same = (card->cis.vendor == oldcard->cis.vendor &&
./drivers/mmc/core/sdio.c:			    card->cis.device == oldcard->cis.device);
./drivers/mmc/core/sdio.c:	if (card->type == MMC_TYPE_SD_COMBO) {
./drivers/mmc/core/sdio.c:			card->type = MMC_TYPE_SDIO;
./drivers/mmc/core/sdio.c:			card->dev.type = &sd_type;
./drivers/mmc/core/sdio.c:		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
./drivers/mmc/core/sdio.c:	for (i = 0;i < host->card->sdio_funcs;i++) {
./drivers/mmc/core/sdio.c:		if (host->card->sdio_func[i]) {
./drivers/mmc/core/sdio.c:			sdio_remove_func(host->card->sdio_func[i]);
./drivers/mmc/core/sdio.c:			host->card->sdio_func[i] = NULL;
./drivers/mmc/core/sdio.c:		err = pm_runtime_get_sync(&host->card->dev);
./drivers/mmc/core/sdio.c:		pm_runtime_put_sync(&host->card->dev);
./drivers/mmc/core/sdio.c:	for (i = 0; i < host->card->sdio_funcs; i++) {
./drivers/mmc/core/sdio.c:		struct sdio_func *func = host->card->sdio_func[i];
./drivers/mmc/core/sdio.c:		struct sdio_func *func = host->card->sdio_func[i];
./drivers/mmc/core/sdio.c:	for (i = 0; !err && i < host->card->sdio_funcs; i++) {
./drivers/mmc/core/sdio.c:		struct sdio_func *func = host->card->sdio_func[i];
./drivers/mmc/core/sdio.c:		err = pm_runtime_set_active(&card->dev);
./drivers/mmc/core/sdio.c:		pm_runtime_enable(&card->dev);
./drivers/mmc/core/sdio.c:	card->sdio_funcs = 0;
./drivers/mmc/core/sdio.c:		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
./drivers/mmc/core/sdio.c:	for (i = 0; i < funcs; i++, card->sdio_funcs++) {
./drivers/mmc/core/sdio.c:			card->sdio_func[i] = tmp;
./drivers/mmc/core/sdio.c:			tmp->vendor = card->cis.vendor;
./drivers/mmc/core/sdio.c:			tmp->device = card->cis.device;
./drivers/mmc/core/sdio.c:			pm_runtime_enable(&card->sdio_func[i]->dev);
./drivers/mmc/core/sdio.c:		err = sdio_add_func(host->card->sdio_func[i]);
./drivers/mmc/core/sdio.c:	struct mmc_host *host = card->host;
./drivers/mmc/core/sdio.c:		err = mmc_send_relative_addr(host, &card->rca);
./drivers/mmc/core/sdio_ops.c:	return mmc_io_rw_direct_host(card->host, write, fn, addr, in, out);
./drivers/mmc/core/sdio_ops.c:	mmc_wait_for_req(card->host, &mrq);
./drivers/mmc/core/sdio_ops.c:	if (mmc_host_is_spi(card->host)) {
./drivers/mmc/core/quirks.c:		card->quirks |= data;
./drivers/mmc/core/quirks.c:		     f->manfid == card->cid.manfid) &&
./drivers/mmc/core/quirks.c:		     f->oemid == card->cid.oemid) &&
./drivers/mmc/core/quirks.c:		     !strncmp(f->name, card->cid.prod_name,
./drivers/mmc/core/quirks.c:			      sizeof(card->cid.prod_name))) &&
./drivers/mmc/core/quirks.c:		    (f->cis_vendor == card->cis.vendor ||
./drivers/mmc/core/quirks.c:		    (f->cis_device == card->cis.device ||
./drivers/mmc/core/quirks.c:			dev_dbg(&card->dev, "calling %pF\n", f->vendor_fixup);
./drivers/mmc/core/sdio_irq.c:	func = card->sdio_single_irq;
./drivers/mmc/core/sdio_irq.c:			func = card->sdio_func[i - 1];
./drivers/mmc/core/sdio_irq.c:	struct mmc_host *host = card->host;
./drivers/mmc/core/sdio_irq.c:	struct mmc_host *host = card->host;
./drivers/mmc/core/sdio_irq.c:	card->sdio_single_irq = NULL;
./drivers/mmc/core/sdio_irq.c:	if ((card->host->caps & MMC_CAP_SDIO_IRQ) &&
./drivers/mmc/core/sdio_irq.c:	    card->host->sdio_irqs == 1)
./drivers/mmc/core/sdio_irq.c:		for (i = 0; i < card->sdio_funcs; i++) {
./drivers/mmc/core/sdio_irq.c:		       func = card->sdio_func[i];
./drivers/mmc/core/sdio_irq.c:			       card->sdio_single_irq = func;
./drivers/mmc/core/bus.c:	switch (card->type) {
./drivers/mmc/core/bus.c:	switch (card->type) {
./drivers/mmc/core/bus.c:	return mmc_power_save_host(card->host);
./drivers/mmc/core/bus.c:	return mmc_power_restore_host(card->host);
./drivers/mmc/core/bus.c:	if (card->info)
./drivers/mmc/core/bus.c:		kfree(card->info);
./drivers/mmc/core/bus.c:	card->host = host;
./drivers/mmc/core/bus.c:	device_initialize(&card->dev);
./drivers/mmc/core/bus.c:	card->dev.parent = mmc_classdev(host);
./drivers/mmc/core/bus.c:	card->dev.bus = &mmc_bus_type;
./drivers/mmc/core/bus.c:	card->dev.release = mmc_release_card;
./drivers/mmc/core/bus.c:	card->dev.type = type;
./drivers/mmc/core/bus.c:	dev_set_name(&card->dev, "%s:%04x", mmc_hostname(card->host), card->rca);
./drivers/mmc/core/bus.c:	switch (card->type) {
./drivers/mmc/core/bus.c:	if (mmc_host_is_spi(card->host)) {
./drivers/mmc/core/bus.c:			mmc_hostname(card->host),
./drivers/mmc/core/bus.c:			mmc_hostname(card->host),
./drivers/mmc/core/bus.c:			type, card->rca);
./drivers/mmc/core/bus.c:	ret = device_add(&card->dev);
./drivers/mmc/core/bus.c:		if (mmc_host_is_spi(card->host)) {
./drivers/mmc/core/bus.c:				mmc_hostname(card->host));
./drivers/mmc/core/bus.c:				mmc_hostname(card->host), card->rca);
./drivers/mmc/core/bus.c:		device_del(&card->dev);
./drivers/mmc/core/bus.c:	put_device(&card->dev);
./drivers/mmc/core/mmc_ops.c:		cmd.arg = card->rca << 16;
./drivers/mmc/core/mmc_ops.c:	return _mmc_select_card(card->host, card);
./drivers/mmc/core/mmc_ops.c:	cmd.arg = card->rca << 16;
./drivers/mmc/core/mmc_ops.c:		mmc_delay(DIV_ROUND_UP(card->ext_csd.sa_timeout, 10000));
./drivers/mmc/core/mmc_ops.c:	BUG_ON(!card->host);
./drivers/mmc/core/mmc_ops.c:	cmd.arg = card->rca << 16;
./drivers/mmc/core/mmc_ops.c:	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
./drivers/mmc/core/mmc_ops.c:	if (!mmc_host_is_spi(card->host))
./drivers/mmc/core/mmc_ops.c:		return mmc_send_cxd_native(card->host, card->rca << 16,
./drivers/mmc/core/mmc_ops.c:	ret = mmc_send_cxd_data(card, card->host, MMC_SEND_CSD, csd, 16);
./drivers/mmc/core/mmc_ops.c:		return mmc_send_cxd_native(host, host->card->rca << 16,
./drivers/mmc/core/mmc_ops.c:	return mmc_send_cxd_data(card, card->host, MMC_SEND_EXT_CSD,
./drivers/mmc/core/mmc_ops.c:	BUG_ON(!card->host);
./drivers/mmc/core/mmc_ops.c:	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
./drivers/mmc/core/mmc_ops.c:		if (card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
./drivers/mmc/core/mmc_ops.c:		if (mmc_host_is_spi(card->host))
./drivers/mmc/core/mmc_ops.c:	if (mmc_host_is_spi(card->host)) {
./drivers/mmc/core/mmc_ops.c:			       "switch", mmc_hostname(card->host), status);
./drivers/mmc/core/mmc_ops.c:	BUG_ON(!card->host);
./drivers/mmc/core/mmc_ops.c:	if (!mmc_host_is_spi(card->host))
./drivers/mmc/core/mmc_ops.c:		cmd.arg = card->rca << 16;
./drivers/mmc/core/mmc_ops.c:	err = mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);
./drivers/mmc/core/mmc_ops.c:	mmc_send_bus_test(card, card->host, MMC_BUS_TEST_W, width);
./drivers/mmc/core/mmc_ops.c:	err = mmc_send_bus_test(card, card->host, MMC_BUS_TEST_R, width);
./drivers/mmc/core/host.c:	return !(card->quirks & MMC_QUIRK_BROKEN_CLK_GATING);
./drivers/mmc/core/sd_ops.c:	BUG_ON(card && (card->host != host));
./drivers/mmc/core/sd_ops.c:		cmd.arg = card->rca << 16;
./drivers/mmc/core/sd_ops.c:	BUG_ON(!card->host);
./drivers/mmc/core/sd_ops.c:	err = mmc_wait_for_app_cmd(card->host, card, &cmd, MMC_CMD_RETRIES);
./drivers/mmc/core/sd_ops.c:	BUG_ON(!card->host);
./drivers/mmc/core/sd_ops.c:	err = mmc_app_cmd(card->host, card);
./drivers/mmc/core/sd_ops.c:	data_buf = kmalloc(sizeof(card->raw_scr), GFP_KERNEL);
./drivers/mmc/core/sd_ops.c:	mmc_wait_for_req(card->host, &mrq);
./drivers/mmc/core/sd_ops.c:	memcpy(scr, data_buf, sizeof(card->raw_scr));
./drivers/mmc/core/sd_ops.c:	BUG_ON(!card->host);
./drivers/mmc/core/sd_ops.c:	mmc_wait_for_req(card->host, &mrq);
./drivers/mmc/core/sd_ops.c:	BUG_ON(!card->host);
./drivers/mmc/core/sd_ops.c:	err = mmc_app_cmd(card->host, card);
./drivers/mmc/core/sd_ops.c:	mmc_wait_for_req(card->host, &mrq);
./drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
./drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
./drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {
./drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
./drivers/mmc/core/sdio_bus.c:	if (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)
./drivers/mmc/core/sdio_bus.c:	if (!func->card->host->embedded_sdio_data.funcs)
./drivers/mmc/core/sdio_bus.c:	func->dev.parent = &card->dev;
./drivers/mmc/core/debugfs.c:	mmc_claim_host(card->host);
./drivers/mmc/core/debugfs.c:	mmc_release_host(card->host);
./drivers/mmc/core/debugfs.c:	mmc_claim_host(card->host);
./drivers/mmc/core/debugfs.c:	mmc_release_host(card->host);
./drivers/mmc/core/debugfs.c:	struct mmc_host	*host = card->host;
./drivers/mmc/core/debugfs.c:	card->debugfs_root = root;
./drivers/mmc/core/debugfs.c:	if (!debugfs_create_x32("state", S_IRUSR, root, &card->state))
./drivers/mmc/core/debugfs.c:	card->debugfs_root = NULL;
./drivers/mmc/core/debugfs.c:	dev_err(&card->dev, "failed to initialize debugfs\n");
./drivers/mmc/core/debugfs.c:	debugfs_remove_recursive(card->debugfs_root);
./drivers/mmc/core/sd.c:	u32 *resp = card->raw_cid;
./drivers/mmc/core/sd.c:	memset(&card->cid, 0, sizeof(struct mmc_cid));
./drivers/mmc/core/sd.c:	card->cid.manfid		= UNSTUFF_BITS(resp, 120, 8);
./drivers/mmc/core/sd.c:	card->cid.oemid			= UNSTUFF_BITS(resp, 104, 16);
./drivers/mmc/core/sd.c:	card->cid.prod_name[0]		= UNSTUFF_BITS(resp, 96, 8);
./drivers/mmc/core/sd.c:	card->cid.prod_name[1]		= UNSTUFF_BITS(resp, 88, 8);
./drivers/mmc/core/sd.c:	card->cid.prod_name[2]		= UNSTUFF_BITS(resp, 80, 8);
./drivers/mmc/core/sd.c:	card->cid.prod_name[3]		= UNSTUFF_BITS(resp, 72, 8);
./drivers/mmc/core/sd.c:	card->cid.prod_name[4]		= UNSTUFF_BITS(resp, 64, 8);
./drivers/mmc/core/sd.c:	card->cid.hwrev			= UNSTUFF_BITS(resp, 60, 4);
./drivers/mmc/core/sd.c:	card->cid.fwrev			= UNSTUFF_BITS(resp, 56, 4);
./drivers/mmc/core/sd.c:	card->cid.serial		= UNSTUFF_BITS(resp, 24, 32);
./drivers/mmc/core/sd.c:	card->cid.year			= UNSTUFF_BITS(resp, 12, 8);
./drivers/mmc/core/sd.c:	card->cid.month			= UNSTUFF_BITS(resp, 8, 4);
./drivers/mmc/core/sd.c:	card->cid.year += 2000; /* SD cards year offset */
./drivers/mmc/core/sd.c:	struct mmc_csd *csd = &card->csd;
./drivers/mmc/core/sd.c:	u32 *resp = card->raw_csd;
./drivers/mmc/core/sd.c:			mmc_hostname(card->host), csd_struct);
./drivers/mmc/core/sd.c:	card->erase_size = csd->erase_size;
./drivers/mmc/core/sd.c:	struct sd_scr *scr = &card->scr;
./drivers/mmc/core/sd.c:	resp[3] = card->raw_scr[1];
./drivers/mmc/core/sd.c:	resp[2] = card->raw_scr[0];
./drivers/mmc/core/sd.c:			mmc_hostname(card->host), scr_struct);
./drivers/mmc/core/sd.c:		card->erased_byte = 0xFF;
./drivers/mmc/core/sd.c:		card->erased_byte = 0x0;
./drivers/mmc/core/sd.c:	if (!(card->csd.cmdclass & CCC_APP_SPEC)) {
./drivers/mmc/core/sd.c:			"function.\n", mmc_hostname(card->host));
./drivers/mmc/core/sd.c:			"register.\n", mmc_hostname(card->host));
./drivers/mmc/core/sd.c:		card->ssr.au = 1 << (au + 4);
./drivers/mmc/core/sd.c:			card->ssr.erase_timeout = (et * 1000) / es;
./drivers/mmc/core/sd.c:			card->ssr.erase_offset = eo * 1000;
./drivers/mmc/core/sd.c:			"size.\n", mmc_hostname(card->host));
./drivers/mmc/core/sd.c:	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
./drivers/mmc/core/sd.c:	if (!(card->csd.cmdclass & CCC_SWITCH)) {
./drivers/mmc/core/sd.c:			mmc_hostname(card->host));
./drivers/mmc/core/sd.c:			mmc_hostname(card->host));
./drivers/mmc/core/sd.c:			mmc_hostname(card->host));
./drivers/mmc/core/sd.c:		card->sw_caps.hs_max_dtr = 50000000;
./drivers/mmc/core/sd.c:	if (card->scr.sda_spec3) {
./drivers/mmc/core/sd.c:		card->sw_caps.sd3_bus_mode = status[13];
./drivers/mmc/core/sd.c:				mmc_hostname(card->host));
./drivers/mmc/core/sd.c:		card->sw_caps.sd3_drv_type = status[9];
./drivers/mmc/core/sd.c:				mmc_hostname(card->host));
./drivers/mmc/core/sd.c:		card->sw_caps.sd3_curr_limit = status[7];
./drivers/mmc/core/sd.c:	if (card->scr.sda_vsn < SCR_SPEC_VER_1)
./drivers/mmc/core/sd.c:	if (!(card->csd.cmdclass & CCC_SWITCH))
./drivers/mmc/core/sd.c:	if (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))
./drivers/mmc/core/sd.c:	if (card->sw_caps.hs_max_dtr == 0)
./drivers/mmc/core/sd.c:			"switch capabilities.\n", mmc_hostname(card->host));
./drivers/mmc/core/sd.c:			mmc_hostname(card->host));
./drivers/mmc/core/sd.c:	if (!(card->host->caps & (MMC_CAP_DRIVER_TYPE_A | MMC_CAP_DRIVER_TYPE_C
./drivers/mmc/core/sd.c:	if (card->host->caps & MMC_CAP_DRIVER_TYPE_A) {
./drivers/mmc/core/sd.c:		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_A)
./drivers/mmc/core/sd.c:		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_B)
./drivers/mmc/core/sd.c:		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
./drivers/mmc/core/sd.c:	} else if (card->host->caps & MMC_CAP_DRIVER_TYPE_C) {
./drivers/mmc/core/sd.c:		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
./drivers/mmc/core/sd.c:	} else if (!(card->host->caps & MMC_CAP_DRIVER_TYPE_D)) {
./drivers/mmc/core/sd.c:		if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_B)
./drivers/mmc/core/sd.c:		else if (card->sw_caps.sd3_drv_type & SD_DRIVER_TYPE_C)
./drivers/mmc/core/sd.c:			mmc_hostname(card->host));
./drivers/mmc/core/sd.c:	mmc_set_driver_type(card->host, host_drv_type);
./drivers/mmc/core/sd.c:	if (!(card->host->caps & (MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 |
./drivers/mmc/core/sd.c:	if ((card->host->caps & MMC_CAP_UHS_SDR104) &&
./drivers/mmc/core/sd.c:	    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {
./drivers/mmc/core/sd.c:			card->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;
./drivers/mmc/core/sd.c:	} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&
./drivers/mmc/core/sd.c:		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {
./drivers/mmc/core/sd.c:			card->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;
./drivers/mmc/core/sd.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./drivers/mmc/core/sd.c:		    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &
./drivers/mmc/core/sd.c:			card->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;
./drivers/mmc/core/sd.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./drivers/mmc/core/sd.c:		   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {
./drivers/mmc/core/sd.c:			card->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;
./drivers/mmc/core/sd.c:	} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |
./drivers/mmc/core/sd.c:		    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &
./drivers/mmc/core/sd.c:			card->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;
./drivers/mmc/core/sd.c:	card->sd_bus_speed = bus_speed;
./drivers/mmc/core/sd.c:			mmc_hostname(card->host));
./drivers/mmc/core/sd.c:		mmc_set_timing(card->host, timing);
./drivers/mmc/core/sd.c:		mmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);
./drivers/mmc/core/sd.c:	if ((card->sd_bus_speed == UHS_SDR50_BUS_SPEED) ||
./drivers/mmc/core/sd.c:	    (card->sd_bus_speed == UHS_SDR104_BUS_SPEED) ||
./drivers/mmc/core/sd.c:	    (card->sd_bus_speed == UHS_DDR50_BUS_SPEED)) {
./drivers/mmc/core/sd.c:		if (card->host->caps & MMC_CAP_MAX_CURRENT_800) {
./drivers/mmc/core/sd.c:			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_800)
./drivers/mmc/core/sd.c:			else if (card->sw_caps.sd3_curr_limit &
./drivers/mmc/core/sd.c:			else if (card->sw_caps.sd3_curr_limit &
./drivers/mmc/core/sd.c:			else if (card->sw_caps.sd3_curr_limit &
./drivers/mmc/core/sd.c:		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_600) {
./drivers/mmc/core/sd.c:			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_600)
./drivers/mmc/core/sd.c:			else if (card->sw_caps.sd3_curr_limit &
./drivers/mmc/core/sd.c:			else if (card->sw_caps.sd3_curr_limit &
./drivers/mmc/core/sd.c:		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_400) {
./drivers/mmc/core/sd.c:			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_400)
./drivers/mmc/core/sd.c:			else if (card->sw_caps.sd3_curr_limit &
./drivers/mmc/core/sd.c:		} else if (card->host->caps & MMC_CAP_MAX_CURRENT_200) {
./drivers/mmc/core/sd.c:			if (card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)
./drivers/mmc/core/sd.c:			mmc_hostname(card->host));
./drivers/mmc/core/sd.c:	if (!card->scr.sda_spec3)
./drivers/mmc/core/sd.c:	if (!(card->csd.cmdclass & CCC_SWITCH))
./drivers/mmc/core/sd.c:			"switch capabilities.\n", mmc_hostname(card->host));
./drivers/mmc/core/sd.c:	if ((card->host->caps & MMC_CAP_4_BIT_DATA) &&
./drivers/mmc/core/sd.c:	    (card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
./drivers/mmc/core/sd.c:		mmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);
./drivers/mmc/core/sd.c:	if (!mmc_host_is_spi(card->host) && card->host->ops->execute_tuning)
./drivers/mmc/core/sd.c:		err = card->host->ops->execute_tuning(card->host);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(cid, "%08x%08x%08x%08x\n", card->raw_cid[0], card->raw_cid[1],
./drivers/mmc/core/sd.c:	card->raw_cid[2], card->raw_cid[3]);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(csd, "%08x%08x%08x%08x\n", card->raw_csd[0], card->raw_csd[1],
./drivers/mmc/core/sd.c:	card->raw_csd[2], card->raw_csd[3]);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(scr, "%08x%08x\n", card->raw_scr[0], card->raw_scr[1]);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(date, "%02d/%04d\n", card->cid.month, card->cid.year);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(erase_size, "%u\n", card->erase_size << 9);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(preferred_erase_size, "%u\n", card->pref_erase << 9);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(fwrev, "0x%x\n", card->cid.fwrev);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(hwrev, "0x%x\n", card->cid.hwrev);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(manfid, "0x%06x\n", card->cid.manfid);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(name, "%s\n", card->cid.prod_name);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(oemid, "0x%04x\n", card->cid.oemid);
./drivers/mmc/core/sd.c:MMC_DEV_ATTR(serial, "0x%08x\n", card->cid.serial);
./drivers/mmc/core/sd.c:	err = mmc_send_csd(card, card->raw_csd);
./drivers/mmc/core/sd.c:		err = mmc_app_send_scr(card, card->raw_scr);
./drivers/mmc/core/sd.c:		if (max_dtr > card->sw_caps.hs_max_dtr)
./drivers/mmc/core/sd.c:			max_dtr = card->sw_caps.hs_max_dtr;
./drivers/mmc/core/sd.c:	} else if (max_dtr > card->csd.max_dtr) {
./drivers/mmc/core/sd.c:		max_dtr = card->csd.max_dtr;
./drivers/mmc/core/sd.c:	mmc_set_timing(card->host, MMC_TIMING_SD_HS);
./drivers/mmc/core/sd.c:		if (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0)
./drivers/mmc/core/sd.c:		card->type = MMC_TYPE_SD;
./drivers/mmc/core/sd.c:		memcpy(card->raw_cid, cid, sizeof(card->raw_cid));
./drivers/mmc/core/sd.c:		err = mmc_send_relative_addr(host, &card->rca);
./drivers/mmc/core/sd.c:			(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {
./drivers/mmc/core/sd.c:	host->card->state &= ~MMC_STATE_HIGHSPEED;
./drivers/mmc/core/sd.c:	host->card->state &= ~MMC_STATE_HIGHSPEED;
./drivers/mmc/core/sdio_io.c:	mmc_claim_host(func->card->host);
./drivers/mmc/core/sdio_io.c:	mmc_release_host(func->card->host);
./drivers/mmc/core/sdio_io.c:	if (blksz > func->card->host->max_blk_size)
./drivers/mmc/core/sdio_io.c:		blksz = min(func->max_blksize, func->card->host->max_blk_size);
./drivers/mmc/core/sdio_io.c:	unsigned mval =	min(func->card->host->max_seg_size,
./drivers/mmc/core/sdio_io.c:			    func->card->host->max_blk_size);
./drivers/mmc/core/sdio_io.c:	if (func->card->cccr.multi_block) {
./drivers/mmc/core/sdio_io.c:	if (func->card->cccr.multi_block && (size > sdio_max_byte_size(func))) {
./drivers/mmc/core/sdio_io.c:		max_blocks = min(func->card->host->max_blk_count,
./drivers/mmc/core/sdio_io.c:			func->card->host->max_seg_size / func->cur_blksize);
./drivers/mmc/core/sdio_io.c:	return func->card->host->pm_caps;
./drivers/mmc/core/sdio_io.c:	host = func->card->host;
./drivers/mmc/core/core.c:		mult <<= card->csd.r2w_factor;
./drivers/mmc/core/core.c:	data->timeout_ns = card->csd.tacc_ns * mult;
./drivers/mmc/core/core.c:	data->timeout_clks = card->csd.tacc_clks * mult;
./drivers/mmc/core/core.c:		if (mmc_host_clk_rate(card->host))
./drivers/mmc/core/core.c:				(mmc_host_clk_rate(card->host) / 1000);
./drivers/mmc/core/core.c:	if (mmc_host_is_spi(card->host)) {
./drivers/mmc/core/core.c:	if (is_power_of_2(card->erase_size))
./drivers/mmc/core/core.c:		card->erase_shift = ffs(card->erase_size) - 1;
./drivers/mmc/core/core.c:		card->erase_shift = 0;
./drivers/mmc/core/core.c:	if (mmc_card_sd(card) && card->ssr.au) {
./drivers/mmc/core/core.c:		card->pref_erase = card->ssr.au;
./drivers/mmc/core/core.c:		card->erase_shift = ffs(card->ssr.au) - 1;
./drivers/mmc/core/core.c:	} else if (card->ext_csd.hc_erase_size) {
./drivers/mmc/core/core.c:		card->pref_erase = card->ext_csd.hc_erase_size;
./drivers/mmc/core/core.c:		sz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;
./drivers/mmc/core/core.c:			card->pref_erase = 512 * 1024 / 512;
./drivers/mmc/core/core.c:			card->pref_erase = 1024 * 1024 / 512;
./drivers/mmc/core/core.c:			card->pref_erase = 2 * 1024 * 1024 / 512;
./drivers/mmc/core/core.c:			card->pref_erase = 4 * 1024 * 1024 / 512;
./drivers/mmc/core/core.c:		if (card->pref_erase < card->erase_size)
./drivers/mmc/core/core.c:			card->pref_erase = card->erase_size;
./drivers/mmc/core/core.c:			sz = card->pref_erase % card->erase_size;
./drivers/mmc/core/core.c:				card->pref_erase += card->erase_size - sz;
./drivers/mmc/core/core.c:	if (card->ext_csd.erase_group_def & 1) {
./drivers/mmc/core/core.c:			erase_timeout = card->ext_csd.trim_timeout;
./drivers/mmc/core/core.c:			erase_timeout = card->ext_csd.hc_erase_timeout;
./drivers/mmc/core/core.c:		unsigned int mult = (10 << card->csd.r2w_factor);
./drivers/mmc/core/core.c:		unsigned int timeout_clks = card->csd.tacc_clks * mult;
./drivers/mmc/core/core.c:		if (card->csd.tacc_ns < 1000000)
./drivers/mmc/core/core.c:			timeout_us = (card->csd.tacc_ns * mult) / 1000;
./drivers/mmc/core/core.c:			timeout_us = (card->csd.tacc_ns / 1000) * mult;
./drivers/mmc/core/core.c:			      (mmc_host_clk_rate(card->host) / 1000);
./drivers/mmc/core/core.c:			erase_timeout *= card->ext_csd.sec_erase_mult;
./drivers/mmc/core/core.c:			erase_timeout *= card->ext_csd.sec_trim_mult;
./drivers/mmc/core/core.c:	if (mmc_host_is_spi(card->host) && erase_timeout < 1000)
./drivers/mmc/core/core.c:	if (card->ssr.erase_timeout) {
./drivers/mmc/core/core.c:		erase_timeout = card->ssr.erase_timeout * qty +
./drivers/mmc/core/core.c:				card->ssr.erase_offset;
./drivers/mmc/core/core.c:	if (card->erase_shift)
./drivers/mmc/core/core.c:		qty += ((to >> card->erase_shift) -
./drivers/mmc/core/core.c:			(from >> card->erase_shift)) + 1;
./drivers/mmc/core/core.c:		qty += ((to / card->erase_size) -
./drivers/mmc/core/core.c:			(from / card->erase_size)) + 1;
./drivers/mmc/core/core.c:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./drivers/mmc/core/core.c:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./drivers/mmc/core/core.c:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./drivers/mmc/core/core.c:	if (mmc_host_is_spi(card->host))
./drivers/mmc/core/core.c:		cmd.arg = card->rca << 16;
./drivers/mmc/core/core.c:		err = mmc_wait_for_cmd(card->host, &cmd, 0);
./drivers/mmc/core/core.c:	if (!(card->host->caps & MMC_CAP_ERASE) ||
./drivers/mmc/core/core.c:	    !(card->csd.cmdclass & CCC_ERASE))
./drivers/mmc/core/core.c:	if (!card->erase_size)
./drivers/mmc/core/core.c:	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN))
./drivers/mmc/core/core.c:	    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN))
./drivers/mmc/core/core.c:		if (from % card->erase_size || nr % card->erase_size)
./drivers/mmc/core/core.c:		rem = from % card->erase_size;
./drivers/mmc/core/core.c:			rem = card->erase_size - rem;
./drivers/mmc/core/core.c:		rem = nr % card->erase_size;
./drivers/mmc/core/core.c:	if ((card->host->caps & MMC_CAP_ERASE) &&
./drivers/mmc/core/core.c:	    (card->csd.cmdclass & CCC_ERASE) && card->erase_size)
./drivers/mmc/core/core.c:	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN)
./drivers/mmc/core/core.c:	if (card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN)
./drivers/mmc/core/core.c:	if (!card->erase_size)
./drivers/mmc/core/core.c:	if (from % card->erase_size || nr % card->erase_size)
./drivers/mmc/core/core.c:	return mmc_wait_for_cmd(card->host, &cmd, 5);
./drivers/mmc/core/core.c:	if (card && mmc_card_mmc(card) && card->ext_csd.rev >= 3)
./drivers/mmc/core/core.c:				pm_runtime_disable(&host->card->dev);
./drivers/mmc/core/core.c:				pm_runtime_set_active(&host->card->dev);
./drivers/mmc/core/core.c:				pm_runtime_enable(&host->card->dev);
./drivers/mmc/core/sdio_cis.c:		card->num_info = nr_strings;
./drivers/mmc/core/sdio_cis.c:		card->info = (const char**)buffer;
./drivers/mmc/core/sdio_cis.c:		card->cis.vendor = vendor;
./drivers/mmc/core/sdio_cis.c:		card->cis.device = device;
./drivers/mmc/core/sdio_cis.c:			       mmc_hostname(card->host), tpl_descr, code, size);
./drivers/mmc/core/sdio_cis.c:	card->cis.blksize = buf[1] | (buf[2] << 8);
./drivers/mmc/core/sdio_cis.c:	card->cis.max_dtr = speed_val[(buf[3] >> 3) & 15] *
./drivers/mmc/core/sdio_cis.c:	vsn = func->card->cccr.sdio_vsn;
./drivers/mmc/core/sdio_cis.c:		prev = &card->tuples;
./drivers/mmc/core/sdio_cis.c:				       mmc_hostname(card->host),
./drivers/mmc/core/sdio_cis.c:		*prev = card->tuples;
./drivers/mmc/core/sdio_cis.c:	tuple = card->tuples;
./drivers/mmc/core/sdio_cis.c:	card->tuples = NULL;
./drivers/mmc/core/sdio_cis.c:	get_device(&func->card->dev);
./drivers/mmc/core/sdio_cis.c:		func->vendor = func->card->cis.vendor;
./drivers/mmc/core/sdio_cis.c:		func->device = func->card->cis.device;
./drivers/mmc/core/sdio_cis.c:	while (tuple && tuple != func->card->tuples) {
./drivers/mmc/core/sdio_cis.c:	put_device(&func->card->dev);
./drivers/mmc/host/atmel-mci.c:	 * non-word-aligned buffers or lengths. Also, we don't bother
./drivers/mmc/host/omap_hsmmc.c:	/* Do not initialize card-specific things if the power is off */
./drivers/mmc/host/au1xmmc.c: * but now the SecureDigital card-detect feature of CD/DAT3 is ineffective
./drivers/mmc/host/au1xmmc.c:	/* board-specific carddetect setup, if any */
./drivers/mmc/host/msm_sdcc.c:		if (mmc->card && mmc->card->type != MMC_TYPE_SDIO)
./drivers/mmc/host/msm_sdcc.c:		if (mmc->card && mmc->card->type != MMC_TYPE_SDIO)
./drivers/mmc/host/vub300.c:	int sdio_funcs = card->sdio_funcs;
./drivers/mmc/host/vub300.c:			 "vub_%04X%04X", card->cis.vendor, card->cis.device);
./drivers/mmc/host/vub300.c:		struct sdio_func *sf = card->sdio_func[n];
./drivers/mmc/host/vub300.c:	retval = request_firmware(&fw, vub300->vub_name, &card->dev);
./drivers/mmc/host/vub300.c:		retval = request_firmware(&fw, vub300->vub_name, &card->dev);
./drivers/mmc/host/vub300.c:		} else if (0 == vub300->mmc->card->sdio_funcs) {
./drivers/mmc/host/tmio_mmc_pio.c:		/* Only entered after a card-insert interrupt */
./drivers/mmc/host/at91_mci.c:	at91_mci_write(host, AT91_MCI_SDCR, host->board->slot_b);
./drivers/mmc/host/at91_mci.c:	if (ios->bus_width == MMC_BUS_WIDTH_4 && host->board->wire4) {
./drivers/mmc/host/at91_mci.c:	if (host->board->vcc_pin) {
./drivers/mmc/host/at91_mci.c:				gpio_set_value(host->board->vcc_pin, 0);
./drivers/mmc/host/at91_mci.c:				gpio_set_value(host->board->vcc_pin, 1);
./drivers/mmc/host/at91_mci.c:	if (host->board->wp_pin)
./drivers/mmc/host/at91_mci.c:		return !!gpio_get_value(host->board->wp_pin);
./drivers/mmc/host/at91_mci.c:		host->board->slot_b ? 'B':'A', enable ? "enable" : "disable");
./drivers/mmc/host/at91_mci.c:		host->board->slot_b ? AT91_MCI_SDIOIRQB : AT91_MCI_SDIOIRQA);
./drivers/mmc/host/at91_mci.c:	if (host->board->wire4) {
./drivers/mmc/host/at91_mci.c:		if (host->board->wire4 || !host->board->slot_b)
./drivers/mmc/host/at91_mci.c:	if (host->board->det_pin) {
./drivers/mmc/host/at91_mci.c:		ret = gpio_request(host->board->det_pin, "mmc_detect");
./drivers/mmc/host/at91_mci.c:	if (host->board->wp_pin) {
./drivers/mmc/host/at91_mci.c:		ret = gpio_request(host->board->wp_pin, "mmc_wp");
./drivers/mmc/host/at91_mci.c:	if (host->board->vcc_pin) {
./drivers/mmc/host/at91_mci.c:		ret = gpio_request(host->board->vcc_pin, "mmc_vcc");
./drivers/mmc/host/at91_mci.c:	if (host->board->det_pin) {
./drivers/mmc/host/at91_mci.c:		host->present = !gpio_get_value(host->board->det_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->det_pin) {
./drivers/mmc/host/at91_mci.c:		ret = request_irq(gpio_to_irq(host->board->det_pin),
./drivers/mmc/host/at91_mci.c:	if (host->board->vcc_pin)
./drivers/mmc/host/at91_mci.c:		gpio_free(host->board->vcc_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->wp_pin)
./drivers/mmc/host/at91_mci.c:		gpio_free(host->board->wp_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->det_pin)
./drivers/mmc/host/at91_mci.c:		gpio_free(host->board->det_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->det_pin) {
./drivers/mmc/host/at91_mci.c:			free_irq(gpio_to_irq(host->board->det_pin), host);
./drivers/mmc/host/at91_mci.c:		gpio_free(host->board->det_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->vcc_pin)
./drivers/mmc/host/at91_mci.c:		gpio_free(host->board->vcc_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->wp_pin)
./drivers/mmc/host/at91_mci.c:		gpio_free(host->board->wp_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
./drivers/mmc/host/at91_mci.c:		enable_irq_wake(host->board->det_pin);
./drivers/mmc/host/at91_mci.c:	if (host->board->det_pin && device_may_wakeup(&pdev->dev))
./drivers/mmc/host/at91_mci.c:		disable_irq_wake(host->board->det_pin);
./drivers/mmc/host/dw_mmc.c:	 * non-word-aligned buffers or lengths. Also, we don't bother
./drivers/mmc/host/dw_mmc.c:	if (brd->get_ro)
./drivers/mmc/host/dw_mmc.c:		read_only = brd->get_ro(slot->id);
./drivers/mmc/host/dw_mmc.c:	if (brd->quirks & DW_MCI_QUIRK_BROKEN_CARD_DETECTION)
./drivers/mmc/host/dw_mmc.c:	else if (brd->get_cd)
./drivers/mmc/host/dw_mmc.c:		present = !brd->get_cd(slot->id);
./drivers/mmc/host/sdhci-s3c.c:	if (mmc->card && (mmc->card->type == MMC_TYPE_SDIO))
./drivers/mmc/host/mxcmmc.c:	if (cpu_is_mx3() && card->type == MMC_TYPE_SDIO)
./drivers/mmc/host/sdhci-esdhc-imx.c:				"no card-detect pin available!\n");
./drivers/mmc/card/block.c:	mmc_claim_host(card->host);
./drivers/mmc/card/block.c:		err = mmc_app_cmd(card->host, card);
./drivers/mmc/card/block.c:	mmc_wait_for_req(card->host, &mrq);
./drivers/mmc/card/block.c:		dev_err(mmc_dev(card->host), "%s: cmd error %d\n",
./drivers/mmc/card/block.c:		dev_err(mmc_dev(card->host), "%s: data error %d\n",
./drivers/mmc/card/block.c:	mmc_release_host(card->host);
./drivers/mmc/card/block.c:		card->ext_csd.part_config &= ~EXT_CSD_PART_CONFIG_ACC_MASK;
./drivers/mmc/card/block.c:		card->ext_csd.part_config |= md->part_type;
./drivers/mmc/card/block.c:				 EXT_CSD_PART_CONFIG, card->ext_csd.part_config,
./drivers/mmc/card/block.c:				 card->ext_csd.part_time);
./drivers/mmc/card/block.c:	cmd.arg = card->rca << 16;
./drivers/mmc/card/block.c:	err = mmc_wait_for_cmd(card->host, &cmd, 0);
./drivers/mmc/card/block.c:	if (!mmc_host_is_spi(card->host) && !(cmd.resp[0] & R1_APP_CMD))
./drivers/mmc/card/block.c:	data.timeout_ns = card->csd.tacc_ns * 100;
./drivers/mmc/card/block.c:	data.timeout_clks = card->csd.tacc_clks * 100;
./drivers/mmc/card/block.c:		(card->host->ios.clock / 1000);
./drivers/mmc/card/block.c:	mmc_wait_for_req(card->host, &mrq);
./drivers/mmc/card/block.c:	err = mmc_wait_for_cmd(card->host, &cmd, 5);
./drivers/mmc/card/block.c:	if (!mmc_host_is_spi(card->host))
./drivers/mmc/card/block.c:		cmd.arg = card->rca << 16;
./drivers/mmc/card/block.c:	err = mmc_wait_for_cmd(card->host, &cmd, retries);
./drivers/mmc/card/block.c:	if (card->quirks & MMC_QUIRK_INAND_CMD38) {
./drivers/mmc/card/block.c:	if (card->quirks & MMC_QUIRK_INAND_CMD38) {
./drivers/mmc/card/block.c:		if (card->quirks & MMC_QUIRK_INAND_CMD38) {
./drivers/mmc/card/block.c:	if (!(card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN)) {
./drivers/mmc/card/block.c:		if (!IS_ALIGNED(brq->cmd.arg, card->ext_csd.rel_sectors))
./drivers/mmc/card/block.c:		if (brq->data.blocks > card->ext_csd.rel_sectors)
./drivers/mmc/card/block.c:			brq->data.blocks = card->ext_csd.rel_sectors;
./drivers/mmc/card/block.c:		else if (brq->data.blocks < card->ext_csd.rel_sectors)
./drivers/mmc/card/block.c:		if (brq.data.blocks > card->host->max_blk_count)
./drivers/mmc/card/block.c:			brq.data.blocks = card->host->max_blk_count;
./drivers/mmc/card/block.c:			if (!mmc_host_is_spi(card->host) ||
./drivers/mmc/card/block.c:		    (do_rel_wr || !(card->quirks & MMC_QUIRK_BLK_NO_CMD23))) {
./drivers/mmc/card/block.c:		mmc_wait_for_req(card->host, &brq.mrq);
./drivers/mmc/card/block.c:		if (!mmc_host_is_spi(card->host) && rq_data_dir(req) != READ) {
./drivers/mmc/card/block.c:	if (mmc_bus_needs_resume(card->host)) {
./drivers/mmc/card/block.c:		mmc_resume_bus(card->host);
./drivers/mmc/card/block.c:	mmc_claim_host(card->host);
./drivers/mmc/card/block.c:	mmc_release_host(card->host);
./drivers/mmc/card/block.c:	       !(card->csd.cmdclass & CCC_BLOCK_WRITE);
./drivers/mmc/card/block.c:	if (mmc_host_cmd23(card->host)) {
./drivers/mmc/card/block.c:		     card->scr.cmds & SD_SCR_CMD23_SUPPORT))
./drivers/mmc/card/block.c:	    ((card->ext_csd.rel_param & EXT_CSD_WR_REL_PARAM_EN) ||
./drivers/mmc/card/block.c:	     card->ext_csd.rel_sectors)) {
./drivers/mmc/card/block.c:		size = card->ext_csd.sectors;
./drivers/mmc/card/block.c:		size = card->csd.capacity << (card->csd.read_blkbits - 9);
./drivers/mmc/card/block.c:	md = mmc_blk_alloc_req(card, &card->dev, size, false, NULL);
./drivers/mmc/card/block.c:	if (card->ext_csd.boot_size) {
./drivers/mmc/card/block.c:					 card->ext_csd.boot_size >> 9,
./drivers/mmc/card/block.c:					 card->ext_csd.boot_size >> 9,
./drivers/mmc/card/block.c:	mmc_claim_host(card->host);
./drivers/mmc/card/block.c:	mmc_release_host(card->host);
./drivers/mmc/card/block.c:	if (!(card->csd.cmdclass & CCC_BLOCK_READ))
./drivers/mmc/card/block.c:	mmc_set_bus_resume_policy(card->host, 1);
./drivers/mmc/card/block.c:	mmc_claim_host(card->host);
./drivers/mmc/card/block.c:	mmc_release_host(card->host);
./drivers/mmc/card/block.c:	mmc_set_bus_resume_policy(card->host, 0);
./drivers/mmc/card/queue.c:	struct mmc_host *host = card->host;
./drivers/mmc/card/queue.c:		if (card->erased_byte == 0)
./drivers/mmc/card/queue.c:		mq->queue->limits.discard_granularity = card->pref_erase << 9;
./drivers/mmc/card/mmc_test.c:		cmd.arg = test->card->rca << 16;
./drivers/mmc/card/mmc_test.c:		ret = mmc_wait_for_cmd(test->card->host, &cmd, 0);
./drivers/mmc/card/mmc_test.c:			if (test->card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)
./drivers/mmc/card/mmc_test.c:					mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:	mmc_wait_for_req(test->card->host, &mrq);
./drivers/mmc/card/mmc_test.c:			 mmc_hostname(test->card->host), sectors, sectors >> 1,
./drivers/mmc/card/mmc_test.c:			 mmc_hostname(test->card->host), count, sectors, count,
./drivers/mmc/card/mmc_test.c:		return card->ext_csd.sectors;
./drivers/mmc/card/mmc_test.c:		return card->csd.capacity << (card->csd.read_blkbits - 9);
./drivers/mmc/card/mmc_test.c:		mrq->cmd->arg = test->card->rca << 16;
./drivers/mmc/card/mmc_test.c:	mmc_wait_for_req(test->card->host, &mrq);
./drivers/mmc/card/mmc_test.c:	mmc_wait_for_req(test->card->host, &mrq);
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
./drivers/mmc/card/mmc_test.c:	if (!test->card->csd.write_partial)
./drivers/mmc/card/mmc_test.c:	if (!test->card->csd.read_partial)
./drivers/mmc/card/mmc_test.c:	if (!test->card->csd.write_partial)
./drivers/mmc/card/mmc_test.c:	if (!test->card->csd.read_partial)
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
./drivers/mmc/card/mmc_test.c:	if (test->card->host->max_blk_count == 1)
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_req_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_seg_size);
./drivers/mmc/card/mmc_test.c:	size = min(size, test->card->host->max_blk_count * 512);
./drivers/mmc/card/mmc_test.c:	       mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:		       mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:	sz = (unsigned long)test->card->pref_erase << 9;
./drivers/mmc/card/mmc_test.c:	t->max_segs = test->card->host->max_segs;
./drivers/mmc/card/mmc_test.c:	t->max_seg_sz = test->card->host->max_seg_size;
./drivers/mmc/card/mmc_test.c:	if (t->max_tfr >> 9 > test->card->host->max_blk_count)
./drivers/mmc/card/mmc_test.c:		t->max_tfr = test->card->host->max_blk_count << 9;
./drivers/mmc/card/mmc_test.c:	if (t->max_tfr > test->card->host->max_req_size)
./drivers/mmc/card/mmc_test.c:		t->max_tfr = test->card->host->max_req_size;
./drivers/mmc/card/mmc_test.c:	range1 = rnd_addr / test->card->pref_erase;
./drivers/mmc/card/mmc_test.c:		dev_addr = rnd_addr + test->card->pref_erase * ea +
./drivers/mmc/card/mmc_test.c:		mmc_hostname(test->card->host), mmc_card_id(test->card));
./drivers/mmc/card/mmc_test.c:	mmc_claim_host(test->card->host);
./drivers/mmc/card/mmc_test.c:			mmc_hostname(test->card->host), i + 1,
./drivers/mmc/card/mmc_test.c:					mmc_hostname(test->card->host),
./drivers/mmc/card/mmc_test.c:				mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:				mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:				mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:				mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:				mmc_hostname(test->card->host), ret);
./drivers/mmc/card/mmc_test.c:					mmc_hostname(test->card->host),
./drivers/mmc/card/mmc_test.c:	mmc_release_host(test->card->host);
./drivers/mmc/card/mmc_test.c:		mmc_hostname(test->card->host));
./drivers/mmc/card/mmc_test.c:	if (card->debugfs_root)
./drivers/mmc/card/mmc_test.c:			card->debugfs_root, card, &mmc_test_fops_test);
./drivers/mmc/card/mmc_test.c:		dev_err(&card->dev,
./drivers/mmc/card/mmc_test.c:		dev_err(&card->dev,
./drivers/mmc/card/mmc_test.c:	dev_info(&card->dev, "Card claimed for testing.\n");
./drivers/md/dm-raid1.c:		dm_bio_record(&read_record->details, bio);
./drivers/md/dm-raid1.c:		read_record->m = m;
./drivers/md/dm-raid1.c:		m = read_record->m;
./drivers/md/dm-raid1.c:			bd = &read_record->details;
./drivers/firewire/core-topology.c:		node = fw_node_create(q, port_count, card->color);
./drivers/firewire/core-topology.c:		if (phy_id == (card->node_id & 0x3f))
./drivers/firewire/core-topology.c:				child->color = card->color;
./drivers/firewire/core-topology.c:	card->root_node = node;
./drivers/firewire/core-topology.c:	card->irm_node = irm_node;
./drivers/firewire/core-topology.c:	card->gap_count = gap_count;
./drivers/firewire/core-topology.c:	card->beta_repeaters_present = beta_repeaters_present;
./drivers/firewire/core-topology.c:		node->color = card->color;
./drivers/firewire/core-topology.c:			if (child->color == card->color)
./drivers/firewire/core-topology.c:	card->bm_retries = 0;
./drivers/firewire/core-topology.c:	card->bm_retries = 0;
./drivers/firewire/core-topology.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-topology.c:	card->color++;
./drivers/firewire/core-topology.c:	if (card->local_node != NULL)
./drivers/firewire/core-topology.c:		for_each_fw_node(card, card->local_node, report_lost_node);
./drivers/firewire/core-topology.c:	card->local_node = NULL;
./drivers/firewire/core-topology.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-topology.c:	list_add_tail(&card->local_node->link, &list0);
./drivers/firewire/core-topology.c:		node0->color = card->color;
./drivers/firewire/core-topology.c:		node1->color = card->color;
./drivers/firewire/core-topology.c:		if (card->root_node == node1)
./drivers/firewire/core-topology.c:			card->root_node = node0;
./drivers/firewire/core-topology.c:		if (card->irm_node == node1)
./drivers/firewire/core-topology.c:			card->irm_node = node0;
./drivers/firewire/core-topology.c:				if (node0->ports[i]->color == card->color)
./drivers/firewire/core-topology.c:	int node_count = (card->root_node->node_id & 0x3f) + 1;
./drivers/firewire/core-topology.c:	__be32 *map = card->topology_map;
./drivers/firewire/core-topology.c:	*map++ = cpu_to_be32(be32_to_cpu(card->topology_map[1]) + 1);
./drivers/firewire/core-topology.c:	fw_compute_block_crc(card->topology_map);
./drivers/firewire/core-topology.c:	if (!is_next_generation(generation, card->generation) &&
./drivers/firewire/core-topology.c:	    card->local_node != NULL) {
./drivers/firewire/core-topology.c:		card->bm_retries = 0;
./drivers/firewire/core-topology.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-topology.c:	card->broadcast_channel_allocated = card->broadcast_channel_auto_allocated;
./drivers/firewire/core-topology.c:	card->node_id = node_id;
./drivers/firewire/core-topology.c:	card->generation = generation;
./drivers/firewire/core-topology.c:	card->reset_jiffies = get_jiffies_64();
./drivers/firewire/core-topology.c:	card->bm_node_id  = 0xffff;
./drivers/firewire/core-topology.c:	card->bm_abdicate = bm_abdicate;
./drivers/firewire/core-topology.c:	card->color++;
./drivers/firewire/core-topology.c:	} else if (card->local_node == NULL) {
./drivers/firewire/core-topology.c:		card->local_node = local_node;
./drivers/firewire/core-topology.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-iso.c:		address = dma_map_page(card->device, buffer->pages[i],
./drivers/firewire/core-iso.c:		if (dma_mapping_error(card->device, address)) {
./drivers/firewire/core-iso.c:		dma_unmap_page(card->device, address,
./drivers/firewire/core-iso.c:		dma_unmap_page(card->device, address,
./drivers/firewire/core-iso.c:	ctx = card->driver->allocate_iso_context(card,
./drivers/firewire/core-iso.c:	ctx->card->driver->free_iso_context(ctx);
./drivers/firewire/core-iso.c:	return ctx->card->driver->start_iso(ctx, cycle, sync, tags);
./drivers/firewire/core-iso.c:	return ctx->card->driver->set_iso_channels(ctx, channels);
./drivers/firewire/core-iso.c:	return ctx->card->driver->queue_iso(ctx, packet, buffer, payload);
./drivers/firewire/core-iso.c:	ctx->card->driver->flush_queue_iso(ctx);
./drivers/firewire/core-iso.c:	return ctx->card->driver->stop_iso(ctx);
./drivers/firewire/core-iso.c:	spin_lock_irq(&card->lock);
./drivers/firewire/core-iso.c:	irm_id = card->irm_node->node_id;
./drivers/firewire/core-iso.c:	spin_unlock_irq(&card->lock);
./drivers/firewire/sbp2.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/sbp2.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/sbp2.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/sbp2.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/sbp2.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/sbp2.c:	spin_lock_irqsave(&device->card->lock, flags);
./drivers/firewire/sbp2.c:	spin_unlock_irqrestore(&device->card->lock, flags);
./drivers/firewire/sbp2.c:	spin_lock_irqsave(&device->card->lock, flags);
./drivers/firewire/sbp2.c:	spin_unlock_irqrestore(&device->card->lock, flags);
./drivers/firewire/sbp2.c:		dma_map_single(device->card->device, &orb->response,
./drivers/firewire/sbp2.c:	if (dma_mapping_error(device->card->device, orb->response_bus))
./drivers/firewire/sbp2.c:		dma_map_single(device->card->device, &orb->request,
./drivers/firewire/sbp2.c:	if (dma_mapping_error(device->card->device, orb->base.request_bus))
./drivers/firewire/sbp2.c:	dma_unmap_single(device->card->device, orb->base.request_bus,
./drivers/firewire/sbp2.c:	dma_unmap_single(device->card->device, orb->response_bus,
./drivers/firewire/sbp2.c:	 * We may access dont_block without taking card->lock here:
./drivers/firewire/sbp2.c: * Note, scsi_block_requests() must be called while holding card->lock,
./drivers/firewire/sbp2.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/sbp2.c:	    lu->generation != card->generation) {
./drivers/firewire/sbp2.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/sbp2.c: * card->lock protected section.  On the other hand, running it inside
./drivers/firewire/sbp2.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/sbp2.c:	if (lu->blocked && lu->generation == card->generation) {
./drivers/firewire/sbp2.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/sbp2.c: * card->lock protected section.  On the other hand, running it inside
./drivers/firewire/sbp2.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/sbp2.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/sbp2.c:	local_node_id = device->card->node_id;
./drivers/firewire/sbp2.c:	if (generation != device->card->generation) {
./drivers/firewire/sbp2.c:	if (dma_get_max_seg_size(device->card->device) > SBP2_MAX_SEG_SIZE)
./drivers/firewire/sbp2.c:		BUG_ON(dma_set_max_seg_size(device->card->device,
./drivers/firewire/sbp2.c:	tgt->max_payload = min(tgt->max_payload, device->card->max_receive - 1);
./drivers/firewire/sbp2.c:	local_node_id = device->card->node_id;
./drivers/firewire/sbp2.c:		if (generation == device->card->generation ||
./drivers/firewire/sbp2.c:	dma_unmap_single(device->card->device, orb->base.request_bus,
./drivers/firewire/sbp2.c:	sbp2_unmap_scatterlist(device->card->device, orb);
./drivers/firewire/sbp2.c:	n = dma_map_sg(device->card->device, sg, scsi_sg_count(orb->cmd),
./drivers/firewire/sbp2.c:		dma_map_single(device->card->device, orb->page_table,
./drivers/firewire/sbp2.c:	if (dma_mapping_error(device->card->device, orb->page_table_bus))
./drivers/firewire/sbp2.c:	dma_unmap_sg(device->card->device, scsi_sglist(orb->cmd),
./drivers/firewire/sbp2.c:		dma_map_single(device->card->device, &orb->request,
./drivers/firewire/sbp2.c:	if (dma_mapping_error(device->card->device, orb->base.request_bus)) {
./drivers/firewire/sbp2.c:		sbp2_unmap_scatterlist(device->card->device, orb);
./drivers/firewire/core-cdev.c:	spin_lock_irq(&card->lock);
./drivers/firewire/core-cdev.c:	event->local_node_id = card->local_node->node_id;
./drivers/firewire/core-cdev.c:	event->bm_node_id    = card->bm_node_id;
./drivers/firewire/core-cdev.c:	event->irm_node_id   = card->irm_node->node_id;
./drivers/firewire/core-cdev.c:	event->root_node_id  = card->root_node->node_id;
./drivers/firewire/core-cdev.c:	spin_unlock_irq(&card->lock);
./drivers/firewire/core-cdev.c:	a->card = client->device->card->index;
./drivers/firewire/core-cdev.c:		req->card	= card->index;
./drivers/firewire/core-cdev.c:	cycle_time = card->driver->read_csr(card, CSR_CYCLE_TIME);
./drivers/firewire/core-cdev.c:			  client->device->card->reset_jiffies + HZ)) {
./drivers/firewire/core-cdev.c:	if (a->speed > client->device->card->link_speed ||
./drivers/firewire/core-cdev.c:	card->driver->send_request(card, &e->p);
./drivers/firewire/core-cdev.c:	spin_lock_irq(&card->lock);
./drivers/firewire/core-cdev.c:	list_move_tail(&client->phy_receiver_link, &card->phy_receiver_list);
./drivers/firewire/core-cdev.c:	spin_unlock_irq(&card->lock);
./drivers/firewire/core-cdev.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-cdev.c:	list_for_each_entry(client, &card->phy_receiver_list, phy_receiver_link) {
./drivers/firewire/core-cdev.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-cdev.c:	spin_lock_irq(&client->device->card->lock);
./drivers/firewire/core-cdev.c:	spin_unlock_irq(&client->device->card->lock);
./drivers/firewire/net.c:	guid = cpu_to_be64(dev->card->guid);
./drivers/firewire/net.c:		generation = dev->card->generation;
./drivers/firewire/net.c:		node_id = dev->card->node_id;
./drivers/firewire/net.c:	max_receive = 1U << (dev->card->max_receive + 1);
./drivers/firewire/net.c:		    dev->card->link_speed, 8, fwnet_receive_broadcast, dev);
./drivers/firewire/net.c:		arp1394->max_rec        = dev->card->max_receive;
./drivers/firewire/net.c:		arp1394->sspd		= dev->card->link_speed;
./drivers/firewire/net.c:	SET_NETDEV_DEV(net, card->device);
./drivers/firewire/net.c:	max_mtu = (1 << (card->max_receive + 1))
./drivers/firewire/net.c:	put_unaligned_be64(card->guid, net->dev_addr);
./drivers/firewire/net.c:		  net->name, (unsigned long long)card->guid);
./drivers/firewire/core-card.c:		BIB_LINK_SPEED(card->link_speed) |
./drivers/firewire/core-card.c:		BIB_GENERATION(card->config_rom_generation++ % 14 + 2) |
./drivers/firewire/core-card.c:		BIB_MAX_RECEIVE(card->max_receive) |
./drivers/firewire/core-card.c:	config_rom[3] = cpu_to_be32(card->guid >> 32);
./drivers/firewire/core-card.c:	config_rom[4] = cpu_to_be32(card->guid);
./drivers/firewire/core-card.c:		card->driver->set_config_rom(card, tmp_config_rom,
./drivers/firewire/core-card.c:	return card->driver->update_phy_reg(card, reg, 0, bit);
./drivers/firewire/core-card.c:	card->br_short = short_reset;
./drivers/firewire/core-card.c:	if (!queue_delayed_work(fw_workqueue, &card->br_work,
./drivers/firewire/core-card.c:	if (card->reset_jiffies != 0 &&
./drivers/firewire/core-card.c:	    time_before64(get_jiffies_64(), card->reset_jiffies + 2 * HZ)) {
./drivers/firewire/core-card.c:		if (!queue_delayed_work(fw_workqueue, &card->br_work, 2 * HZ))
./drivers/firewire/core-card.c:	fw_send_phy_config(card, FW_PHY_CONFIG_NO_NODE_ID, card->generation,
./drivers/firewire/core-card.c:	reset_bus(card, card->br_short);
./drivers/firewire/core-card.c:	if (!card->broadcast_channel_allocated) {
./drivers/firewire/core-card.c:		card->broadcast_channel_allocated = true;
./drivers/firewire/core-card.c:	device_for_each_child(card->device, (void *)(long)generation,
./drivers/firewire/core-card.c:	if (!schedule_delayed_work(&card->bm_work, delay))
./drivers/firewire/core-card.c:	spin_lock_irq(&card->lock);
./drivers/firewire/core-card.c:	if (card->local_node == NULL) {
./drivers/firewire/core-card.c:		spin_unlock_irq(&card->lock);
./drivers/firewire/core-card.c:	generation = card->generation;
./drivers/firewire/core-card.c:	root_node = card->root_node;
./drivers/firewire/core-card.c:	irm_device = card->irm_node->data;
./drivers/firewire/core-card.c:	irm_id   = card->irm_node->node_id;
./drivers/firewire/core-card.c:	local_id = card->local_node->node_id;
./drivers/firewire/core-card.c:			     card->reset_jiffies + DIV_ROUND_UP(HZ, 8));
./drivers/firewire/core-card.c:	if ((is_next_generation(generation, card->bm_generation) &&
./drivers/firewire/core-card.c:	     !card->bm_abdicate) ||
./drivers/firewire/core-card.c:	    (card->bm_generation != generation && grace)) {
./drivers/firewire/core-card.c:		if (!card->irm_node->link_on) {
./drivers/firewire/core-card.c:		spin_unlock_irq(&card->lock);
./drivers/firewire/core-card.c:		spin_lock_irq(&card->lock);
./drivers/firewire/core-card.c:		if (rcode == RCODE_COMPLETE && generation == card->generation)
./drivers/firewire/core-card.c:			card->bm_node_id =
./drivers/firewire/core-card.c:		spin_unlock_irq(&card->lock);
./drivers/firewire/core-card.c:		spin_lock_irq(&card->lock);
./drivers/firewire/core-card.c:	} else if (card->bm_generation != generation) {
./drivers/firewire/core-card.c:		spin_unlock_irq(&card->lock);
./drivers/firewire/core-card.c:	card->bm_generation = generation;
./drivers/firewire/core-card.c:		spin_unlock_irq(&card->lock);
./drivers/firewire/core-card.c:	if (!card->beta_repeaters_present &&
./drivers/firewire/core-card.c:	if (card->bm_retries++ < 5 &&
./drivers/firewire/core-card.c:	    (card->gap_count != gap_count || new_root_id != root_id))
./drivers/firewire/core-card.c:	spin_unlock_irq(&card->lock);
./drivers/firewire/core-card.c:			  card->index, new_root_id, gap_count);
./drivers/firewire/core-card.c:	card->index = atomic_inc_return(&index);
./drivers/firewire/core-card.c:	card->driver = driver;
./drivers/firewire/core-card.c:	card->device = device;
./drivers/firewire/core-card.c:	card->current_tlabel = 0;
./drivers/firewire/core-card.c:	card->tlabel_mask = 0;
./drivers/firewire/core-card.c:	card->split_timeout_hi = DEFAULT_SPLIT_TIMEOUT / 8000;
./drivers/firewire/core-card.c:	card->split_timeout_lo = (DEFAULT_SPLIT_TIMEOUT % 8000) << 19;
./drivers/firewire/core-card.c:	card->split_timeout_cycles = DEFAULT_SPLIT_TIMEOUT;
./drivers/firewire/core-card.c:	card->split_timeout_jiffies =
./drivers/firewire/core-card.c:	card->color = 0;
./drivers/firewire/core-card.c:	card->broadcast_channel = BROADCAST_CHANNEL_INITIAL;
./drivers/firewire/core-card.c:	kref_init(&card->kref);
./drivers/firewire/core-card.c:	init_completion(&card->done);
./drivers/firewire/core-card.c:	INIT_LIST_HEAD(&card->transaction_list);
./drivers/firewire/core-card.c:	INIT_LIST_HEAD(&card->phy_receiver_list);
./drivers/firewire/core-card.c:	spin_lock_init(&card->lock);
./drivers/firewire/core-card.c:	card->local_node = NULL;
./drivers/firewire/core-card.c:	INIT_DELAYED_WORK(&card->br_work, br_work);
./drivers/firewire/core-card.c:	INIT_DELAYED_WORK(&card->bm_work, bm_work);
./drivers/firewire/core-card.c:	card->max_receive = max_receive;
./drivers/firewire/core-card.c:	card->link_speed = link_speed;
./drivers/firewire/core-card.c:	card->guid = guid;
./drivers/firewire/core-card.c:	ret = card->driver->enable(card, tmp_config_rom, config_rom_length);
./drivers/firewire/core-card.c:		list_add_tail(&card->link, &card_list);
./drivers/firewire/core-card.c:	complete(&card->done);
./drivers/firewire/core-card.c:	card->driver->update_phy_reg(card, 4,
./drivers/firewire/core-card.c:	list_del_init(&card->link);
./drivers/firewire/core-card.c:	dummy_driver.free_iso_context	= card->driver->free_iso_context;
./drivers/firewire/core-card.c:	dummy_driver.stop_iso		= card->driver->stop_iso;
./drivers/firewire/core-card.c:	card->driver = &dummy_driver;
./drivers/firewire/core-card.c:	wait_for_completion(&card->done);
./drivers/firewire/core-card.c:	WARN_ON(!list_empty(&card->transaction_list));
./drivers/firewire/ohci.c:		dma_free_coherent(card->device, PAGE_SIZE, desc,
./drivers/firewire/ohci.c:	struct pci_dev *dev = to_pci_dev(card->device);
./drivers/firewire/ohci.c:		card->broadcast_channel_auto_allocated = true;
./drivers/firewire/ohci.c:	card->priority_budget_implemented = ohci->pri_req_max != 0;
./drivers/firewire/core-transaction.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-transaction.c:	list_for_each_entry(t, &card->transaction_list, link) {
./drivers/firewire/core-transaction.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:			card->tlabel_mask &= ~(1ULL << t->tlabel);
./drivers/firewire/core-transaction.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:	if (&t->link != &card->transaction_list) {
./drivers/firewire/core-transaction.c:	if (card->driver->cancel_packet(card, &transaction->packet) == 0)
./drivers/firewire/core-transaction.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-transaction.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:	card->tlabel_mask &= ~(1ULL << t->tlabel);
./drivers/firewire/core-transaction.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-transaction.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:		  jiffies + card->split_timeout_jiffies);
./drivers/firewire/core-transaction.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:	tlabel = card->current_tlabel;
./drivers/firewire/core-transaction.c:	while (card->tlabel_mask & (1ULL << tlabel)) {
./drivers/firewire/core-transaction.c:		if (tlabel == card->current_tlabel)
./drivers/firewire/core-transaction.c:	card->current_tlabel = (tlabel + 1) & 0x3f;
./drivers/firewire/core-transaction.c:	card->tlabel_mask |= 1ULL << tlabel;
./drivers/firewire/core-transaction.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-transaction.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:			destination_id, card->node_id, generation,
./drivers/firewire/core-transaction.c:	list_add_tail(&t->link, &card->transaction_list);
./drivers/firewire/core-transaction.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:	card->driver->send_request(card, &t->packet);
./drivers/firewire/core-transaction.c:		gap_count = card->driver->read_phy_reg(card, 1);
./drivers/firewire/core-transaction.c:	card->driver->send_request(card, &phy_config_packet);
./drivers/firewire/core-transaction.c:	cycles = card->split_timeout_cycles;
./drivers/firewire/core-transaction.c:	card->driver->send_response(card, &request->response);
./drivers/firewire/core-transaction.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-transaction.c:	list_for_each_entry(t, &card->transaction_list, link) {
./drivers/firewire/core-transaction.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:			card->tlabel_mask &= ~(1ULL << t->tlabel);
./drivers/firewire/core-transaction.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:	if (&t->link == &card->transaction_list) {
./drivers/firewire/core-transaction.c:	card->driver->cancel_packet(card, &t->packet);
./drivers/firewire/core-transaction.c:	memcpy(payload, &card->topology_map[start], length);
./drivers/firewire/core-transaction.c:	cycles = card->split_timeout_hi * 8000 + (card->split_timeout_lo >> 19);
./drivers/firewire/core-transaction.c:	card->split_timeout_cycles = cycles;
./drivers/firewire/core-transaction.c:	card->split_timeout_jiffies = DIV_ROUND_UP(cycles * HZ, 8000);
./drivers/firewire/core-transaction.c:		if (!card->priority_budget_implemented) {
./drivers/firewire/core-transaction.c:			*data = cpu_to_be32(card->driver->read_csr(card, reg));
./drivers/firewire/core-transaction.c:			card->driver->write_csr(card, reg, be32_to_cpu(*data));
./drivers/firewire/core-transaction.c:			card->driver->write_csr(card, CSR_STATE_CLEAR,
./drivers/firewire/core-transaction.c:			*data = cpu_to_be32(card->split_timeout_hi);
./drivers/firewire/core-transaction.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-transaction.c:			card->split_timeout_hi = be32_to_cpu(*data) & 7;
./drivers/firewire/core-transaction.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:			*data = cpu_to_be32(card->split_timeout_lo);
./drivers/firewire/core-transaction.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-transaction.c:			card->split_timeout_lo =
./drivers/firewire/core-transaction.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-transaction.c:			*data = card->maint_utility_register;
./drivers/firewire/core-transaction.c:			card->maint_utility_register = *data;
./drivers/firewire/core-transaction.c:			*data = cpu_to_be32(card->broadcast_channel);
./drivers/firewire/core-transaction.c:			card->broadcast_channel =
./drivers/firewire/core-device.c:	return device->card->driver->enable_phys_dma(device->card,
./drivers/firewire/core-device.c:	    device->card->beta_repeaters_present) {
./drivers/firewire/core-device.c:			device->max_speed = device->card->link_speed;
./drivers/firewire/core-device.c:			  device->card->reset_jiffies + SHUTDOWN_DELAY)
./drivers/firewire/core-device.c:	    && !list_empty(&device->card->link)) {
./drivers/firewire/core-device.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/firewire/core-device.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/firewire/core-device.c:	spin_lock_irq(&card->lock);  /* serialize node access */
./drivers/firewire/core-device.c:		old->generation = card->generation;
./drivers/firewire/core-device.c:		if (current_node == card->root_node)
./drivers/firewire/core-device.c:	spin_unlock_irq(&card->lock);
./drivers/firewire/core-device.c:	if (!card->broadcast_channel_allocated)
./drivers/firewire/core-device.c:			if (device->node == device->card->root_node)
./drivers/firewire/core-device.c:	revived_dev = device_find_child(device->card->device,
./drivers/firewire/core-device.c:	device->device.parent = device->card->device;
./drivers/firewire/core-device.c:	if (device->node == device->card->root_node)
./drivers/firewire/core-device.c:	if (node_id == card->root_node->node_id)
./drivers/firewire/core-device.c:		 * card->lock.
./drivers/firewire/core-device.c:		device->generation = card->generation;
./drivers/firewire/core-device.c:		device->is_local = node == card->local_node;
./drivers/firewire/core-device.c:		device->generation = card->generation;
./drivers/firewire/core-device.c:		device->generation = card->generation;
./drivers/firewire/core-device.c:				list_empty(&card->link) ? 0 : SHUTDOWN_DELAY);
./drivers/media/dvb/siano/sms-cards.c: *  Card-specific functions for the Siano SMS1xxx USB dongle
./drivers/media/dvb/siano/sms-cards.c:		sms_set_gpio(coredev, board->led_power, 0);
./drivers/media/dvb/siano/sms-cards.c:		sms_set_gpio(coredev, board->led_hi, 0);
./drivers/media/dvb/siano/sms-cards.c:		sms_set_gpio(coredev, board->led_lo, 0);
./drivers/media/dvb/siano/sms-cards.c:		sms_set_gpio(coredev, board->lna_ctrl, 0);
./drivers/media/dvb/siano/sms-cards.c:			     board->led_power, onoff ? 1 : 0);
./drivers/media/dvb/siano/sms-cards.c:			sms_set_gpio(coredev, board->lna_ctrl, 0);
./drivers/media/dvb/siano/sms-cards.c:			     board->led_lo, (led & SMS_LED_LO) ? 1 : 0);
./drivers/media/dvb/siano/sms-cards.c:			     board->led_hi, (led & SMS_LED_HI) ? 1 : 0);
./drivers/media/dvb/siano/sms-cards.c:			     board->rf_switch, onoff ? 1 : 0);
./drivers/media/dvb/siano/sms-cards.c:				    board->lna_ctrl, onoff ? 1 : 0);
./drivers/media/dvb/dvb-usb/cxusb.c:	.firmware          = "dvb-usb-bluebird-01.fw",
./drivers/media/dvb/dvb-usb/cxusb.c:	.firmware          = "dvb-usb-bluebird-01.fw",
./drivers/media/dvb/dvb-usb/cxusb.c:	.firmware          = "dvb-usb-bluebird-01.fw",
./drivers/media/dvb/dvb-usb/cxusb.c:	.firmware          = "dvb-usb-bluebird-01.fw",
./drivers/media/dvb/dvb-usb/cxusb.c:	.firmware          = "dvb-usb-bluebird-02.fw",
./drivers/media/dvb/ttpci/av7110.c:	/* card-specific recovery */
./drivers/media/dvb/ttpci/budget-core.c:	switch(budget->card->type) {
./drivers/media/dvb/ttpci/budget-core.c:	switch(budget->card->type) {
./drivers/media/dvb/ttpci/budget-core.c:	ret = dvb_register_adapter(&budget->dvb_adapter, budget->card->name,
./drivers/media/dvb/ttpci/budget-core.c:	strlcpy(budget->i2c_adap.name, budget->card->name, sizeof(budget->i2c_adap.name));
./drivers/media/dvb/ttpci/budget-core.c:	strcpy(budget->i2c_adap.name, budget->card->name);
./drivers/media/dvb/frontends/bcm3510.c: *  This driver is "hard-coded" to be used with the 1st generation of
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	//printk("%d ", card->bt->finished_block);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	while (card->bt->last_block != card->bt->finished_block) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		(card->bt->TS_Size ? dvb_dmx_swfilter_204 : dvb_dmx_swfilter)
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			(&card->demux,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			 &card->bt->buf_cpu[card->bt->last_block *
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:					    card->bt->block_bytes],
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			 card->bt->block_bytes);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->bt->last_block = (card->bt->last_block + 1) %
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:					card->bt->block_count;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	mutex_lock(&card->lock);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->nfeeds++;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	rc = card->nfeeds;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if (card->nfeeds == 1)
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		bt878_start(card->bt, card->gpio_mode,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			    card->op_sync_orin, card->irq_err_ignore);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	mutex_unlock(&card->lock);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	mutex_lock(&card->lock);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->nfeeds--;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if (card->nfeeds == 0)
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		bt878_stop(card->bt);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	mutex_unlock(&card->lock);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	bttv_gpio_enable(card->bttv_nr, 1, 1);  /* output */
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	bttv_write_gpio(card->bttv_nr, 1, 1);   /* relay on */
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	bttv_write_gpio(card->bttv_nr, 1, 0);   /* relay off */
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	i2c_transfer(card->i2c_adapter, &msg, 1);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	i2c_transfer(card->i2c_adapter, &msg, 1);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(mt352_attach, &thomson_dtt7579_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe == NULL)
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe = dvb_attach(zl10353_attach, &thomson_dtt7579_zl10353_config,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:						  card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe != NULL) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.calc_regs = thomson_dtt7579_tuner_calc_regs;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.info.frequency_min = 174000000;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.info.frequency_max = 862000000;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(lgdt330x_attach, &tdvs_tua6034_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe != NULL) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			dvb_attach(simple_tuner_attach, card->fe,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:				   card->i2c_adapter, 0x61,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(nxt6000_attach, &vp3021_alps_tded4_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe != NULL) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.set_params = vp3021_alps_tded4_tuner_set_params;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(mt352_attach, &digitv_alps_tded4_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe != NULL) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.calc_regs = digitv_alps_tded4_tuner_calc_regs;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(sp887x_attach, &microtune_mt7202dtf_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.set_params = microtune_mt7202dtf_tuner_set_params;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(mt352_attach, &advbt771_samsung_tdtc9251dh0_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe != NULL) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.calc_regs = advbt771_samsung_tdtc9251dh0_tuner_calc_regs;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.info.frequency_min = 174000000;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.info.frequency_max = 862000000;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		state->i2c = card->i2c_adapter;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		state->bt = card->bt;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (dvb_attach(dst_attach, state, &card->dvb_adapter) == NULL) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = &state->frontend;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			dvb_attach(dst_ca_attach, state, &card->dvb_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(cx24110_attach, &pctvsat_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.init = pinnsat_tuner_init;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.sleep = pinnsat_tuner_sleep;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe->ops.tuner_ops.set_params = cx24108_tuner_set_params;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->fe = dvb_attach(or51211_attach, &or51211_config, card->i2c_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (card->fe != NULL)
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			dvb_attach(simple_tuner_attach, card->fe,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:				   card->i2c_adapter, 0x61,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if (card->fe == NULL)
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		       card->bt->dev->vendor,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		       card->bt->dev->device,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		       card->bt->dev->subsystem_vendor,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		       card->bt->dev->subsystem_device);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		if (dvb_register_frontend(&card->dvb_adapter, card->fe)) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			dvb_frontend_detach(card->fe);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:			card->fe = NULL;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	result = dvb_register_adapter(&card->dvb_adapter, card->card_name,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:				      THIS_MODULE, &card->bt->dev->dev,
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->dvb_adapter.priv = card;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->bt->adapter = card->i2c_adapter;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	memset(&card->demux, 0, sizeof(struct dvb_demux));
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING | DMX_MEMORY_BASED_FILTERING;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.priv = card;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.filternum = 256;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.feednum = 256;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.start_feed = dvb_bt8xx_start_feed;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.stop_feed = dvb_bt8xx_stop_feed;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.write_to_decoder = NULL;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if ((result = dvb_dmx_init(&card->demux)) < 0) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_unregister_adapter(&card->dvb_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->dmxdev.filternum = 256;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->dmxdev.demux = &card->demux.dmx;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->dmxdev.capabilities = 0;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if ((result = dvb_dmxdev_init(&card->dmxdev, &card->dvb_adapter)) < 0) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_dmx_release(&card->demux);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_unregister_adapter(&card->dvb_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->fe_hw.source = DMX_FRONTEND_0;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if ((result = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_hw)) < 0) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_dmxdev_release(&card->dmxdev);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_dmx_release(&card->demux);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_unregister_adapter(&card->dvb_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->fe_mem.source = DMX_MEMORY_FE;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if ((result = card->demux.dmx.add_frontend(&card->demux.dmx, &card->fe_mem)) < 0) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_dmxdev_release(&card->dmxdev);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_dmx_release(&card->demux);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_unregister_adapter(&card->dvb_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if ((result = card->demux.dmx.connect_frontend(&card->demux.dmx, &card->fe_hw)) < 0) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_dmxdev_release(&card->dmxdev);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_dmx_release(&card->demux);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_unregister_adapter(&card->dvb_adapter);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	dvb_net_init(&card->dvb_adapter, &card->dvbnet, &card->demux.dmx);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	tasklet_init(&card->bt->tasklet, dvb_bt8xx_task, (unsigned long) card);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	mutex_init(&card->lock);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->bttv_nr = sub->core->nr;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	strlcpy(card->card_name, sub->core->v4l2_dev.name, sizeof(card->card_name));
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->i2c_adapter = &sub->core->i2c_adap;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->gpio_mode = 0x0400c060;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->gpio_mode = 0x0400C060;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->gpio_mode = 0x0400c060;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->gpio_mode = (1 << 26) | (1 << 14) | (1 << 5);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->gpio_mode = 0x0400402B;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->gpio_mode = 0x2204f2c;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->irq_err_ignore = BT878_APABORT | BT878_ARIPERR |
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->gpio_mode = 0x0100EC7B;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->op_sync_orin = BT878_RISC_SYNC_MASK;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		card->irq_err_ignore = BT878_AFBUS | BT878_AFDSR;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	dprintk("dvb_bt8xx: identified card%d as %s\n", card->bttv_nr, card->card_name);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if (!(bttv_pci_dev = bttv_get_pcidev(card->bttv_nr))) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		printk("dvb_bt8xx: no pci device for card %d\n", card->bttv_nr);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if (!(card->bt = dvb_bt8xx_878_match(card->bttv_nr, bttv_pci_dev))) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		       card->bttv_nr);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	mutex_init(&card->bt->gpio_lock);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->bt->bttv_nr = sub->core->nr;
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	dprintk("dvb_bt8xx: unloading card%d\n", card->bttv_nr);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	bt878_stop(card->bt);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	tasklet_kill(&card->bt->tasklet);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	dvb_net_release(&card->dvbnet);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_mem);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	card->demux.dmx.remove_frontend(&card->demux.dmx, &card->fe_hw);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	dvb_dmxdev_release(&card->dmxdev);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	dvb_dmx_release(&card->demux);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	if (card->fe) {
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_unregister_frontend(card->fe);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:		dvb_frontend_detach(card->fe);
./drivers/media/dvb/bt8xx/dvb-bt8xx.c:	dvb_unregister_adapter(&card->dvb_adapter);
./drivers/media/video/saa7134/saa7134-cards.c: * card-specific stuff.
./drivers/media/video/saa7134/saa7134-alsa.c:	strcpy(card->mixername, "SAA7134 Mixer");
./drivers/media/video/saa7134/saa7134-alsa.c:	snd_card_saa7134_t *chip = card->private_data;
./drivers/media/video/saa7134/saa7134-alsa.c:	strcpy(card->driver, "SAA7134");
./drivers/media/video/saa7134/saa7134-alsa.c:	card->private_free = snd_saa7134_free;
./drivers/media/video/saa7134/saa7134-alsa.c:	chip = card->private_data;
./drivers/media/video/saa7134/saa7134-alsa.c:	strcpy(card->shortname, "SAA7134");
./drivers/media/video/saa7134/saa7134-alsa.c:	sprintf(card->longname, "%s at 0x%lx irq %d",
./drivers/media/video/saa7134/saa7134-alsa.c:	printk(KERN_INFO "%s/alsa: %s registered as card %d\n",dev->name,card->longname,index[devnum]);
./drivers/media/video/cx231xx/cx231xx-input.c:	 * Board-dependent values
./drivers/media/video/cx231xx/cx231xx-audio.c:	strcpy(card->driver, "Cx231xx-Audio");
./drivers/media/video/cx231xx/cx231xx-audio.c:	strcpy(card->shortname, "Cx231xx Audio");
./drivers/media/video/cx231xx/cx231xx-audio.c:	strcpy(card->longname, "Conexant cx231xx Audio");
./drivers/media/video/mxb.c:	if (V4L2_STD_PAL_I == standard->id) {
./drivers/media/video/uvc/uvc_driver.c:			if (forward->bNrInPins != 1) {
./drivers/media/video/uvc/uvc_driver.c:			list_add_tail(&forward->chain, &chain->entities);
./drivers/media/video/uvc/uvc_driver.c:				printk(" XU %d", forward->id);
./drivers/media/video/uvc/uvc_driver.c:					"terminal %u.\n", forward->id);
./drivers/media/video/uvc/uvc_driver.c:			list_add_tail(&forward->chain, &chain->entities);
./drivers/media/video/uvc/uvc_driver.c:				printk(" OT %d", forward->id);
./drivers/media/video/cx18/cx18-ioctl.c:	cx->audio_input = cx->card->video_inputs[inp].audio_index;
./drivers/media/video/cx18/cx18-firmware.c:	cx18_write_reg(cx, cx->card->ddr.chip_config, CX18_DDR_CHIP_CONFIG);
./drivers/media/video/cx18/cx18-firmware.c:	cx18_write_reg(cx, cx->card->ddr.refresh, CX18_DDR_REFRESH);
./drivers/media/video/cx18/cx18-firmware.c:	cx18_write_reg(cx, cx->card->ddr.timing1, CX18_DDR_TIMING1);
./drivers/media/video/cx18/cx18-firmware.c:	cx18_write_reg(cx, cx->card->ddr.timing2, CX18_DDR_TIMING2);
./drivers/media/video/cx18/cx18-firmware.c:	cx18_write_reg(cx, cx->card->ddr.tune_lane, CX18_DDR_TUNE_LANE);
./drivers/media/video/cx18/cx18-firmware.c:	cx18_write_reg(cx, cx->card->ddr.initial_emrs, CX18_DDR_INITIAL_EMRS);
./drivers/media/video/cx18/cx18-cards.c:		cx->card->video_inputs + index;
./drivers/media/video/cx18/cx18-cards.c:		cx->card->audio_inputs + index;
./drivers/media/video/cx18/cx18-audio.c:		in = &cx->card->radio_input;
./drivers/media/video/cx18/cx18-audio.c:		in = &cx->card->audio_inputs[cx->audio_input];
./drivers/media/video/cx18/cx18-audio.c:	err = cx18_call_hw_err(cx, cx->card->hw_audio_ctrl,
./drivers/media/video/cx18/cx18-streams.c:		if (cx->card->hw_all & CX18_HW_DVB) {
./drivers/media/video/cx18/cx18-driver.c:	switch (cx->card->type) {
./drivers/media/video/cx18/cx18-driver.c:	cx->v4l2_cap = cx->card->v4l2_capabilities;
./drivers/media/video/cx18/cx18-driver.c:	cx->card_name = cx->card->name;
./drivers/media/video/cx18/cx18-driver.c:	cx->card_i2c = cx->card->i2c;
./drivers/media/video/cx18/cx18-driver.c:		CX18_INFO("User specified %s card\n", cx->card->name);
./drivers/media/video/cx18/cx18-driver.c:			if (cx->card->pci_list == NULL)
./drivers/media/video/cx18/cx18-driver.c:			for (j = 0; cx->card->pci_list[j].device; j++) {
./drivers/media/video/cx18/cx18-driver.c:				    cx->card->pci_list[j].device)
./drivers/media/video/cx18/cx18-driver.c:				    cx->card->pci_list[j].subsystem_vendor)
./drivers/media/video/cx18/cx18-driver.c:				    cx->card->pci_list[j].subsystem_device)
./drivers/media/video/cx18/cx18-driver.c:				CX18_INFO("Autodetected %s card\n", cx->card->name);
./drivers/media/video/cx18/cx18-driver.c:		CX18_ERR("Defaulting to %s card\n", cx->card->name);
./drivers/media/video/cx18/cx18-driver.c:	cx->v4l2_cap = cx->card->v4l2_capabilities;
./drivers/media/video/cx18/cx18-driver.c:	cx->card_name = cx->card->name;
./drivers/media/video/cx18/cx18-driver.c:	cx->card_i2c = cx->card->i2c;
./drivers/media/video/cx18/cx18-driver.c:		if (cx->card->video_inputs[i].video_type == 0)
./drivers/media/video/cx18/cx18-driver.c:		if (cx->card->audio_inputs[i].audio_type == 0)
./drivers/media/video/cx18/cx18-driver.c:		if (cx->card->video_inputs[i].video_type ==
./drivers/media/video/cx18/cx18-driver.c:	cx->audio_input = cx->card->video_inputs[i].audio_index;
./drivers/media/video/cx18/cx18-driver.c:	u32 hw = cx->card->hw_all;
./drivers/media/video/cx18/cx18-driver.c:	if (cx->card->hw_muxer != 0)
./drivers/media/video/cx18/cx18-driver.c:		cx->sd_extmux = cx18_find_hw(cx, cx->card->hw_muxer);
./drivers/media/video/cx18/cx18-driver.c:	if (cx->card->hw_all & CX18_HW_GPIO_RESET_CTRL) {
./drivers/media/video/cx18/cx18-driver.c:	if (cx->card->hw_all & CX18_HW_TVEEPROM) {
./drivers/media/video/cx18/cx18-driver.c:	if (cx->card->comment)
./drivers/media/video/cx18/cx18-driver.c:		CX18_INFO("%s", cx->card->comment);
./drivers/media/video/cx18/cx18-driver.c:	if (cx->card->v4l2_capabilities == 0) {
./drivers/media/video/cx18/cx18-driver.c:			if ((cx->std & cx->card->tuners[i].std) == 0)
./drivers/media/video/cx18/cx18-driver.c:			cx->options.tuner = cx->card->tuners[i].tuner;
./drivers/media/video/cx18/cx18-driver.c:	if (cx->options.tuner == -1 && cx->card->tuners[0].std) {
./drivers/media/video/cx18/cx18-driver.c:		cx->std = cx->card->tuners[0].std;
./drivers/media/video/cx18/cx18-driver.c:		cx->options.tuner = cx->card->tuners[0].tuner;
./drivers/media/video/cx18/cx18-driver.c:		cx->options.radio = (cx->card->radio_input.audio_type != 0);
./drivers/media/video/cx18/cx18-driver.c:	/* The card is now fully identified, continue with card-specific
./drivers/media/video/cx18/cx18-gpio.c:	gpio_update(cx, cx->card->gpio_audio_input.mask,
./drivers/media/video/cx18/cx18-gpio.c:			cx->card->gpio_audio_input.radio);
./drivers/media/video/cx18/cx18-gpio.c:	switch (cx->card->audio_inputs[cx->audio_input].muxer_input) {
./drivers/media/video/cx18/cx18-gpio.c:		data = cx->card->gpio_audio_input.linein;
./drivers/media/video/cx18/cx18-gpio.c:		data = cx->card->gpio_audio_input.tuner;
./drivers/media/video/cx18/cx18-gpio.c:		data = cx->card->gpio_audio_input.tuner;
./drivers/media/video/cx18/cx18-gpio.c:	gpio_update(cx, cx->card->gpio_audio_input.mask, data);
./drivers/media/video/cx18/cx18-gpio.c:		data = cx->card->gpio_audio_input.tuner;
./drivers/media/video/cx18/cx18-gpio.c:		data = cx->card->gpio_audio_input.linein;
./drivers/media/video/cx18/cx18-gpio.c:		data = cx->card->gpio_audio_input.radio;
./drivers/media/video/cx18/cx18-gpio.c:	gpio_update(cx, cx->card->gpio_audio_input.mask, data);
./drivers/media/video/cx18/cx18-gpio.c:	p = &cx->card->gpio_i2c_slave_reset;
./drivers/media/video/cx18/cx18-gpio.c:		if (cx->card->tuners[0].tuner == TUNER_XC2028)
./drivers/media/video/cx18/cx18-gpio.c:			gpio_reset_seq(cx, (1 << cx->card->xceive_pin), 0,
./drivers/media/video/cx18/cx18-gpio.c:	cx->gpio_dir = cx->card->gpio_init.direction;
./drivers/media/video/cx18/cx18-gpio.c:	cx->gpio_val = cx->card->gpio_init.initial_value;
./drivers/media/video/cx18/cx18-gpio.c:	if (cx->card->tuners[0].tuner == TUNER_XC2028) {
./drivers/media/video/cx18/cx18-gpio.c:		cx->gpio_dir |= 1 << cx->card->xceive_pin;
./drivers/media/video/cx18/cx18-gpio.c:		cx->gpio_val |= 1 << cx->card->xceive_pin;
./drivers/media/video/cx18/cx18-gpio.c:	if (cx->card->gpio_i2c_slave_reset.ir_reset_mask == 0)
./drivers/media/video/cx18/cx18-gpio.c:	    cx->card->tuners[0].tuner != TUNER_XC2028)
./drivers/media/video/cx18/cx18-video.c:			cx->card->video_inputs[inp].video_input, 0, 0);
./drivers/media/video/cx18/cx18-i2c.c:/* This might well become a card-specific array */
./drivers/media/video/cx18/cx18-dvb.c:	switch (cx->card->type) {
./drivers/media/video/cx18/cx18-dvb.c:	switch (cx->card->type) {
./drivers/media/video/ivtv/ivtv-ioctl.c:	itv->audio_input = itv->card->video_inputs[inp].audio_index;
./drivers/media/video/ivtv/ivtv-ioctl.c:	if (outp >= itv->card->nof_outputs)
./drivers/media/video/ivtv/ivtv-ioctl.c:			itv->card->video_outputs[outp].video_output, 0);
./drivers/media/video/ivtv/ivtv-gpio.c:	if (itv->card->type != IVTV_CARD_PVR_150)
./drivers/media/video/ivtv/ivtv-gpio.c:	curout &= ~(1 << itv->card->xceive_pin);
./drivers/media/video/ivtv/ivtv-gpio.c:	curout |= 1 << itv->card->xceive_pin;
./drivers/media/video/ivtv/ivtv-gpio.c:	mask = itv->card->gpio_audio_freq.mask;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_freq.f32000;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_freq.f44100;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_freq.f48000;
./drivers/media/video/ivtv/ivtv-gpio.c:	mask = itv->card->gpio_audio_detect.mask;
./drivers/media/video/ivtv/ivtv-gpio.c:	mask = itv->card->gpio_audio_mode.mask;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_mode.lang1;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_mode.lang2;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_mode.mono;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_mode.stereo;
./drivers/media/video/ivtv/ivtv-gpio.c:	mask = itv->card->gpio_audio_input.mask;
./drivers/media/video/ivtv/ivtv-gpio.c:	data = itv->card->gpio_audio_input.radio;
./drivers/media/video/ivtv/ivtv-gpio.c:	mask = itv->card->gpio_audio_input.mask;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_input.tuner;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_input.linein;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_audio_input.radio;
./drivers/media/video/ivtv/ivtv-gpio.c:		mask = itv->card->gpio_audio_mute.mask;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = ctrl->val ? itv->card->gpio_audio_mute.mute : 0;
./drivers/media/video/ivtv/ivtv-gpio.c:	mask = itv->card->gpio_video_input.mask;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_video_input.tuner;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_video_input.composite;
./drivers/media/video/ivtv/ivtv-gpio.c:		data = itv->card->gpio_video_input.svideo;
./drivers/media/video/ivtv/ivtv-gpio.c:	if (itv->card->xceive_pin)
./drivers/media/video/ivtv/ivtv-gpio.c:		pin = 1 << itv->card->xceive_pin;
./drivers/media/video/ivtv/ivtv-gpio.c:	if ((itv->card->gpio_init.direction | pin) == 0)
./drivers/media/video/ivtv/ivtv-gpio.c:	write_reg(itv->card->gpio_init.initial_value | pin, IVTV_REG_GPIO_OUT);
./drivers/media/video/ivtv/ivtv-gpio.c:	write_reg(itv->card->gpio_init.direction | pin, IVTV_REG_GPIO_DIR);
./drivers/media/video/ivtv/ivtv-cards.c:	const struct ivtv_card_video_input *card_input = itv->card->video_inputs + index;
./drivers/media/video/ivtv/ivtv-cards.c:	const struct ivtv_card_output *card_output = itv->card->video_outputs + index;
./drivers/media/video/ivtv/ivtv-cards.c:	if (index >= itv->card->nof_outputs)
./drivers/media/video/ivtv/ivtv-cards.c:	const struct ivtv_card_audio_input *aud_input = itv->card->audio_inputs + index;
./drivers/media/video/ivtv/ivtv-cards.c:	if (itv->card->video_outputs == NULL || index != 0)
./drivers/media/video/ivtv/ivtv-streams.c:		if (itv->card->hw_all & (IVTV_HW_SAA7115 | IVTV_HW_SAA717X))
./drivers/media/video/ivtv/ivtv-streams.c:		else if (itv->card->hw_all & IVTV_HW_SAA7114)
./drivers/media/video/ivtv/ivtv-firmware.c:		    itv->card->video_outputs[itv->active_output].video_output,
./drivers/media/video/ivtv/ivtv-firmware.c:		    itv->card->video_outputs[itv->active_output].video_output,
./drivers/media/video/ivtv/ivtv-driver.c:	itv->v4l2_cap = itv->card->v4l2_capabilities;
./drivers/media/video/ivtv/ivtv-driver.c:	itv->card_name = itv->card->name;
./drivers/media/video/ivtv/ivtv-driver.c:	itv->card_i2c = itv->card->i2c;
./drivers/media/video/ivtv/ivtv-driver.c:				itv->card->name, chipname);
./drivers/media/video/ivtv/ivtv-driver.c:			if (itv->card->pci_list == NULL)
./drivers/media/video/ivtv/ivtv-driver.c:			for (j = 0; itv->card->pci_list[j].device; j++) {
./drivers/media/video/ivtv/ivtv-driver.c:				    itv->card->pci_list[j].device)
./drivers/media/video/ivtv/ivtv-driver.c:				    itv->card->pci_list[j].subsystem_vendor)
./drivers/media/video/ivtv/ivtv-driver.c:				    itv->card->pci_list[j].subsystem_device)
./drivers/media/video/ivtv/ivtv-driver.c:						itv->card->name, chipname);
./drivers/media/video/ivtv/ivtv-driver.c:		IVTV_ERR("Defaulting to %s card\n", itv->card->name);
./drivers/media/video/ivtv/ivtv-driver.c:	itv->v4l2_cap = itv->card->v4l2_capabilities;
./drivers/media/video/ivtv/ivtv-driver.c:	itv->card_name = itv->card->name;
./drivers/media/video/ivtv/ivtv-driver.c:	itv->card_i2c = itv->card->i2c;
./drivers/media/video/ivtv/ivtv-driver.c:		if (itv->card->video_inputs[i].video_type == 0)
./drivers/media/video/ivtv/ivtv-driver.c:		if (itv->card->audio_inputs[i].audio_type == 0)
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->hw_all & IVTV_HW_CX25840) {
./drivers/media/video/ivtv/ivtv-driver.c:		if (itv->card->video_inputs[i].video_type ==
./drivers/media/video/ivtv/ivtv-driver.c:	itv->audio_input = itv->card->video_inputs[i].audio_index;
./drivers/media/video/ivtv/ivtv-driver.c:	u32 hw = itv->card->hw_all;
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->hw_all & IVTV_HW_CX25840)
./drivers/media/video/ivtv/ivtv-driver.c:	else if (itv->card->hw_all & IVTV_HW_SAA717X)
./drivers/media/video/ivtv/ivtv-driver.c:	else if (itv->card->hw_all & IVTV_HW_SAA7114)
./drivers/media/video/ivtv/ivtv-driver.c:	itv->sd_audio = ivtv_find_hw(itv, itv->card->hw_audio_ctrl);
./drivers/media/video/ivtv/ivtv-driver.c:	itv->sd_muxer = ivtv_find_hw(itv, itv->card->hw_muxer);
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->type == IVTV_CARD_CX23416GYC) {
./drivers/media/video/ivtv/ivtv-driver.c:	else if (itv->card->type == IVTV_CARD_GV_MVPRX ||
./drivers/media/video/ivtv/ivtv-driver.c:		 itv->card->type == IVTV_CARD_GV_MVPRX2E) {
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->hw_all & IVTV_HW_TVEEPROM) {
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->comment)
./drivers/media/video/ivtv/ivtv-driver.c:		IVTV_INFO("%s", itv->card->comment);
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->v4l2_capabilities == 0) {
./drivers/media/video/ivtv/ivtv-driver.c:			if ((itv->std & itv->card->tuners[i].std) == 0)
./drivers/media/video/ivtv/ivtv-driver.c:			itv->options.tuner = itv->card->tuners[i].tuner;
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->options.tuner == -1 && itv->card->tuners[0].std) {
./drivers/media/video/ivtv/ivtv-driver.c:		itv->std = itv->card->tuners[0].std;
./drivers/media/video/ivtv/ivtv-driver.c:		itv->options.tuner = itv->card->tuners[0].tuner;
./drivers/media/video/ivtv/ivtv-driver.c:		itv->options.radio = (itv->card->radio_input.audio_type != 0);
./drivers/media/video/ivtv/ivtv-driver.c:	/* The card is now fully identified, continue with card-specific
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->hw_all & IVTV_HW_CX25840)
./drivers/media/video/ivtv/ivtv-driver.c:	if (itv->card->v4l2_capabilities & V4L2_CAP_VIDEO_OUTPUT) {
./drivers/media/video/ivtv/ivtv-routing.c:		in = &itv->card->radio_input;
./drivers/media/video/ivtv/ivtv-routing.c:		in = &itv->card->audio_inputs[itv->audio_input];
./drivers/media/video/ivtv/ivtv-routing.c:	if (itv->card->hw_muxer & IVTV_HW_M52790)
./drivers/media/video/ivtv/ivtv-routing.c:	if (itv->card->hw_audio & IVTV_HW_MSP34XX)
./drivers/media/video/ivtv/ivtv-routing.c:	ivtv_call_hw(itv, itv->card->hw_audio, audio, s_routing,
./drivers/media/video/ivtv/ivtv-routing.c:		itv->card->video_inputs[inp].video_input, 0, 0);
./drivers/media/video/ivtv/ivtv-routing.c:	type = itv->card->video_inputs[inp].video_type;
./drivers/media/video/ivtv/ivtv-routing.c:	if (itv->card->hw_video & IVTV_HW_GPIO)
./drivers/media/video/ivtv/ivtv-routing.c:	if (itv->card->hw_video & IVTV_HW_UPD64031A) {
./drivers/media/video/ivtv/ivtv-routing.c:		input |= itv->card->gr_config;
./drivers/media/video/ivtv/ivtv-routing.c:	if (itv->card->hw_video & IVTV_HW_UPD6408X) {
./drivers/media/video/ivtv/ivtv-routing.c:		else if (itv->card->hw_video & IVTV_HW_UPD64031A) {
./drivers/media/video/ivtv/ivtv-routing.c:			    itv->card->type == IVTV_CARD_CX23416GYC) {
./drivers/media/video/zoran/zoran_card.c: * This part handles card-specific data and detection
./drivers/media/video/cx88/cx88-cards.c: * card-specific stuff.
./drivers/media/video/cx88/cx88-cards.c:	/* Board-specific callbacks */
./drivers/media/video/cx88/cx88-cards.c: * Sets board-dependent xc3028 configuration
./drivers/media/video/cx88/cx88-alsa.c:	snd_cx88_card_t *chip = card->private_data;
./drivers/media/video/cx88/cx88-alsa.c:	chip = card->private_data;
./drivers/media/video/cx88/cx88-alsa.c:	card->private_free = snd_cx88_dev_free;
./drivers/media/video/cx88/cx88-alsa.c:	strcpy (card->driver, "CX88x");
./drivers/media/video/cx88/cx88-alsa.c:	sprintf(card->shortname, "Conexant CX%x", pci->device);
./drivers/media/video/cx88/cx88-alsa.c:	sprintf(card->longname, "%s at %#llx",
./drivers/media/video/cx88/cx88-alsa.c:		card->shortname,(unsigned long long)pci_resource_start(pci, 0));
./drivers/media/video/cx88/cx88-alsa.c:	strcpy (card->mixername, "CX88");
./drivers/media/video/cx88/cx88-alsa.c:	       card->driver,devno);
./drivers/media/video/msp3400-driver.c:int msp_amsound;	 /* hard-wire AM sound at 6.5 Hz (france),
./drivers/media/video/bt8xx/bttv-cards.c:    this file has configuration informations - card-specific stuff
./drivers/media/video/bt8xx/bttv-driver.c:	/* some card-specific stuff (needs working i2c) */
./drivers/media/video/tlg2300/pd-alsa.c:	strcpy(card->driver, "ALSA driver");
./drivers/media/video/tlg2300/pd-alsa.c:	strcpy(card->shortname, "poseidon Audio");
./drivers/media/video/tlg2300/pd-alsa.c:	strcpy(card->longname, "poseidon ALSA Audio");
./drivers/media/video/em28xx/em28xx-audio.c:	strcpy(card->driver, "Em28xx-Audio");
./drivers/media/video/em28xx/em28xx-audio.c:	strcpy(card->shortname, "Em28xx Audio");
./drivers/media/video/em28xx/em28xx-audio.c:	strcpy(card->longname, "Empia Em28xx Audio");
./drivers/media/radio/radio-aztech.c:	/* convert to card-friendly values */
./drivers/media/common/saa7146_hlp.c:	hyo = vv->standard->v_offset;
./drivers/media/common/saa7146_hlp.c:	hxo = vv->standard->h_offset;
./drivers/media/common/saa7146_hlp.c:	calculate_v_scale_registers(dev, field, vv->standard->v_field*2, height, &hps_v_scale, &hps_v_gain);
./drivers/media/common/saa7146_hlp.c:	calculate_h_scale_registers(dev, vv->standard->h_pixels, width, vv->hflip, &hps_ctrl, &hps_v_gain, &hps_h_prescale, &hps_h_scale);
./drivers/media/common/saa7146_hlp.c:	vdma1.num_line_byte = (vv->standard->v_field<<16)+vv->standard->h_pixels;
./drivers/media/common/saa7146_hlp.c:	vdma1.num_line_byte	= ((vv->standard->v_field<<16) + vv->standard->h_pixels);
./drivers/media/common/saa7146_hlp.c:	vdma1.num_line_byte	= ((vv->standard->v_field<<16) + vv->standard->h_pixels);
./drivers/media/common/saa7146_video.c:	v4l2_video_std_frame_period(vv->standard->id,
./drivers/media/common/saa7146_video.c:	maxw  = vv->standard->h_max_out;
./drivers/media/common/saa7146_video.c:	maxh  = vv->standard->v_max_out;
./drivers/media/common/saa7146_video.c:	maxw  = vv->standard->h_max_out;
./drivers/media/common/saa7146_video.c:	maxh  = vv->standard->v_max_out;
./drivers/media/common/saa7146_video.c:	*norm = vv->standard->id;
./drivers/media/common/saa7146_video.c:	DEB_EE(("VIDIOC_S_STD: set to standard to '%s'\n", vv->standard->name));
./drivers/media/common/saa7146_video.c:	    fh->video_fmt.width  > vv->standard->h_max_out ||
./drivers/media/common/saa7146_video.c:	    fh->video_fmt.height > vv->standard->v_max_out) {
./drivers/media/rc/mceusb.c: * support for what appears to be 3rd-gen hardware added by Jarod.
./drivers/media/rc/imon.c:			 * to use hard-coded scancodes here...
./drivers/media/rc/imon.c:			 * to use hard-coded scancodes here...
./drivers/media/rc/imon.c: * actually supports. These devices have their IR protocol hard-coded into
./drivers/ssb/pci.c:/* Get the word-offset for a SSB_SPROM_XXX define. */
./drivers/amba/bus.c:	/* Hard-coded primecell ID instead of plug-n-play */
./drivers/pcmcia/at91_cf.c:	return !gpio_get_value(cf->board->det_pin);
./drivers/pcmcia/at91_cf.c:	if (irq == cf->board->det_pin) {
./drivers/pcmcia/at91_cf.c:		int rdy	= cf->board->irq_pin;	/* RDY/nIRQ */
./drivers/pcmcia/at91_cf.c:		int vcc	= cf->board->vcc_pin;
./drivers/pcmcia/at91_cf.c:	if (cf->board->vcc_pin) {
./drivers/pcmcia/at91_cf.c:				gpio_set_value(cf->board->vcc_pin, 0);
./drivers/pcmcia/at91_cf.c:				gpio_set_value(cf->board->vcc_pin, 1);
./drivers/pcmcia/at91_cf.c:	gpio_set_value(cf->board->rst_pin, s->flags & SS_RESET);
./drivers/pcmcia/at91_cf.c:	csr = at91_sys_read(AT91_SMC_CSR(cf->board->chipselect)) & ~AT91_SMC_DBW;
./drivers/pcmcia/at91_cf.c:	at91_sys_write(AT91_SMC_CSR(cf->board->chipselect), csr);
./drivers/pcmcia/at91_cf.c:	if (!board || !board->det_pin || !board->rst_pin)
./drivers/pcmcia/at91_cf.c:	status = gpio_request(board->det_pin, "cf_det");
./drivers/pcmcia/at91_cf.c:	status = request_irq(board->det_pin, at91_cf_irq, 0, driver_name, cf);
./drivers/pcmcia/at91_cf.c:	status = gpio_request(board->rst_pin, "cf_rst");
./drivers/pcmcia/at91_cf.c:	if (board->vcc_pin) {
./drivers/pcmcia/at91_cf.c:		status = gpio_request(board->vcc_pin, "cf_vcc");
./drivers/pcmcia/at91_cf.c:	if (board->irq_pin) {
./drivers/pcmcia/at91_cf.c:		status = gpio_request(board->irq_pin, "cf_irq");
./drivers/pcmcia/at91_cf.c:		status = request_irq(board->irq_pin, at91_cf_irq,
./drivers/pcmcia/at91_cf.c:		cf->socket.pci_irq = board->irq_pin;
./drivers/pcmcia/at91_cf.c:		board->det_pin, board->irq_pin);
./drivers/pcmcia/at91_cf.c:	if (board->irq_pin) {
./drivers/pcmcia/at91_cf.c:		free_irq(board->irq_pin, cf);
./drivers/pcmcia/at91_cf.c:		gpio_free(board->irq_pin);
./drivers/pcmcia/at91_cf.c:	if (board->vcc_pin)
./drivers/pcmcia/at91_cf.c:		gpio_free(board->vcc_pin);
./drivers/pcmcia/at91_cf.c:	gpio_free(board->rst_pin);
./drivers/pcmcia/at91_cf.c:	free_irq(board->det_pin, cf);
./drivers/pcmcia/at91_cf.c:	gpio_free(board->det_pin);
./drivers/pcmcia/at91_cf.c:	if (board->irq_pin) {
./drivers/pcmcia/at91_cf.c:		free_irq(board->irq_pin, cf);
./drivers/pcmcia/at91_cf.c:		gpio_free(board->irq_pin);
./drivers/pcmcia/at91_cf.c:	if (board->vcc_pin)
./drivers/pcmcia/at91_cf.c:		gpio_free(board->vcc_pin);
./drivers/pcmcia/at91_cf.c:	gpio_free(board->rst_pin);
./drivers/pcmcia/at91_cf.c:	free_irq(board->det_pin, cf);
./drivers/pcmcia/at91_cf.c:	gpio_free(board->det_pin);
./drivers/pcmcia/at91_cf.c:		enable_irq_wake(board->det_pin);
./drivers/pcmcia/at91_cf.c:		if (board->irq_pin)
./drivers/pcmcia/at91_cf.c:			enable_irq_wake(board->irq_pin);
./drivers/pcmcia/at91_cf.c:		disable_irq_wake(board->det_pin);
./drivers/pcmcia/at91_cf.c:		if (board->irq_pin)
./drivers/pcmcia/at91_cf.c:			disable_irq_wake(board->irq_pin);
./drivers/pcmcia/electra_cf.c:	prop = of_get_property(np, "card-detect-gpio", NULL);
./drivers/pcmcia/electra_cf.c:	prop = of_get_property(np, "card-vsense-gpio", NULL);
./drivers/pcmcia/electra_cf.c:	prop = of_get_property(np, "card-3v-gpio", NULL);
./drivers/pcmcia/electra_cf.c:	prop = of_get_property(np, "card-5v-gpio", NULL);
./drivers/pcmcia/db1xxx_ss.c: * The Db1000 is used as a reference:  Per-socket card-, carddetect- and
./drivers/pcmcia/db1xxx_ss.c: *	- Au1200-based:	  additional card-eject irqs, irqs not gpios!
./drivers/pcmcia/db1xxx_ss.c:	int	stschg_irq;	/* card-status-change irq */
./drivers/pcmcia/omap_cf.c: * hard-wired timings to support Compact Flash memory cards; they won't work
./drivers/pcmcia/omap_cf.c: * NOTE:  right now the only board-specific platform_data is
./drivers/tty/serial/atmel_serial.c: * Register board-specific modem-control line handlers.
./drivers/tty/serial/pch_uart.c:	port_type = board->port_type;
./drivers/tty/serial/pch_uart.c:	priv->port.line = board->line_no;
./drivers/tty/serial/8250_pnp.c:		(dev->card && check_name(dev->card->name))))
./drivers/tty/serial/lantiq.c:	port->irq	= tx_irq; /* unused, just to be backward-compatibe */
./drivers/tty/serial/8250_pci.c: *  = 0 - use board->num_ports
./drivers/tty/serial/8250_pci.c:	unsigned int bar = 0, offset = board->first_offset;
./drivers/tty/serial/8250_pci.c:	bar = FL_GET_BASE(board->flags);
./drivers/tty/serial/8250_pci.c:		offset += idx * board->uart_offset;
./drivers/tty/serial/8250_pci.c:		offset += ((idx - 2) * board->uart_offset);
./drivers/tty/serial/8250_pci.c:		offset += ((idx - 4) * board->uart_offset);
./drivers/tty/serial/8250_pci.c:		offset += ((idx - 6) * board->uart_offset);
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	unsigned int bar, offset = board->first_offset;
./drivers/tty/serial/8250_pci.c:	bar = FL_GET_BASE(board->flags);
./drivers/tty/serial/8250_pci.c:		offset += (idx - 4) * board->uart_offset;
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	unsigned int offset = board->first_offset;
./drivers/tty/serial/8250_pci.c:	unsigned int bar = FL_GET_BASE(board->flags);
./drivers/tty/serial/8250_pci.c:	offset += idx * board->uart_offset;
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	unsigned int bar, offset = board->first_offset;
./drivers/tty/serial/8250_pci.c:		offset += idx * board->uart_offset;
./drivers/tty/serial/8250_pci.c:		offset += idx * board->uart_offset + 0xC00;
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	unsigned int bar = FL_GET_BASE(board->flags) + idx, offset = 0;
./drivers/tty/serial/8250_pci.c:	unsigned int bar = 0, offset = board->first_offset;
./drivers/tty/serial/8250_pci.c:		offset = board->uart_offset;
./drivers/tty/serial/8250_pci.c:		offset = board->uart_offset;
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	unsigned int bar, offset = board->first_offset;
./drivers/tty/serial/8250_pci.c:		offset = (idx - 2) * board->uart_offset;
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	unsigned int bar, offset = board->first_offset;
./drivers/tty/serial/8250_pci.c:	if (idx >= board->num_ports)
./drivers/tty/serial/8250_pci.c:	bar = FL_GET_BASE(board->flags);
./drivers/tty/serial/8250_pci.c:	offset += idx * board->uart_offset;
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	unsigned int bar, offset = board->first_offset, maxnr;
./drivers/tty/serial/8250_pci.c:	bar = FL_GET_BASE(board->flags);
./drivers/tty/serial/8250_pci.c:	if (board->flags & FL_BASE_BARS)
./drivers/tty/serial/8250_pci.c:		offset += idx * board->uart_offset;
./drivers/tty/serial/8250_pci.c:	maxnr = (pci_resource_len(priv->dev, bar) - board->first_offset) >>
./drivers/tty/serial/8250_pci.c:		(board->reg_shift + 3);
./drivers/tty/serial/8250_pci.c:	if (board->flags & FL_REGION_SZ_CAP && idx >= maxnr)
./drivers/tty/serial/8250_pci.c:	return setup_port(priv, port, bar, offset, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	ret = setup_port(priv, port, 0, 0, board->reg_shift);
./drivers/tty/serial/8250_pci.c:	if (board->flags & FL_NOIRQ)
./drivers/tty/serial/8250_pci.c:	 * Board-specific versions.
./drivers/tty/serial/8250_pci.c:	 * Entries following this are board-specific.
./drivers/tty/serial/8250_pci.c:		board->flags = first_port;
./drivers/tty/serial/8250_pci.c:		board->num_ports = pci_resource_len(dev, first_port) / 8;
./drivers/tty/serial/8250_pci.c:		board->flags = first_port | FL_BASE_BARS;
./drivers/tty/serial/8250_pci.c:		board->num_ports = num_port;
./drivers/tty/serial/8250_pci.c:	    board->num_ports == guessed->num_ports &&
./drivers/tty/serial/8250_pci.c:	    board->base_baud == guessed->base_baud &&
./drivers/tty/serial/8250_pci.c:	    board->uart_offset == guessed->uart_offset &&
./drivers/tty/serial/8250_pci.c:	    board->reg_shift == guessed->reg_shift &&
./drivers/tty/serial/8250_pci.c:	    board->first_offset == guessed->first_offset;
./drivers/tty/serial/8250_pci.c:	nr_ports = board->num_ports;
./drivers/tty/serial/8250_pci.c:	 *   0  - use board->num_ports
./drivers/tty/serial/8250_pci.c:	serial_port.uartclk = board->base_baud * 16;
./drivers/tty/serial/ioc3_serial.c:	port->ip_card->ic_enable &= ~hooks->intr_clear;
./drivers/tty/serial/ioc3_serial.c:	if ((port->ip_card->ic_enable & mask) != mask) {
./drivers/tty/serial/ioc3_serial.c:		port->ip_card->ic_enable |= mask;
./drivers/tty/serial/ioc3_serial.c:	if (port->ip_card->ic_enable & mask) {
./drivers/tty/serial/ioc3_serial.c:		port->ip_card->ic_enable &= ~mask;
./drivers/tty/serial/ioc3_serial.c:	else if (!(port->ip_card->ic_enable & hooks->intr_tx_mt))
./drivers/tty/serial/8250_hp300.c:		/* Enable board-interrupts */
./drivers/tty/serial/8250_hp300.c:	/* Enable board-interrupts */
./drivers/tty/serial/8250_hp300.c:		/* Disable board-interrupts */
./drivers/tty/serial/jsm/jsm_tty.c:	brd->bd_ops->flush_uart_write(channel);
./drivers/tty/serial/jsm/jsm_tty.c:	brd->bd_ops->flush_uart_read(channel);
./drivers/tty/serial/jsm/jsm_tty.c:	brd->bd_ops->uart_init(channel);
./drivers/tty/serial/jsm/jsm_tty.c:	brd->bd_ops->param(channel);
./drivers/tty/serial/jsm/jsm_tty.c:	jsm_printk(INIT, INFO, &brd->pci_dev, "start\n");
./drivers/tty/serial/jsm/jsm_tty.c:	brd->nasync = brd->maxports;
./drivers/tty/serial/jsm/jsm_tty.c:	for (i = 0; i < brd->nasync; i++) {
./drivers/tty/serial/jsm/jsm_tty.c:		if (!brd->channels[i]) {
./drivers/tty/serial/jsm/jsm_tty.c:			brd->channels[i] = kzalloc(sizeof(struct jsm_channel), GFP_KERNEL);
./drivers/tty/serial/jsm/jsm_tty.c:			if (!brd->channels[i]) {
./drivers/tty/serial/jsm/jsm_tty.c:				jsm_printk(CORE, ERR, &brd->pci_dev,
./drivers/tty/serial/jsm/jsm_tty.c:	ch = brd->channels[0];
./drivers/tty/serial/jsm/jsm_tty.c:	vaddr = brd->re_map_membase;
./drivers/tty/serial/jsm/jsm_tty.c:	for (i = 0; i < brd->nasync; i++, ch = brd->channels[i]) {
./drivers/tty/serial/jsm/jsm_tty.c:		if (!brd->channels[i])
./drivers/tty/serial/jsm/jsm_tty.c:		if (brd->bd_uart_offset == 0x200)
./drivers/tty/serial/jsm/jsm_tty.c:			ch->ch_neo_uart =  vaddr + (brd->bd_uart_offset * i);
./drivers/tty/serial/jsm/jsm_tty.c:	jsm_printk(INIT, INFO, &brd->pci_dev, "finish\n");
./drivers/tty/serial/jsm/jsm_tty.c:	jsm_printk(INIT, INFO, &brd->pci_dev, "start\n");
./drivers/tty/serial/jsm/jsm_tty.c:	brd->nasync = brd->maxports;
./drivers/tty/serial/jsm/jsm_tty.c:	for (i = 0; i < brd->nasync; i++, ch = brd->channels[i]) {
./drivers/tty/serial/jsm/jsm_tty.c:		if (!brd->channels[i])
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.irq = brd->irq;
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.uartclk = 14745600;
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.type = PORT_JSM;
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.iotype = UPIO_MEM;
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.membase = brd->re_map_membase;
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.fifosize = 16;
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.ops = &jsm_ops;
./drivers/tty/serial/jsm/jsm_tty.c:		brd->channels[i]->uart_port.line = line;
./drivers/tty/serial/jsm/jsm_tty.c:		rc = uart_add_one_port (&jsm_uart_driver, &brd->channels[i]->uart_port);
./drivers/tty/serial/jsm/jsm_tty.c:	jsm_printk(INIT, INFO, &brd->pci_dev, "finish\n");
./drivers/tty/serial/jsm/jsm_tty.c:	jsm_printk(INIT, INFO, &brd->pci_dev, "start\n");
./drivers/tty/serial/jsm/jsm_tty.c:	brd->nasync = brd->maxports;
./drivers/tty/serial/jsm/jsm_tty.c:	for (i = 0; i < brd->nasync; i++) {
./drivers/tty/serial/jsm/jsm_tty.c:		if (!brd->channels[i])
./drivers/tty/serial/jsm/jsm_tty.c:		ch = brd->channels[i];
./drivers/tty/serial/jsm/jsm_tty.c:		uart_remove_one_port(&jsm_uart_driver, &brd->channels[i]->uart_port);
./drivers/tty/serial/jsm/jsm_tty.c:	jsm_printk(INIT, INFO, &brd->pci_dev, "finish\n");
./drivers/tty/serial/jsm/jsm_driver.c:	brd->boardnum = adapter_count++;
./drivers/tty/serial/jsm/jsm_driver.c:	brd->pci_dev = pdev;
./drivers/tty/serial/jsm/jsm_driver.c:		brd->maxports = 4;
./drivers/tty/serial/jsm/jsm_driver.c:		brd->maxports = 8;
./drivers/tty/serial/jsm/jsm_driver.c:		brd->maxports = 2;
./drivers/tty/serial/jsm/jsm_driver.c:	spin_lock_init(&brd->bd_intr_lock);
./drivers/tty/serial/jsm/jsm_driver.c:	brd->rev = pdev->revision;
./drivers/tty/serial/jsm/jsm_driver.c:	brd->irq = pdev->irq;
./drivers/tty/serial/jsm/jsm_driver.c:	jsm_printk(INIT, INFO, &brd->pci_dev,
./drivers/tty/serial/jsm/jsm_driver.c:	brd->membase	= pci_resource_start(pdev, 0);
./drivers/tty/serial/jsm/jsm_driver.c:	brd->membase_end = pci_resource_end(pdev, 0);
./drivers/tty/serial/jsm/jsm_driver.c:	if (brd->membase & 1)
./drivers/tty/serial/jsm/jsm_driver.c:		brd->membase &= ~3;
./drivers/tty/serial/jsm/jsm_driver.c:		brd->membase &= ~15;
./drivers/tty/serial/jsm/jsm_driver.c:	brd->bd_ops = &jsm_neo_ops;
./drivers/tty/serial/jsm/jsm_driver.c:	brd->bd_uart_offset = 0x200;
./drivers/tty/serial/jsm/jsm_driver.c:	brd->bd_dividend = 921600;
./drivers/tty/serial/jsm/jsm_driver.c:	brd->re_map_membase = ioremap(brd->membase, pci_resource_len(pdev, 0));
./drivers/tty/serial/jsm/jsm_driver.c:	if (!brd->re_map_membase) {
./drivers/tty/serial/jsm/jsm_driver.c:	rc = request_irq(brd->irq, brd->bd_ops->intr,
./drivers/tty/serial/jsm/jsm_driver.c:		printk(KERN_WARNING "Failed to hook IRQ %d\n",brd->irq);
./drivers/tty/serial/jsm/jsm_driver.c:			adapter_count, brd->rev, brd->irq);
./drivers/tty/serial/jsm/jsm_driver.c:	brd->flipbuf = kzalloc(MYFLIPLEN, GFP_KERNEL);
./drivers/tty/serial/jsm/jsm_driver.c:	if (!brd->flipbuf) {
./drivers/tty/serial/jsm/jsm_driver.c:	free_irq(brd->irq, brd);
./drivers/tty/serial/jsm/jsm_driver.c:	iounmap(brd->re_map_membase);
./drivers/tty/serial/jsm/jsm_driver.c:	free_irq(brd->irq, brd);
./drivers/tty/serial/jsm/jsm_driver.c:	iounmap(brd->re_map_membase);
./drivers/tty/serial/jsm/jsm_driver.c:	for (i = 0; i < brd->maxports; i++) {
./drivers/tty/serial/jsm/jsm_driver.c:		if (brd->channels[i]) {
./drivers/tty/serial/jsm/jsm_driver.c:			kfree(brd->channels[i]->ch_rqueue);
./drivers/tty/serial/jsm/jsm_driver.c:			kfree(brd->channels[i]->ch_equeue);
./drivers/tty/serial/jsm/jsm_driver.c:			kfree(brd->channels[i]);
./drivers/tty/serial/jsm/jsm_driver.c:	kfree(brd->flipbuf);
./drivers/tty/serial/jsm/jsm_neo.c:	if (port > brd->maxports)
./drivers/tty/serial/jsm/jsm_neo.c:	ch = brd->channels[port];
./drivers/tty/serial/jsm/jsm_neo.c:				if (brd->channels[port]->ch_flags & CH_STOP) {
./drivers/tty/serial/jsm/jsm_neo.c:				if (!(brd->channels[port]->ch_flags & CH_STOP)) {
./drivers/tty/serial/jsm/jsm_neo.c:	if (port > brd->maxports)
./drivers/tty/serial/jsm/jsm_neo.c:	ch = brd->channels[port];
./drivers/tty/serial/jsm/jsm_neo.c:	spin_lock_irqsave(&brd->bd_intr_lock, lock_flags);
./drivers/tty/serial/jsm/jsm_neo.c:	uart_poll = readl(brd->re_map_membase + UART_17158_POLL_ADDR_OFFSET);
./drivers/tty/serial/jsm/jsm_neo.c:	jsm_printk(INTR, INFO, &brd->pci_dev,
./drivers/tty/serial/jsm/jsm_neo.c:		jsm_printk(INTR, INFO, &brd->pci_dev,
./drivers/tty/serial/jsm/jsm_neo.c:		spin_unlock_irqrestore(&brd->bd_intr_lock, lock_flags);
./drivers/tty/serial/jsm/jsm_neo.c:		jsm_printk(INTR, INFO, &brd->pci_dev,
./drivers/tty/serial/jsm/jsm_neo.c:			jsm_printk(INTR, ERR, &brd->pci_dev,
./drivers/tty/serial/jsm/jsm_neo.c:			if (port > brd->nasync)
./drivers/tty/serial/jsm/jsm_neo.c:			ch = brd->channels[port];
./drivers/tty/serial/jsm/jsm_neo.c:			jsm_printk(INTR, ERR, &brd->pci_dev,
./drivers/tty/serial/jsm/jsm_neo.c:	spin_unlock_irqrestore(&brd->bd_intr_lock, lock_flags);
./drivers/tty/serial/jsm/jsm_neo.c:	jsm_printk(INTR, INFO, &brd->pci_dev, "finish.\n");
./drivers/tty/moxa.c:	switch (brd->boardType) {
./drivers/tty/moxa.c:	void __iomem *baseAddr = brd->basemem;
./drivers/tty/moxa.c:	switch (brd->boardType) {
./drivers/tty/moxa.c:	void __iomem *baseAddr = brd->basemem;
./drivers/tty/moxa.c:	void __iomem *baseAddr = brd->basemem;
./drivers/tty/moxa.c:	keycode = (brd->boardType == MOXA_BOARD_CP204J) ? CP204J_KeyCode :
./drivers/tty/moxa.c:	switch (brd->boardType) {
./drivers/tty/moxa.c:		if (brd->busType == MOXA_BUS_TYPE_PCI) {	/* ASIC board */
./drivers/tty/moxa.c:		brd->numPorts = j * 8;
./drivers/tty/moxa.c:	brd->intNdx = baseAddr + IRQindex;
./drivers/tty/moxa.c:	brd->intPend = baseAddr + IRQpending;
./drivers/tty/moxa.c:	brd->intTable = baseAddr + IRQtable;
./drivers/tty/moxa.c:	void __iomem *ofsAddr, *baseAddr = brd->basemem;
./drivers/tty/moxa.c:	switch (brd->boardType) {
./drivers/tty/moxa.c:		port = brd->ports;
./drivers/tty/moxa.c:		for (i = 0; i < brd->numPorts; i++, port++) {
./drivers/tty/moxa.c:		port = brd->ports;
./drivers/tty/moxa.c:		for (i = 0; i < brd->numPorts; i++, port++) {
./drivers/tty/moxa.c:			switch (brd->numPorts) {
./drivers/tty/moxa.c:	brd->ports = kcalloc(MAX_PORTS_PER_BOARD, sizeof(*brd->ports),
./drivers/tty/moxa.c:	if (brd->ports == NULL) {
./drivers/tty/moxa.c:	for (i = 0, p = brd->ports; i < MAX_PORTS_PER_BOARD; i++, p++) {
./drivers/tty/moxa.c:	switch (brd->boardType) {
./drivers/tty/moxa.c:	brd->ready = 1;
./drivers/tty/moxa.c:	kfree(brd->ports);
./drivers/tty/moxa.c:	brd->ready = 0;
./drivers/tty/moxa.c:	for (a = 0; a < brd->numPorts; a++)
./drivers/tty/moxa.c:		if (brd->ports[a].port.flags & ASYNC_INITIALIZED) {
./drivers/tty/moxa.c:						&brd->ports[a].port);
./drivers/tty/moxa.c:		for (a = 0; a < brd->numPorts; a++)
./drivers/tty/moxa.c:			if (brd->ports[a].port.flags & ASYNC_INITIALIZED)
./drivers/tty/moxa.c:	iounmap(brd->basemem);
./drivers/tty/moxa.c:	brd->basemem = NULL;
./drivers/tty/moxa.c:	kfree(brd->ports);
./drivers/tty/moxa.c:	board->basemem = ioremap_nocache(pci_resource_start(pdev, 2), 0x4000);
./drivers/tty/moxa.c:	if (board->basemem == NULL) {
./drivers/tty/moxa.c:	board->boardType = board_type;
./drivers/tty/moxa.c:		board->numPorts = 8;
./drivers/tty/moxa.c:		board->numPorts = 4;
./drivers/tty/moxa.c:		board->numPorts = 0;
./drivers/tty/moxa.c:	board->busType = MOXA_BUS_TYPE_PCI;
./drivers/tty/moxa.c:			moxa_brdname[board_type - 1], board->numPorts);
./drivers/tty/moxa.c:	iounmap(board->basemem);
./drivers/tty/moxa.c:	board->basemem = NULL;
./drivers/tty/moxa.c:			brd->boardType = type[i];
./drivers/tty/moxa.c:			brd->numPorts = type[i] == MOXA_BOARD_C218_ISA ? 8 :
./drivers/tty/moxa.c:			brd->busType = MOXA_BUS_TYPE_ISA;
./drivers/tty/moxa.c:			brd->basemem = ioremap_nocache(baseaddr[i], 0x4000);
./drivers/tty/moxa.c:			if (!brd->basemem) {
./drivers/tty/moxa.c:				iounmap(brd->basemem);
./drivers/tty/moxa.c:				brd->basemem = NULL;
./drivers/tty/moxa.c:					baseaddr[i], brd->numPorts);
./drivers/tty/moxa.c:	if (!brd->ready) {
./drivers/tty/moxa.c:	if (port % MAX_PORTS_PER_BOARD >= brd->numPorts) {
./drivers/tty/moxa.c:	ch = &brd->ports[port % MAX_PORTS_PER_BOARD];
./drivers/tty/moxa.c:		if (!brd->ready)
./drivers/tty/moxa.c:		if (readb(brd->intPend) == 0xff)
./drivers/tty/moxa.c:			ip = brd->intTable + readb(brd->intNdx);
./drivers/tty/moxa.c:		for (port = 0; port < brd->numPorts; port++)
./drivers/tty/moxa.c:			moxa_poll_port(&brd->ports[port], !!ip, ip + port);
./drivers/tty/moxa.c:			writeb(0, brd->intPend); /* ACK */
./drivers/tty/moxa.c:			struct moxa_port *p = brd->ports;
./drivers/tty/moxa.c:			for (port = 0; port < brd->numPorts; port++, p++)
./drivers/tty/moxa.c:	baseAddr = port->board->basemem;
./drivers/tty/moxa.c:	baseAddr = port->board->basemem;
./drivers/tty/mxser.c:			if (info->board->chip_flag == Gpci_uart_info[i].type) {
./drivers/tty/mxser.c:		if (info->board->chip_flag) {
./drivers/tty/mxser.c:		if (info->board->chip_flag) {
./drivers/tty/mxser.c:		if ((info->type == PORT_16550A) || (info->board->chip_flag)) {
./drivers/tty/mxser.c:							!info->board->chip_flag) {
./drivers/tty/mxser.c:							(!info->board->chip_flag)) {
./drivers/tty/mxser.c:	if (info->board->chip_flag) {
./drivers/tty/mxser.c:						(!port->board->chip_flag)) {
./drivers/tty/mxser.c:						!port->board->chip_flag) {
./drivers/tty/mxser.c:	if (info->board->chip_flag)
./drivers/tty/mxser.c:	if (info->board->chip_flag)
./drivers/tty/mxser.c:	if (info->board->chip_flag)
./drivers/tty/mxser.c:	if (info->board->chip_flag)
./drivers/tty/mxser.c:	if (info->board->chip_flag)
./drivers/tty/mxser.c:				(info->board->chip_flag)) {
./drivers/tty/mxser.c:				info->board->chip_flag) {
./drivers/tty/mxser.c:			 !info->board->chip_flag))
./drivers/tty/mxser.c:		.irq = info->board->irq,
./drivers/tty/mxser.c:	if (new_serial.irq != info->board->irq ||
./drivers/tty/mxser.c:		if (info->board->chip_flag) {
./drivers/tty/mxser.c:			if (info->board->chip_flag) {
./drivers/tty/mxser.c:		if (info->board->chip_flag) {
./drivers/tty/mxser.c:	if (port->board->chip_flag != MOXA_OTHER_UART) {
./drivers/tty/mxser.c:		if (port->board->chip_flag == MOXA_MUST_MU860_HWID &&
./drivers/tty/mxser.c:		if (port->board->chip_flag == MOXA_MUST_MU150_HWID)
./drivers/tty/mxser.c:		if (port->board->chip_flag && (*status & UART_LSR_OE))
./drivers/tty/mxser.c:		if (port->board->chip_flag)
./drivers/tty/mxser.c:			(!port->board->chip_flag))) {
./drivers/tty/mxser.c:	max = brd->info->nports;
./drivers/tty/mxser.c:		irqbits = inb(brd->vector) & brd->vector_mask;
./drivers/tty/mxser.c:		if (irqbits == brd->vector_mask)
./drivers/tty/mxser.c:			if (irqbits == brd->vector_mask)
./drivers/tty/mxser.c:			port = &brd->ports[i];
./drivers/tty/mxser.c:				if (port->board->chip_flag) {
./drivers/tty/mxser.c:				if (port->board->chip_flag) {
./drivers/tty/mxser.c:	free_irq(brd->irq, brd);
./drivers/tty/mxser.c:	release_region(brd->ports[0].ioaddr, 8 * brd->info->nports);
./drivers/tty/mxser.c:	release_region(brd->vector, 1);
./drivers/tty/mxser.c:			brd->ports[0].max_baud);
./drivers/tty/mxser.c:	for (i = 0; i < brd->info->nports; i++) {
./drivers/tty/mxser.c:		info = &brd->ports[i];
./drivers/tty/mxser.c:		if (brd->chip_flag != MOXA_OTHER_UART)
./drivers/tty/mxser.c:		info->type = brd->uart_type;
./drivers/tty/mxser.c:	retval = request_irq(brd->irq, mxser_interrupt, IRQF_SHARED, "mxser",
./drivers/tty/mxser.c:			brd->info->name, brd->irq);
./drivers/tty/mxser.c:	brd->chip_flag = MOXA_OTHER_UART;
./drivers/tty/mxser.c:		brd->info = &mxser_cards[0];
./drivers/tty/mxser.c:		brd->info = &mxser_cards[1];
./drivers/tty/mxser.c:		brd->info = &mxser_cards[2];
./drivers/tty/mxser.c:		brd->info = &mxser_cards[5];
./drivers/tty/mxser.c:		brd->info = &mxser_cards[6];
./drivers/tty/mxser.c:		brd->info = &mxser_cards[7];
./drivers/tty/mxser.c:	if (brd->info->nports == 2 || (brd->info->flags & MXSER_HAS2)) {
./drivers/tty/mxser.c:	} else if (brd->info->nports == 4) {
./drivers/tty/mxser.c:	} else if (brd->info->nports == 8) {
./drivers/tty/mxser.c:	brd->irq = ((int)(irq & 0xF000) >> 12);
./drivers/tty/mxser.c:		brd->ports[i].ioaddr = (int) regs[i + 1] & 0xFFF8;
./drivers/tty/mxser.c:	brd->vector = (int)regs[11];	/* interrupt vector */
./drivers/tty/mxser.c:		brd->vector_mask = 0x00FF;
./drivers/tty/mxser.c:		brd->vector_mask = 0x000F;
./drivers/tty/mxser.c:			brd->ports[i].baud_base = 921600;
./drivers/tty/mxser.c:			brd->ports[i].max_baud = 921600;
./drivers/tty/mxser.c:			brd->ports[i].baud_base = 115200;
./drivers/tty/mxser.c:			brd->ports[i].max_baud = 115200;
./drivers/tty/mxser.c:		brd->uart_type = PORT_16550A;
./drivers/tty/mxser.c:		brd->uart_type = PORT_16450;
./drivers/tty/mxser.c:	if (!request_region(brd->ports[0].ioaddr, 8 * brd->info->nports,
./drivers/tty/mxser.c:				brd->ports[0].ioaddr, brd->ports[0].ioaddr +
./drivers/tty/mxser.c:				8 * brd->info->nports - 1);
./drivers/tty/mxser.c:	if (!request_region(brd->vector, 1, "mxser(vector)")) {
./drivers/tty/mxser.c:		release_region(brd->ports[0].ioaddr, 8 * brd->info->nports);
./drivers/tty/mxser.c:				brd->ports[0].ioaddr, brd->ports[0].ioaddr +
./drivers/tty/mxser.c:				8 * brd->info->nports - 1);
./drivers/tty/mxser.c:	return brd->info->nports;
./drivers/tty/mxser.c:	brd->idx = i * MXSER_PORTS_PER_BOARD;
./drivers/tty/mxser.c:	brd->info = &mxser_cards[ent->driver_data];
./drivers/tty/mxser.c:	for (i = 0; i < brd->info->nports; i++)
./drivers/tty/mxser.c:		brd->ports[i].ioaddr = ioaddress + 8 * i;
./drivers/tty/mxser.c:	brd->vector = ioaddress;
./drivers/tty/mxser.c:	brd->irq = pdev->irq;
./drivers/tty/mxser.c:	brd->chip_flag = CheckIsMoxaMust(brd->ports[0].ioaddr);
./drivers/tty/mxser.c:	brd->uart_type = PORT_16550A;
./drivers/tty/mxser.c:	brd->vector_mask = 0;
./drivers/tty/mxser.c:	for (i = 0; i < brd->info->nports; i++) {
./drivers/tty/mxser.c:			if (Gpci_uart_info[j].type == brd->chip_flag) {
./drivers/tty/mxser.c:				brd->ports[i].max_baud =
./drivers/tty/mxser.c:				if (brd->info->flags & MXSER_HIGHBAUD)
./drivers/tty/mxser.c:					brd->ports[i].max_baud = 921600;
./drivers/tty/mxser.c:	if (brd->chip_flag == MOXA_MUST_MU860_HWID) {
./drivers/tty/mxser.c:		for (i = 0; i < brd->info->nports; i++) {
./drivers/tty/mxser.c:				brd->ports[i].opmode_ioaddr = ioaddress + 4;
./drivers/tty/mxser.c:				brd->ports[i].opmode_ioaddr = ioaddress + 0x0c;
./drivers/tty/mxser.c:	for (i = 0; i < brd->info->nports; i++) {
./drivers/tty/mxser.c:		brd->vector_mask |= (1 << i);
./drivers/tty/mxser.c:		brd->ports[i].baud_base = 921600;
./drivers/tty/mxser.c:	for (i = 0; i < brd->info->nports; i++)
./drivers/tty/mxser.c:		tty_register_device(mxvar_sdriver, brd->idx + i, &pdev->dev);
./drivers/tty/mxser.c:	brd->info = NULL;
./drivers/tty/mxser.c:	for (i = 0; i < brd->info->nports; i++)
./drivers/tty/mxser.c:		tty_unregister_device(mxvar_sdriver, brd->idx + i);
./drivers/tty/mxser.c:	brd->info = NULL;
./drivers/tty/mxser.c:			brd->info = NULL;
./drivers/tty/mxser.c:				brd->info->name, ioaddr[b]);
./drivers/tty/mxser.c:			brd->info = NULL;
./drivers/tty/mxser.c:		brd->idx = m * MXSER_PORTS_PER_BOARD;
./drivers/tty/mxser.c:		for (i = 0; i < brd->info->nports; i++)
./drivers/tty/mxser.c:			tty_register_device(mxvar_sdriver, brd->idx + i, NULL);
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:		spin_lock_irqsave(&card->card_lock, card->flags);
./drivers/tty/isicom.c:		spin_unlock_irqrestore(&card->card_lock, card->flags);
./drivers/tty/isicom.c:	pr_warning("Failed to lock Card (0x%lx)\n", card->base);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&card->card_lock, card->flags);
./drivers/tty/isicom.c:/* card->lock HAS to be held */
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./drivers/tty/isicom.c:/* card->lock HAS to be held */
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./drivers/tty/isicom.c:/* card->lock HAS to be held */
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./drivers/tty/isicom.c:/* card->lock HAS to be held */
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./drivers/tty/isicom.c:/* card->lock MUST NOT be held */
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:		outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./drivers/tty/isicom.c:		outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./drivers/tty/isicom.c:/* card->lock HAS to be held */
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
./drivers/tty/isicom.c:	if (!card || !(card->status & FIRMWARE_LOADED))
./drivers/tty/isicom.c:	base = card->base;
./drivers/tty/isicom.c:	spin_lock(&card->card_lock);
./drivers/tty/isicom.c:	channel = (header & 0x7800) >> card->shift_count;
./drivers/tty/isicom.c:	if (channel + 1 > card->port_count) {
./drivers/tty/isicom.c:		spin_unlock(&card->card_lock);
./drivers/tty/isicom.c:	port = card->ports + channel;
./drivers/tty/isicom.c:		spin_unlock(&card->card_lock);
./drivers/tty/isicom.c:		spin_unlock(&card->card_lock);
./drivers/tty/isicom.c:	spin_unlock(&card->card_lock);
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:		shift_count = card->shift_count;
./drivers/tty/isicom.c:		card->port_status |= (1 << channel);
./drivers/tty/isicom.c:		outw(card->port_status, base + 0x02);
./drivers/tty/isicom.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/isicom.c:	if (WaitTillCardIsFree(card->base) == 0) {
./drivers/tty/isicom.c:		outw(0x8000 | (port->channel << card->shift_count) | 0x02,
./drivers/tty/isicom.c:				card->base);
./drivers/tty/isicom.c:		outw(((ISICOM_KILLTX | ISICOM_KILLRX) << 8) | 0x06, card->base);
./drivers/tty/isicom.c:		InterruptTheCard(card->base);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/isicom.c:	if (!(card->status & FIRMWARE_LOADED))
./drivers/tty/isicom.c:	if (line > ((board * 16) + card->port_count - 1))
./drivers/tty/isicom.c:/* card->lock HAS to be held */
./drivers/tty/isicom.c:	if (--card->count < 0) {
./drivers/tty/isicom.c:			 __func__, card->base, card->count);
./drivers/tty/isicom.c:		card->count = 0;
./drivers/tty/isicom.c:	if (!card->count)
./drivers/tty/isicom.c:		card->status &= BOARD_ACTIVE;
./drivers/tty/isicom.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/isicom.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/isicom.c:	card->port_status &= ~(1 << ip->channel);
./drivers/tty/isicom.c:	outw(card->port_status, card->base + 0x02);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/isicom.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/isicom.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/isicom.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/isicom.c:	unsigned long base = card->base;
./drivers/tty/isicom.c:	outw(0x8000 | ((port->channel) << (card->shift_count)) | 0x3, base);
./drivers/tty/isicom.c:	spin_lock_irqsave(&port->card->card_lock, flags);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&port->card->card_lock, flags);
./drivers/tty/isicom.c:		spin_lock_irqsave(&port->card->card_lock, flags);
./drivers/tty/isicom.c:		spin_unlock_irqrestore(&port->card->card_lock, flags);
./drivers/tty/isicom.c:	out_info.port = port->card->base;
./drivers/tty/isicom.c:	out_info.irq = port->card->irq;
./drivers/tty/isicom.c:	spin_lock_irqsave(&port->card->card_lock, flags);
./drivers/tty/isicom.c:	spin_unlock_irqrestore(&port->card->card_lock, flags);
./drivers/tty/isicom.c:	card->port_status &= ~(1 << port->channel);
./drivers/tty/isicom.c:	outw(card->port_status, card->base + 0x02);
./drivers/tty/isicom.c:	card->port_status |= (1 << port->channel);
./drivers/tty/isicom.c:	outw(card->port_status, card->base + 0x02);
./drivers/tty/isicom.c:	unsigned long base = board->base;
./drivers/tty/isicom.c:		board->port_count = (portcount == 4) ? 4 : 8;
./drivers/tty/isicom.c:		board->shift_count = 12;
./drivers/tty/isicom.c:		board->port_count = 16;
./drivers/tty/isicom.c:		board->shift_count = 11;
./drivers/tty/isicom.c:	unsigned long base = board->base;
./drivers/tty/isicom.c:	board->status |= FIRMWARE_LOADED;
./drivers/tty/isicom.c:	board->index = index;
./drivers/tty/isicom.c:	board->base = pci_resource_start(pdev, 3);
./drivers/tty/isicom.c:	board->irq = pdev->irq;
./drivers/tty/isicom.c:			"will be disabled.\n", board->base, board->base + 15,
./drivers/tty/isicom.c:	retval = request_irq(board->irq, isicom_interrupt,
./drivers/tty/isicom.c:			"Card%d will be disabled.\n", board->irq, index + 1);
./drivers/tty/isicom.c:	for (index = 0; index < board->port_count; index++)
./drivers/tty/isicom.c:		tty_register_device(isicom_normal, board->index * 16 + index,
./drivers/tty/isicom.c:	free_irq(board->irq, board);
./drivers/tty/isicom.c:	board->base = 0;
./drivers/tty/isicom.c:	for (i = 0; i < board->port_count; i++)
./drivers/tty/isicom.c:		tty_unregister_device(isicom_normal, board->index * 16 + i);
./drivers/tty/isicom.c:	free_irq(board->irq, board);
./drivers/tty/isicom.c:	board->base = 0;
./drivers/tty/vt/selection.c:		case TIOCL_SELWORD:	/* word-by-word selection */
./drivers/tty/cyclades.c:	cy_writeb(port->u.cyy.base_addr + (reg << card->bus_index), val);
./drivers/tty/cyclades.c:	return readb(port->u.cyy.base_addr + (reg << card->bus_index));
./drivers/tty/cyclades.c:	return card->num_chips == (unsigned int)-1;
./drivers/tty/cyclades.c:	return __cyz_fpga_loaded(card->ctl_addr.p9060);
./drivers/tty/cyclades.c:	struct FIRM_ID __iomem *fw_id = card->base_addr + ID_ADDRESS;
./drivers/tty/cyclades.c:	return (card->hw_ver == ZO_V1 || cyz_fpga_loaded(card)) &&
./drivers/tty/cyclades.c:			port->card->bus_index);
./drivers/tty/cyclades.c:	int channel = info->line - card->first_line;
./drivers/tty/cyclades.c:	__u32 channel = info->line - card->first_line;
./drivers/tty/cyclades.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	channel = info->line - card->first_line;
./drivers/tty/cyclades.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:			"base_addr %p\n", card, channel, card->base_addr);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	int channel = info->line - card->first_line;
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		int channel = info->line - card->first_line;
./drivers/tty/cyclades.c:			"base_addr %p\n", card, channel, card->base_addr);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	channel = info->line - card->first_line;
./drivers/tty/cyclades.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	channel = info->line - card->first_line;
./drivers/tty/cyclades.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:			spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:			spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:			spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:			spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_lock_irqsave(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_lock_irqsave(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	channel = info->line - card->first_line;
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		int channel = info->line - card->first_line;
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		int retval, channel = info->line - card->first_line;
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:					spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:					spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:					spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:					spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:				info->line - card->first_line,
./drivers/tty/cyclades.c:				info->line - card->first_line,
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_lock_irqsave(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_lock_irqsave(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:		spin_unlock_irqrestore(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_lock_irqsave(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	spin_unlock_irqrestore(&info->card->card_lock, flags);
./drivers/tty/cyclades.c:	channel = info->line - card->first_line;
./drivers/tty/cyclades.c:			spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:			spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:			spin_lock_irqsave(&card->card_lock, flags);
./drivers/tty/cyclades.c:			spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/tty/cyclades.c:		if (card->base_addr) {
./drivers/tty/cyclades.c:			cy_writeb(card->base_addr + Cy_ClrIntr, 0);
./drivers/tty/cyclades.c:			iounmap(card->base_addr);
./drivers/tty/cyclades.c:			if (card->ctl_addr.p9050)
./drivers/tty/cyclades.c:				iounmap(card->ctl_addr.p9050);
./drivers/tty/cyclades.c:			if (card->irq
./drivers/tty/cyclades.c:				free_irq(card->irq, card);
./drivers/tty/cyclades.c:			for (e1 = card->first_line; e1 < card->first_line +
./drivers/tty/cyclades.c:					card->nports; e1++)
./drivers/tty/cyclades.c:			kfree(card->ports);
./drivers/crypto/amcc/crypto4xx_core.c:		memcpy((void *) pd_uinfo->dest_va, state_record->save_digest,
./drivers/dma/pl330.c:	 * going to be word-unaligned and more than 200MB,
./drivers/net/sungem.c:		/* We hard-code the PHY address so we can properly bring it out of
./drivers/net/3c515.c:II. Board-specific settings
./drivers/net/3c515.c:	/* The Rx and Tx rings are here to keep them quad-word-aligned. */
./drivers/net/irda/vlsi_ir.c:		printk("skb=%p data=%p hw=%p\n", rd->skb, rd->buf, rd->hw);
./drivers/net/irda/vlsi_ir.c:				seq_printf(seq, " %02x", (unsigned)((unsigned char *)rd->buf)[i]);
./drivers/net/irda/vlsi_ir.c:		seq_printf(seq, "skb=%p data=%p hw=%p\n", rd->skb, rd->buf, rd->hw);
./drivers/net/irda/vlsi_ir.c:		rd->hw = hwmap + i;
./drivers/net/irda/vlsi_ir.c:		rd->buf = kmalloc(len, GFP_KERNEL|GFP_DMA);
./drivers/net/irda/vlsi_ir.c:		if (rd->buf == NULL ||
./drivers/net/irda/vlsi_ir.c:		    !(busaddr = pci_map_single(pdev, rd->buf, len, dir))) {
./drivers/net/irda/vlsi_ir.c:			if (rd->buf) {
./drivers/net/irda/vlsi_ir.c:					   __func__, rd->buf);
./drivers/net/irda/vlsi_ir.c:				kfree(rd->buf);
./drivers/net/irda/vlsi_ir.c:				rd->buf = NULL;
./drivers/net/irda/vlsi_ir.c:				kfree(rd->buf);
./drivers/net/irda/vlsi_ir.c:				rd->buf = NULL;
./drivers/net/irda/vlsi_ir.c:		rd->skb = NULL;
./drivers/net/irda/vlsi_ir.c:		if (rd->skb)
./drivers/net/irda/vlsi_ir.c:			dev_kfree_skb_any(rd->skb);
./drivers/net/irda/vlsi_ir.c:		kfree(rd->buf);
./drivers/net/irda/vlsi_ir.c:		/* rd->buf is a streaming PCI_DMA_FROMDEVICE map. Doing the
./drivers/net/irda/vlsi_ir.c:		le16_to_cpus(rd->buf+len);
./drivers/net/irda/vlsi_ir.c:		if (irda_calc_crc16(INIT_FCS,rd->buf,len+crclen) != GOOD_FCS) {
./drivers/net/irda/vlsi_ir.c:	if (!rd->skb) {
./drivers/net/irda/vlsi_ir.c:	skb = rd->skb;
./drivers/net/irda/vlsi_ir.c:	rd->skb = NULL;
./drivers/net/irda/vlsi_ir.c:	memcpy(skb_put(skb,len), rd->buf, len);
./drivers/net/irda/vlsi_ir.c:		if (!rd->skb) {
./drivers/net/irda/vlsi_ir.c:			rd->skb = dev_alloc_skb(IRLAP_SKB_ALLOCSIZE);
./drivers/net/irda/vlsi_ir.c:			if (rd->skb) {
./drivers/net/irda/vlsi_ir.c:				skb_reserve(rd->skb,1);
./drivers/net/irda/vlsi_ir.c:				rd->skb->protocol = htons(ETH_P_IRDA);
./drivers/net/irda/vlsi_ir.c:			if (rd->skb) {
./drivers/net/irda/vlsi_ir.c:				dev_kfree_skb_any(rd->skb);
./drivers/net/irda/vlsi_ir.c:				rd->skb = NULL;
./drivers/net/irda/vlsi_ir.c:	if (rd->skb) {
./drivers/net/irda/vlsi_ir.c:		len = rd->skb->len;
./drivers/net/irda/vlsi_ir.c:		dev_kfree_skb_any(rd->skb);
./drivers/net/irda/vlsi_ir.c:		rd->skb = NULL;
./drivers/net/irda/vlsi_ir.c:	if (!rd->buf) {
./drivers/net/irda/vlsi_ir.c:	if (rd->skb) {
./drivers/net/irda/vlsi_ir.c:		len = async_wrap_skb(skb, rd->buf, r->len);
./drivers/net/irda/vlsi_ir.c:			skb_copy_from_linear_data(skb, rd->buf, len);
./drivers/net/irda/vlsi_ir.c:	rd->skb = skb;			/* remember skb for tx-complete stats */
./drivers/net/irda/vlsi_ir.c:			if (rd->skb) {
./drivers/net/irda/vlsi_ir.c:				dev_kfree_skb_any(rd->skb);
./drivers/net/irda/vlsi_ir.c:				rd->skb = NULL;
./drivers/net/irda/kingsun-sir.c: * "Code Mercenaries Hard- und Software GmbH"
./drivers/net/pci-skeleton.c:II. Board-specific settings
./drivers/net/mac8390.c:	dev->irq = SLOT2IRQ(ndev->board->slot);
./drivers/net/mac8390.c:	dev->base_addr = (ndev->board->slot_addr |
./drivers/net/mac8390.c:			  ((ndev->board->slot & 0xf) << 20));
./drivers/net/mac8390.c:		       dev->name, ndev->board->slot);
./drivers/net/mac8390.c:			       dev->name, ndev->board->slot);
./drivers/net/mac8390.c:				dev->name, ndev->board->slot);
./drivers/net/mac8390.c:			dev->base_addr = (int)(ndev->board->slot_addr +
./drivers/net/mac8390.c:			dev->mem_start = (int)(ndev->board->slot_addr +
./drivers/net/mac8390.c:			dev->base_addr = (int)(ndev->board->slot_addr +
./drivers/net/mac8390.c:			dev->mem_start = (int)(ndev->board->slot_addr +
./drivers/net/mac8390.c:			dev->base_addr = (int)(ndev->board->slot_addr +
./drivers/net/mac8390.c:			dev->mem_start = (int)(ndev->board->slot_addr +
./drivers/net/mac8390.c:			       ndev->board->name);
./drivers/net/mac8390.c:		if (slots & (1 << ndev->board->slot))
./drivers/net/mac8390.c:		slots |= 1 << ndev->board->slot;
./drivers/net/mac8390.c:		       ndev->board->name);
./drivers/net/mac8390.c:		dev->name, ndev->board->name, ndev->board->slot,
./drivers/net/atlx/atl1.c:	while (rfd_ring->next_to_clean != (rrd->buf_indx + offset)) {
./drivers/net/atlx/atl1.c:	num_buf = (rrd->xsz.xsum_sz.pkt_size + adapter->rx_buffer_len - 1) /
./drivers/net/atlx/atl1.c:	if (rrd->num_buf == num_buf)
./drivers/net/atlx/atl1.c:	if (unlikely(rrd->pkt_flg & PACKET_FLAG_ERR)) {
./drivers/net/atlx/atl1.c:		if (rrd->err_flg & (ERR_FLAG_CRC | ERR_FLAG_TRUNC |
./drivers/net/atlx/atl1.c:	if (!(rrd->pkt_flg & PACKET_FLAG_IPV4))
./drivers/net/atlx/atl1.c:	if (likely(!(rrd->err_flg &
./drivers/net/atlx/atl1.c:		if (likely(rrd->xsz.valid)) {	/* packet valid */
./drivers/net/atlx/atl1.c:			if (likely(rrd->num_buf == 1))
./drivers/net/atlx/atl1.c:					rrd->num_buf);
./drivers/net/atlx/atl1.c:					rrd->xsz.xsum_sz.pkt_size);
./drivers/net/atlx/atl1.c:					rrd->pkt_flg);
./drivers/net/atlx/atl1.c:					rrd->err_flg);
./drivers/net/atlx/atl1.c:					rrd->vlan_tag);
./drivers/net/atlx/atl1.c:			if (rrd->num_buf > 1)
./drivers/net/atlx/atl1.c:			rrd->xsz.valid = 0;
./drivers/net/atlx/atl1.c:		buffer_info = &rfd_ring->buffer_info[rrd->buf_indx];
./drivers/net/atlx/atl1.c:		if (unlikely(rrd->pkt_flg & PACKET_FLAG_ERR)) {
./drivers/net/atlx/atl1.c:			if (!(rrd->err_flg &
./drivers/net/atlx/atl1.c:				rrd->xsz.valid = 0;
./drivers/net/atlx/atl1.c:		length = le16_to_cpu(rrd->xsz.xsum_sz.pkt_size);
./drivers/net/atlx/atl1.c:		if (adapter->vlgrp && (rrd->pkt_flg & PACKET_FLAG_VLAN_INS)) {
./drivers/net/atlx/atl1.c:			u16 vlan_tag = (rrd->vlan_tag >> 4) |
./drivers/net/atlx/atl1.c:					((rrd->vlan_tag & 7) << 13) |
./drivers/net/atlx/atl1.c:					((rrd->vlan_tag & 8) << 9);
./drivers/net/atlx/atl1.c:		rrd->xsz.valid = 0;
./drivers/net/3c503.c: *  is word-aligned. Variable 'count' is NOT checked. Caller must check
./drivers/net/sfc/falcon.c:	board->i2c_adap.owner = THIS_MODULE;
./drivers/net/sfc/falcon.c:	board->i2c_data = falcon_i2c_bit_operations;
./drivers/net/sfc/falcon.c:	board->i2c_data.data = efx;
./drivers/net/sfc/falcon.c:	board->i2c_adap.algo_data = &board->i2c_data;
./drivers/net/sfc/falcon.c:	board->i2c_adap.dev.parent = &efx->pci_dev->dev;
./drivers/net/sfc/falcon.c:	strlcpy(board->i2c_adap.name, "SFC4000 GPIO",
./drivers/net/sfc/falcon.c:		sizeof(board->i2c_adap.name));
./drivers/net/sfc/falcon.c:	rc = i2c_bit_add_bus(&board->i2c_adap);
./drivers/net/sfc/falcon.c:	BUG_ON(i2c_del_adapter(&board->i2c_adap));
./drivers/net/sfc/falcon.c:	memset(&board->i2c_adap, 0, sizeof(board->i2c_adap));
./drivers/net/sfc/falcon.c:	board->type->fini(efx);
./drivers/net/sfc/falcon.c:	rc = i2c_del_adapter(&board->i2c_adap);
./drivers/net/sfc/falcon.c:	memset(&board->i2c_adap, 0, sizeof(board->i2c_adap));
./drivers/net/sfc/falcon_boards.c:	struct i2c_client *client = i2c_new_device(&board->i2c_adap, info);
./drivers/net/sfc/falcon_boards.c:	board->hwmon_client = client;
./drivers/net/sfc/falcon_boards.c:	i2c_unregister_device(board->ioexp_client);
./drivers/net/sfc/falcon_boards.c:	i2c_unregister_device(board->hwmon_client);
./drivers/net/sfc/falcon_boards.c:	board->hwmon_client =
./drivers/net/sfc/falcon_boards.c:		i2c_new_device(&board->i2c_adap, &sfe4001_hwmon_info);
./drivers/net/sfc/falcon_boards.c:	board->hwmon_client =
./drivers/net/sfc/falcon_boards.c:		i2c_new_dummy(&board->i2c_adap, sfe4001_hwmon_info.addr);
./drivers/net/sfc/falcon_boards.c:	if (!board->hwmon_client)
./drivers/net/sfc/falcon_boards.c:	rc = i2c_smbus_write_byte_data(board->hwmon_client,
./drivers/net/sfc/falcon_boards.c:	board->ioexp_client = i2c_new_dummy(&board->i2c_adap, PCA9539);
./drivers/net/sfc/falcon_boards.c:	if (!board->ioexp_client) {
./drivers/net/sfc/falcon_boards.c:	i2c_unregister_device(board->ioexp_client);
./drivers/net/sfc/falcon_boards.c:	i2c_unregister_device(board->hwmon_client);
./drivers/net/sfc/falcon_boards.c:		(board->major == 0 && board->minor == 0) ?
./drivers/net/sfc/falcon_boards.c:/* Board-specific LED info. */
./drivers/net/sfc/falcon_boards.c:	if (board->minor < 3 && board->major == 0)
./drivers/net/sfc/falcon_boards.c:	if (board->minor < 3 && board->major == 0)
./drivers/net/sfc/falcon_boards.c:		(board->major == 0 && board->minor <= 2) ?
./drivers/net/sfc/falcon_boards.c:	board->major = FALCON_BOARD_MAJOR(revision_info);
./drivers/net/sfc/falcon_boards.c:	board->minor = FALCON_BOARD_MINOR(revision_info);
./drivers/net/sfc/falcon_boards.c:			board->type = &board_types[i];
./drivers/net/sfc/falcon_boards.c:	if (board->type) {
./drivers/net/sfc/falcon_boards.c:			 ? board->type->ref_model : board->type->gen_type,
./drivers/net/sfc/falcon_boards.c:			 'A' + board->major, board->minor);
./drivers/net/sfc/qt202x_phy.c:	if (board->major == 0 && board->minor < 2) {
./drivers/net/hplance.c: * plus board-specific init, open and close actions.
./drivers/net/appletalk/ipddp.c:		 * This is due to a hard-header problem. This is the
./drivers/net/atp.c:/* Read the station address PROM, usually a word-wide EEPROM. */
./drivers/net/epic100.c:II. Board-specific settings
./drivers/net/a2065.c:	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
./drivers/net/a2065.c:			int len = (rd->mblength & 0xfff) - 4;
./drivers/net/a2065.c:				rd->mblength = 0;
./drivers/net/a2065.c:				rd->rmd1_bits = LE_R1_OWN;
./drivers/net/a2065.c:		rd->mblength = 0;
./drivers/net/a2065.c:		rd->rmd1_bits = LE_R1_OWN;
./drivers/net/tulip/winbond-840.c:II. Board-specific settings
./drivers/net/tulip/xircom_cb.c:	pci_free_consistent(pdev,8192,card->rx_buffer,card->rx_dma_handle);
./drivers/net/tulip/xircom_cb.c:	pci_free_consistent(pdev,8192,card->tx_buffer,card->tx_dma_handle);
./drivers/net/tulip/xircom_cb.c:	spin_lock(&card->lock);
./drivers/net/tulip/xircom_cb.c:	status = inl(card->io_port+CSR5);
./drivers/net/tulip/xircom_cb.c:		 card->tx_buffer[0], card->tx_buffer[4]);
./drivers/net/tulip/xircom_cb.c:		 card->rx_buffer[0], card->rx_buffer[4]);
./drivers/net/tulip/xircom_cb.c:		spin_unlock(&card->lock);
./drivers/net/tulip/xircom_cb.c:	outl(status,card->io_port+CSR5);
./drivers/net/tulip/xircom_cb.c:	spin_unlock(&card->lock);
./drivers/net/tulip/xircom_cb.c:	spin_lock_irqsave(&card->lock,flags);
./drivers/net/tulip/xircom_cb.c:	nextdescriptor = (card->transmit_used +1) % (NUMDESCRIPTORS);
./drivers/net/tulip/xircom_cb.c:	desc = card->transmit_used;
./drivers/net/tulip/xircom_cb.c:	if (card->tx_buffer[4*desc]==0) {
./drivers/net/tulip/xircom_cb.c:			memset(&card->tx_buffer[bufferoffsets[desc]/4],0,1536);
./drivers/net/tulip/xircom_cb.c:				  &(card->tx_buffer[bufferoffsets[desc] / 4]),
./drivers/net/tulip/xircom_cb.c:			card->tx_buffer[4*desc+1] = cpu_to_le32(skb->len);
./drivers/net/tulip/xircom_cb.c:				card->tx_buffer[4*desc+1] |= cpu_to_le32(1<<25);  
./drivers/net/tulip/xircom_cb.c:			card->tx_buffer[4*desc+1] |= cpu_to_le32(0xF0000000);
./drivers/net/tulip/xircom_cb.c:			card->tx_skb[desc] = skb;
./drivers/net/tulip/xircom_cb.c:			card->tx_buffer[4*desc] = cpu_to_le32(0x80000000);
./drivers/net/tulip/xircom_cb.c:			if (card->tx_buffer[nextdescriptor*4] & cpu_to_le32(0x8000000)) {
./drivers/net/tulip/xircom_cb.c:			card->transmit_used = nextdescriptor;
./drivers/net/tulip/xircom_cb.c:			spin_unlock_irqrestore(&card->lock,flags);
./drivers/net/tulip/xircom_cb.c:	spin_unlock_irqrestore(&card->lock,flags);
./drivers/net/tulip/xircom_cb.c:	spin_lock_irqsave(&card->lock,flags);
./drivers/net/tulip/xircom_cb.c:	spin_unlock_irqrestore(&card->lock,flags);
./drivers/net/tulip/xircom_cb.c:	card->open = 0;
./drivers/net/tulip/xircom_cb.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR0);
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR0);
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR0);
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR0);
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR0);
./drivers/net/tulip/xircom_cb.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR1);
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR2);
./drivers/net/tulip/xircom_cb.c:	BUG_ON(card->rx_buffer == NULL);
./drivers/net/tulip/xircom_cb.c:	BUG_ON(card->tx_buffer == NULL);
./drivers/net/tulip/xircom_cb.c:	memset(card->rx_buffer, 0, 128);	/* clear the descriptors */
./drivers/net/tulip/xircom_cb.c:		card->rx_buffer[i*4 + 0] = cpu_to_le32(0x80000000);
./drivers/net/tulip/xircom_cb.c:		card->rx_buffer[i*4 + 1] = cpu_to_le32(1536);
./drivers/net/tulip/xircom_cb.c:			card->rx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);
./drivers/net/tulip/xircom_cb.c:		address = card->rx_dma_handle;
./drivers/net/tulip/xircom_cb.c:		card->rx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);
./drivers/net/tulip/xircom_cb.c:		card->rx_buffer[i*4 + 3] = 0;
./drivers/net/tulip/xircom_cb.c:	address = card->rx_dma_handle;
./drivers/net/tulip/xircom_cb.c:	outl(address, card->io_port + CSR3);	/* Receive descr list address */
./drivers/net/tulip/xircom_cb.c:	memset(card->tx_buffer, 0, 128);	/* clear the descriptors */
./drivers/net/tulip/xircom_cb.c:		card->tx_buffer[i*4 + 0] = 0x00000000;
./drivers/net/tulip/xircom_cb.c:		card->tx_buffer[i*4 + 1] = cpu_to_le32(1536);
./drivers/net/tulip/xircom_cb.c:			card->tx_buffer[i*4 + 1] |= cpu_to_le32(1 << 25);
./drivers/net/tulip/xircom_cb.c:		address = card->tx_dma_handle;
./drivers/net/tulip/xircom_cb.c:		card->tx_buffer[i*4 + 2] = cpu_to_le32(address + bufferoffsets[i]);
./drivers/net/tulip/xircom_cb.c:		card->tx_buffer[i*4 + 3] = 0;
./drivers/net/tulip/xircom_cb.c:	address = card->tx_dma_handle;
./drivers/net/tulip/xircom_cb.c:	outl(address, card->io_port + CSR4);	/* xmit descr list address */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR3);	/* Receive descriptor address */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR4);	/* Send descriptor address */
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR5);	/* Status register */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR5);
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR5);	/* Status register */
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR5);	/* Status register */
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR6);	/* Operation mode */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:			netdev_err(card->dev, "Receiver failed to deactivate\n");
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR6);	/* Operation mode */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:			netdev_err(card->dev,
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR6);	/* Operation mode */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:			netdev_err(card->dev, "Receiver failed to deactivate\n");
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR6);	/* Operation mode */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:			netdev_err(card->dev,
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR6);	/* Operation mode */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:			netdev_err(card->dev,
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR6);	/* Operation mode */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:			netdev_err(card->dev,
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR7);
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR7);
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR7);
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR7);
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR7);	/* Interrupt enable register */
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR7);
./drivers/net/tulip/xircom_cb.c:	val = inl(card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:	outl(val, card->io_port + CSR6);
./drivers/net/tulip/xircom_cb.c:	val = inb(card->io_port + CSR12);
./drivers/net/tulip/xircom_cb.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:	outl(1 << 12, card->io_port + CSR9);	/* enable boot rom access */
./drivers/net/tulip/xircom_cb.c:		outl(i, card->io_port + CSR10);
./drivers/net/tulip/xircom_cb.c:		tuple = inl(card->io_port + CSR9) & 0xff;
./drivers/net/tulip/xircom_cb.c:		outl(i + 1, card->io_port + CSR10);
./drivers/net/tulip/xircom_cb.c:		link = inl(card->io_port + CSR9) & 0xff;
./drivers/net/tulip/xircom_cb.c:		outl(i + 2, card->io_port + CSR10);
./drivers/net/tulip/xircom_cb.c:		data_id = inl(card->io_port + CSR9) & 0xff;
./drivers/net/tulip/xircom_cb.c:		outl(i + 3, card->io_port + CSR10);
./drivers/net/tulip/xircom_cb.c:		data_count = inl(card->io_port + CSR9) & 0xff;
./drivers/net/tulip/xircom_cb.c:				outl(i + j + 4, card->io_port + CSR10);
./drivers/net/tulip/xircom_cb.c:				card->dev->dev_addr[j] = inl(card->io_port + CSR9) & 0xff;
./drivers/net/tulip/xircom_cb.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:	pr_debug(" %pM\n", card->dev->dev_addr);
./drivers/net/tulip/xircom_cb.c:	pci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);
./drivers/net/tulip/xircom_cb.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:	outl(0x0008, card->io_port + CSR15);
./drivers/net/tulip/xircom_cb.c:        outl(0xa8050000, card->io_port + CSR15);
./drivers/net/tulip/xircom_cb.c:        outl(0xa00f0000, card->io_port + CSR15);
./drivers/net/tulip/xircom_cb.c:        spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:	netif_start_queue(card->dev);
./drivers/net/tulip/xircom_cb.c:	pci_write_config_dword(card->pdev, PCI_POWERMGMT, 0x0000);
./drivers/net/tulip/xircom_cb.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:		investigate_read_descriptor(card->dev,card,i,bufferoffsets[i]);
./drivers/net/tulip/xircom_cb.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/tulip/xircom_cb.c:	netif_start_queue(card->dev);
./drivers/net/tulip/xircom_cb.c:	status = le32_to_cpu(card->rx_buffer[4*descnr]);
./drivers/net/tulip/xircom_cb.c:					&card->rx_buffer[bufferoffset / 4],
./drivers/net/tulip/xircom_cb.c:		card->rx_buffer[4*descnr] = cpu_to_le32(0x80000000);
./drivers/net/tulip/xircom_cb.c:	status = le32_to_cpu(card->tx_buffer[4*descnr]);
./drivers/net/tulip/xircom_cb.c:		card->tx_buffer[4*descnr] = 0;
./drivers/net/tulip/xircom_cb.c:		if (card->tx_skb[descnr]!=NULL) {
./drivers/net/tulip/xircom_cb.c:			dev->stats.tx_bytes += card->tx_skb[descnr]->len;
./drivers/net/tulip/xircom_cb.c:			dev_kfree_skb_irq(card->tx_skb[descnr]);
./drivers/net/tulip/xircom_cb.c:		card->tx_skb[descnr] = NULL;
./drivers/net/tulip/xircom_cb.c:		card->tx_buffer[4*descnr] = 0; /* descriptor is free again */
./drivers/net/bmac.c:       		st_le32(&rd->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));	/* clear run bit */
./drivers/net/bmac.c:	out_le32(&rd->cmdptr, virt_to_bus(bp->rx_cmds));
./drivers/net/bmac.c:	st_le32(&rd->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE));	/* clear run bit */
./drivers/net/bmac.c:	cp = bus_to_virt(ld_le32(&rd->cmdptr));
./drivers/net/bmac.c:	out_le32(&rd->control, DBDMA_CLEAR(RUN|PAUSE|FLUSH|WAKE|ACTIVE|DEAD));
./drivers/net/bmac.c:	out_le32(&rd->cmdptr, virt_to_bus(cp));
./drivers/net/bmac.c:	out_le32(&rd->control, DBDMA_SET(RUN|WAKE));
./drivers/net/lib82596.c: * must be word-swapped with the most significant word written first.
./drivers/net/niu.c:		} else if (!strcmp(namebuf, "board-model")) {
./drivers/net/can/softing/softing_fw.c: * Make sure that card->dpram[DPRAM_FCT_HOST] is preset
./drivers/net/can/softing/softing_fw.c:	iowrite16(cmd, &card->dpram[DPRAM_FCT_PARAM]);
./drivers/net/can/softing/softing_fw.c:	iowrite8(vector >> 8, &card->dpram[DPRAM_FCT_HOST + 1]);
./drivers/net/can/softing/softing_fw.c:	iowrite8(vector, &card->dpram[DPRAM_FCT_HOST]);
./drivers/net/can/softing/softing_fw.c:		ret = ioread8(&card->dpram[DPRAM_FCT_HOST]) +
./drivers/net/can/softing/softing_fw.c:			(ioread8(&card->dpram[DPRAM_FCT_HOST + 1]) << 8);
./drivers/net/can/softing/softing_fw.c:			return ioread16(&card->dpram[DPRAM_FCT_RESULT]);
./drivers/net/can/softing/softing_fw.c:	dev_alert(&card->pdev->dev, "firmware %s failed (%i)\n", msg, ret);
./drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "%s returned %u\n", msg, ret);
./drivers/net/can/softing/softing_fw.c:	iowrite16(RES_NONE, &card->dpram[DPRAM_RECEIPT]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(cmd, &card->dpram[DPRAM_COMMAND]);
./drivers/net/can/softing/softing_fw.c:		ret = ioread16(&card->dpram[DPRAM_RECEIPT]);
./drivers/net/can/softing/softing_fw.c:	dev_alert(&card->pdev->dev, "bootloader %s failed (%i)\n", msg, ret);
./drivers/net/can/softing/softing_fw.c:	ret = request_firmware(&fw, file, &card->pdev->dev);
./drivers/net/can/softing/softing_fw.c:	dev_dbg(&card->pdev->dev, "%s, firmware(%s) got %u bytes"
./drivers/net/can/softing/softing_fw.c:		card->pdat->name, file, (unsigned int)fw->size,
./drivers/net/can/softing/softing_fw.c:			dev_alert(&card->pdev->dev, "DPRAM readback failed\n");
./drivers/net/can/softing/softing_fw.c:		dev_info(&card->pdev->dev, "firmware %s failed\n", file);
./drivers/net/can/softing/softing_fw.c:	ret = request_firmware(&fw, file, &card->pdev->dev);
./drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "request_firmware(%s) got %i\n",
./drivers/net/can/softing/softing_fw.c:	dev_dbg(&card->pdev->dev, "firmware(%s) got %lu bytes\n",
./drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "firmware starts with type 0x%x\n",
./drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev, "firmware string '%.*s' fault\n",
./drivers/net/can/softing/softing_fw.c:			dev_alert(&card->pdev->dev,
./drivers/net/can/softing/softing_fw.c:		memcpy_toio(&card->dpram[card->pdat->app.offs], dat, len);
./drivers/net/can/softing/softing_fw.c:		iowrite32(card->pdat->app.offs + card->pdat->app.addr,
./drivers/net/can/softing/softing_fw.c:				&card->dpram[DPRAM_COMMAND + 2]);
./drivers/net/can/softing/softing_fw.c:		iowrite32(addr, &card->dpram[DPRAM_COMMAND + 6]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(len, &card->dpram[DPRAM_COMMAND + 10]);
./drivers/net/can/softing/softing_fw.c:		iowrite8(1, &card->dpram[DPRAM_COMMAND + 12]);
./drivers/net/can/softing/softing_fw.c:		rx_sum = ioread16(&card->dpram[DPRAM_RECEIPT + 2]);
./drivers/net/can/softing/softing_fw.c:			dev_alert(&card->pdev->dev, "SRAM seems to be damaged"
./drivers/net/can/softing/softing_fw.c:	iowrite32(start_addr, &card->dpram[DPRAM_COMMAND + 2]);
./drivers/net/can/softing/softing_fw.c:	iowrite8(1, &card->dpram[DPRAM_COMMAND + 6]);
./drivers/net/can/softing/softing_fw.c:		dev_info(&card->pdev->dev, "firmware %s failed\n", file);
./drivers/net/can/softing/softing_fw.c:		iowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO]);
./drivers/net/can/softing/softing_fw.c:		iowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO+1]);
./drivers/net/can/softing/softing_fw.c:		iowrite8(1, &card->dpram[DPRAM_RESET]);
./drivers/net/can/softing/softing_fw.c:		iowrite8(0, &card->dpram[DPRAM_RESET+1]);
./drivers/net/can/softing/softing_fw.c:	card->tx.pending = 0;
./drivers/net/can/softing/softing_fw.c:	card->id.serial = ioread32(&card->dpram[DPRAM_FCT_PARAM]);
./drivers/net/can/softing/softing_fw.c:	card->id.fw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:	card->id.hw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:	card->id.license = ioread16(&card->dpram[DPRAM_FCT_PARAM + 6]);
./drivers/net/can/softing/softing_fw.c:	card->id.chip[0] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 8]);
./drivers/net/can/softing/softing_fw.c:	card->id.chip[1] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 10]);
./drivers/net/can/softing/softing_fw.c:	card->ts_ref = ktime_get();
./drivers/net/can/softing/softing_fw.c:	do_div(ovf, card->pdat->freq ?: 16);
./drivers/net/can/softing/softing_fw.c:	card->ts_overflow = ktime_add_us(ktime_set(0, 0), ovf);
./drivers/net/can/softing/softing_fw.c:	do_div(rawl, card->pdat->freq ?: 16);
./drivers/net/can/softing/softing_fw.c:	target = ktime_add_us(card->ts_ref, rawl);
./drivers/net/can/softing/softing_fw.c:	tmp = ktime_add(target, card->ts_overflow);
./drivers/net/can/softing/softing_fw.c:		card->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);
./drivers/net/can/softing/softing_fw.c:		tmp = ktime_add(target, card->ts_overflow);
./drivers/net/can/softing/softing_fw.c:	if (!card->fw.up)
./drivers/net/can/softing/softing_fw.c:	ret = mutex_lock_interruptible(&card->fw.lock);
./drivers/net/can/softing/softing_fw.c:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_fw.c:		netdev = card->net[j];
./drivers/net/can/softing/softing_fw.c:	card->tx.pending = 0;
./drivers/net/can/softing/softing_fw.c:			&& (softing_error_reporting(card->net[0])
./drivers/net/can/softing/softing_fw.c:				!= softing_error_reporting(card->net[1]))) {
./drivers/net/can/softing/softing_fw.c:		dev_alert(&card->pdev->dev,
./drivers/net/can/softing/softing_fw.c:		netdev = card->net[0];
./drivers/net/can/softing/softing_fw.c:		iowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:				&card->dpram[DPRAM_FCT_PARAM + 6]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);
./drivers/net/can/softing/softing_fw.c:				&card->dpram[DPRAM_FCT_PARAM + 10]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:		netdev = card->net[1];
./drivers/net/can/softing/softing_fw.c:		iowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:				&card->dpram[DPRAM_FCT_PARAM + 6]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);
./drivers/net/can/softing/softing_fw.c:				&card->dpram[DPRAM_FCT_PARAM + 10]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);
./drivers/net/can/softing/softing_fw.c:		iowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 2]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 4]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 6]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 8]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 10]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 12]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 14]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 16]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 18]);
./drivers/net/can/softing/softing_fw.c:	iowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 20]);
./drivers/net/can/softing/softing_fw.c:	iowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE]);
./drivers/net/can/softing/softing_fw.c:	iowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE2]);
./drivers/net/can/softing/softing_fw.c:	if (card->pdat->generation < 2) {
./drivers/net/can/softing/softing_fw.c:		iowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);
./drivers/net/can/softing/softing_fw.c:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_fw.c:		netdev = card->net[j];
./drivers/net/can/softing/softing_fw.c:	mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_fw.c:	mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_fw.c:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_fw.c:		netdev = card->net[j];
./drivers/net/can/softing/softing_fw.c:		return (card->pdat->generation < 2) ? 0xfb : 0xfa;
./drivers/net/can/softing/softing_main.c:	if (card->pdat->generation >= 2) {
./drivers/net/can/softing/softing_main.c:		spin_lock_bh(&card->spin);
./drivers/net/can/softing/softing_main.c:		iowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) & ~1,
./drivers/net/can/softing/softing_main.c:				&card->dpram[DPRAM_V2_RESET]);
./drivers/net/can/softing/softing_main.c:		spin_unlock_bh(&card->spin);
./drivers/net/can/softing/softing_main.c:	if (card->pdat->generation >= 2) {
./drivers/net/can/softing/softing_main.c:		spin_lock_bh(&card->spin);
./drivers/net/can/softing/softing_main.c:		iowrite8(ioread8(&card->dpram[DPRAM_V2_RESET]) | 1,
./drivers/net/can/softing/softing_main.c:				&card->dpram[DPRAM_V2_RESET]);
./drivers/net/can/softing/softing_main.c:		spin_unlock_bh(&card->spin);
./drivers/net/can/softing/softing_main.c:	spin_lock(&card->spin);
./drivers/net/can/softing/softing_main.c:	if (!card->fw.up ||
./drivers/net/can/softing/softing_main.c:			(card->tx.pending >= TXMAX) ||
./drivers/net/can/softing/softing_main.c:	fifo_wr = ioread8(&card->dpram[DPRAM_TX_WR]);
./drivers/net/can/softing/softing_main.c:	fifo_rd = ioread8(&card->dpram[DPRAM_TX_RD]);
./drivers/net/can/softing/softing_main.c:	memcpy_toio(&card->dpram[DPRAM_TX + DPRAM_TX_SIZE * fifo_wr],
./drivers/net/can/softing/softing_main.c:	iowrite8(fifo_wr, &card->dpram[DPRAM_TX_WR]);
./drivers/net/can/softing/softing_main.c:	card->tx.last_bus = priv->index;
./drivers/net/can/softing/softing_main.c:	++card->tx.pending;
./drivers/net/can/softing/softing_main.c:	spin_unlock(&card->spin);
./drivers/net/can/softing/softing_main.c:	if (card->tx.pending >= TXMAX) {
./drivers/net/can/softing/softing_main.c:		for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_main.c:			if (card->net[j])
./drivers/net/can/softing/softing_main.c:				netif_stop_queue(card->net[j]);
./drivers/net/can/softing/softing_main.c:	lost_msg = ioread8(&card->dpram[DPRAM_RX_LOST]);
./drivers/net/can/softing/softing_main.c:		iowrite8(0, &card->dpram[DPRAM_RX_LOST]);
./drivers/net/can/softing/softing_main.c:		for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_main.c:			netdev = card->net[j];
./drivers/net/can/softing/softing_main.c:	fifo_rd = ioread8(&card->dpram[DPRAM_RX_RD]);
./drivers/net/can/softing/softing_main.c:	fifo_wr = ioread8(&card->dpram[DPRAM_RX_WR]);
./drivers/net/can/softing/softing_main.c:	memcpy_fromio(buf, &card->dpram[DPRAM_RX + DPRAM_RX_SIZE*fifo_rd],
./drivers/net/can/softing/softing_main.c:	iowrite8(fifo_rd, &card->dpram[DPRAM_RX_RD]);
./drivers/net/can/softing/softing_main.c:	netdev = card->net[0];
./drivers/net/can/softing/softing_main.c:		netdev = card->net[1];
./drivers/net/can/softing/softing_main.c:		iowrite8(state, &card->dpram[priv->index ?
./drivers/net/can/softing/softing_main.c:			if (card->tx.pending)
./drivers/net/can/softing/softing_main.c:				--card->tx.pending;
./drivers/net/can/softing/softing_main.c:	spin_lock_bh(&card->spin);
./drivers/net/can/softing/softing_main.c:		++card->irq.svc_count;
./drivers/net/can/softing/softing_main.c:	spin_unlock_bh(&card->spin);
./drivers/net/can/softing/softing_main.c:	offset = card->tx.last_bus;
./drivers/net/can/softing/softing_main.c:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_main.c:		if (card->tx.pending >= TXMAX)
./drivers/net/can/softing/softing_main.c:		netdev = card->net[(j + offset + 1) % card->pdat->nbus];
./drivers/net/can/softing/softing_main.c:	ir = ioread8(&card->dpram[DPRAM_V2_IRQ_TOHOST]);
./drivers/net/can/softing/softing_main.c:	iowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);
./drivers/net/can/softing/softing_main.c:	ir = ioread8(&card->dpram[DPRAM_IRQ_TOHOST]);
./drivers/net/can/softing/softing_main.c:	iowrite8(0, &card->dpram[DPRAM_IRQ_TOHOST]);
./drivers/net/can/softing/softing_main.c:	if (!card->irq.nr) {
./drivers/net/can/softing/softing_main.c:	} else if (card->irq.requested && !enable) {
./drivers/net/can/softing/softing_main.c:		free_irq(card->irq.nr, card);
./drivers/net/can/softing/softing_main.c:		card->irq.requested = 0;
./drivers/net/can/softing/softing_main.c:	} else if (!card->irq.requested && enable) {
./drivers/net/can/softing/softing_main.c:		ret = request_threaded_irq(card->irq.nr,
./drivers/net/can/softing/softing_main.c:				(card->pdat->generation >= 2) ?
./drivers/net/can/softing/softing_main.c:				dev_name(&card->pdev->dev), card);
./drivers/net/can/softing/softing_main.c:			dev_alert(&card->pdev->dev,
./drivers/net/can/softing/softing_main.c:					card->irq.nr);
./drivers/net/can/softing/softing_main.c:		card->irq.requested = 1;
./drivers/net/can/softing/softing_main.c:	if (mutex_lock_interruptible(&card->fw.lock))
./drivers/net/can/softing/softing_main.c:	fw_up = card->fw.up;
./drivers/net/can/softing/softing_main.c:	card->fw.up = 0;
./drivers/net/can/softing/softing_main.c:	if (card->irq.requested && card->irq.nr) {
./drivers/net/can/softing/softing_main.c:		free_irq(card->irq.nr, card);
./drivers/net/can/softing/softing_main.c:		card->irq.requested = 0;
./drivers/net/can/softing/softing_main.c:		if (card->pdat->enable_irq)
./drivers/net/can/softing/softing_main.c:			card->pdat->enable_irq(card->pdev, 0);
./drivers/net/can/softing/softing_main.c:		if (card->pdat->reset)
./drivers/net/can/softing/softing_main.c:			card->pdat->reset(card->pdev, 1);
./drivers/net/can/softing/softing_main.c:	mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:	if (mutex_lock_interruptible(&card->fw.lock))
./drivers/net/can/softing/softing_main.c:	if (card->fw.up) {
./drivers/net/can/softing/softing_main.c:		mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:	if (card->pdat->enable_irq)
./drivers/net/can/softing/softing_main.c:		card->pdat->enable_irq(card->pdev, 1);
./drivers/net/can/softing/softing_main.c:	if (card->pdat->reset)
./drivers/net/can/softing/softing_main.c:		card->pdat->reset(card->pdev, 1);
./drivers/net/can/softing/softing_main.c:	for (j = 0; (j + sizeof(stream)) < card->dpram_size;
./drivers/net/can/softing/softing_main.c:		memcpy_toio(&card->dpram[j], stream, sizeof(stream));
./drivers/net/can/softing/softing_main.c:		memcpy_fromio(back, &card->dpram[j], sizeof(stream));
./drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "dpram failed at 0x%04x\n", j);
./drivers/net/can/softing/softing_main.c:	ret = softing_load_fw(card->pdat->boot.fw, card, card->dpram,
./drivers/net/can/softing/softing_main.c:				card->dpram_size,
./drivers/net/can/softing/softing_main.c:				card->pdat->boot.offs - card->pdat->boot.addr);
./drivers/net/can/softing/softing_main.c:	ret = softing_load_fw(card->pdat->load.fw, card, card->dpram,
./drivers/net/can/softing/softing_main.c:				card->dpram_size,
./drivers/net/can/softing/softing_main.c:				card->pdat->load.offs - card->pdat->load.addr);
./drivers/net/can/softing/softing_main.c:	if (card->pdat->reset)
./drivers/net/can/softing/softing_main.c:		card->pdat->reset(card->pdev, 0);
./drivers/net/can/softing/softing_main.c:	ret = softing_load_app_fw(card->pdat->app.fw, card);
./drivers/net/can/softing/softing_main.c:	card->fw.up = 1;
./drivers/net/can/softing/softing_main.c:	mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:	card->fw.up = 0;
./drivers/net/can/softing/softing_main.c:	if (card->pdat->enable_irq)
./drivers/net/can/softing/softing_main.c:		card->pdat->enable_irq(card->pdev, 0);
./drivers/net/can/softing/softing_main.c:	if (card->pdat->reset)
./drivers/net/can/softing/softing_main.c:		card->pdat->reset(card->pdev, 1);
./drivers/net/can/softing/softing_main.c:	mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:	ret = mutex_lock_interruptible(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:		mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:	mutex_unlock(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "alloc_candev failed\n");
./drivers/net/can/softing/softing_main.c:	priv->btr_const.brp_max = card->pdat->max_brp;
./drivers/net/can/softing/softing_main.c:	priv->btr_const.sjw_max = card->pdat->max_sjw;
./drivers/net/can/softing/softing_main.c:	SET_NETDEV_DEV(netdev, &card->pdev->dev);
./drivers/net/can/softing/softing_main.c:	return sprintf(buf, "%u\n", card->member); \
./drivers/net/can/softing/softing_main.c:	return sprintf(buf, "%s\n", card->member); \
./drivers/net/can/softing/softing_main.c:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_main.c:		if (!card->net[j])
./drivers/net/can/softing/softing_main.c:		softing_netdev_cleanup(card->net[j]);
./drivers/net/can/softing/softing_main.c:		card->net[j] = NULL;
./drivers/net/can/softing/softing_main.c:	iounmap(card->dpram);
./drivers/net/can/softing/softing_main.c:	if (pdat->nbus > ARRAY_SIZE(card->net)) {
./drivers/net/can/softing/softing_main.c:	card->pdat = pdat;
./drivers/net/can/softing/softing_main.c:	card->pdev = pdev;
./drivers/net/can/softing/softing_main.c:	mutex_init(&card->fw.lock);
./drivers/net/can/softing/softing_main.c:	spin_lock_init(&card->spin);
./drivers/net/can/softing/softing_main.c:	card->dpram_phys = pres->start;
./drivers/net/can/softing/softing_main.c:	card->dpram_size = pres->end - pres->start + 1;
./drivers/net/can/softing/softing_main.c:	card->dpram = ioremap_nocache(card->dpram_phys, card->dpram_size);
./drivers/net/can/softing/softing_main.c:	if (!card->dpram) {
./drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "dpram ioremap failed\n");
./drivers/net/can/softing/softing_main.c:		card->irq.nr = pres->start;
./drivers/net/can/softing/softing_main.c:	card->id.freq = card->pdat->freq;
./drivers/net/can/softing/softing_main.c:		dev_alert(&card->pdev->dev, "sysfs failed\n");
./drivers/net/can/softing/softing_main.c:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_main.c:		card->net[j] = netdev =
./drivers/net/can/softing/softing_main.c:			softing_netdev_create(card, card->id.chip[j]);
./drivers/net/can/softing/softing_main.c:		priv = netdev_priv(card->net[j]);
./drivers/net/can/softing/softing_main.c:			card->net[j] = NULL;
./drivers/net/can/softing/softing_main.c:			dev_alert(&card->pdev->dev,
./drivers/net/can/softing/softing_main.c:	dev_info(&card->pdev->dev, "%s ready.\n", card->pdat->name);
./drivers/net/can/softing/softing_main.c:	for (j = 0; j < ARRAY_SIZE(card->net); ++j) {
./drivers/net/can/softing/softing_main.c:		if (!card->net[j])
./drivers/net/can/softing/softing_main.c:		softing_netdev_cleanup(card->net[j]);
./drivers/net/can/softing/softing_main.c:	iounmap(card->dpram);
./drivers/net/can/softing/softing_cs.c:	.name = "CANcard-NEC",
./drivers/net/can/softing/softing_cs.c:	.name = "CANcard-SJA",
./drivers/net/can/softing/softing_cs.c:	.name = "CANcard-2",
./drivers/net/can/softing/softing_cs.c:	.name = "Vector-CANcard-SJA",
./drivers/net/can/softing/softing_cs.c:	.name = "Vector-CANcard-2",
./drivers/net/can/softing/softing_cs.c:	.name = "EDICcard-NEC",
./drivers/net/can/softing/softing_cs.c:	.name = "EDICcard-2",
./drivers/net/can/sja1000/plx_pci.c:	cntrl = ioread32(card->conf_addr + PLX_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	iowrite32(cntrl, card->conf_addr + PLX_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	iowrite32(cntrl, card->conf_addr + PLX_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	cntrl = ioread32(card->conf_addr + PLX9056_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	iowrite32(cntrl, card->conf_addr + PLX9056_CNTRL);
./drivers/net/can/sja1000/plx_pci.c:	for (i = 0; i < card->channels; i++) {
./drivers/net/can/sja1000/plx_pci.c:		dev = card->net_dev[i];
./drivers/net/can/sja1000/plx_pci.c:	card->reset_func(pdev);
./drivers/net/can/sja1000/plx_pci.c:		iowrite32(0x0, card->conf_addr + PLX_INTCSR);
./drivers/net/can/sja1000/plx_pci.c:		iowrite32(0x0, card->conf_addr + PLX9056_INTCSR);
./drivers/net/can/sja1000/plx_pci.c:	if (card->conf_addr)
./drivers/net/can/sja1000/plx_pci.c:		pci_iounmap(pdev, card->conf_addr);
./drivers/net/can/sja1000/plx_pci.c:	card->channels = 0;
./drivers/net/can/sja1000/plx_pci.c:	card->conf_addr = addr + ci->conf_map.offset;
./drivers/net/can/sja1000/plx_pci.c:	card->reset_func = ci->reset_func;
./drivers/net/can/sja1000/plx_pci.c:		card->net_dev[i] = dev;
./drivers/net/can/sja1000/plx_pci.c:			card->channels++;
./drivers/net/can/sja1000/plx_pci.c:	if (!card->channels) {
./drivers/net/can/sja1000/plx_pci.c:		val = ioread32(card->conf_addr + PLX_INTCSR);
./drivers/net/can/sja1000/plx_pci.c:		iowrite32(val, card->conf_addr + PLX_INTCSR);
./drivers/net/can/sja1000/plx_pci.c:			  card->conf_addr + PLX9056_INTCSR);
./drivers/net/can/sja1000/kvaser_pci.c:	intcsr = ioread32(board->conf_addr + S5920_INTCSR);
./drivers/net/can/sja1000/kvaser_pci.c:	iowrite32(intcsr, board->conf_addr + S5920_INTCSR);
./drivers/net/can/sja1000/kvaser_pci.c:	tmp_en_io = ioread32(board->conf_addr + S5920_INTCSR);
./drivers/net/can/sja1000/kvaser_pci.c:	iowrite32(tmp_en_io, board->conf_addr + S5920_INTCSR);
./drivers/net/can/sja1000/kvaser_pci.c:	dev_info(&board->pci_dev->dev, "Removing device %s\n",
./drivers/net/can/sja1000/kvaser_pci.c:	for (i = 0; i < board->no_channels - 1; i++) {
./drivers/net/can/sja1000/kvaser_pci.c:		if (board->slave_dev[i]) {
./drivers/net/can/sja1000/kvaser_pci.c:			dev_info(&board->pci_dev->dev, "Removing device %s\n",
./drivers/net/can/sja1000/kvaser_pci.c:				 board->slave_dev[i]->name);
./drivers/net/can/sja1000/kvaser_pci.c:			unregister_sja1000dev(board->slave_dev[i]);
./drivers/net/can/sja1000/kvaser_pci.c:			free_sja1000dev(board->slave_dev[i]);
./drivers/net/can/sja1000/kvaser_pci.c:	pci_iounmap(board->pci_dev, priv->reg_base);
./drivers/net/can/sja1000/kvaser_pci.c:	pci_iounmap(board->pci_dev, board->conf_addr);
./drivers/net/can/sja1000/kvaser_pci.c:	pci_iounmap(board->pci_dev, board->res_addr);
./drivers/net/can/sja1000/kvaser_pci.c:	board->pci_dev = pdev;
./drivers/net/can/sja1000/kvaser_pci.c:	board->channel = channel;
./drivers/net/can/sja1000/kvaser_pci.c:	board->conf_addr = conf_addr;
./drivers/net/can/sja1000/kvaser_pci.c:	board->res_addr = res_addr;
./drivers/net/can/sja1000/kvaser_pci.c:		board->xilinx_ver =
./drivers/net/can/sja1000/kvaser_pci.c:			ioread8(board->res_addr + XILINX_VERINT) >> 4;
./drivers/net/can/sja1000/kvaser_pci.c:		iowrite32(0x80808080UL, board->conf_addr + S5920_PTCR);
./drivers/net/can/sja1000/kvaser_pci.c:		master_board->slave_dev[channel - 1] = dev;
./drivers/net/can/sja1000/kvaser_pci.c:		master_board->no_channels = channel + 1;
./drivers/net/can/sja1000/kvaser_pci.c:		board->xilinx_ver = master_board->xilinx_ver;
./drivers/net/can/sja1000/kvaser_pci.c:		 priv->reg_base, board->conf_addr, dev->irq);
./drivers/net/can/sja1000/kvaser_pci.c:		 board->xilinx_ver, board->no_channels);
./drivers/net/can/sja1000/ems_pci.c:	return readb(card->base_addr + (port * 4));
./drivers/net/can/sja1000/ems_pci.c:	       card->conf_addr + PITA2_ICR);
./drivers/net/can/sja1000/ems_pci.c:	writel(PLX_ICSR_ENA_CLR, card->conf_addr + PLX_ICSR);
./drivers/net/can/sja1000/ems_pci.c:	for (i = 0; i < card->channels; i++) {
./drivers/net/can/sja1000/ems_pci.c:		dev = card->net_dev[i];
./drivers/net/can/sja1000/ems_pci.c:	if (card->base_addr != NULL)
./drivers/net/can/sja1000/ems_pci.c:		pci_iounmap(card->pci_dev, card->base_addr);
./drivers/net/can/sja1000/ems_pci.c:	if (card->conf_addr != NULL)
./drivers/net/can/sja1000/ems_pci.c:		pci_iounmap(card->pci_dev, card->conf_addr);
./drivers/net/can/sja1000/ems_pci.c:	writeb(0, card->base_addr);
./drivers/net/can/sja1000/ems_pci.c:	card->pci_dev = pdev;
./drivers/net/can/sja1000/ems_pci.c:	card->channels = 0;
./drivers/net/can/sja1000/ems_pci.c:		card->version = 2; /* CPC-PCI v2 */
./drivers/net/can/sja1000/ems_pci.c:		card->version = 1; /* CPC-PCI v1 */
./drivers/net/can/sja1000/ems_pci.c:	card->conf_addr = pci_iomap(pdev, 0, conf_size);
./drivers/net/can/sja1000/ems_pci.c:	if (card->conf_addr == NULL) {
./drivers/net/can/sja1000/ems_pci.c:	card->base_addr = pci_iomap(pdev, base_bar, EMS_PCI_BASE_SIZE);
./drivers/net/can/sja1000/ems_pci.c:	if (card->base_addr == NULL) {
./drivers/net/can/sja1000/ems_pci.c:	if (card->version == 1) {
./drivers/net/can/sja1000/ems_pci.c:		writel(PITA2_MISC_CONFIG, card->conf_addr + PITA2_MISC);
./drivers/net/can/sja1000/ems_pci.c:		card->net_dev[i] = dev;
./drivers/net/can/sja1000/ems_pci.c:		priv->reg_base = card->base_addr + EMS_PCI_CAN_BASE_OFFSET
./drivers/net/can/sja1000/ems_pci.c:		if (card->version == 1) {
./drivers/net/can/sja1000/ems_pci.c:			if (card->version == 1)
./drivers/net/can/sja1000/ems_pci.c:				       card->conf_addr + PITA2_ICR);
./drivers/net/can/sja1000/ems_pci.c:				       card->conf_addr + PLX_ICSR);
./drivers/net/can/sja1000/ems_pci.c:			card->channels++;
./drivers/net/hamachi.c: * RX_CHECKSUM turns on card-generated receive checksum generation for
./drivers/net/hamachi.c:II. Board-specific settings
./drivers/net/at1700.c:#define DATAPORT		8		/* Word-wide DMA or programmed-I/O dataport. */
./drivers/net/sundance.c:II. Board-specific settings
./drivers/net/ni65.c:	writereg(0,CSR3);	/* busmaster/no word-swap */
./drivers/net/myri_sbus.c:		prop = of_get_property(dp, "myrinet-board-id", &len);
./drivers/net/macb.c:/* Make the IP header word-aligned (the ethernet header is 14 bytes) */
./drivers/net/smc-mca.c:	switch (adapter) {	/* card-# in const array above [hs] */
./drivers/net/ps3_gelic_wireless.c:	if (!card->vlan[GELIC_PORT_WIRELESS].tx)
./drivers/net/ps3_gelic_wireless.c:	SET_NETDEV_DEV(netdev, &card->dev->core);
./drivers/net/ps3_gelic_wireless.c:	card->netdev[GELIC_PORT_WIRELESS] = netdev;
./drivers/net/ps3_gelic_wireless.c:	card->irq_mask |= GELIC_CARD_WLAN_EVENT_RECEIVED |
./drivers/net/ps3_gelic_wireless.c:	if (!card->vlan[GELIC_PORT_WIRELESS].tx)
./drivers/net/ps3_gelic_wireless.c:	netdev = card->netdev[GELIC_PORT_WIRELESS];
./drivers/net/ps3_gelic_wireless.c:	card->irq_mask &= ~(GELIC_CARD_WLAN_EVENT_RECEIVED |
./drivers/net/tg3.c:	/* Some third-party PHYs need to be reset on link going
./drivers/net/tg3.c:		 * to either the hard-coded table based PHY_ID and failing
./drivers/net/sunbmac.c:					      "board-version", 1);
./drivers/net/starfire.c:II. Board-specific settings
./drivers/net/mvme147.c: * plus board-specific init, open and close actions.
./drivers/net/ps3_gelic_net.c:	card->irq_mask |= GELIC_CARD_RXINT;
./drivers/net/ps3_gelic_net.c:	gelic_card_set_irq_mask(card, card->irq_mask);
./drivers/net/ps3_gelic_net.c:	card->irq_mask &= ~GELIC_CARD_RXINT;
./drivers/net/ps3_gelic_net.c:	gelic_card_set_irq_mask(card, card->irq_mask);
./drivers/net/ps3_gelic_net.c:			&card->ether_port_status, &v2);
./drivers/net/ps3_gelic_net.c:		ether_netdev = card->netdev[GELIC_PORT_ETHERNET_0];
./drivers/net/ps3_gelic_net.c:		if (card->ether_port_status & GELIC_LV1_ETHER_LINK_UP)
./drivers/net/ps3_gelic_net.c:	card->link_mode = mode;
./drivers/net/ps3_gelic_net.c:	mutex_lock(&card->updown_lock);
./drivers/net/ps3_gelic_net.c:	if (atomic_inc_return(&card->users) == 1) {
./drivers/net/ps3_gelic_net.c:		gelic_card_set_irq_mask(card, card->irq_mask);
./drivers/net/ps3_gelic_net.c:		napi_enable(&card->napi);
./drivers/net/ps3_gelic_net.c:	mutex_unlock(&card->updown_lock);
./drivers/net/ps3_gelic_net.c:	mutex_lock(&card->updown_lock);
./drivers/net/ps3_gelic_net.c:	if (atomic_dec_if_positive(&card->users) == 0) {
./drivers/net/ps3_gelic_net.c:		napi_disable(&card->napi);
./drivers/net/ps3_gelic_net.c:		mask = card->irq_mask & (GELIC_CARD_WLAN_EVENT_RECEIVED |
./drivers/net/ps3_gelic_net.c:		gelic_card_reset_chain(card, &card->rx_chain,
./drivers/net/ps3_gelic_net.c:				       card->descr + GELIC_NET_TX_DESCRIPTORS);
./drivers/net/ps3_gelic_net.c:	mutex_unlock(&card->updown_lock);
./drivers/net/ps3_gelic_net.c:	struct gelic_descr *descr = card->rx_chain.head;
./drivers/net/ps3_gelic_net.c:	} while (descr != card->rx_chain.head);
./drivers/net/ps3_gelic_net.c:	struct gelic_descr *descr = card->rx_chain.head;
./drivers/net/ps3_gelic_net.c:	} while (descr != card->rx_chain.head);
./drivers/net/ps3_gelic_net.c:	chain = &card->rx_chain;
./drivers/net/ps3_gelic_net.c:	chain->tail = card->rx_top->prev; /* point to the last */
./drivers/net/ps3_gelic_net.c:	netif_stop_queue(card->netdev[GELIC_PORT_ETHERNET_0]);
./drivers/net/ps3_gelic_net.c:	if (card->netdev[GELIC_PORT_WIRELESS])
./drivers/net/ps3_gelic_net.c:		netif_stop_queue(card->netdev[GELIC_PORT_WIRELESS]);
./drivers/net/ps3_gelic_net.c:	netif_wake_queue(card->netdev[GELIC_PORT_ETHERNET_0]);
./drivers/net/ps3_gelic_net.c:	if (card->netdev[GELIC_PORT_WIRELESS])
./drivers/net/ps3_gelic_net.c:		netif_wake_queue(card->netdev[GELIC_PORT_WIRELESS]);
./drivers/net/ps3_gelic_net.c:	for (tx_chain = &card->tx_chain;
./drivers/net/ps3_gelic_net.c:	if (gelic_descr_get_status(card->rx_chain.head) !=
./drivers/net/ps3_gelic_net.c:		       be32_to_cpu(card->rx_chain.head->dmac_cmd_status));
./drivers/net/ps3_gelic_net.c:		       be32_to_cpu(card->rx_chain.head->next_descr_addr));
./drivers/net/ps3_gelic_net.c:		       card->rx_chain.head);
./drivers/net/ps3_gelic_net.c:				card->rx_chain.head->bus_addr, 0);
./drivers/net/ps3_gelic_net.c:	if (!card->tx_chain.head)
./drivers/net/ps3_gelic_net.c:	if (card->tx_chain.tail != card->tx_chain.head->next &&
./drivers/net/ps3_gelic_net.c:	    gelic_descr_get_status(card->tx_chain.head) ==
./drivers/net/ps3_gelic_net.c:		return card->tx_chain.head;
./drivers/net/ps3_gelic_net.c:	if (card->vlan_required) {
./drivers/net/ps3_gelic_net.c:					     card->vlan[type].tx);
./drivers/net/ps3_gelic_net.c:	card->tx_chain.head = descr->next;
./drivers/net/ps3_gelic_net.c:	if (card->tx_dma_progress)
./drivers/net/ps3_gelic_net.c:		card->tx_dma_progress = 1;
./drivers/net/ps3_gelic_net.c:	spin_lock_irqsave(&card->tx_lock, flags);
./drivers/net/ps3_gelic_net.c:		spin_unlock_irqrestore(&card->tx_lock, flags);
./drivers/net/ps3_gelic_net.c:		spin_unlock_irqrestore(&card->tx_lock, flags);
./drivers/net/ps3_gelic_net.c:		card->tx_chain.tail = descr->next->next;
./drivers/net/ps3_gelic_net.c:	spin_unlock_irqrestore(&card->tx_lock, flags);
./drivers/net/ps3_gelic_net.c:	struct gelic_descr_chain *chain = &card->rx_chain;
./drivers/net/ps3_gelic_net.c:	if (card->vlan_required) {
./drivers/net/ps3_gelic_net.c:			if (card->vlan[i].rx == vid) {
./drivers/net/ps3_gelic_net.c:				netdev = card->netdev[i];
./drivers/net/ps3_gelic_net.c:		netdev = card->netdev[GELIC_PORT_ETHERNET_0];
./drivers/net/ps3_gelic_net.c:		card->rx_dma_restart_required = 1;
./drivers/net/ps3_gelic_net.c:	status = card->irq_status;
./drivers/net/ps3_gelic_net.c:	status &= card->irq_mask;
./drivers/net/ps3_gelic_net.c:	if (card->rx_dma_restart_required) {
./drivers/net/ps3_gelic_net.c:		card->rx_dma_restart_required = 0;
./drivers/net/ps3_gelic_net.c:		napi_schedule(&card->napi);
./drivers/net/ps3_gelic_net.c:		spin_lock_irqsave(&card->tx_lock, flags);
./drivers/net/ps3_gelic_net.c:		card->tx_dma_progress = 0;
./drivers/net/ps3_gelic_net.c:		gelic_card_kick_txdma(card, card->tx_chain.tail);
./drivers/net/ps3_gelic_net.c:		spin_unlock_irqrestore(&card->tx_lock, flags);
./drivers/net/ps3_gelic_net.c:		gelic_wl_interrupt(card->netdev[GELIC_PORT_WIRELESS], status);
./drivers/net/ps3_gelic_net.c:	gelic_card_set_irq_mask(card, card->irq_mask);
./drivers/net/ps3_gelic_net.c:	if (card->ether_port_status & GELIC_LV1_ETHER_FULL_DUPLEX)
./drivers/net/ps3_gelic_net.c:	switch (card->ether_port_status & GELIC_LV1_ETHER_SPEED_MASK) {
./drivers/net/ps3_gelic_net.c:	if (card->link_mode & GELIC_LV1_ETHER_AUTO_NEG) {
./drivers/net/ps3_gelic_net.c:	struct net_device *netdev = card->netdev[GELIC_PORT_ETHERNET_0];
./drivers/net/ps3_gelic_net.c:	atomic_dec(&card->tx_timeout_task_counter);
./drivers/net/ps3_gelic_net.c:	atomic_inc(&card->tx_timeout_task_counter);
./drivers/net/ps3_gelic_net.c:		schedule_work(&card->tx_timeout_task);
./drivers/net/ps3_gelic_net.c:		atomic_dec(&card->tx_timeout_task_counter);
./drivers/net/ps3_gelic_net.c:	if (card->vlan_required) {
./drivers/net/ps3_gelic_net.c:	card->unalign = p;
./drivers/net/ps3_gelic_net.c:		kfree(card->unalign);
./drivers/net/ps3_gelic_net.c:	card->netdev[GELIC_PORT_ETHERNET_0] = *netdev;
./drivers/net/ps3_gelic_net.c:	INIT_WORK(&card->tx_timeout_task, gelic_net_tx_timeout_task);
./drivers/net/ps3_gelic_net.c:	init_waitqueue_head(&card->waitq);
./drivers/net/ps3_gelic_net.c:	atomic_set(&card->tx_timeout_task_counter, 0);
./drivers/net/ps3_gelic_net.c:	mutex_init(&card->updown_lock);
./drivers/net/ps3_gelic_net.c:	atomic_set(&card->users, 0);
./drivers/net/ps3_gelic_net.c:			card->vlan[i].tx = 0;
./drivers/net/ps3_gelic_net.c:			card->vlan[i].rx = 0;
./drivers/net/ps3_gelic_net.c:		card->vlan[i].tx = (u16)v1;
./drivers/net/ps3_gelic_net.c:			card->vlan[i].tx = 0;
./drivers/net/ps3_gelic_net.c:			card->vlan[i].rx = 0;
./drivers/net/ps3_gelic_net.c:		card->vlan[i].rx = (u16)v1;
./drivers/net/ps3_gelic_net.c:			i, card->vlan[i].tx, card->vlan[i].rx);
./drivers/net/ps3_gelic_net.c:	if (card->vlan[GELIC_PORT_ETHERNET_0].tx) {
./drivers/net/ps3_gelic_net.c:		BUG_ON(!card->vlan[GELIC_PORT_WIRELESS].tx);
./drivers/net/ps3_gelic_net.c:		card->vlan_required = 1;
./drivers/net/ps3_gelic_net.c:		card->vlan_required = 0;
./drivers/net/ps3_gelic_net.c:		card->vlan[GELIC_PORT_WIRELESS].tx = 0;
./drivers/net/ps3_gelic_net.c:		card->vlan[GELIC_PORT_WIRELESS].rx = 0;
./drivers/net/ps3_gelic_net.c:		 card->vlan_required? "enabled" : "disabled");
./drivers/net/ps3_gelic_net.c:	card->dev = dev;
./drivers/net/ps3_gelic_net.c:	card->link_mode = GELIC_LV1_ETHER_AUTO_NEG;
./drivers/net/ps3_gelic_net.c:		ps3_mm_phys_to_lpar(__pa(&card->irq_status)),
./drivers/net/ps3_gelic_net.c:		&card->irq);
./drivers/net/ps3_gelic_net.c:	result = request_irq(card->irq, gelic_card_interrupt,
./drivers/net/ps3_gelic_net.c:	card->irq_mask = GELIC_CARD_RXINT | GELIC_CARD_TXINT |
./drivers/net/ps3_gelic_net.c:	if (gelic_card_init_chain(card, &card->tx_chain,
./drivers/net/ps3_gelic_net.c:			card->descr, GELIC_NET_TX_DESCRIPTORS))
./drivers/net/ps3_gelic_net.c:	if (gelic_card_init_chain(card, &card->rx_chain,
./drivers/net/ps3_gelic_net.c:				 card->descr + GELIC_NET_TX_DESCRIPTORS,
./drivers/net/ps3_gelic_net.c:	card->tx_top = card->tx_chain.head;
./drivers/net/ps3_gelic_net.c:	card->rx_top = card->rx_chain.head;
./drivers/net/ps3_gelic_net.c:		card->rx_top, card->tx_top, sizeof(struct gelic_descr),
./drivers/net/ps3_gelic_net.c:	spin_lock_init(&card->tx_lock);
./drivers/net/ps3_gelic_net.c:	card->tx_dma_progress = 0;
./drivers/net/ps3_gelic_net.c:	netdev->irq = card->irq;
./drivers/net/ps3_gelic_net.c:	SET_NETDEV_DEV(netdev, &card->dev->core);
./drivers/net/ps3_gelic_net.c:	gelic_ether_setup_netdev_ops(netdev, &card->napi);
./drivers/net/ps3_gelic_net.c:	gelic_card_free_chain(card, card->rx_chain.head);
./drivers/net/ps3_gelic_net.c:	gelic_card_free_chain(card, card->tx_chain.head);
./drivers/net/ps3_gelic_net.c:	free_irq(card->irq, card);
./drivers/net/ps3_gelic_net.c:	ps3_sb_event_receive_port_destroy(dev, card->irq);
./drivers/net/ps3_gelic_net.c:	gelic_card_free_chain(card, card->tx_top);
./drivers/net/ps3_gelic_net.c:	gelic_card_free_chain(card, card->rx_top);
./drivers/net/ps3_gelic_net.c:	netdev0 = card->netdev[GELIC_PORT_ETHERNET_0];
./drivers/net/ps3_gelic_net.c:	free_irq(card->irq, card);
./drivers/net/ps3_gelic_net.c:	ps3_sb_event_receive_port_destroy(card->dev, card->irq);
./drivers/net/ps3_gelic_net.c:	wait_event(card->waitq,
./drivers/net/ps3_gelic_net.c:		   atomic_read(&card->tx_timeout_task_counter) == 0);
./drivers/net/au1000_eth.c: * board-specific configurations
./drivers/net/via-velocity.c:	*((u32 *) & (rd->rdesc0)) = 0;
./drivers/net/via-velocity.c:	rd->size = cpu_to_le16(vptr->rx.buf_sz) | RX_INTEN;
./drivers/net/via-velocity.c:	rd->pa_low = cpu_to_le32(rd_info->skb_dma);
./drivers/net/via-velocity.c:	rd->pa_high = 0;
./drivers/net/via-velocity.c:		if (rd->rdesc0.len & OWNED_BY_NIC)
./drivers/net/via-velocity.c:	if (rd->rdesc1.CSM & CSM_IPKT) {
./drivers/net/via-velocity.c:		if (rd->rdesc1.CSM & CSM_IPOK) {
./drivers/net/via-velocity.c:			if ((rd->rdesc1.CSM & CSM_TCPKT) ||
./drivers/net/via-velocity.c:					(rd->rdesc1.CSM & CSM_UDPKT)) {
./drivers/net/via-velocity.c:				if (!(rd->rdesc1.CSM & CSM_TUPOK))
./drivers/net/via-velocity.c:	int pkt_len = le16_to_cpu(rd->rdesc0.len) & 0x3fff;
./drivers/net/via-velocity.c:	if (rd->rdesc0.RSR & (RSR_STP | RSR_EDP)) {
./drivers/net/via-velocity.c:	if (rd->rdesc0.RSR & RSR_MAR)
./drivers/net/via-velocity.c:		if (rd->rdesc0.RSR & RSR_RL) {
./drivers/net/via-velocity.c:	if (vptr->vlgrp && (rd->rdesc0.RSR & RSR_DETAG)) {
./drivers/net/via-velocity.c:				swab16(le16_to_cpu(rd->rdesc1.PQTAG)));
./drivers/net/via-velocity.c:		if (rd->rdesc0.len & OWNED_BY_NIC)
./drivers/net/via-velocity.c:		if (rd->rdesc0.RSR & (RSR_RXOK | RSR_CE | RSR_RL)) {
./drivers/net/via-velocity.c:			if (rd->rdesc0.RSR & RSR_CRC)
./drivers/net/via-velocity.c:			if (rd->rdesc0.RSR & RSR_FAE)
./drivers/net/via-velocity.c:		rd->size |= RX_INTEN;
./drivers/net/skfp/cfm.c:	 * Don't send ever MAC_PATH_CHANGE events. Our MAC is hard-wired
./drivers/net/skge.c:	rd->dma_lo = map;
./drivers/net/skge.c:	rd->dma_hi = map >> 32;
./drivers/net/skge.c:	rd->csum1_start = ETH_HLEN;
./drivers/net/skge.c:	rd->csum2_start = ETH_HLEN;
./drivers/net/skge.c:	rd->csum1 = 0;
./drivers/net/skge.c:	rd->csum2 = 0;
./drivers/net/skge.c:	rd->control = BMU_OWN | BMU_STF | BMU_IRQ_EOF | BMU_TCP_CHECK | bufsize;
./drivers/net/skge.c:	rd->csum2 = 0;
./drivers/net/skge.c:	rd->csum2_start = ETH_HLEN;
./drivers/net/skge.c:	rd->control = BMU_OWN | BMU_STF | BMU_IRQ_EOF | BMU_TCP_CHECK | size;
./drivers/net/skge.c:		rd->control = 0;
./drivers/net/skge.c:		control = rd->control;
./drivers/net/skge.c:		skb = skge_rx_get(dev, e, control, rd->status, rd->csum2);
./drivers/net/sunlance.c:	     !((bits = rd->rmd1_bits) & LE_R1_OWN);
./drivers/net/sunlance.c:			len = (rd->mblength & 0xfff) - 4;
./drivers/net/sunlance.c:				rd->mblength = 0;
./drivers/net/sunlance.c:				rd->rmd1_bits = LE_R1_OWN;
./drivers/net/sunlance.c:		rd->mblength = 0;
./drivers/net/sunlance.c:		rd->rmd1_bits = LE_R1_OWN;
./drivers/net/sunlance.c:	     !((bits = sbus_readb(&rd->rmd1_bits)) & LE_R1_OWN);
./drivers/net/sunlance.c:			len = (sbus_readw(&rd->mblength) & 0xfff) - 4;
./drivers/net/sunlance.c:				sbus_writew(0, &rd->mblength);
./drivers/net/sunlance.c:				sbus_writeb(LE_R1_OWN, &rd->rmd1_bits);
./drivers/net/sunlance.c:		sbus_writew(0, &rd->mblength);
./drivers/net/sunlance.c:		sbus_writeb(LE_R1_OWN, &rd->rmd1_bits);
./drivers/net/pcmcia/pcnet_cs.c:    outb_p(0x01, ioaddr + EN0_DCFG);	/* Set word-wide access. */
./drivers/net/pcmcia/pcnet_cs.c:	PCMCIA_DEVICE_PROD_ID12("SMC", "EZCard-10-PCMCIA", 0xc4f8b18b, 0xfb21d265),
./drivers/net/pcmcia/3c574_cs.c:II. Board-specific settings
./drivers/net/pcmcia/ibmtr_cs.c:    /* Third nibble, hard-coded values */
./drivers/net/pcmcia/smc91c92_cs.c:	PCMCIA_DEVICE_PROD_ID12("dit Co., Ltd.", "PC Card-10/100BTX", 0xe59365c8, 0x6a2161d1),
./drivers/net/pcmcia/axnet_cs.c:	{0x01,	EN0_DCFG},	/* Set word-wide access. */
./drivers/net/pcmcia/axnet_cs.c:  This is not a complete driver, it must be combined with board-specific
./drivers/net/pcmcia/axnet_cs.c:/* These are the operational function interfaces to board-specific
./drivers/net/ne.c:   Reading the SAPROM from a word-wide card with the 8390 set in byte-wide
./drivers/net/mace.c:    out_le32(&rd->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
./drivers/net/mace.c:    out_le32(&rd->cmdptr, virt_to_bus(mp->rx_cmds));
./drivers/net/mace.c:    out_le32(&rd->control, (RUN << 16) | RUN);
./drivers/net/mace.c:    st_le32(&rd->control, (RUN|PAUSE|FLUSH|WAKE) << 16); /* clear run bit */
./drivers/net/mace.c:    cp = bus_to_virt(ld_le32(&rd->cmdptr));
./drivers/net/mace.c:    out_le32(&rd->cmdptr, virt_to_bus(cp));
./drivers/net/mace.c:    out_le32(&rd->control, (RUN << 16) | RUN);
./drivers/net/mace.c:	if ((ld_le32(&rd->status) & ACTIVE) != 0) {
./drivers/net/mace.c:	    out_le32(&rd->control, (PAUSE << 16) | PAUSE);
./drivers/net/mace.c:	    while ((in_le32(&rd->status) & ACTIVE) != 0)
./drivers/net/mace.c:	out_le32(&rd->control, ((RUN|WAKE) << 16) | (RUN|WAKE));
./drivers/net/natsemi.c:II. Board-specific settings
./drivers/net/declance.c: * accesses only.  Each halfword of the buffer is word-aligned in the
./drivers/net/82596.c: * must be word-swapped with the most significant word written first.
./drivers/net/usb/sierra_net.c:		hh->payload_len.word--;
./drivers/net/usb/cdc_ether.c:				/* fall back to hard-wiring for RNDIS */
./drivers/net/usb/cdc_ether.c:	 * CDC descriptors, so we'll hard-wire the interfaces and not check
./drivers/net/usb/cdc_ether.c:	 * hard-wired 0 and 1 interfaces.
./drivers/net/usb/rtl8150.c:	/* Write the MAC address into eeprom. Eeprom writes must be word-sized,
./drivers/net/korina.c:		devcs = rd->devcs;
./drivers/net/korina.c:		if ((KORINA_RBSIZE - (u32)DMA_COUNT(rd->control)) == 0)
./drivers/net/korina.c:		rd->devcs = 0;
./drivers/net/korina.c:			rd->ca = CPHYSADDR(skb_new->data);
./drivers/net/korina.c:			rd->ca = CPHYSADDR(skb->data);
./drivers/net/korina.c:		rd->control = DMA_COUNT(KORINA_RBSIZE) |
./drivers/net/korina.c:		rd->devcs = 0;
./drivers/net/korina.c:		rd->ca = CPHYSADDR(skb->data);
./drivers/net/sb1000.c:	serial_number = pdev->card->serial;
./drivers/net/acenic.c:		set_aceaddr(&rd->addr, mapping);
./drivers/net/acenic.c:		rd->size = ACE_STD_BUFSIZE;
./drivers/net/acenic.c:		rd->idx = idx;
./drivers/net/acenic.c:		set_aceaddr(&rd->addr, mapping);
./drivers/net/acenic.c:		rd->size = ACE_MINI_BUFSIZE;
./drivers/net/acenic.c:		rd->idx = idx;
./drivers/net/acenic.c:		set_aceaddr(&rd->addr, mapping);
./drivers/net/acenic.c:		rd->size = ACE_JUMBO_BUFSIZE;
./drivers/net/acenic.c:		rd->idx = idx;
./drivers/net/yellowfin.c:II. Board-specific settings
./drivers/net/lance.c:II. Board-specific settings
./drivers/net/spider_net.c:	return in_be32(card->regs + reg);
./drivers/net/spider_net.c:	out_be32(card->regs + reg, value);
./drivers/net/spider_net.c:	struct mii_phy *phy = &card->phy;
./drivers/net/spider_net.c:	bmsr  = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);
./drivers/net/spider_net.c:	estat = spider_net_read_phy(card->netdev, phy->mii_id, MII_ESTATUS);
./drivers/net/spider_net.c:	struct net_device *netdev = card->netdev;
./drivers/net/spider_net.c:	dma_free_coherent(&card->pdev->dev, chain->num_desc,
./drivers/net/spider_net.c:	chain->hwring = dma_alloc_coherent(&card->pdev->dev, alloc_size,
./drivers/net/spider_net.c:	descr = card->rx_chain.head;
./drivers/net/spider_net.c:			pci_unmap_single(card->pdev, descr->hwdescr->buf_addr,
./drivers/net/spider_net.c:	} while (descr != card->rx_chain.head);
./drivers/net/spider_net.c:	descr->skb = netdev_alloc_skb(card->netdev,
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:		card->spider_stats.alloc_rx_skb_error++;
./drivers/net/spider_net.c:	buf = pci_map_single(card->pdev, descr->skb->data,
./drivers/net/spider_net.c:	if (pci_dma_mapping_error(card->pdev, buf)) {
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev, "Could not iommu-map rx buffer\n");
./drivers/net/spider_net.c:		card->spider_stats.rx_iommu_map_error++;
./drivers/net/spider_net.c:			     card->rx_chain.tail->bus_addr);
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->rx_chain;
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->rx_chain;
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->tx_chain;
./drivers/net/spider_net.c:	buf = pci_map_single(card->pdev, skb->data, skb->len, PCI_DMA_TODEVICE);
./drivers/net/spider_net.c:	if (pci_dma_mapping_error(card->pdev, buf)) {
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev, "could not iommu-map packet (%p, %i). "
./drivers/net/spider_net.c:		card->spider_stats.tx_iommu_map_error++;
./drivers/net/spider_net.c:	descr = card->tx_chain.head;
./drivers/net/spider_net.c:		pci_unmap_single(card->pdev, buf, skb->len, PCI_DMA_TODEVICE);
./drivers/net/spider_net.c:	card->netdev->trans_start = jiffies; /* set netdev watchdog timer */
./drivers/net/spider_net.c:	struct spider_net_descr *descr = card->tx_chain.tail;
./drivers/net/spider_net.c:	while (descr != card->tx_chain.head) {
./drivers/net/spider_net.c:	if (cnt < card->tx_chain.num_desc/4)
./drivers/net/spider_net.c:	descr = card->tx_chain.tail;
./drivers/net/spider_net.c:	spin_lock_irqsave(&card->tx_chain.lock, flags);
./drivers/net/spider_net.c:	if (card->low_watermark && card->low_watermark != descr) {
./drivers/net/spider_net.c:		hwdescr = card->low_watermark->hwdescr;
./drivers/net/spider_net.c:	card->low_watermark = descr;
./drivers/net/spider_net.c:	spin_unlock_irqrestore(&card->tx_chain.lock, flags);
./drivers/net/spider_net.c:	struct net_device *dev = card->netdev;
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->tx_chain;
./drivers/net/spider_net.c:				dev_err(&card->netdev->dev, "forcing end of tx descriptor "
./drivers/net/spider_net.c:			pci_unmap_single(card->pdev, buf_addr, skb->len,
./drivers/net/spider_net.c:	descr = card->tx_chain.tail;
./drivers/net/spider_net.c:		if (descr == card->tx_chain.head)
./drivers/net/spider_net.c:	mod_timer(&card->tx_timer, jiffies + SPIDER_NET_TX_TIMER);
./drivers/net/spider_net.c:	    (card->netdev->flags & IFF_UP)) {
./drivers/net/spider_net.c:		netif_wake_queue(card->netdev);
./drivers/net/spider_net.c:	struct net_device *netdev = card->netdev;
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->rx_chain;
./drivers/net/spider_net.c:	struct device *dev = &card->netdev->dev;
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->rx_chain;
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->rx_chain;
./drivers/net/spider_net.c:	struct net_device *dev = card->netdev;
./drivers/net/spider_net.c:	struct spider_net_descr_chain *chain = &card->rx_chain;
./drivers/net/spider_net.c:	pci_unmap_single(card->pdev, hw_buf_addr,
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:		card->spider_stats.rx_desc_unk_state++;
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:		dev_err(&card->netdev->dev, "bad status, cmd_status=x%08x\n",
./drivers/net/spider_net.c:		pr_err("which=%ld\n", descr - card->rx_chain.ring);
./drivers/net/spider_net.c:		card->spider_stats.rx_desc_error++;
./drivers/net/spider_net.c:	if ((packets_done == 0) && (card->num_rx_ints != 0)) {
./drivers/net/spider_net.c:	card->num_rx_ints = 0;
./drivers/net/spider_net.c:		card->ignore_rx_ramfull = 0;
./drivers/net/spider_net.c:	del_timer_sync(&card->aneg_timer);
./drivers/net/spider_net.c:	card->aneg_count = 0;
./drivers/net/spider_net.c:	card->medium = BCM54XX_COPPER;
./drivers/net/spider_net.c:	mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev, "PHY write queue full\n");
./drivers/net/spider_net.c:		if (card->tx_chain.tail != card->tx_chain.head)
./drivers/net/spider_net.c:		if (card->ignore_rx_ramfull == 0) {
./drivers/net/spider_net.c:			card->ignore_rx_ramfull = 1;
./drivers/net/spider_net.c:			card->num_rx_ints ++;
./drivers/net/spider_net.c:			napi_schedule(&card->napi);
./drivers/net/spider_net.c:		card->num_rx_ints ++;
./drivers/net/spider_net.c:		napi_schedule(&card->napi);
./drivers/net/spider_net.c:		card->num_rx_ints ++;
./drivers/net/spider_net.c:		napi_schedule(&card->napi);
./drivers/net/spider_net.c:		dev_err(&card->netdev->dev, "Error interrupt, GHIINT0STS = 0x%08x, "
./drivers/net/spider_net.c:		napi_schedule(&card->napi);
./drivers/net/spider_net.c:		card->num_rx_ints ++;
./drivers/net/spider_net.c:		napi_schedule(&card->napi);
./drivers/net/spider_net.c:			     SPIDER_NET_FIRMWARE_NAME, &card->pdev->dev) == 0) {
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:	dn = pci_device_to_OF_node(card->pdev);
./drivers/net/spider_net.c:		dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:		dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:	card->aneg_count = 0;
./drivers/net/spider_net.c:	card->medium = BCM54XX_COPPER;
./drivers/net/spider_net.c:	if (card->phy.def->phy_id)
./drivers/net/spider_net.c:		mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./drivers/net/spider_net.c:	result = spider_net_init_chain(card, &card->tx_chain);
./drivers/net/spider_net.c:	card->low_watermark = NULL;
./drivers/net/spider_net.c:	result = spider_net_init_chain(card, &card->rx_chain);
./drivers/net/spider_net.c:	napi_enable(&card->napi);
./drivers/net/spider_net.c:	spider_net_free_chain(card, &card->rx_chain);
./drivers/net/spider_net.c:	spider_net_free_chain(card, &card->tx_chain);
./drivers/net/spider_net.c:	del_timer_sync(&card->aneg_timer);
./drivers/net/spider_net.c:	struct mii_phy *phy = &card->phy;
./drivers/net/spider_net.c:	if (card->aneg_count > SPIDER_NET_ANEG_TIMEOUT) {
./drivers/net/spider_net.c:			 card->netdev->name);
./drivers/net/spider_net.c:		switch (card->medium) {
./drivers/net/spider_net.c:			card->medium = BCM54XX_FIBER;
./drivers/net/spider_net.c:			card->medium = BCM54XX_UNKNOWN;
./drivers/net/spider_net.c:			card->medium = BCM54XX_COPPER;
./drivers/net/spider_net.c:		card->aneg_count = 0;
./drivers/net/spider_net.c:		mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./drivers/net/spider_net.c:		card->aneg_count++;
./drivers/net/spider_net.c:		mod_timer(&card->aneg_timer, jiffies + SPIDER_NET_ANEG_TIMER);
./drivers/net/spider_net.c:	card->aneg_count = 0;
./drivers/net/spider_net.c:		card->netdev->name, phy->speed,
./drivers/net/spider_net.c:	struct mii_phy *phy = &card->phy;
./drivers/net/spider_net.c:	phy->dev = card->netdev;
./drivers/net/spider_net.c:		id = spider_net_read_phy(card->netdev, phy->mii_id, MII_BMSR);
./drivers/net/spider_net.c:	napi_disable(&card->napi);
./drivers/net/spider_net.c:	del_timer_sync(&card->tx_timer);
./drivers/net/spider_net.c:	del_timer_sync(&card->aneg_timer);
./drivers/net/spider_net.c:	spider_net_free_chain(card, &card->tx_chain);
./drivers/net/spider_net.c:	spider_net_free_chain(card, &card->rx_chain);
./drivers/net/spider_net.c:	struct net_device *netdev = card->netdev;
./drivers/net/spider_net.c:	atomic_dec(&card->tx_timeout_task_counter);
./drivers/net/spider_net.c:	atomic_inc(&card->tx_timeout_task_counter);
./drivers/net/spider_net.c:		schedule_work(&card->tx_timeout_task);
./drivers/net/spider_net.c:		atomic_dec(&card->tx_timeout_task_counter);
./drivers/net/spider_net.c:	card->spider_stats.tx_timeouts++;
./drivers/net/spider_net.c:	struct net_device *netdev = card->netdev;
./drivers/net/spider_net.c:	SET_NETDEV_DEV(netdev, &card->pdev->dev);
./drivers/net/spider_net.c:	pci_set_drvdata(card->pdev, netdev);
./drivers/net/spider_net.c:	init_timer(&card->tx_timer);
./drivers/net/spider_net.c:	card->tx_timer.function =
./drivers/net/spider_net.c:	card->tx_timer.data = (unsigned long) card;
./drivers/net/spider_net.c:	netdev->irq = card->pdev->irq;
./drivers/net/spider_net.c:	card->aneg_count = 0;
./drivers/net/spider_net.c:	init_timer(&card->aneg_timer);
./drivers/net/spider_net.c:	card->aneg_timer.function = spider_net_link_phy;
./drivers/net/spider_net.c:	card->aneg_timer.data = (unsigned long) card;
./drivers/net/spider_net.c:	netif_napi_add(netdev, &card->napi,
./drivers/net/spider_net.c:	netdev->irq = card->pdev->irq;
./drivers/net/spider_net.c:	card->num_rx_ints = 0;
./drivers/net/spider_net.c:	card->ignore_rx_ramfull = 0;
./drivers/net/spider_net.c:	dn = pci_device_to_OF_node(card->pdev);
./drivers/net/spider_net.c:		dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:			dev_err(&card->netdev->dev,
./drivers/net/spider_net.c:	card->netdev = netdev;
./drivers/net/spider_net.c:	card->msg_enable = SPIDER_NET_DEFAULT_MSG;
./drivers/net/spider_net.c:	INIT_WORK(&card->tx_timeout_task, spider_net_tx_timeout_task);
./drivers/net/spider_net.c:	init_waitqueue_head(&card->waitq);
./drivers/net/spider_net.c:	atomic_set(&card->tx_timeout_task_counter, 0);
./drivers/net/spider_net.c:	card->rx_chain.num_desc = rx_descriptors;
./drivers/net/spider_net.c:	card->rx_chain.ring = card->darray;
./drivers/net/spider_net.c:	card->tx_chain.num_desc = tx_descriptors;
./drivers/net/spider_net.c:	card->tx_chain.ring = card->darray + rx_descriptors;
./drivers/net/spider_net.c:	iounmap(card->regs);
./drivers/net/spider_net.c:	pci_release_regions(card->pdev);
./drivers/net/spider_net.c:	card->pdev = pdev;
./drivers/net/spider_net.c:	card->netdev->mem_start = mmio_start;
./drivers/net/spider_net.c:	card->netdev->mem_end = mmio_start + mmio_len;
./drivers/net/spider_net.c:	card->regs = ioremap(mmio_start, mmio_len);
./drivers/net/spider_net.c:	if (!card->regs) {
./drivers/net/spider_net.c:	free_netdev(card->netdev);
./drivers/net/spider_net.c:	wait_event(card->waitq,
./drivers/net/spider_net.c:		   atomic_read(&card->tx_timeout_task_counter) == 0);
./drivers/net/forcedeth.c:	return le32_to_cpu(prd->flaglen)
./drivers/net/forcedeth.c:	return le32_to_cpu(prd->flaglen) & LEN_MASK_V2;
./drivers/net/ne2k-pci.c:  Reading the SAPROM from a word-wide card with the 8390 set in byte-wide
./drivers/net/ne2k-pci.c:			{0x49,	EN0_DCFG},	/* Set word-wide access. */
./drivers/net/spider_net_ethtool.c:	ethtool_cmd_speed_set(cmd, card->phy.speed);
./drivers/net/spider_net_ethtool.c:	strncpy(drvinfo->bus_info, pci_name(card->pdev), 32);
./drivers/net/spider_net_ethtool.c:	return card->msg_enable;
./drivers/net/spider_net_ethtool.c:	card->msg_enable = level;
./drivers/net/spider_net_ethtool.c:	ering->tx_pending = card->tx_chain.num_desc;
./drivers/net/spider_net_ethtool.c:	ering->rx_pending = card->rx_chain.num_desc;
./drivers/net/spider_net_ethtool.c:	data[7] = card->spider_stats.rx_desc_error;
./drivers/net/spider_net_ethtool.c:	data[8] = card->spider_stats.tx_timeouts;
./drivers/net/spider_net_ethtool.c:	data[9] = card->spider_stats.alloc_rx_skb_error;
./drivers/net/spider_net_ethtool.c:	data[10] = card->spider_stats.rx_iommu_map_error;
./drivers/net/spider_net_ethtool.c:	data[11] = card->spider_stats.tx_iommu_map_error;
./drivers/net/spider_net_ethtool.c:	data[12] = card->spider_stats.rx_desc_unk_state;
./drivers/net/via-rhine.c:II. Board-specific settings
./drivers/net/cs89x0.c:#include <mach/board-mx31ads.h>
./drivers/net/wireless/b43/main.c:/* Hard-reset the chip. Do not call this directly.
./drivers/net/wireless/mwifiex/sdio.c:	card->func = func;
./drivers/net/wireless/mwifiex/sdio.c:	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
./drivers/net/wireless/mwifiex/sdio.c:			mwifiex_remove_card(card->adapter,
./drivers/net/wireless/mwifiex/sdio.c:		if (!card || !card->adapter) {
./drivers/net/wireless/mwifiex/sdio.c:	adapter = card->adapter;
./drivers/net/wireless/mwifiex/sdio.c:		if (!card || !card->adapter) {
./drivers/net/wireless/mwifiex/sdio.c:	adapter = card->adapter;
./drivers/net/wireless/mwifiex/sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:	sdio_writeb(card->func, (u8) data, reg, &ret);
./drivers/net/wireless/mwifiex/sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:	val = sdio_readb(card->func, reg, &ret);
./drivers/net/wireless/mwifiex/sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:	if (!sdio_writesb(card->func, ioport, buffer, blk_cnt * blk_size))
./drivers/net/wireless/mwifiex/sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:		sdio_claim_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:	if (!sdio_readsb(card->func, buffer, ioport, blk_cnt * blk_size))
./drivers/net/wireless/mwifiex/sdio.c:		sdio_release_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:	u16 rd_bitmap = card->mp_rd_bitmap;
./drivers/net/wireless/mwifiex/sdio.c:	if (card->mp_rd_bitmap & CTRL_PORT_MASK) {
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_rd_bitmap &= (u16) (~CTRL_PORT_MASK);
./drivers/net/wireless/mwifiex/sdio.c:		       *port, card->mp_rd_bitmap);
./drivers/net/wireless/mwifiex/sdio.c:		if (card->mp_rd_bitmap & (1 << card->curr_rd_port)) {
./drivers/net/wireless/mwifiex/sdio.c:			card->mp_rd_bitmap &=
./drivers/net/wireless/mwifiex/sdio.c:				(u16) (~(1 << card->curr_rd_port));
./drivers/net/wireless/mwifiex/sdio.c:			*port = card->curr_rd_port;
./drivers/net/wireless/mwifiex/sdio.c:			if (++card->curr_rd_port == MAX_PORT)
./drivers/net/wireless/mwifiex/sdio.c:				card->curr_rd_port = 1;
./drivers/net/wireless/mwifiex/sdio.c:		       *port, rd_bitmap, card->mp_rd_bitmap);
./drivers/net/wireless/mwifiex/sdio.c:	u16 wr_bitmap = card->mp_wr_bitmap;
./drivers/net/wireless/mwifiex/sdio.c:	if (!(wr_bitmap & card->mp_data_port_mask))
./drivers/net/wireless/mwifiex/sdio.c:	if (card->mp_wr_bitmap & (1 << card->curr_wr_port)) {
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_wr_bitmap &= (u16) (~(1 << card->curr_wr_port));
./drivers/net/wireless/mwifiex/sdio.c:		*port = card->curr_wr_port;
./drivers/net/wireless/mwifiex/sdio.c:		if (++card->curr_wr_port == card->mp_end_port)
./drivers/net/wireless/mwifiex/sdio.c:			card->curr_wr_port = 1;
./drivers/net/wireless/mwifiex/sdio.c:				*port, card->curr_wr_port, wr_bitmap,
./drivers/net/wireless/mwifiex/sdio.c:				card->mp_wr_bitmap);
./drivers/net/wireless/mwifiex/sdio.c:	       *port, wr_bitmap, card->mp_wr_bitmap);
./drivers/net/wireless/mwifiex/sdio.c:	if (mwifiex_read_data_sync(adapter, card->mp_regs, MAX_MP_REGS,
./drivers/net/wireless/mwifiex/sdio.c:	sdio_ireg = card->mp_regs[HOST_INTSTATUS_REG];
./drivers/net/wireless/mwifiex/sdio.c:	if (!card || !card->adapter) {
./drivers/net/wireless/mwifiex/sdio.c:		       func, card, card ? card->adapter : NULL);
./drivers/net/wireless/mwifiex/sdio.c:	adapter = card->adapter;
./drivers/net/wireless/mwifiex/sdio.c:	if (!card->mpa_rx.enabled) {
./drivers/net/wireless/mwifiex/sdio.c:	if (card->mp_rd_bitmap & (~((u16) CTRL_PORT_MASK))) {
./drivers/net/wireless/mwifiex/sdio.c:		       card->mpa_rx.pkt_cnt);
./drivers/net/wireless/mwifiex/sdio.c:		if (mwifiex_read_data_sync(adapter, card->mpa_rx.buf,
./drivers/net/wireless/mwifiex/sdio.c:					   card->mpa_rx.buf_len,
./drivers/net/wireless/mwifiex/sdio.c:					    (card->mpa_rx.ports << 4)) +
./drivers/net/wireless/mwifiex/sdio.c:					   card->mpa_rx.start_port, 1))
./drivers/net/wireless/mwifiex/sdio.c:		curr_ptr = card->mpa_rx.buf;
./drivers/net/wireless/mwifiex/sdio.c:		for (pind = 0; pind < card->mpa_rx.pkt_cnt; pind++) {
./drivers/net/wireless/mwifiex/sdio.c:			skb_deaggr = card->mpa_rx.skb_arr[pind];
./drivers/net/wireless/mwifiex/sdio.c:					 card->mpa_rx.len_arr[pind])) {
./drivers/net/wireless/mwifiex/sdio.c:					card->mpa_rx.len_arr[pind]);
./drivers/net/wireless/mwifiex/sdio.c:			curr_ptr += card->mpa_rx.len_arr[pind];
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_wr_bitmap = ((u16) card->mp_regs[WR_BITMAP_U]) << 8;
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_wr_bitmap |= (u16) card->mp_regs[WR_BITMAP_L];
./drivers/net/wireless/mwifiex/sdio.c:				card->mp_wr_bitmap);
./drivers/net/wireless/mwifiex/sdio.c:		    (card->mp_wr_bitmap & card->mp_data_port_mask)) {
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_wr_bitmap |=
./drivers/net/wireless/mwifiex/sdio.c:			(u16) card->mp_regs[WR_BITMAP_L] & CTRL_PORT_MASK;
./drivers/net/wireless/mwifiex/sdio.c:		if (card->mp_wr_bitmap & CTRL_PORT_MASK)
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_rd_bitmap = ((u16) card->mp_regs[RD_BITMAP_U]) << 8;
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_rd_bitmap |= (u16) card->mp_regs[RD_BITMAP_L];
./drivers/net/wireless/mwifiex/sdio.c:				card->mp_rd_bitmap);
./drivers/net/wireless/mwifiex/sdio.c:			rx_len = ((u16) card->mp_regs[len_reg_u]) << 8;
./drivers/net/wireless/mwifiex/sdio.c:			rx_len |= (u16) card->mp_regs[len_reg_l];
./drivers/net/wireless/mwifiex/sdio.c:	if ((!card->mpa_tx.enabled) || (port == CTRL_PORT)) {
./drivers/net/wireless/mwifiex/sdio.c:				if (!(card->mp_wr_bitmap &
./drivers/net/wireless/mwifiex/sdio.c:						(1 << card->curr_wr_port))
./drivers/net/wireless/mwifiex/sdio.c:				    !(card->mp_wr_bitmap &
./drivers/net/wireless/mwifiex/sdio.c:				      (1 << card->curr_wr_port)))
./drivers/net/wireless/mwifiex/sdio.c:			    && (card->mp_wr_bitmap & (1 << card->curr_wr_port)))
./drivers/net/wireless/mwifiex/sdio.c:				card->mpa_tx.start_port, card->mpa_tx.ports);
./drivers/net/wireless/mwifiex/sdio.c:		ret = mwifiex_write_data_to_card(adapter, card->mpa_tx.buf,
./drivers/net/wireless/mwifiex/sdio.c:						 card->mpa_tx.buf_len,
./drivers/net/wireless/mwifiex/sdio.c:						 (card->mpa_tx.ports << 4)) +
./drivers/net/wireless/mwifiex/sdio.c:						  card->mpa_tx.start_port);
./drivers/net/wireless/mwifiex/sdio.c:			if (!(card->mp_wr_bitmap & (1 << card->curr_wr_port)))
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_tx.buf = kzalloc(mpa_tx_buf_size, GFP_KERNEL);
./drivers/net/wireless/mwifiex/sdio.c:	if (!card->mpa_tx.buf) {
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_tx.buf_size = mpa_tx_buf_size;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_rx.buf = kzalloc(mpa_rx_buf_size, GFP_KERNEL);
./drivers/net/wireless/mwifiex/sdio.c:	if (!card->mpa_rx.buf) {
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_rx.buf_size = mpa_rx_buf_size;
./drivers/net/wireless/mwifiex/sdio.c:		kfree(card->mpa_tx.buf);
./drivers/net/wireless/mwifiex/sdio.c:		kfree(card->mpa_rx.buf);
./drivers/net/wireless/mwifiex/sdio.c:		sdio_claim_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:		sdio_release_irq(card->func);
./drivers/net/wireless/mwifiex/sdio.c:		sdio_disable_func(card->func);
./drivers/net/wireless/mwifiex/sdio.c:		sdio_release_host(card->func);
./drivers/net/wireless/mwifiex/sdio.c:		sdio_set_drvdata(card->func, NULL);
./drivers/net/wireless/mwifiex/sdio.c:	struct sdio_func *func = card->func;
./drivers/net/wireless/mwifiex/sdio.c:	card->adapter = adapter;
./drivers/net/wireless/mwifiex/sdio.c:	ret = sdio_set_block_size(card->func, MWIFIEX_SDIO_BLOCK_SIZE);
./drivers/net/wireless/mwifiex/sdio.c:	card->mp_rd_bitmap = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mp_wr_bitmap = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->curr_rd_port = 1;
./drivers/net/wireless/mwifiex/sdio.c:	card->curr_wr_port = 1;
./drivers/net/wireless/mwifiex/sdio.c:	card->mp_data_port_mask = DATA_PORT_MASK;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_tx.buf_len = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_tx.pkt_cnt = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_tx.start_port = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_tx.enabled = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_tx.pkt_aggr_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_rx.buf_len = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_rx.pkt_cnt = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_rx.start_port = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_rx.enabled = 0;
./drivers/net/wireless/mwifiex/sdio.c:	card->mpa_rx.pkt_aggr_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
./drivers/net/wireless/mwifiex/sdio.c:	card->mp_regs = kzalloc(MAX_MP_REGS, GFP_KERNEL);
./drivers/net/wireless/mwifiex/sdio.c:	if (!card->mp_regs) {
./drivers/net/wireless/mwifiex/sdio.c:		kfree(card->mp_regs);
./drivers/net/wireless/mwifiex/sdio.c:	kfree(card->mp_regs);
./drivers/net/wireless/mwifiex/sdio.c:	kfree(card->mpa_tx.buf);
./drivers/net/wireless/mwifiex/sdio.c:	kfree(card->mpa_rx.buf);
./drivers/net/wireless/mwifiex/sdio.c:	card->mp_end_port = port;
./drivers/net/wireless/mwifiex/sdio.c:	card->mp_data_port_mask = DATA_PORT_MASK;
./drivers/net/wireless/mwifiex/sdio.c:	for (i = 1; i <= MAX_PORT - card->mp_end_port; i++)
./drivers/net/wireless/mwifiex/sdio.c:		card->mp_data_port_mask &= ~(1 << (MAX_PORT - i));
./drivers/net/wireless/mwifiex/sdio.c:	card->curr_wr_port = 1;
./drivers/net/wireless/mwifiex/sdio.c:	       port, card->mp_data_port_mask);
./drivers/net/wireless/rt2x00/rt2x00usb.c:	if (rd->callback(rd->rt2x00dev, urb->status, le32_to_cpu(rd->reg))) {
./drivers/net/wireless/rt2x00/rt2x00usb.c:	rd->rt2x00dev = rt2x00dev;
./drivers/net/wireless/rt2x00/rt2x00usb.c:	rd->callback = callback;
./drivers/net/wireless/rt2x00/rt2x00usb.c:	rd->cr.bRequestType = USB_VENDOR_REQUEST_IN;
./drivers/net/wireless/rt2x00/rt2x00usb.c:	rd->cr.bRequest = USB_MULTI_READ;
./drivers/net/wireless/rt2x00/rt2x00usb.c:	rd->cr.wValue = 0;
./drivers/net/wireless/rt2x00/rt2x00usb.c:	rd->cr.wIndex = cpu_to_le16(offset);
./drivers/net/wireless/rt2x00/rt2x00usb.c:	rd->cr.wLength = cpu_to_le16(sizeof(u32));
./drivers/net/wireless/rt2x00/rt2x00usb.c:			     (unsigned char *)(&rd->cr), &rd->reg, sizeof(rd->reg),
./drivers/net/wireless/ath/ath5k/debug.c:		rd->rx_ctl.rx_control_0, rd->rx_ctl.rx_control_1,
./drivers/net/wireless/ath/ath5k/debug.c:		rd->rx_stat.rx_status_0, rd->rx_stat.rx_status_1,
./drivers/net/wireless/b43legacy/main.c:/* Hard-reset the chip. Do not call this directly.
./drivers/net/wireless/libertas/if_spi.c:	list_for_each_safe(cursor, next, &card->cmd_packet_list) {
./drivers/net/wireless/libertas/if_spi.c:	list_for_each_safe(cursor, next, &card->data_packet_list) {
./drivers/net/wireless/libertas/if_spi.c:	spi_set_drvdata(card->spi, NULL);
./drivers/net/wireless/libertas/if_spi.c:	if (!time_after(jiffies, card->prev_xfer_time + 1)) {
./drivers/net/wireless/libertas/if_spi.c:	card->prev_xfer_time = jiffies;
./drivers/net/wireless/libertas/if_spi.c:	err = spi_sync(card->spi, &m);
./drivers/net/wireless/libertas/if_spi.c:	delay = spu_reg_is_port_reg(reg) ? card->spu_port_delay :
./drivers/net/wireless/libertas/if_spi.c:						card->spu_reg_delay;
./drivers/net/wireless/libertas/if_spi.c:	if (card->use_dummy_writes) {
./drivers/net/wireless/libertas/if_spi.c:	err = spi_sync(card->spi, &m);
./drivers/net/wireless/libertas/if_spi.c:	card->use_dummy_writes = 0;
./drivers/net/wireless/libertas/if_spi.c:	card->spu_port_delay = 1000;
./drivers/net/wireless/libertas/if_spi.c:	card->spu_reg_delay = 1000;
./drivers/net/wireless/libertas/if_spi.c:	card->spu_port_delay = delay & 0x0000ffff;
./drivers/net/wireless/libertas/if_spi.c:	card->spu_reg_delay = (delay & 0xffff0000) >> 16;
./drivers/net/wireless/libertas/if_spi.c:		card->use_dummy_writes = 1;
./drivers/net/wireless/libertas/if_spi.c:		    card->spu_port_delay, card->spu_reg_delay);
./drivers/net/wireless/libertas/if_spi.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:			memset(card->cmd_buffer, 0, len);
./drivers/net/wireless/libertas/if_spi.c:			memcpy(card->cmd_buffer, fw, bytes);
./drivers/net/wireless/libertas/if_spi.c:			memcpy(card->cmd_buffer, fw, len);
./drivers/net/wireless/libertas/if_spi.c:				card->cmd_buffer, len);
./drivers/net/wireless/libertas/if_spi.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:				card->cmd_buffer, ALIGN(len, 4));
./drivers/net/wireless/libertas/if_spi.c:	memcpy(priv->resp_buf[i], card->cmd_buffer, len);
./drivers/net/wireless/libertas/if_spi.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:	err = lbs_process_rxed_packet(card->priv, skb);
./drivers/net/wireless/libertas/if_spi.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:	priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:	   (card->priv->psstate != PS_STATE_FULL_POWER &&
./drivers/net/wireless/libertas/if_spi.c:		lbs_host_to_card_done(card->priv);
./drivers/net/wireless/libertas/if_spi.c:		spin_lock_irqsave(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:		if (!list_empty(&card->cmd_packet_list)) {
./drivers/net/wireless/libertas/if_spi.c:			packet = (struct if_spi_packet *)(card->
./drivers/net/wireless/libertas/if_spi.c:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:		spin_lock_irqsave(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:		if (!list_empty(&card->data_packet_list)) {
./drivers/net/wireless/libertas/if_spi.c:			packet = (struct if_spi_packet *)(card->
./drivers/net/wireless/libertas/if_spi.c:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:		spin_lock_irqsave(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:		list_add_tail(&packet->list, &card->cmd_packet_list);
./drivers/net/wireless/libertas/if_spi.c:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:		spin_lock_irqsave(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:		list_add_tail(&packet->list, &card->data_packet_list);
./drivers/net/wireless/libertas/if_spi.c:		spin_unlock_irqrestore(&card->buffer_lock, flags);
./drivers/net/wireless/libertas/if_spi.c:	queue_work(card->workqueue, &card->packet_work);
./drivers/net/wireless/libertas/if_spi.c:	queue_work(card->workqueue, &card->packet_work);
./drivers/net/wireless/libertas/if_spi.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:	struct spi_device *spi = card->spi;
./drivers/net/wireless/libertas/if_spi.c:	err = spu_init(card, card->pdata->use_dummy_writes);
./drivers/net/wireless/libertas/if_spi.c:	err = spu_get_chip_revision(card, &card->card_id, &card->card_rev);
./drivers/net/wireless/libertas/if_spi.c:			if (card->card_id == fw_table[i].model)
./drivers/net/wireless/libertas/if_spi.c:				   card->card_id);
./drivers/net/wireless/libertas/if_spi.c:		err = lbs_get_firmware(&card->spi->dev, NULL, NULL,
./drivers/net/wireless/libertas/if_spi.c:					card->card_id, &fw_table[0], &helper,
./drivers/net/wireless/libertas/if_spi.c:				card->card_id, card->card_rev,
./drivers/net/wireless/libertas/if_spi.c:	if (card->suspended) {
./drivers/net/wireless/libertas/if_spi.c:		if (card->pdata->setup)
./drivers/net/wireless/libertas/if_spi.c:			card->pdata->setup(card->spi);
./drivers/net/wireless/libertas/if_spi.c:		enable_irq(card->spi->irq);
./drivers/net/wireless/libertas/if_spi.c:		lbs_resume(card->priv);
./drivers/net/wireless/libertas/if_spi.c:		card->suspended = 0;
./drivers/net/wireless/libertas/if_spi.c:	card->pdata = pdata;
./drivers/net/wireless/libertas/if_spi.c:	card->spi = spi;
./drivers/net/wireless/libertas/if_spi.c:	card->prev_xfer_time = jiffies;
./drivers/net/wireless/libertas/if_spi.c:	INIT_LIST_HEAD(&card->cmd_packet_list);
./drivers/net/wireless/libertas/if_spi.c:	INIT_LIST_HEAD(&card->data_packet_list);
./drivers/net/wireless/libertas/if_spi.c:	spin_lock_init(&card->buffer_lock);
./drivers/net/wireless/libertas/if_spi.c:	card->priv = priv;
./drivers/net/wireless/libertas/if_spi.c:	card->workqueue = create_workqueue("libertas_spi");
./drivers/net/wireless/libertas/if_spi.c:	INIT_WORK(&card->packet_work, if_spi_host_to_card_worker);
./drivers/net/wireless/libertas/if_spi.c:	INIT_WORK(&card->resume_work, if_spi_resume_worker);
./drivers/net/wireless/libertas/if_spi.c:	flush_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_spi.c:	destroy_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_spi.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_spi.c:	cancel_work_sync(&card->resume_work);
./drivers/net/wireless/libertas/if_spi.c:	flush_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_spi.c:	destroy_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_spi.c:	if (card->pdata->teardown)
./drivers/net/wireless/libertas/if_spi.c:		card->pdata->teardown(spi);
./drivers/net/wireless/libertas/if_spi.c:	if (!card->suspended) {
./drivers/net/wireless/libertas/if_spi.c:		lbs_suspend(card->priv);
./drivers/net/wireless/libertas/if_spi.c:		flush_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_spi.c:		if (card->pdata->teardown)
./drivers/net/wireless/libertas/if_spi.c:			card->pdata->teardown(spi);
./drivers/net/wireless/libertas/if_spi.c:		card->suspended = 1;
./drivers/net/wireless/libertas/if_spi.c:	schedule_work(&card->resume_work);
./drivers/net/wireless/libertas/if_sdio.c:	scratch = sdio_readb(card->func, card->scratch_reg, &ret);
./drivers/net/wireless/libertas/if_sdio.c:		scratch |= sdio_readb(card->func, card->scratch_reg + 1,
./drivers/net/wireless/libertas/if_sdio.c:	rx_unit = sdio_readb(card->func, IF_SDIO_RX_UNIT, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	switch (card->model) {
./drivers/net/wireless/libertas/if_sdio.c:		rx_len = sdio_readb(card->func, IF_SDIO_RX_LEN, &ret);
./drivers/net/wireless/libertas/if_sdio.c:			rx_len <<= card->rx_unit;
./drivers/net/wireless/libertas/if_sdio.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_sdio.c:	spin_unlock_irqrestore(&card->priv->driver_lock, flags);
./drivers/net/wireless/libertas/if_sdio.c:	lbs_process_rxed_packet(card->priv, skb);
./drivers/net/wireless/libertas/if_sdio.c:	if (card->model == MODEL_8385) {
./drivers/net/wireless/libertas/if_sdio.c:		event = sdio_readb(card->func, IF_SDIO_EVENT, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	lbs_queue_event(card->priv, event & 0xFF);
./drivers/net/wireless/libertas/if_sdio.c:		status = sdio_readb(card->func, IF_SDIO_STATUS, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	chunk = sdio_align_size(card->func, size);
./drivers/net/wireless/libertas/if_sdio.c:	ret = sdio_readsb(card->func, card->buffer, card->ioport, chunk);
./drivers/net/wireless/libertas/if_sdio.c:	chunk = card->buffer[0] | (card->buffer[1] << 8);
./drivers/net/wireless/libertas/if_sdio.c:	type = card->buffer[2] | (card->buffer[3] << 8);
./drivers/net/wireless/libertas/if_sdio.c:		ret = if_sdio_handle_cmd(card, card->buffer + 4, chunk - 4);
./drivers/net/wireless/libertas/if_sdio.c:		ret = if_sdio_handle_data(card, card->buffer + 4, chunk - 4);
./drivers/net/wireless/libertas/if_sdio.c:		ret = if_sdio_handle_event(card, card->buffer + 4, chunk - 4);
./drivers/net/wireless/libertas/if_sdio.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/net/wireless/libertas/if_sdio.c:		packet = card->packets;
./drivers/net/wireless/libertas/if_sdio.c:			card->packets = packet->next;
./drivers/net/wireless/libertas/if_sdio.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/wireless/libertas/if_sdio.c:		sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:			ret = sdio_writesb(card->func, card->ioport,
./drivers/net/wireless/libertas/if_sdio.c:		sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	ret = sdio_set_block_size(card->func, 32);
./drivers/net/wireless/libertas/if_sdio.c:		ret = sdio_writesb(card->func, card->ioport,
./drivers/net/wireless/libertas/if_sdio.c:	ret = sdio_writesb(card->func, card->ioport, chunk_buffer, 64);
./drivers/net/wireless/libertas/if_sdio.c:		req_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);
./drivers/net/wireless/libertas/if_sdio.c:		req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;
./drivers/net/wireless/libertas/if_sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	ret = sdio_set_block_size(card->func, 32);
./drivers/net/wireless/libertas/if_sdio.c:		req_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);
./drivers/net/wireless/libertas/if_sdio.c:		req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;
./drivers/net/wireless/libertas/if_sdio.c:			ret = sdio_writesb(card->func, card->ioport,
./drivers/net/wireless/libertas/if_sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_writeb(card->func, 0x00, IF_SDIO_H_INT_MASK, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	} else if ((card->model == MODEL_8686) && (scratch & 0x7fff)) {
./drivers/net/wireless/libertas/if_sdio.c:	ret = lbs_get_firmware(&card->func->dev, lbs_helper_name, lbs_fw_name,
./drivers/net/wireless/libertas/if_sdio.c:				card->model, &fw_table[0], &helper, &mainfw);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_set_block_size(card->func, IF_SDIO_BLOCK_SIZE);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	size = sdio_align_size(card->func, nb + 4);
./drivers/net/wireless/libertas/if_sdio.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/net/wireless/libertas/if_sdio.c:	if (!card->packets)
./drivers/net/wireless/libertas/if_sdio.c:		card->packets = packet;
./drivers/net/wireless/libertas/if_sdio.c:		cur = card->packets;
./drivers/net/wireless/libertas/if_sdio.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/wireless/libertas/if_sdio.c:	queue_work(card->workqueue, &card->packet_worker);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_claim_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_writeb(card->func, 0, CONFIGURATION_REG, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_release_host(card->func);
./drivers/net/wireless/libertas/if_sdio.c:	cause = sdio_readb(card->func, IF_SDIO_H_INT_STATUS, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	sdio_writeb(card->func, ~cause, IF_SDIO_H_INT_STATUS, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	card->priv->is_activity_detected = 1;
./drivers/net/wireless/libertas/if_sdio.c:		lbs_host_to_card_done(card->priv);
./drivers/net/wireless/libertas/if_sdio.c:	struct mmc_host *host = func->card->host;
./drivers/net/wireless/libertas/if_sdio.c:	for (i = 0;i < func->card->num_info;i++) {
./drivers/net/wireless/libertas/if_sdio.c:		if (sscanf(func->card->info[i],
./drivers/net/wireless/libertas/if_sdio.c:		if (sscanf(func->card->info[i],
./drivers/net/wireless/libertas/if_sdio.c:		if (!strcmp(func->card->info[i], "IBIS Wireless SDIO Card")) {
./drivers/net/wireless/libertas/if_sdio.c:	if (i == func->card->num_info) {
./drivers/net/wireless/libertas/if_sdio.c:	card->func = func;
./drivers/net/wireless/libertas/if_sdio.c:	card->model = model;
./drivers/net/wireless/libertas/if_sdio.c:	switch (card->model) {
./drivers/net/wireless/libertas/if_sdio.c:		card->scratch_reg = IF_SDIO_SCRATCH_OLD;
./drivers/net/wireless/libertas/if_sdio.c:		card->scratch_reg = IF_SDIO_SCRATCH;
./drivers/net/wireless/libertas/if_sdio.c:		card->scratch_reg = IF_SDIO_FW_STATUS;
./drivers/net/wireless/libertas/if_sdio.c:	spin_lock_init(&card->lock);
./drivers/net/wireless/libertas/if_sdio.c:	card->workqueue = create_workqueue("libertas_sdio");
./drivers/net/wireless/libertas/if_sdio.c:	INIT_WORK(&card->packet_worker, if_sdio_host_to_card_worker);
./drivers/net/wireless/libertas/if_sdio.c:		if (card->model == fw_table[i].model)
./drivers/net/wireless/libertas/if_sdio.c:		pr_err("unknown card model 0x%x\n", card->model);
./drivers/net/wireless/libertas/if_sdio.c:	if ((card->model == MODEL_8686) &&
./drivers/net/wireless/libertas/if_sdio.c:		func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
./drivers/net/wireless/libertas/if_sdio.c:	card->ioport = sdio_readb(func, IF_SDIO_IOPORT, &ret);
./drivers/net/wireless/libertas/if_sdio.c:	card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 1, &ret) << 8;
./drivers/net/wireless/libertas/if_sdio.c:	card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 2, &ret) << 16;
./drivers/net/wireless/libertas/if_sdio.c:			model, (unsigned)card->ioport);
./drivers/net/wireless/libertas/if_sdio.c:	card->priv = priv;
./drivers/net/wireless/libertas/if_sdio.c:	if ((card->model != MODEL_8385)
./drivers/net/wireless/libertas/if_sdio.c:			&& (card->model != MODEL_8686))
./drivers/net/wireless/libertas/if_sdio.c:		card->rx_unit = if_sdio_read_rx_unit(card);
./drivers/net/wireless/libertas/if_sdio.c:		card->rx_unit = 0;
./drivers/net/wireless/libertas/if_sdio.c:	if (card->model == MODEL_8688) {
./drivers/net/wireless/libertas/if_sdio.c:	flush_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_sdio.c:	destroy_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_sdio.c:	while (card->packets) {
./drivers/net/wireless/libertas/if_sdio.c:		packet = card->packets;
./drivers/net/wireless/libertas/if_sdio.c:		card->packets = card->packets->next;
./drivers/net/wireless/libertas/if_sdio.c:	if (card->helper_allocated)
./drivers/net/wireless/libertas/if_sdio.c:		kfree(card->helper);
./drivers/net/wireless/libertas/if_sdio.c:	if (card->firmware_allocated)
./drivers/net/wireless/libertas/if_sdio.c:		kfree(card->firmware);
./drivers/net/wireless/libertas/if_sdio.c:	if (user_rmmod && (card->model == MODEL_8688)) {
./drivers/net/wireless/libertas/if_sdio.c:		if (__lbs_cmd(card->priv, CMD_FUNC_SHUTDOWN,
./drivers/net/wireless/libertas/if_sdio.c:	lbs_stop_card(card->priv);
./drivers/net/wireless/libertas/if_sdio.c:	lbs_remove_card(card->priv);
./drivers/net/wireless/libertas/if_sdio.c:	flush_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_sdio.c:	destroy_workqueue(card->workqueue);
./drivers/net/wireless/libertas/if_sdio.c:	while (card->packets) {
./drivers/net/wireless/libertas/if_sdio.c:		packet = card->packets;
./drivers/net/wireless/libertas/if_sdio.c:		card->packets = card->packets->next;
./drivers/net/wireless/libertas/if_sdio.c:	if (card->helper_allocated)
./drivers/net/wireless/libertas/if_sdio.c:		kfree(card->helper);
./drivers/net/wireless/libertas/if_sdio.c:	if (card->firmware_allocated)
./drivers/net/wireless/libertas/if_sdio.c:		kfree(card->firmware);
./drivers/net/wireless/libertas/if_sdio.c:	if (card->priv->wol_criteria == EHS_REMOVE_WAKEUP) {
./drivers/net/wireless/libertas/if_sdio.c:	ret = lbs_suspend(card->priv);
./drivers/net/wireless/libertas/if_sdio.c:	ret = lbs_resume(card->priv);
./drivers/net/wireless/libertas/if_cs.c:	unsigned int val = ioread8(card->iobase + reg);
./drivers/net/wireless/libertas/if_cs.c:	unsigned int val = ioread16(card->iobase + reg);
./drivers/net/wireless/libertas/if_cs.c:	ioread16_rep(card->iobase + reg, buf, count);
./drivers/net/wireless/libertas/if_cs.c:	iowrite8(val, card->iobase + reg);
./drivers/net/wireless/libertas/if_cs.c:	iowrite16(val, card->iobase + reg);
./drivers/net/wireless/libertas/if_cs.c:	iowrite16_rep(card->iobase + reg, buf, count);
./drivers/net/wireless/libertas/if_cs.c:	struct lbs_private *priv = card->priv;
./drivers/net/wireless/libertas/if_cs.c:		card->priv->surpriseremoved = 1;
./drivers/net/wireless/libertas/if_cs.c:	if (card->align_regs)
./drivers/net/wireless/libertas/if_cs.c:	if (card->iobase)
./drivers/net/wireless/libertas/if_cs.c:		ioport_unmap(card->iobase);
./drivers/net/wireless/libertas/if_cs.c:	card->p_dev = p_dev;
./drivers/net/wireless/libertas/if_cs.c:	card->iobase = ioport_map(p_dev->resource[0]->start,
./drivers/net/wireless/libertas/if_cs.c:	if (!card->iobase) {
./drivers/net/wireless/libertas/if_cs.c:	card->align_regs = 0;
./drivers/net/wireless/libertas/if_cs.c:	card->model = get_model(p_dev->manf_id, p_dev->card_id);
./drivers/net/wireless/libertas/if_cs.c:	if (card->model == MODEL_UNKNOWN) {
./drivers/net/wireless/libertas/if_cs.c:	if (card->model == MODEL_8305) {
./drivers/net/wireless/libertas/if_cs.c:		card->align_regs = 1;
./drivers/net/wireless/libertas/if_cs.c:	if ((card->model == MODEL_8381) && prod_id < IF_CS_CF8381_B3_REV) {
./drivers/net/wireless/libertas/if_cs.c:	if ((card->model == MODEL_8385) && prod_id < IF_CS_CF8385_B1_REV) {
./drivers/net/wireless/libertas/if_cs.c:	ret = lbs_get_firmware(&p_dev->dev, NULL, NULL, card->model,
./drivers/net/wireless/libertas/if_cs.c:	if (ret == 0 && (card->model != MODEL_8305))
./drivers/net/wireless/libertas/if_cs.c:	card->priv = priv;
./drivers/net/wireless/libertas/if_cs.c:	ioport_unmap(card->iobase);
./drivers/net/wireless/libertas/if_cs.c:	lbs_stop_card(card->priv);
./drivers/net/wireless/libertas/if_cs.c:	lbs_remove_card(card->priv);
./drivers/net/wireless/wl1251/spi.c:	 * comes from the board-peripherals file */
./drivers/net/wireless/orinoco/orinoco_cs.c:	struct pcmcia_device *link = card->p_dev;
./drivers/net/wireless/orinoco/orinoco_cs.c:	set_bit(0, &card->hard_reset_in_progress);
./drivers/net/wireless/orinoco/orinoco_cs.c:	clear_bit(0, &card->hard_reset_in_progress);
./drivers/net/wireless/orinoco/orinoco_cs.c:	card->p_dev = link;
./drivers/net/wireless/orinoco/orinoco_cs.c:	if (!test_bit(0, &card->hard_reset_in_progress))
./drivers/net/wireless/orinoco/orinoco_cs.c:	if (!test_bit(0, &card->hard_reset_in_progress))
./drivers/net/wireless/orinoco/airport.c:	disable_irq(card->irq);
./drivers/net/wireless/orinoco/airport.c:	enable_irq(card->irq);
./drivers/net/wireless/orinoco/airport.c:	if (card->ndev_registered)
./drivers/net/wireless/orinoco/airport.c:	card->ndev_registered = 0;
./drivers/net/wireless/orinoco/airport.c:	if (card->irq_requested)
./drivers/net/wireless/orinoco/airport.c:		free_irq(card->irq, priv);
./drivers/net/wireless/orinoco/airport.c:	card->irq_requested = 0;
./drivers/net/wireless/orinoco/airport.c:	if (card->vaddr)
./drivers/net/wireless/orinoco/airport.c:		iounmap(card->vaddr);
./drivers/net/wireless/orinoco/airport.c:	card->vaddr = NULL;
./drivers/net/wireless/orinoco/airport.c:	disable_irq(card->irq);
./drivers/net/wireless/orinoco/airport.c:			  macio_get_of_node(card->mdev), 0, 0);
./drivers/net/wireless/orinoco/airport.c:			  macio_get_of_node(card->mdev), 0, 1);
./drivers/net/wireless/orinoco/airport.c:	enable_irq(card->irq);
./drivers/net/wireless/orinoco/airport.c:	card->mdev = mdev;
./drivers/net/wireless/orinoco/airport.c:	card->irq = macio_irq(mdev, 0);
./drivers/net/wireless/orinoco/airport.c:	card->vaddr = ioremap(phys_addr, AIRPORT_IO_LEN);
./drivers/net/wireless/orinoco/airport.c:	if (!card->vaddr) {
./drivers/net/wireless/orinoco/airport.c:	hermes_struct_init(hw, card->vaddr, HERMES_16BIT_REGSPACING);
./drivers/net/wireless/orinoco/airport.c:	if (request_irq(card->irq, orinoco_interrupt, 0, DRIVER_NAME, priv)) {
./drivers/net/wireless/orinoco/airport.c:		printk(KERN_ERR PFX "Couldn't get IRQ %d\n", card->irq);
./drivers/net/wireless/orinoco/airport.c:	card->irq_requested = 1;
./drivers/net/wireless/orinoco/airport.c:	if (orinoco_if_add(priv, phys_addr, card->irq, NULL) != 0) {
./drivers/net/wireless/orinoco/airport.c:	card->ndev_registered = 1;
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(8, card->bridge_io + 2);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	ioread16(card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0x80, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(COR_VALUE, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(COR_VALUE, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0x228, card->bridge_io + 2);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	if (ioread16(card->bridge_io) & 1) {
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0x118, card->bridge_io + 2);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0x108, card->bridge_io + 2);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0x8, card->bridge_io + 2);
./drivers/net/wireless/orinoco/orinoco_nortel.c:		if (ioread16(card->bridge_io) & 0x10)
./drivers/net/wireless/orinoco/orinoco_nortel.c:	if (ioread16(card->attr_io + COR_OFFSET) & 1) {
./drivers/net/wireless/orinoco/orinoco_nortel.c:	if (ioread16(card->attr_io + COR_OFFSET + 2) & 1) {
./drivers/net/wireless/orinoco/orinoco_nortel.c:	if (ioread16(card->attr_io + COR_OFFSET + 4) & 1) {
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(COR_VALUE, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	reg = ioread16(card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(1, card->bridge_io + 10);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	card->bridge_io = bridge_io;
./drivers/net/wireless/orinoco/orinoco_nortel.c:	card->attr_io = attr_io;
./drivers/net/wireless/orinoco/orinoco_nortel.c:	iowrite16(0, card->bridge_io + 10);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	pci_iounmap(pdev, card->attr_io);
./drivers/net/wireless/orinoco/orinoco_nortel.c:	pci_iounmap(pdev, card->bridge_io);
./drivers/net/wireless/orinoco/orinoco_plx.c:	iowrite8(COR_VALUE | COR_RESET, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_plx.c:	iowrite8(COR_VALUE, card->attr_io + COR_OFFSET);
./drivers/net/wireless/orinoco/orinoco_plx.c:		printk("%02X:", ioread8(card->attr_io + (i << 1)));
./drivers/net/wireless/orinoco/orinoco_plx.c:		if (cis_magic[i] != ioread8(card->attr_io + (i << 1))) {
./drivers/net/wireless/orinoco/orinoco_plx.c:	csr_reg = ioread32(card->bridge_io + PLX_INTCSR);
./drivers/net/wireless/orinoco/orinoco_plx.c:		iowrite32(csr_reg, card->bridge_io + PLX_INTCSR);
./drivers/net/wireless/orinoco/orinoco_plx.c:		csr_reg = ioread32(card->bridge_io + PLX_INTCSR);
./drivers/net/wireless/orinoco/orinoco_plx.c:	card->bridge_io = bridge_io;
./drivers/net/wireless/orinoco/orinoco_plx.c:	card->attr_io = attr_io;
./drivers/net/wireless/orinoco/orinoco_plx.c:	pci_iounmap(pdev, card->attr_io);
./drivers/net/wireless/orinoco/orinoco_plx.c:	pci_iounmap(pdev, card->bridge_io);
./drivers/net/wireless/orinoco/spectrum_cs.c:	struct pcmcia_device *link = card->p_dev;
./drivers/net/wireless/orinoco/spectrum_cs.c:	struct pcmcia_device *link = card->p_dev;
./drivers/net/wireless/orinoco/spectrum_cs.c:	card->p_dev = link;
./drivers/net/wireless/orinoco/orinoco_tmd.c:	iowrite8(COR_VALUE | COR_RESET, card->bridge_io);
./drivers/net/wireless/orinoco/orinoco_tmd.c:	iowrite8(COR_VALUE, card->bridge_io);
./drivers/net/wireless/orinoco/orinoco_tmd.c:	card->bridge_io = bridge_io;
./drivers/net/wireless/orinoco/orinoco_tmd.c:	pci_iounmap(pdev, card->bridge_io);
./drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c:		mmc_wait_for_req(gInstance->func[func]->card->host, &mmc_req);
./drivers/net/wireless/wl12xx/sdio.c:	ret = mmc_power_restore_host(func->card->host);
./drivers/net/wireless/wl12xx/sdio.c:	ret = mmc_power_save_host(func->card->host);
./drivers/net/wireless/wl12xx/sdio.c:	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
./drivers/net/wireless/wl12xx/sdio.c:	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
./drivers/net/wireless/wl12xx/spi.c:	 * comes from the board-peripherals file */
./drivers/net/wireless/wl12xx/sdio_test.c:	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
./drivers/net/wireless/wl12xx/sdio_test.c:	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
./drivers/net/wireless/zd1211rw/zd_usb.c:		if (rd->addr != req->addr[i]) {
./drivers/net/wireless/zd1211rw/zd_usb.c:				 le16_to_cpu(rd->addr),
./drivers/net/wireless/zd1211rw/zd_usb.c:		values[i] = le16_to_cpu(rd->value);
./drivers/net/wireless/ipw2x00/ipw2100.c:		      &ord->table1_addr);
./drivers/net/wireless/ipw2x00/ipw2100.c:		      &ord->table2_addr);
./drivers/net/wireless/ipw2x00/ipw2100.c:	read_nic_dword(priv->net_dev, ord->table1_addr, &ord->table1_size);
./drivers/net/wireless/ipw2x00/ipw2100.c:	read_nic_dword(priv->net_dev, ord->table2_addr, &ord->table2_size);
./drivers/net/wireless/ipw2x00/ipw2100.c:	ord->table2_size &= 0x0000FFFF;
./drivers/net/wireless/ipw2x00/ipw2100.c:	IPW_DEBUG_INFO("table 1 size: %d\n", ord->table1_size);
./drivers/net/wireless/ipw2x00/ipw2100.c:	IPW_DEBUG_INFO("table 2 size: %d\n", ord->table2_size);
./drivers/net/wireless/iwlegacy/iwl3945-base.c:	 * ucode filename and max sizes are card-specific. */
./drivers/net/lib8390.c:  This is not a complete driver, it must be combined with board-specific
./drivers/net/lib8390.c:/* These are the operational function interfaces to board-specific
./drivers/net/sgiseeq.c:	while (!(rd->rdma.cntinfo & HPCDMA_OWN)) {
./drivers/net/sgiseeq.c:		len = PKT_BUF_SZ - (rd->rdma.cntinfo & HPCDMA_BCNT) - 3;
./drivers/net/sgiseeq.c:		dma_unmap_single(dev->dev.parent, rd->rdma.pbuf,
./drivers/net/sgiseeq.c:		pkt_status = rd->skb->data[len];
./drivers/net/sgiseeq.c:			if (memcmp(rd->skb->data + 6, dev->dev_addr, ETH_ALEN)) {
./drivers/net/sgiseeq.c:					skb = rd->skb;
./drivers/net/sgiseeq.c:						skb_copy_to_linear_data(skb, rd->skb->data, len);
./drivers/net/sgiseeq.c:					newskb = rd->skb;
./drivers/net/sgiseeq.c:				newskb = rd->skb;
./drivers/net/sgiseeq.c:			newskb = rd->skb;
./drivers/net/sgiseeq.c:		rd->skb = newskb;
./drivers/net/sgiseeq.c:		rd->rdma.pbuf = dma_map_single(dev->dev.parent,
./drivers/net/sgiseeq.c:		rd->rdma.cntinfo = RCNTINFO_INIT;
./drivers/net/3c59x.c:II. Board-specific settings
./drivers/net/3c59x.c:	/* The Rx and Tx rings should be quad-word-aligned. */
./drivers/net/7990.c:             !((bits = rd->rmd1_bits) & LE_R1_OWN);
./drivers/net/7990.c:			int len = (rd->mblength & 0xfff) - 4;
./drivers/net/7990.c:                                rd->mblength = 0;
./drivers/net/7990.c:                                rd->rmd1_bits = LE_R1_OWN;
./drivers/net/7990.c:                rd->mblength = 0;
./drivers/net/7990.c:                rd->rmd1_bits = LE_R1_OWN;
./drivers/net/macsonic.c:		if (strstr(ndev->board->name, "DuoDock"))
./drivers/net/macsonic.c:		if (slots & (1<<ndev->board->slot))
./drivers/net/macsonic.c:		slots |= 1<<ndev->board->slot;
./drivers/net/macsonic.c:		base_addr = ndev->board->slot_addr + DUODOCK_SONIC_REGISTERS;
./drivers/net/macsonic.c:		prom_addr = ndev->board->slot_addr + DUODOCK_SONIC_PROM_BASE;
./drivers/net/macsonic.c:		base_addr = ndev->board->slot_addr + APPLE_SONIC_REGISTERS;
./drivers/net/macsonic.c:		prom_addr = ndev->board->slot_addr + APPLE_SONIC_PROM_BASE;
./drivers/net/macsonic.c:		base_addr = ndev->board->slot_addr + APPLE_SONIC_REGISTERS;
./drivers/net/macsonic.c:		prom_addr = ndev->board->slot_addr + APPLE_SONIC_PROM_BASE;
./drivers/net/macsonic.c:		base_addr = ndev->board->slot_addr + APPLE_SONIC_REGISTERS;
./drivers/net/macsonic.c:		prom_addr = ndev->board->slot_addr + DAYNALINK_PROM_BASE;
./drivers/net/macsonic.c:		base_addr = ndev->board->slot_addr + DAYNA_SONIC_REGISTERS;
./drivers/net/macsonic.c:		prom_addr = ndev->board->slot_addr + DAYNA_SONIC_MAC_ADDR;
./drivers/net/macsonic.c:	dev->irq = SLOT2IRQ(ndev->board->slot);
./drivers/net/macsonic.c:	       dev_name(lp->device), ndev->board->name, ndev->board->slot);
./drivers/net/wd.c:				/* Magic to set ASIC to word-wide mode. */
./drivers/net/tokenring/madgemc.c: * Read a word-length value from a register
./drivers/net/tokenring/madgemc.c: * Write a word-length value to a register.
./drivers/net/tokenring/madgemc.c:	card->arblevel = ((mdev->pos[0] >> 1) & 0x7) + 8;
./drivers/net/tokenring/madgemc.c:	card->burstmode = ((mdev->pos[2] >> 6) & 0x3);
./drivers/net/tokenring/madgemc.c:	card->fairness = ((mdev->pos[2] >> 4) & 0x1);
./drivers/net/tokenring/madgemc.c:		card->ringspeed = 2; /* not selected */
./drivers/net/tokenring/madgemc.c:		card->ringspeed = 1; /* 16Mb */
./drivers/net/tokenring/madgemc.c:		card->ringspeed = 0; /* 4Mb */
./drivers/net/tokenring/madgemc.c:		card->cabletype = 1; /* STP/DB9 */
./drivers/net/tokenring/madgemc.c:		card->cabletype = 0; /* UTP/RJ-45 */
./drivers/net/tokenring/madgemc.c:	if (card->manid != 0x4d) { /* something went wrong */
./drivers/net/tokenring/madgemc.c:		printk(KERN_INFO "%s: Madge MC ROM read failed (unknown manufacturer ID %02x)\n", dev->name, card->manid);
./drivers/net/tokenring/madgemc.c:	if ((card->cardtype != 0x08) && (card->cardtype != 0x0d)) {
./drivers/net/tokenring/madgemc.c:		printk(KERN_INFO "%s: Madge MC ROM read failed (unknown card ID %02x)\n", dev->name, card->cardtype);
./drivers/net/tokenring/madgemc.c:	if ((card->cardtype == 0x08) && (card->cardrev <= 0x01))
./drivers/net/tokenring/madgemc.c:		card->ramsize = 128;
./drivers/net/tokenring/madgemc.c:		card->ramsize = 256;
./drivers/net/tokenring/madgemc.c:	       (card->cardtype == 0x08)?MADGEMC16_CARDNAME:
./drivers/net/tokenring/madgemc.c:	       MADGEMC32_CARDNAME, card->cardrev, 
./drivers/net/tokenring/madgemc.c:	if (card->cardtype == 0x0d)
./drivers/net/tokenring/madgemc.c:	if (card->ringspeed==2) { /* Unknown */
./drivers/net/tokenring/madgemc.c:		card->ringspeed = 1; /* default to 16mb */
./drivers/net/tokenring/madgemc.c:	printk("%s:     RAM Size: %dKB\n", dev->name, card->ramsize);
./drivers/net/tokenring/madgemc.c:	       (card->ringspeed)?16:4, 
./drivers/net/tokenring/madgemc.c:	       card->cabletype?"STP/DB9":"UTP/RJ-45");
./drivers/net/tokenring/madgemc.c:	       card->arblevel);
./drivers/net/tokenring/madgemc.c:	switch(card->burstmode) {
./drivers/net/tokenring/madgemc.c:	printk(" (%s)\n", (card->fairness)?"Unfair":"Fair");
./drivers/net/tokenring/madgemc.c:	madgemc_setcabletype(dev, card->cabletype);
./drivers/net/tokenring/madgemc.c:	mca_device_set_name(mdev, (card->cardtype == 0x08)?MADGEMC16_CARDNAME:MADGEMC32_CARDNAME);
./drivers/net/tokenring/madgemc.c:	tp->DataRate = (card->ringspeed)?SPEED_16:SPEED_4;
./drivers/net/tokenring/madgemc.c:	card->manid = inb(ioaddr + MC_ROM_MANUFACTURERID);
./drivers/net/tokenring/madgemc.c:	card->cardtype = inb(ioaddr + MC_ROM_ADAPTERID);
./drivers/net/tokenring/madgemc.c:	card->cardrev = inb(ioaddr + MC_ROM_REVISION);
./drivers/net/tokenring/madgemc.c:		len += sprintf(buf+len, "Card Revision: %d\n", curcard->cardrev);
./drivers/net/tokenring/madgemc.c:		len += sprintf(buf+len, "RAM Size: %dkb\n", curcard->ramsize);
./drivers/net/tokenring/madgemc.c:		len += sprintf(buf+len, "Cable type: %s\n", (curcard->cabletype)?"STP/DB9":"UTP/RJ-45");
./drivers/net/tokenring/madgemc.c:		len += sprintf(buf+len, "Configured ring speed: %dMb/sec\n", (curcard->ringspeed)?16:4);
./drivers/net/tokenring/madgemc.c:		len += sprintf(buf+len, "Arbitration Level: %d\n", curcard->arblevel);
./drivers/net/tokenring/madgemc.c:		switch(curcard->burstmode) {
./drivers/net/tokenring/madgemc.c:		len += sprintf(buf+len, " (%s)\n", (curcard->fairness)?"Unfair":"Fair");
./drivers/net/arcnet/rfc1051.c:		hard->offset[0] = 0;
./drivers/net/arcnet/rfc1051.c:		hard->offset[1] = ofs = 512 - length;
./drivers/net/arcnet/rfc1051.c:		hard->offset[0] = 0;
./drivers/net/arcnet/rfc1051.c:		hard->offset[1] = ofs = 512 - length - 3;
./drivers/net/arcnet/rfc1051.c:		hard->offset[0] = ofs = 256 - length;
./drivers/net/arcnet/rfc1051.c:	lp->lastload_dest = hard->dest;
./drivers/net/arcnet/capmode.c:		hard->offset[0] = 0;
./drivers/net/arcnet/capmode.c:		hard->offset[1] = ofs = 512 - length;
./drivers/net/arcnet/capmode.c:		hard->offset[0] = 0;
./drivers/net/arcnet/capmode.c:		hard->offset[1] = ofs = 512 - length - 3;
./drivers/net/arcnet/capmode.c:		hard->offset[0] = ofs = 256 - length;
./drivers/net/arcnet/capmode.c:	lp->lastload_dest = hard->dest;
./drivers/net/arcnet/arc-rawmode.c:		hard->offset[0] = 0;
./drivers/net/arcnet/arc-rawmode.c:		hard->offset[1] = ofs = 512 - length;
./drivers/net/arcnet/arc-rawmode.c:		hard->offset[0] = 0;
./drivers/net/arcnet/arc-rawmode.c:		hard->offset[1] = ofs = 512 - length - 3;
./drivers/net/arcnet/arc-rawmode.c:		hard->offset[0] = ofs = 256 - length;
./drivers/net/arcnet/arc-rawmode.c:	lp->lastload_dest = hard->dest;
./drivers/net/arcnet/rfc1201.c:		hard->offset[0] = 0;
./drivers/net/arcnet/rfc1201.c:		hard->offset[1] = ofs = 512 - softlen;
./drivers/net/arcnet/rfc1201.c:		hard->offset[0] = 0;
./drivers/net/arcnet/rfc1201.c:		hard->offset[1] = ofs - RFC1201_HDR_SIZE;
./drivers/net/arcnet/rfc1201.c:		hard->offset[0] = ofs = 256 - softlen;
./drivers/net/arcnet/rfc1201.c:	lp->lastload_dest = hard->dest;
./drivers/net/wan/c101.c:	return card->page;
./drivers/net/wan/c101.c:	card->page = page;
./drivers/net/wan/c101.c:	writeb(page, card->win0base + C101_PAGE);
./drivers/net/wan/c101.c:	readb(card->win0base + C101_PAGE); /* Resets SCA? */
./drivers/net/wan/c101.c:	if (card->irq)
./drivers/net/wan/c101.c:		free_irq(card->irq, card);
./drivers/net/wan/c101.c:	if (card->win0base) {
./drivers/net/wan/c101.c:		iounmap(card->win0base);
./drivers/net/wan/c101.c:		release_mem_region(card->phy_winbase, C101_MAPPED_RAM_SIZE);
./drivers/net/wan/c101.c:	free_netdev(card->dev);
./drivers/net/wan/c101.c:	card->dev = alloc_hdlcdev(card);
./drivers/net/wan/c101.c:	if (!card->dev) {
./drivers/net/wan/c101.c:	card->irq = irq;
./drivers/net/wan/c101.c:	card->phy_winbase = winbase;
./drivers/net/wan/c101.c:	card->win0base = ioremap(winbase, C101_MAPPED_RAM_SIZE);
./drivers/net/wan/c101.c:	if (!card->win0base) {
./drivers/net/wan/c101.c:	card->tx_ring_buffers = TX_RING_BUFFERS;
./drivers/net/wan/c101.c:	card->rx_ring_buffers = RX_RING_BUFFERS;
./drivers/net/wan/c101.c:	card->buff_offset = C101_WINDOW_SIZE; /* Bytes 1D00-1FFF reserved */
./drivers/net/wan/c101.c:	readb(card->win0base + C101_PAGE); /* Resets SCA? */
./drivers/net/wan/c101.c:	writeb(0, card->win0base + C101_PAGE);
./drivers/net/wan/c101.c:	writeb(0, card->win0base + C101_DTR); /* Power-up for RAM? */
./drivers/net/wan/c101.c:	spin_lock_init(&card->lock);
./drivers/net/wan/c101.c:	card->settings.clock_type = CLOCK_EXT;
./drivers/net/wan/c101.c:	       dev->name, card->irq,
./drivers/net/wan/c101.c:	       card->tx_ring_buffers, card->rx_ring_buffers);
./drivers/net/wan/c101.c:	new_card = &card->next_card;
./drivers/net/wan/c101.c:		card = card->next_card;
./drivers/net/wan/sbni.c: *        - for them, optionally supported word-interchange on some chipsets,
./drivers/net/wan/hd64570.c:		u16 buffs = transmit ? card->tx_ring_buffers
./drivers/net/wan/hd64570.c:			: card->rx_ring_buffers;
./drivers/net/wan/pc300_tty.c:		spin_lock_irqsave(&card->card_lock, flags);	\
./drivers/net/wan/pc300_tty.c:		spin_unlock_irqrestore(&card->card_lock, flags);	\
./drivers/net/wan/pc300_tty.c:	cpc_writeb(card->hw.scabase + M_REG(CTL,ch), 
./drivers/net/wan/pc300_tty.c:		cpc_readb(card->hw.scabase+M_REG(CTL,ch))& signal);
./drivers/net/wan/pc300_tty.c:	cpc_writeb(card->hw.scabase + M_REG(CTL,ch), 
./drivers/net/wan/pc300_tty.c:		cpc_readb(card->hw.scabase+M_REG(CTL,ch))& ~signal);
./drivers/net/wan/pc300_tty.c:	if (cpc_readb(card->hw.scabase + M_REG(ST3,ch)) & ST3_DCD) { 
./drivers/net/wan/pc300_tty.c:		cpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_BUF_CLR); 
./drivers/net/wan/pc300_tty.c:		if (card->hw.type == PC300_TE) { 
./drivers/net/wan/pc300_tty.c:			cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2, 
./drivers/net/wan/pc300_tty.c:				cpc_readb(card->hw.falcbase + card->hw.cpld_reg2) & 
./drivers/net/wan/pc300_tty.c:	status = cpc_readb(card->hw.scabase+M_REG(CTL,ch));
./drivers/net/wan/pc300_tty.c:	ptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase + 
./drivers/net/wan/pc300_tty.c:		ptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase + cpc_readl(&ptdescr->next)); 
./drivers/net/wan/pc300_tty.c:	dsr_rx = cpc_readb(card->hw.scabase + DSR_RX(ch));
./drivers/net/wan/pc300_tty.c:		ptdescr = (pcsca_bd_t  __iomem *)(card->hw.rambase + RX_BD_ADDR(ch, first_bd));
./drivers/net/wan/pc300_tty.c:			ptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase+cpc_readl(&ptdescr->next));
./drivers/net/wan/pc300_tty.c:				cpc_writel(card->hw.scabase + DRX_REG(EDAL, ch), 
./drivers/net/wan/pc300_tty.c:		ptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase + 
./drivers/net/wan/pc300_tty.c:					(void __iomem *)(card->hw.rambase + 
./drivers/net/wan/pc300_tty.c:			ptdescr = (pcsca_bd_t __iomem *) (card->hw.rambase + 
./drivers/net/wan/pc300_tty.c:			cpc_writel(card->hw.scabase + DRX_REG(EDAL, ch), 
./drivers/net/wan/pc300_tty.c:	if (nbuf >= card->chan[ch].nfree_tx_bd) {
./drivers/net/wan/pc300_tty.c:		ptdescr = (pcsca_bd_t __iomem *)(card->hw.rambase + 
./drivers/net/wan/pc300_tty.c:			TX_BD_ADDR(ch, card->chan[ch].tx_next_bd));
./drivers/net/wan/pc300_tty.c:			memcpy_toio((void __iomem *)(card->hw.rambase + 
./drivers/net/wan/pc300_tty.c:			card->chan[ch].nfree_tx_bd--;
./drivers/net/wan/pc300_tty.c:		card->chan[ch].tx_next_bd = 
./drivers/net/wan/pc300_tty.c:			(card->chan[ch].tx_next_bd + 1) & (N_DMA_TX_BUF - 1);
./drivers/net/wan/pc300_tty.c:	cpc_writeb(card->hw.scabase + DTX_REG(EDAL, ch), 
./drivers/net/wan/pc300_tty.c:	cpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_ENA); 
./drivers/net/wan/pc300_tty.c:	cpc_writeb(card->hw.scabase + DSR_TX(ch), DSR_DE); 
./drivers/net/wan/pc300_tty.c:	if (card->hw.type == PC300_TE) { 
./drivers/net/wan/pc300_tty.c:		cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2, 
./drivers/net/wan/pc300_tty.c:			cpc_readb(card->hw.falcbase + card->hw.cpld_reg2) |
./drivers/net/wan/pc300_drv.c: * Driver load messages are now device-centric, instead of board-centric.
./drivers/net/wan/pc300_drv.c:		spin_lock_irqsave(&card->card_lock, flags);	\
./drivers/net/wan/pc300_drv.c:		spin_unlock_irqrestore(&card->card_lock, flags);	\
./drivers/net/wan/pc300_drv.c:	volatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase
./drivers/net/wan/pc300_drv.c:	volatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase
./drivers/net/wan/pc300_drv.c:	volatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase
./drivers/net/wan/pc300_drv.c:	volatile pcsca_bd_t __iomem *ptdescr = (card->hw.rambase
./drivers/net/wan/pc300_drv.c:	u16 first_bd = card->chan[ch].tx_first_bd;
./drivers/net/wan/pc300_drv.c:	u16 next_bd = card->chan[ch].tx_next_bd;
./drivers/net/wan/pc300_drv.c:	     ptdescr = (card->hw.rambase + TX_BD_ADDR(ch, first_bd));
./drivers/net/wan/pc300_drv.c:		 ptdescr = (card->hw.rambase + TX_BD_ADDR(ch, i))) {
./drivers/net/wan/pc300_drv.c:	u16 first_bd = card->chan[ch].tx_first_bd;
./drivers/net/wan/pc300_drv.c:	u16 next_bd = card->chan[ch].tx_next_bd;
./drivers/net/wan/pc300_drv.c:	u32 scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	printk ("\nnfree_tx_bd = %d\n", card->chan[ch].nfree_tx_bd);
./drivers/net/wan/pc300_drv.c:		ptdescr = (card->hw.rambase + TX_BD_ADDR(ch, i));
./drivers/net/wan/pc300_drv.c:	u16 first_bd = card->chan[ch].rx_first_bd;
./drivers/net/wan/pc300_drv.c:	u16 last_bd = card->chan[ch].rx_last_bd;
./drivers/net/wan/pc300_drv.c:	for (i = 0, ptdescr = (card->hw.rambase +
./drivers/net/wan/pc300_drv.c:	u16 first_bd = card->chan[ch].rx_first_bd;
./drivers/net/wan/pc300_drv.c:	ptdescr = (card->hw.rambase + RX_BD_ADDR(ch, first_bd));
./drivers/net/wan/pc300_drv.c:		if ((status & DST_EOM) || (first_bd == card->chan[ch].rx_last_bd)) {
./drivers/net/wan/pc300_drv.c:		ptdescr = (card->hw.rambase + cpc_readl(&ptdescr->next));
./drivers/net/wan/pc300_drv.c:	if (nbuf >= card->chan[ch].nfree_tx_bd) {
./drivers/net/wan/pc300_drv.c:		ptdescr = (card->hw.rambase +
./drivers/net/wan/pc300_drv.c:					  TX_BD_ADDR(ch, card->chan[ch].tx_next_bd));
./drivers/net/wan/pc300_drv.c:			memcpy_toio((card->hw.rambase + cpc_readl(&ptdescr->ptbuf)),
./drivers/net/wan/pc300_drv.c:			card->chan[ch].nfree_tx_bd--;
./drivers/net/wan/pc300_drv.c:		card->chan[ch].tx_next_bd =
./drivers/net/wan/pc300_drv.c:			(card->chan[ch].tx_next_bd + 1) & (N_DMA_TX_BUF - 1);
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	ptdescr = (card->hw.rambase +
./drivers/net/wan/pc300_drv.c:				ptdescr = (card->hw.rambase +
./drivers/net/wan/pc300_drv.c:				 (card->hw.rambase+cpc_readl(&ptdescr->ptbuf)),nchar);
./drivers/net/wan/pc300_drv.c:		ptdescr = (card->hw.rambase + cpc_readl(&ptdescr->next));
./drivers/net/wan/pc300_drv.c:		cpc_writel(card->hw.scabase + DRX_REG(EDAL, ch),
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:			       card->chan[ch].d.name, cmd);
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	u8 tshf = card->chan[ch].falc.offset;
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	u8 tshf = card->chan[ch].falc.offset;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,
./drivers/net/wan/pc300_drv.c:		   cpc_readb(card->hw.falcbase + card->hw.cpld_reg1) &
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,
./drivers/net/wan/pc300_drv.c:		   cpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:			cpc_writeb(falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:				   cpc_readb(falcbase + card->hw.cpld_reg2) |
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,
./drivers/net/wan/pc300_drv.c:		   cpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,
./drivers/net/wan/pc300_drv.c:		   cpc_readb(card->hw.falcbase + card->hw.cpld_reg1) &
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:		   cpc_readb(card->hw.falcbase + card->hw.cpld_reg2) |
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:			cpc_writeb(falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:				   cpc_readb(falcbase + card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:			cpc_writeb(falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:				   cpc_readb(falcbase + card->hw.cpld_reg2) |
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:		cpc_writeb(falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(falcbase + card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:		cpc_writeb(falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(falcbase + card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	cpc_writeb(falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:		   cpc_readb(falcbase + card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	if ((ilar = cpc_readb(card->hw.scabase + ILAR)) != 0) {
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.scabase + ILAR, ilar);
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.scabase + DMER, 0x80);
./drivers/net/wan/pc300_drv.c:	if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(card->hw.falcbase + card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:	} else if (cpc_readb(card->hw.scabase + M_REG(ST3, ch)) & ST3_DCD) {
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_BUF_CLR);
./drivers/net/wan/pc300_drv.c:		if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:			cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:				   cpc_readb(card->hw.falcbase + card->hw.cpld_reg2) & 
./drivers/net/wan/pc300_drv.c:	if (card->chan[ch].nfree_tx_bd <= 1) {
./drivers/net/wan/pc300_drv.c:	cpc_writel(card->hw.scabase + DTX_REG(EDAL, ch),
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_TX_ENA);
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.scabase + DSR_TX(ch), DSR_DE);
./drivers/net/wan/pc300_drv.c:	if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(card->hw.falcbase + card->hw.cpld_reg2) |
./drivers/net/wan/pc300_drv.c:	ptdescr = (card->hw.rambase +
./drivers/net/wan/pc300_drv.c:	while ((cpc_readl(card->hw.scabase + DTX_REG(CDAL,ch)) !=
./drivers/net/wan/pc300_drv.c:		ptdescr = (card->hw.rambase + TX_BD_ADDR(ch,chan->tx_first_bd));
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:		for (ch = 0; ch < card->hw.nchan; ch++) {
./drivers/net/wan/pc300_drv.c:			pc300ch_t *chan = &card->chan[ch];
./drivers/net/wan/pc300_drv.c:			spin_lock(&card->card_lock);
./drivers/net/wan/pc300_drv.c:						if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:							cpc_writeb(card->hw.falcbase +
./drivers/net/wan/pc300_drv.c:								   card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:								   cpc_readb (card->hw.falcbase +
./drivers/net/wan/pc300_drv.c:								    	card->hw.cpld_reg2) |
./drivers/net/wan/pc300_drv.c:						if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:							cpc_writeb(card->hw.falcbase +
./drivers/net/wan/pc300_drv.c:								   card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:								   cpc_readb (card->hw.falcbase +
./drivers/net/wan/pc300_drv.c:								    		card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:						if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:							cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:								   cpc_readb (card->hw.falcbase + 
./drivers/net/wan/pc300_drv.c:										   card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:						if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:							cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:								   cpc_readb (card->hw.falcbase +
./drivers/net/wan/pc300_drv.c:								    			card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:						card->chan[ch].d.line_off++;
./drivers/net/wan/pc300_drv.c:						card->chan[ch].d.line_on++;
./drivers/net/wan/pc300_drv.c:			spin_unlock(&card->card_lock);
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = (pc300ch_t *) & card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *falcbase = card->hw.falcbase;
./drivers/net/wan/pc300_drv.c:	for (ch = 0; ch < card->hw.nchan; ch++) {
./drivers/net/wan/pc300_drv.c:		pc300ch_t *chan = &card->chan[ch];
./drivers/net/wan/pc300_drv.c:	if (!card->hw.rambase) {
./drivers/net/wan/pc300_drv.c:	switch (card->hw.type) {
./drivers/net/wan/pc300_drv.c:			while ( (plx_status = (cpc_readb(card->hw.plxbase + card->hw.intctl_reg) &
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	pc300ch_t *chan = &card->chan[ch];
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:			memcpy(&conf_aux.hw, &card->hw, sizeof(pc300hw_t));
./drivers/net/wan/pc300_drv.c:			if (card->hw.cpld_id < 0x02 &&
./drivers/net/wan/pc300_drv.c:					if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:					pc300stats.hw_type = card->hw.type;
./drivers/net/wan/pc300_drv.c:					pc300stats.line_on = card->chan[ch].d.line_on;
./drivers/net/wan/pc300_drv.c:					pc300stats.line_off = card->chan[ch].d.line_off;
./drivers/net/wan/pc300_drv.c:					if (card->hw.type == PC300_TE)
./drivers/net/wan/pc300_drv.c:				pc300status.hw_type = card->hw.type;
./drivers/net/wan/pc300_drv.c:				if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:				if (card->hw.type != PC300_TE)
./drivers/net/wan/pc300_drv.c:				if (card->hw.type != PC300_TE)
./drivers/net/wan/pc300_drv.c:				if (card->hw.cpld_id < 0x02) {
./drivers/net/wan/pc300_drv.c:						cpc_writeb(card->hw.scabase + M_REG(MD2, ch),
./drivers/net/wan/pc300_drv.c:							cpc_readb(card->hw.scabase + M_REG(MD2, ch)) | 
./drivers/net/wan/pc300_drv.c:						cpc_writeb(card->hw.scabase + M_REG(MD2, ch),
./drivers/net/wan/pc300_drv.c:							cpc_readb(card->hw.scabase + M_REG(MD2, ch)) | 
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	void __iomem *plxbase = card->hw.plxbase;
./drivers/net/wan/pc300_drv.c:	switch (card->hw.type) {
./drivers/net/wan/pc300_drv.c:				cpc_writel((plxbase + card->hw.gpioc_reg),
./drivers/net/wan/pc300_drv.c:					   cpc_readl(plxbase + card->hw.gpioc_reg) | PC300_CHMEDIA_MASK(ch));
./drivers/net/wan/pc300_drv.c:				cpc_writel((plxbase + card->hw.gpioc_reg),
./drivers/net/wan/pc300_drv.c:					   cpc_readl(plxbase + card->hw.gpioc_reg) & ~PC300_CHMEDIA_MASK(ch));
./drivers/net/wan/pc300_drv.c:	switch (card->hw.type) {
./drivers/net/wan/pc300_drv.c:				tmc = clock_rate_calc(clkrate, card->hw.clock, &br);
./drivers/net/wan/pc300_drv.c:	    			if (card->hw.type == PC300_X21) {
./drivers/net/wan/pc300_drv.c:				if (card->hw.type == PC300_X21) {
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:	void __iomem *scabase = card->hw.scabase;
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.scabase + M_REG(CMD, ch), CMD_CH_RST);
./drivers/net/wan/pc300_drv.c:	if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.falcbase + card->hw.cpld_reg2,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(card->hw.falcbase + card->hw.cpld_reg2) &
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(card->hw.falcbase + card->hw.cpld_reg1) &
./drivers/net/wan/pc300_drv.c:	void __iomem *rambase = card->hw.rambase;
./drivers/net/wan/pc300_drv.c:	card->hw.ramsize = PC300_RAMSIZE;
./drivers/net/wan/pc300_drv.c:	for (i = 0; i < card->hw.ramsize; i++) {
./drivers/net/wan/pc300_drv.c:	struct RUNTIME_9050 __iomem *plx_ctl = card->hw.plxbase;
./drivers/net/wan/pc300_drv.c:	cpc_writew(card->hw.plxbase + card->hw.intctl_reg,
./drivers/net/wan/pc300_drv.c:		   cpc_readw(card->hw.plxbase + card->hw.intctl_reg) | 0x0040);
./drivers/net/wan/pc300_drv.c:	cpc_writel(card->hw.plxbase + card->hw.gpioc_reg,
./drivers/net/wan/pc300_drv.c:		   cpc_readl(card->hw.plxbase + card->hw.gpioc_reg) | 0x00000004UL);
./drivers/net/wan/pc300_drv.c:	card->hw.clock = PC300_PCI_CLOCK;
./drivers/net/wan/pc300_drv.c:	cpc_writel(card->hw.plxbase + card->hw.gpioc_reg,
./drivers/net/wan/pc300_drv.c:		   cpc_readl(card->hw.plxbase + card->hw.gpioc_reg) & ~0x00000004UL);
./drivers/net/wan/pc300_drv.c:	card->hw.clock = PC300_OSC_CLOCK;
./drivers/net/wan/pc300_drv.c:	card->hw.ramsize = detect_ram(card);
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.scabase + PCR, PCR_PR2);
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.scabase + BTCR, 0x10);
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.scabase + WCRL, 0);
./drivers/net/wan/pc300_drv.c:	cpc_writeb(card->hw.scabase + DMER, 0x80);
./drivers/net/wan/pc300_drv.c:	if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:		reg1 = cpc_readb(card->hw.falcbase + CPLD_REG1);
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.falcbase + CPLD_REG1, (reg1 + 0x5a));
./drivers/net/wan/pc300_drv.c:		if (cpc_readb(card->hw.falcbase + CPLD_REG1) == reg1) {
./drivers/net/wan/pc300_drv.c:			card->hw.cpld_id = cpc_readb(card->hw.falcbase + CPLD_ID_REG);
./drivers/net/wan/pc300_drv.c:			card->hw.cpld_reg1 = CPLD_V2_REG1;
./drivers/net/wan/pc300_drv.c:			card->hw.cpld_reg2 = CPLD_V2_REG2;
./drivers/net/wan/pc300_drv.c:			card->hw.cpld_id = 0;
./drivers/net/wan/pc300_drv.c:			card->hw.cpld_reg1 = CPLD_REG1;
./drivers/net/wan/pc300_drv.c:			card->hw.cpld_reg2 = CPLD_REG2;
./drivers/net/wan/pc300_drv.c:			cpc_writeb(card->hw.falcbase + CPLD_REG1, reg1);
./drivers/net/wan/pc300_drv.c:		cpc_writeb(card->hw.falcbase + card->hw.cpld_reg1,
./drivers/net/wan/pc300_drv.c:			   cpc_readb(card->hw.falcbase + card->hw.cpld_reg1) |
./drivers/net/wan/pc300_drv.c:	for (i = 0; i < card->hw.nchan; i++) {
./drivers/net/wan/pc300_drv.c:		pc300ch_t *chan = &card->chan[i];
./drivers/net/wan/pc300_drv.c:		switch (card->hw.type) {
./drivers/net/wan/pc300_drv.c:		dev->mem_start = card->hw.ramphys;
./drivers/net/wan/pc300_drv.c:		dev->mem_end = card->hw.ramphys + card->hw.ramsize - 1;
./drivers/net/wan/pc300_drv.c:		dev->irq = card->hw.irq;
./drivers/net/wan/pc300_drv.c:			switch (card->hw.type) {
./drivers/net/wan/pc300_drv.c:					if (card->hw.bus == PC300_PMC) {
./drivers/net/wan/pc300_drv.c:				 board_nbr, card->hw.ramsize / 1024,
./drivers/net/wan/pc300_drv.c:				 card->hw.ramphys, card->hw.irq, i + 1);
./drivers/net/wan/pc300_drv.c:				 i + 1, card->hw.ramphys);
./drivers/net/wan/pc300_drv.c:	spin_lock_init(&card->card_lock);
./drivers/net/wan/pc300_drv.c:	card->hw.irq = pdev->irq;
./drivers/net/wan/pc300_drv.c:	card->hw.iophys = pci_resource_start(pdev, 1);
./drivers/net/wan/pc300_drv.c:	card->hw.iosize = pci_resource_len(pdev, 1);
./drivers/net/wan/pc300_drv.c:	card->hw.scaphys = pci_resource_start(pdev, 2);
./drivers/net/wan/pc300_drv.c:	card->hw.scasize = pci_resource_len(pdev, 2);
./drivers/net/wan/pc300_drv.c:	card->hw.ramphys = pci_resource_start(pdev, 3);
./drivers/net/wan/pc300_drv.c:	card->hw.alloc_ramsize = pci_resource_len(pdev, 3);
./drivers/net/wan/pc300_drv.c:	card->hw.falcphys = pci_resource_start(pdev, 4);
./drivers/net/wan/pc300_drv.c:	card->hw.falcsize = pci_resource_len(pdev, 4);
./drivers/net/wan/pc300_drv.c:	card->hw.plxphys = pci_resource_start(pdev, 5);
./drivers/net/wan/pc300_drv.c:	card->hw.plxsize = pci_resource_len(pdev, 5);
./drivers/net/wan/pc300_drv.c:			card->hw.nchan = 1;
./drivers/net/wan/pc300_drv.c:			card->hw.nchan = PC300_MAXCHAN;
./drivers/net/wan/pc300_drv.c:	printk("rev_id=%d) IRQ%d\n", pdev->revision, card->hw.irq);
./drivers/net/wan/pc300_drv.c:	       card->hw.ramphys, card->hw.plxphys, card->hw.scaphys,
./drivers/net/wan/pc300_drv.c:	       card->hw.falcphys);
./drivers/net/wan/pc300_drv.c:	if (!request_region(card->hw.iophys, card->hw.iosize, "PLX Registers")) {
./drivers/net/wan/pc300_drv.c:		       "at 0x%08x!\n", card->hw.ramphys);
./drivers/net/wan/pc300_drv.c:	if (card->hw.plxphys) {
./drivers/net/wan/pc300_drv.c:		pci_write_config_dword(pdev, PCI_BASE_ADDRESS_0, card->hw.plxphys);
./drivers/net/wan/pc300_drv.c:		card->hw.plxphys = pci_resource_start(pdev, 0);
./drivers/net/wan/pc300_drv.c:		card->hw.plxsize = pci_resource_len(pdev, 0);
./drivers/net/wan/pc300_drv.c:	if (!request_mem_region(card->hw.plxphys, card->hw.plxsize,
./drivers/net/wan/pc300_drv.c:		       card->hw.ramphys);
./drivers/net/wan/pc300_drv.c:	if (!request_mem_region(card->hw.ramphys, card->hw.alloc_ramsize,
./drivers/net/wan/pc300_drv.c:		       card->hw.ramphys);
./drivers/net/wan/pc300_drv.c:	if (!request_mem_region(card->hw.scaphys, card->hw.scasize,
./drivers/net/wan/pc300_drv.c:		       card->hw.ramphys);
./drivers/net/wan/pc300_drv.c:	card->hw.plxbase = ioremap(card->hw.plxphys, card->hw.plxsize);
./drivers/net/wan/pc300_drv.c:	card->hw.rambase = ioremap(card->hw.ramphys, card->hw.alloc_ramsize);
./drivers/net/wan/pc300_drv.c:	card->hw.scabase = ioremap(card->hw.scaphys, card->hw.scasize);
./drivers/net/wan/pc300_drv.c:			request_mem_region(card->hw.falcphys, card->hw.falcsize,
./drivers/net/wan/pc300_drv.c:			card->hw.falcbase = ioremap(card->hw.falcphys, card->hw.falcsize);
./drivers/net/wan/pc300_drv.c:			card->hw.falcbase = NULL;
./drivers/net/wan/pc300_drv.c:	       card->hw.rambase, card->hw.plxbase, card->hw.scabase,
./drivers/net/wan/pc300_drv.c:	       card->hw.falcbase);
./drivers/net/wan/pc300_drv.c:			card->hw.type = PC300_TE;
./drivers/net/wan/pc300_drv.c:				card->hw.bus = PC300_PMC;
./drivers/net/wan/pc300_drv.c:				card->hw.gpioc_reg = 0x54;
./drivers/net/wan/pc300_drv.c:				card->hw.intctl_reg = 0x4c;
./drivers/net/wan/pc300_drv.c:				card->hw.bus = PC300_PCI;
./drivers/net/wan/pc300_drv.c:				card->hw.gpioc_reg = 0x50;
./drivers/net/wan/pc300_drv.c:				card->hw.intctl_reg = 0x4c;
./drivers/net/wan/pc300_drv.c:			card->hw.bus = PC300_PCI;
./drivers/net/wan/pc300_drv.c:			card->hw.gpioc_reg = 0x50;
./drivers/net/wan/pc300_drv.c:			card->hw.intctl_reg = 0x4c;
./drivers/net/wan/pc300_drv.c:			if ((cpc_readl(card->hw.plxbase + card->hw.gpioc_reg) & PC300_CTYPE_MASK)) {
./drivers/net/wan/pc300_drv.c:				card->hw.type = PC300_X21;
./drivers/net/wan/pc300_drv.c:				card->hw.type = PC300_RSV;
./drivers/net/wan/pc300_drv.c:	if (request_irq(card->hw.irq, cpc_intr, IRQF_SHARED, "Cyclades-PC300", card)) {
./drivers/net/wan/pc300_drv.c:			 card->hw.ramphys, card->hw.irq);
./drivers/net/wan/pc300_drv.c:	iounmap(card->hw.plxbase);
./drivers/net/wan/pc300_drv.c:	iounmap(card->hw.scabase);
./drivers/net/wan/pc300_drv.c:	iounmap(card->hw.rambase);
./drivers/net/wan/pc300_drv.c:	if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:		iounmap(card->hw.falcbase);
./drivers/net/wan/pc300_drv.c:		release_mem_region(card->hw.falcphys, card->hw.falcsize);
./drivers/net/wan/pc300_drv.c:	release_mem_region(card->hw.scaphys, card->hw.scasize);
./drivers/net/wan/pc300_drv.c:	release_mem_region(card->hw.ramphys, card->hw.alloc_ramsize);
./drivers/net/wan/pc300_drv.c:	release_mem_region(card->hw.plxphys, card->hw.plxsize);
./drivers/net/wan/pc300_drv.c:	release_region(card->hw.iophys, card->hw.iosize);
./drivers/net/wan/pc300_drv.c:	if (card->hw.rambase) {
./drivers/net/wan/pc300_drv.c:		cpc_writew(card->hw.plxbase + card->hw.intctl_reg,
./drivers/net/wan/pc300_drv.c:			   cpc_readw(card->hw.plxbase + card->hw.intctl_reg) & ~(0x0040));
./drivers/net/wan/pc300_drv.c:		for (i = 0; i < card->hw.nchan; i++) {
./drivers/net/wan/pc300_drv.c:			unregister_hdlc_device(card->chan[i].d.dev);
./drivers/net/wan/pc300_drv.c:		iounmap(card->hw.plxbase);
./drivers/net/wan/pc300_drv.c:		iounmap(card->hw.scabase);
./drivers/net/wan/pc300_drv.c:		iounmap(card->hw.rambase);
./drivers/net/wan/pc300_drv.c:		release_mem_region(card->hw.plxphys, card->hw.plxsize);
./drivers/net/wan/pc300_drv.c:		release_mem_region(card->hw.ramphys, card->hw.alloc_ramsize);
./drivers/net/wan/pc300_drv.c:		release_mem_region(card->hw.scaphys, card->hw.scasize);
./drivers/net/wan/pc300_drv.c:		release_region(card->hw.iophys, card->hw.iosize);
./drivers/net/wan/pc300_drv.c:		if (card->hw.type == PC300_TE) {
./drivers/net/wan/pc300_drv.c:			iounmap(card->hw.falcbase);
./drivers/net/wan/pc300_drv.c:			release_mem_region(card->hw.falcphys, card->hw.falcsize);
./drivers/net/wan/pc300_drv.c:		for (i = 0; i < card->hw.nchan; i++)
./drivers/net/wan/pc300_drv.c:			if (card->chan[i].d.dev)
./drivers/net/wan/pc300_drv.c:				free_netdev(card->chan[i].d.dev);
./drivers/net/wan/pc300_drv.c:		if (card->hw.irq)
./drivers/net/wan/pc300_drv.c:			free_irq(card->hw.irq, card);
./drivers/net/wan/n2.c:	return inb(card->io + N2_PSR) & PSR_PAGEBITS;
./drivers/net/wan/n2.c:	u8 psr = inb(card->io + N2_PSR);
./drivers/net/wan/n2.c:	outb((psr & ~PSR_PAGEBITS) | page, card->io + N2_PSR);
./drivers/net/wan/n2.c:	int io = card->io;
./drivers/net/wan/n2.c:	int io = port->card->io;
./drivers/net/wan/n2.c:	int io = port->card->io;
./drivers/net/wan/n2.c:		if (card->ports[cnt].card) {
./drivers/net/wan/n2.c:			struct net_device *dev = port_to_dev(&card->ports[cnt]);
./drivers/net/wan/n2.c:	if (card->irq)
./drivers/net/wan/n2.c:		free_irq(card->irq, card);
./drivers/net/wan/n2.c:	if (card->winbase) {
./drivers/net/wan/n2.c:		iounmap(card->winbase);
./drivers/net/wan/n2.c:		release_mem_region(card->phy_winbase, USE_WINDOWSIZE);
./drivers/net/wan/n2.c:	if (card->io)
./drivers/net/wan/n2.c:		release_region(card->io, N2_IOPORTS);
./drivers/net/wan/n2.c:	if (card->ports[0].dev)
./drivers/net/wan/n2.c:		free_netdev(card->ports[0].dev);
./drivers/net/wan/n2.c:	if (card->ports[1].dev)
./drivers/net/wan/n2.c:		free_netdev(card->ports[1].dev);
./drivers/net/wan/n2.c:	card->ports[0].dev = alloc_hdlcdev(&card->ports[0]);
./drivers/net/wan/n2.c:	card->ports[1].dev = alloc_hdlcdev(&card->ports[1]);
./drivers/net/wan/n2.c:	if (!card->ports[0].dev || !card->ports[1].dev) {
./drivers/net/wan/n2.c:	card->io = io;
./drivers/net/wan/n2.c:	card->irq = irq;
./drivers/net/wan/n2.c:	card->phy_winbase = winbase;
./drivers/net/wan/n2.c:	card->winbase = ioremap(winbase, USE_WINDOWSIZE);
./drivers/net/wan/n2.c:	if (!card->winbase) {
./drivers/net/wan/n2.c:	card->ram_size = sca_detect_ram(card, card->winbase, MAX_RAM_SIZE);
./drivers/net/wan/n2.c:	i = card->ram_size / ((valid0 + valid1) * (sizeof(pkt_desc) +
./drivers/net/wan/n2.c:	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
./drivers/net/wan/n2.c:	card->rx_ring_buffers = i - card->tx_ring_buffers;
./drivers/net/wan/n2.c:	card->buff_offset = (valid0 + valid1) * sizeof(pkt_desc) *
./drivers/net/wan/n2.c:		(card->tx_ring_buffers + card->rx_ring_buffers);
./drivers/net/wan/n2.c:	       "using %u TX + %u RX packets rings\n", card->ram_size / 1024,
./drivers/net/wan/n2.c:	       card->irq, card->tx_ring_buffers, card->rx_ring_buffers);
./drivers/net/wan/n2.c:	if (card->tx_ring_buffers < 1) {
./drivers/net/wan/n2.c:		port_t *port = &card->ports[cnt];
./drivers/net/wan/n2.c:	new_card = &card->next_card;
./drivers/net/wan/n2.c:		card = card->next_card;
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		    (card->device, PCI_INTERRUPT_LINE, &interrupt_line_register)) {
./drivers/net/wan/farsync.c:		outw(0x440f, card->pci_conf + CNTRL_9054 + 2);
./drivers/net/wan/farsync.c:		outw(0x040f, card->pci_conf + CNTRL_9054 + 2);
./drivers/net/wan/farsync.c:		outw(0x240f, card->pci_conf + CNTRL_9054 + 2);
./drivers/net/wan/farsync.c:		outw(0x040f, card->pci_conf + CNTRL_9054 + 2);
./drivers/net/wan/farsync.c:		    (card->device, PCI_INTERRUPT_LINE, interrupt_line_register)) {
./drivers/net/wan/farsync.c:		regval = inl(card->pci_conf + CNTRL_9052);
./drivers/net/wan/farsync.c:		outl(regval | 0x40000000, card->pci_conf + CNTRL_9052);
./drivers/net/wan/farsync.c:		outl(regval & ~0x40000000, card->pci_conf + CNTRL_9052);
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		(void) readb(card->mem);
./drivers/net/wan/farsync.c:		outw(0x040e, card->pci_conf + CNTRL_9054 + 2);
./drivers/net/wan/farsync.c:		outw(0x040f, card->pci_conf + CNTRL_9054 + 2);
./drivers/net/wan/farsync.c:		(void) readb(card->ctlmem);
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		(void) readb(card->ctlmem);
./drivers/net/wan/farsync.c:		outw(0x0543, card->pci_conf + INTCSR_9052);
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		outl(0x0f0c0900, card->pci_conf + INTCSR_9054);
./drivers/net/wan/farsync.c:		outw(0x0543, card->pci_conf + INTCSR_9052);
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		outl(0x00000000, card->pci_conf + INTCSR_9054);
./drivers/net/wan/farsync.c:		outw(0x0000, card->pci_conf + INTCSR_9052);
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:	        pci_set_master(card->device);
./drivers/net/wan/farsync.c:		outl(0x00020441, card->pci_conf + DMAMODE0);
./drivers/net/wan/farsync.c:		outl(0x00020441, card->pci_conf + DMAMODE1);
./drivers/net/wan/farsync.c:		outl(0x0, card->pci_conf + DMATHR);
./drivers/net/wan/farsync.c:	memcpy(skb_put(skb, len), card->rx_dma_handle_host, len);
./drivers/net/wan/farsync.c:	if (card->dmarx_in_progress) {
./drivers/net/wan/farsync.c:	outl(skb, card->pci_conf + DMAPADR0);	/* Copy to here */
./drivers/net/wan/farsync.c:	outl(mem, card->pci_conf + DMALADR0);	/* from here */
./drivers/net/wan/farsync.c:	outl(len, card->pci_conf + DMASIZ0);	/* for this length */
./drivers/net/wan/farsync.c:	outl(0x00000000c, card->pci_conf + DMADPR0);	/* In this direction */
./drivers/net/wan/farsync.c:	card->dmarx_in_progress = 1;
./drivers/net/wan/farsync.c:	outb(0x03, card->pci_conf + DMACSR0);	/* Start the transfer */
./drivers/net/wan/farsync.c:	if (card->dmatx_in_progress) {
./drivers/net/wan/farsync.c:	outl((unsigned long) skb, card->pci_conf + DMAPADR1);	/* Copy from here */
./drivers/net/wan/farsync.c:	outl((unsigned long) mem, card->pci_conf + DMALADR1);	/* to here */
./drivers/net/wan/farsync.c:	outl(len, card->pci_conf + DMASIZ1);	/* for this length */
./drivers/net/wan/farsync.c:	outl(0x000000004, card->pci_conf + DMADPR1);	/* In this direction */
./drivers/net/wan/farsync.c:	card->dmatx_in_progress = 1;
./drivers/net/wan/farsync.c:	outb(0x03, card->pci_conf + DMACSR1);	/* Start the transfer */
./drivers/net/wan/farsync.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:		spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:		spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:		    card->card_no, port->index, rxp);
./drivers/net/wan/farsync.c:		    card->card_no, port->index);
./drivers/net/wan/farsync.c:		    card->card_no, port->index);
./drivers/net/wan/farsync.c:		    len, card->card_no, port->index);
./drivers/net/wan/farsync.c:	if (card->dmarx_in_progress) {
./drivers/net/wan/farsync.c:		       card->card_no, port->index);
./drivers/net/wan/farsync.c:	if ((len < FST_MIN_DMA_LEN) || (card->family == FST_FAMILY_TXP)) {
./drivers/net/wan/farsync.c:			      card->mem + BUF_OFFSET(rxBuffer[pi][rxp][0]),
./drivers/net/wan/farsync.c:		card->dma_skb_rx = skb;
./drivers/net/wan/farsync.c:		card->dma_port_rx = port;
./drivers/net/wan/farsync.c:		card->dma_len_rx = len;
./drivers/net/wan/farsync.c:		card->dma_rxpos = rxp;
./drivers/net/wan/farsync.c:		fst_rx_dma(card, card->rx_dma_handle_card,
./drivers/net/wan/farsync.c:	for (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {
./drivers/net/wan/farsync.c:		       !(card->dmatx_in_progress)) {
./drivers/net/wan/farsync.c:			spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:			spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:				spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:				spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:				    (card->family == FST_FAMILY_TXP)) {
./drivers/net/wan/farsync.c:					memcpy_toio(card->mem +
./drivers/net/wan/farsync.c:					memcpy(card->tx_dma_handle_host,
./drivers/net/wan/farsync.c:					card->dma_port_tx = port;
./drivers/net/wan/farsync.c:					card->dma_len_tx = skb->len;
./drivers/net/wan/farsync.c:					card->dma_txpos = port->txpos;
./drivers/net/wan/farsync.c:						   (char *) card->
./drivers/net/wan/farsync.c:	for (pi = 0, port = card->ports; pi < card->nports; pi++, port++) {
./drivers/net/wan/farsync.c:			 & DMA_OWN) && !(card->dmarx_in_progress)) {
./drivers/net/wan/farsync.c:				fst_q_work_item(&fst_work_intq, card->card_no);
./drivers/net/wan/farsync.c:	dbg(DBG_INTR, "intr: %d %p\n", card->irq, card);
./drivers/net/wan/farsync.c:	if (card->state != FST_RUNNING) {
./drivers/net/wan/farsync.c:		       card->card_no, card->state);
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		dma_intcsr = inl(card->pci_conf + INTCSR_9054);
./drivers/net/wan/farsync.c:			outb(0x8, card->pci_conf + DMACSR0);
./drivers/net/wan/farsync.c:			fst_rx_dma_complete(card, card->dma_port_rx,
./drivers/net/wan/farsync.c:					    card->dma_len_rx, card->dma_skb_rx,
./drivers/net/wan/farsync.c:					    card->dma_rxpos);
./drivers/net/wan/farsync.c:			card->dmarx_in_progress = 0;
./drivers/net/wan/farsync.c:			outb(0x8, card->pci_conf + DMACSR1);
./drivers/net/wan/farsync.c:			fst_tx_dma_complete(card, card->dma_port_tx,
./drivers/net/wan/farsync.c:					    card->dma_len_tx, card->dma_txpos);
./drivers/net/wan/farsync.c:			card->dmatx_in_progress = 0;
./drivers/net/wan/farsync.c:		    card->card_no, int_retry_count);
./drivers/net/wan/farsync.c:	fst_q_work_item(&fst_work_intq, card->card_no);
./drivers/net/wan/farsync.c:		port = &card->ports[event & 0x03];
./drivers/net/wan/farsync.c:			    card->card_no, port->index);
./drivers/net/wan/farsync.c:			card->state = FST_IFAILED;
./drivers/net/wan/farsync.c:		card->state = FST_BADVERSION;
./drivers/net/wan/farsync.c:		card->state = FST_BADVERSION;
./drivers/net/wan/farsync.c:		card->state = FST_RUNNING;
./drivers/net/wan/farsync.c:		card->state = FST_HALTED;
./drivers/net/wan/farsync.c:		card->state = FST_HALTED;
./drivers/net/wan/farsync.c:	if (FST_RDL(card, numberOfPorts) != card->nports) {
./drivers/net/wan/farsync.c:			   card->card_no,
./drivers/net/wan/farsync.c:			   FST_RDL(card, numberOfPorts), card->nports);
./drivers/net/wan/farsync.c:	info->nports = card->nports;
./drivers/net/wan/farsync.c:	info->type = card->type;
./drivers/net/wan/farsync.c:	info->state = card->state;
./drivers/net/wan/farsync.c:	info->valid = ((card->state == FST_RUNNING) ? FSTVAL_ALL : FSTVAL_CARD)
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:	if (card->type == FST_TYPE_TE1) {
./drivers/net/wan/farsync.c:		card->state = FST_RESET;
./drivers/net/wan/farsync.c:		card->state = FST_STARTING;
./drivers/net/wan/farsync.c:		memcpy_toio(card->mem + wrthdr.offset, buf, wrthdr.size);
./drivers/net/wan/farsync.c:		if (card->state == FST_RESET) {
./drivers/net/wan/farsync.c:			card->state = FST_DOWNLOAD;
./drivers/net/wan/farsync.c:		if (card->state == FST_STARTING) {
./drivers/net/wan/farsync.c:			if (card->state == FST_RUNNING) {
./drivers/net/wan/farsync.c:				spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:				spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:		if (card->state != FST_RUNNING) {
./drivers/net/wan/farsync.c:			       card->card_no, card->state);
./drivers/net/wan/farsync.c:	if (port->card->state == FST_RUNNING) {
./drivers/net/wan/farsync.c:	if (port->card->state == FST_RUNNING) {
./drivers/net/wan/farsync.c:	tx_dma_done = inb(card->pci_conf + DMACSR1);
./drivers/net/wan/farsync.c:	rx_dma_done = inb(card->pci_conf + DMACSR0);
./drivers/net/wan/farsync.c:	    card->dmatx_in_progress, tx_dma_done, card->dmarx_in_progress,
./drivers/net/wan/farsync.c:	    card->card_no, port->index);
./drivers/net/wan/farsync.c:		    card->card_no, port->index);
./drivers/net/wan/farsync.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:		    card->card_no, port->index);
./drivers/net/wan/farsync.c:	spin_lock_irqsave(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	spin_unlock_irqrestore(&card->card_lock, flags);
./drivers/net/wan/farsync.c:	fst_q_work_item(&fst_work_txq, card->card_no);
./drivers/net/wan/farsync.c:	for (i = 0; i < card->nports; i++) {
./drivers/net/wan/farsync.c:                err = register_hdlc_device(card->ports[i].dev);
./drivers/net/wan/farsync.c:			for (j = i; j < card->nports; j++) {
./drivers/net/wan/farsync.c:				free_netdev(card->ports[j].dev);
./drivers/net/wan/farsync.c:				card->ports[j].dev = NULL;
./drivers/net/wan/farsync.c:                        card->nports = i;
./drivers/net/wan/farsync.c:		port_to_dev(&card->ports[0])->name,
./drivers/net/wan/farsync.c:		port_to_dev(&card->ports[card->nports - 1])->name,
./drivers/net/wan/farsync.c:		type_strings[card->type], card->irq, card->nports);
./drivers/net/wan/farsync.c:	card->pci_conf = pci_resource_start(pdev, 1);
./drivers/net/wan/farsync.c:	card->phys_mem = pci_resource_start(pdev, 2);
./drivers/net/wan/farsync.c:	card->phys_ctlmem = pci_resource_start(pdev, 3);
./drivers/net/wan/farsync.c:	if ((card->mem = ioremap(card->phys_mem, FST_MEMSIZE)) == NULL) {
./drivers/net/wan/farsync.c:	if ((card->ctlmem = ioremap(card->phys_ctlmem, 0x10)) == NULL) {
./drivers/net/wan/farsync.c:	dbg(DBG_PCI, "kernel mem %p, ctlmem %p\n", card->mem, card->ctlmem);
./drivers/net/wan/farsync.c:		pr_err("Unable to register interrupt %d\n", card->irq);
./drivers/net/wan/farsync.c:		iounmap(card->ctlmem);
./drivers/net/wan/farsync.c:		iounmap(card->mem);
./drivers/net/wan/farsync.c:	card->irq = pdev->irq;
./drivers/net/wan/farsync.c:	card->type = ent->driver_data;
./drivers/net/wan/farsync.c:	card->family = ((ent->driver_data == FST_TYPE_T2P) ||
./drivers/net/wan/farsync.c:		card->nports = 1;
./drivers/net/wan/farsync.c:		card->nports = ((ent->driver_data == FST_TYPE_T2P) ||
./drivers/net/wan/farsync.c:	card->state = FST_UNINIT;
./drivers/net/wan/farsync.c:        spin_lock_init ( &card->card_lock );
./drivers/net/wan/farsync.c:        for ( i = 0 ; i < card->nports ; i++ ) {
./drivers/net/wan/farsync.c:		struct net_device *dev = alloc_hdlcdev(&card->ports[i]);
./drivers/net/wan/farsync.c:				free_netdev(card->ports[i].dev);
./drivers/net/wan/farsync.c:                        free_irq(card->irq, card);
./drivers/net/wan/farsync.c:                        iounmap(card->ctlmem);
./drivers/net/wan/farsync.c:                        iounmap(card->mem);
./drivers/net/wan/farsync.c:		card->ports[i].dev    = dev;
./drivers/net/wan/farsync.c:                card->ports[i].card   = card;
./drivers/net/wan/farsync.c:                card->ports[i].index  = i;
./drivers/net/wan/farsync.c:                card->ports[i].run    = 0;
./drivers/net/wan/farsync.c:                dev->mem_start   = card->phys_mem
./drivers/net/wan/farsync.c:                dev->mem_end     = card->phys_mem
./drivers/net/wan/farsync.c:                dev->base_addr   = card->pci_conf;
./drivers/net/wan/farsync.c:                dev->irq         = card->irq;
./drivers/net/wan/farsync.c:	card->device = pdev;
./drivers/net/wan/farsync.c:	dbg(DBG_PCI, "type %d nports %d irq %d\n", card->type,
./drivers/net/wan/farsync.c:	    card->nports, card->irq);
./drivers/net/wan/farsync.c:	    card->pci_conf, card->phys_mem, card->phys_ctlmem);
./drivers/net/wan/farsync.c:	card->state = FST_RESET;
./drivers/net/wan/farsync.c:	card->card_no = no_of_cards_added++;	/* Record instance and bump it */
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		card->rx_dma_handle_host =
./drivers/net/wan/farsync.c:		    pci_alloc_consistent(card->device, FST_MAX_MTU,
./drivers/net/wan/farsync.c:					 &card->rx_dma_handle_card);
./drivers/net/wan/farsync.c:		if (card->rx_dma_handle_host == NULL) {
./drivers/net/wan/farsync.c:			iounmap(card->ctlmem);
./drivers/net/wan/farsync.c:			iounmap(card->mem);
./drivers/net/wan/farsync.c:		card->tx_dma_handle_host =
./drivers/net/wan/farsync.c:		    pci_alloc_consistent(card->device, FST_MAX_MTU,
./drivers/net/wan/farsync.c:					 &card->tx_dma_handle_card);
./drivers/net/wan/farsync.c:		if (card->tx_dma_handle_host == NULL) {
./drivers/net/wan/farsync.c:			iounmap(card->ctlmem);
./drivers/net/wan/farsync.c:			iounmap(card->mem);
./drivers/net/wan/farsync.c:	for (i = 0; i < card->nports; i++) {
./drivers/net/wan/farsync.c:		struct net_device *dev = port_to_dev(&card->ports[i]);
./drivers/net/wan/farsync.c:	free_irq(card->irq, card);
./drivers/net/wan/farsync.c:	iounmap(card->ctlmem);
./drivers/net/wan/farsync.c:	iounmap(card->mem);
./drivers/net/wan/farsync.c:	if (card->family == FST_FAMILY_TXU) {
./drivers/net/wan/farsync.c:		pci_free_consistent(card->device, FST_MAX_MTU,
./drivers/net/wan/farsync.c:				    card->rx_dma_handle_host,
./drivers/net/wan/farsync.c:				    card->rx_dma_handle_card);
./drivers/net/wan/farsync.c:		pci_free_consistent(card->device, FST_MAX_MTU,
./drivers/net/wan/farsync.c:				    card->tx_dma_handle_host,
./drivers/net/wan/farsync.c:				    card->tx_dma_handle_card);
./drivers/net/wan/farsync.c:	fst_card_array[card->card_no] = NULL;
./drivers/net/wan/cycx_x25.c:				 card->devname, conf->config_id);
./drivers/net/wan/cycx_x25.c:	card->mbox  = card->hw.dpmbase + X25_MBOX_OFFS;
./drivers/net/wan/cycx_x25.c:	card->u.x.connection_keys = 0;
./drivers/net/wan/cycx_x25.c:	spin_lock_init(&card->u.x.lock);
./drivers/net/wan/cycx_x25.c:		card->wandev.mtu = 512;
./drivers/net/wan/cycx_x25.c:		card->wandev.mtu = 256;
./drivers/net/wan/cycx_x25.c:		card->wandev.mtu = 128;
./drivers/net/wan/cycx_x25.c:		card->wandev.mtu = 64;
./drivers/net/wan/cycx_x25.c:	cfg.pktlen = cycx_log2(card->wandev.mtu);
./drivers/net/wan/cycx_x25.c:		card->u.x.hi_pvc = min_t(unsigned int, conf->u.x25.hi_pvc, 4095);
./drivers/net/wan/cycx_x25.c:		card->u.x.lo_pvc = min_t(unsigned int, conf->u.x25.lo_pvc, card->u.x.hi_pvc);
./drivers/net/wan/cycx_x25.c:		card->u.x.hi_svc = min_t(unsigned int, conf->u.x25.hi_svc, 4095);
./drivers/net/wan/cycx_x25.c:		card->u.x.lo_svc = min_t(unsigned int, conf->u.x25.lo_svc, card->u.x.hi_svc);
./drivers/net/wan/cycx_x25.c:	if (card->u.x.lo_pvc == 255)
./drivers/net/wan/cycx_x25.c:		cfg.npvc = card->u.x.hi_pvc - card->u.x.lo_pvc + 1;
./drivers/net/wan/cycx_x25.c:	cfg.nvc = card->u.x.hi_svc - card->u.x.lo_svc + 1 + cfg.npvc;
./drivers/net/wan/cycx_x25.c:	card->wandev.bps	= conf->bps;
./drivers/net/wan/cycx_x25.c:	card->wandev.interface	= conf->interface;
./drivers/net/wan/cycx_x25.c:	card->wandev.clocking	= conf->clocking;
./drivers/net/wan/cycx_x25.c:	card->wandev.station	= conf->station;
./drivers/net/wan/cycx_x25.c:	card->isr		= cycx_x25_irq_handler;
./drivers/net/wan/cycx_x25.c:	card->exec		= NULL;
./drivers/net/wan/cycx_x25.c:	card->wandev.update	= cycx_wan_update;
./drivers/net/wan/cycx_x25.c:	card->wandev.new_if	= cycx_wan_new_if;
./drivers/net/wan/cycx_x25.c:	card->wandev.del_if	= cycx_wan_del_if;
./drivers/net/wan/cycx_x25.c:	card->wandev.state	= WAN_DISCONNECTED;
./drivers/net/wan/cycx_x25.c:		       card->devname);
./drivers/net/wan/cycx_x25.c:		if (lcn >= card->u.x.lo_pvc && lcn <= card->u.x.hi_pvc)
./drivers/net/wan/cycx_x25.c:	struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_x25.c:	if (card->wandev.state != WAN_CONNECTED)
./drivers/net/wan/cycx_x25.c:		       card->devname, ntohs(skb->protocol), dev->name);
./drivers/net/wan/cycx_x25.c:			++card->wandev.stats.tx_dropped;
./drivers/net/wan/cycx_x25.c:			       card->devname, skb->data[0], dev->name);
./drivers/net/wan/cycx_x25.c:	card->in_isr = 1;
./drivers/net/wan/cycx_x25.c:	card->buff_int_mode_unbusy = 0;
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, X25_RXMBOX_OFFS, &cmd, sizeof(cmd));
./drivers/net/wan/cycx_x25.c:	cycx_poke(&card->hw, 0, &z, sizeof(z));
./drivers/net/wan/cycx_x25.c:	cycx_poke(&card->hw, X25_RXMBOX_OFFS, &z, sizeof(z));
./drivers/net/wan/cycx_x25.c:	card->in_isr = 0;
./drivers/net/wan/cycx_x25.c:	struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));
./drivers/net/wan/cycx_x25.c:		card->buff_int_mode_unbusy = 1;
./drivers/net/wan/cycx_x25.c:				 card->devname, lcn);
./drivers/net/wan/cycx_x25.c:	struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 4, &bitm, sizeof(bitm));
./drivers/net/wan/cycx_x25.c:				 card->devname, lcn);
./drivers/net/wan/cycx_x25.c:					 card->devname);
./drivers/net/wan/cycx_x25.c:			"on interface %s!\n", card->devname, dev->name);
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 5, skb_put(skb, pktlen), pktlen);
./drivers/net/wan/cycx_x25.c:	struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 5, &sizeloc, sizeof(sizeloc));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 6, d, cmd->len - 6);
./drivers/net/wan/cycx_x25.c:				 card->devname, rem);
./drivers/net/wan/cycx_x25.c:	struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 1, &key, sizeof(key));
./drivers/net/wan/cycx_x25.c:			  card->devname, __func__, lcn, key);
./drivers/net/wan/cycx_x25.c:		clear_bit(--key, (void*)&card->u.x.connection_keys);
./drivers/net/wan/cycx_x25.c:				 "key=%d!\n", card->devname, lcn, key);
./drivers/net/wan/cycx_x25.c:	clear_bit(--key, (void*)&card->u.x.connection_keys);
./drivers/net/wan/cycx_x25.c:	struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));
./drivers/net/wan/cycx_x25.c:			  card->devname, __func__, lcn);
./drivers/net/wan/cycx_x25.c:				 card->devname, lcn);
./drivers/net/wan/cycx_x25.c:	struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &lcn, sizeof(lcn));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &msg_code, sizeof(msg_code));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 2, &link, sizeof(link));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 4, &size, sizeof(size));
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 10, &bf, toread);
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 10 + toread, &code, 1);
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf + 10 + toread + 1, &routine, 1);
./drivers/net/wan/cycx_x25.c:	cycx_peek(&card->hw, cmd->buf, &card->u.x.stats,
./drivers/net/wan/cycx_x25.c:		  sizeof(card->u.x.stats));
./drivers/net/wan/cycx_x25.c:	hex_dump("cycx_x25_irq_stat", (unsigned char*)&card->u.x.stats,
./drivers/net/wan/cycx_x25.c:		 sizeof(card->u.x.stats));
./drivers/net/wan/cycx_x25.c:	cycx_x25_dump_stats(&card->u.x.stats);
./drivers/net/wan/cycx_x25.c:	wake_up_interruptible(&card->wait_stats);
./drivers/net/wan/cycx_x25.c:			 card->devname, cmd->command);
./drivers/net/wan/cycx_x25.c:	spin_lock_irqsave(&card->u.x.lock, flags);
./drivers/net/wan/cycx_x25.c:	cycx_poke(&card->hw, X25_MBOX_OFFS, &c, sizeof(c) - sizeof(c.buf));
./drivers/net/wan/cycx_x25.c:		cycx_poke(&card->hw, addr, d1, len1);
./drivers/net/wan/cycx_x25.c:				cycx_poke(&card->hw, addr + len1, d2, 249);
./drivers/net/wan/cycx_x25.c:				cycx_poke(&card->hw, addr1, ((u8*)d2) + 249,
./drivers/net/wan/cycx_x25.c:				cycx_poke(&card->hw, addr + len1, d2, len2);
./drivers/net/wan/cycx_x25.c:	cycx_intr(&card->hw);
./drivers/net/wan/cycx_x25.c:	/* wait till card->mbox == 0 */
./drivers/net/wan/cycx_x25.c:		err = cycx_exec(card->mbox);
./drivers/net/wan/cycx_x25.c:	spin_unlock_irqrestore(&card->u.x.lock, flags);
./drivers/net/wan/cycx_x25.c:	interruptible_sleep_on(&card->wait_stats);
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_packets = card->u.x.stats.n2_rx_frames;
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_over_errors = card->u.x.stats.rx_over_errors;
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_crc_errors = card->u.x.stats.rx_crc_errors;
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_length_errors = 0; /* not available from fw */
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_frame_errors = 0; /* not available from fw */
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_missed_errors = card->u.x.stats.rx_aborts;
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_dropped = 0; /* not available from fw */
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.rx_errors = 0; /* not available from fw */
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.tx_packets = card->u.x.stats.n2_tx_frames;
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.tx_aborted_errors = card->u.x.stats.tx_aborts;
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.tx_dropped = 0; /* not available from fw */
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.collisions = 0; /* not available from fw */
./drivers/net/wan/cycx_x25.c:	card->wandev.stats.tx_errors = 0; /* not available from fw */
./drivers/net/wan/cycx_x25.c:	cycx_x25_dump_devs(&card->wandev);
./drivers/net/wan/cycx_x25.c:	if (card->u.x.connection_keys == ~0U) {
./drivers/net/wan/cycx_x25.c:				 "requests!\n", card->devname);
./drivers/net/wan/cycx_x25.c:	key = ffz(card->u.x.connection_keys);
./drivers/net/wan/cycx_x25.c:	set_bit(key, (void*)&card->u.x.connection_keys);
./drivers/net/wan/cycx_x25.c:	dprintk(1, KERN_INFO "%s:x25_place_call:key=%d\n", card->devname, key);
./drivers/net/wan/cycx_x25.c:		clear_bit(--key, (void*)&card->u.x.connection_keys);
./drivers/net/wan/cycx_x25.c:				  card->devname, chan->addr);
./drivers/net/wan/cycx_x25.c:				chan->card->devname, __func__, dev->name);
./drivers/net/wan/cycx_x25.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/net/wan/cycx_x25.c:		printk(KERN_INFO "%s: interface %s %s\n", card->devname,
./drivers/net/wan/cycx_x25.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/wan/cycx_x25.c:	if (skb->len > card->wandev.mtu) {
./drivers/net/wan/cycx_x25.c:		len = card->wandev.mtu;
./drivers/net/wan/wanxl.c:	return &port->card->status->port_status[port->node];
./drivers/net/wan/wanxl.c:		pci_unmap_single(port->card->pdev, desc->address, skb->len,
./drivers/net/wan/wanxl.c:	while (desc = &card->status->rx_descs[card->rx_in],
./drivers/net/wan/wanxl.c:		if ((desc->stat & PACKET_PORT_MASK) > card->n_ports)
./drivers/net/wan/wanxl.c:			       " nonexistent port\n", pci_name(card->pdev));
./drivers/net/wan/wanxl.c:			struct sk_buff *skb = card->rx_skbs[card->rx_in];
./drivers/net/wan/wanxl.c:			port_t *port = &card->ports[desc->stat &
./drivers/net/wan/wanxl.c:				pci_unmap_single(card->pdev, desc->address,
./drivers/net/wan/wanxl.c:					pci_map_single(card->pdev, skb->data,
./drivers/net/wan/wanxl.c:				card->rx_skbs[card->rx_in] = skb;
./drivers/net/wan/wanxl.c:		card->rx_in = (card->rx_in + 1) % RX_QUEUE_LENGTH;
./drivers/net/wan/wanxl.c:        while((stat = readl(card->plx + PLX_DOORBELL_FROM_CARD)) != 0) {
./drivers/net/wan/wanxl.c:		writel(stat, card->plx + PLX_DOORBELL_FROM_CARD);
./drivers/net/wan/wanxl.c:                for (i = 0; i < card->n_ports; i++) {
./drivers/net/wan/wanxl.c:				wanxl_tx_intr(&card->ports[i]);
./drivers/net/wan/wanxl.c:				wanxl_cable_intr(&card->ports[i]);
./drivers/net/wan/wanxl.c:	desc->address = pci_map_single(port->card->pdev, skb->data, skb->len,
./drivers/net/wan/wanxl.c:	       port->card->plx + PLX_DOORBELL_TO_CARD);
./drivers/net/wan/wanxl.c:	u8 __iomem *dbr = port->card->plx + PLX_DOORBELL_TO_CARD;
./drivers/net/wan/wanxl.c:	       port->card->plx + PLX_DOORBELL_TO_CARD);
./drivers/net/wan/wanxl.c:			pci_unmap_single(port->card->pdev, desc->address,
./drivers/net/wan/wanxl.c:	writel(cmd, card->plx + PLX_MAILBOX_1);
./drivers/net/wan/wanxl.c:		if (readl(card->plx + PLX_MAILBOX_1) == 0)
./drivers/net/wan/wanxl.c:	u32 old_value = readl(card->plx + PLX_CONTROL) & ~PLX_CTL_RESET;
./drivers/net/wan/wanxl.c:	writel(0x80, card->plx + PLX_MAILBOX_0);
./drivers/net/wan/wanxl.c:	writel(old_value | PLX_CTL_RESET, card->plx + PLX_CONTROL);
./drivers/net/wan/wanxl.c:	readl(card->plx + PLX_CONTROL); /* wait for posted write */
./drivers/net/wan/wanxl.c:	writel(old_value, card->plx + PLX_CONTROL);
./drivers/net/wan/wanxl.c:	readl(card->plx + PLX_CONTROL); /* wait for posted write */
./drivers/net/wan/wanxl.c:	for (i = 0; i < card->n_ports; i++) {
./drivers/net/wan/wanxl.c:		unregister_hdlc_device(card->ports[i].dev);
./drivers/net/wan/wanxl.c:		free_netdev(card->ports[i].dev);
./drivers/net/wan/wanxl.c:	if (card->irq)
./drivers/net/wan/wanxl.c:		free_irq(card->irq, card);
./drivers/net/wan/wanxl.c:		if (card->rx_skbs[i]) {
./drivers/net/wan/wanxl.c:			pci_unmap_single(card->pdev,
./drivers/net/wan/wanxl.c:					 card->status->rx_descs[i].address,
./drivers/net/wan/wanxl.c:			dev_kfree_skb(card->rx_skbs[i]);
./drivers/net/wan/wanxl.c:	if (card->plx)
./drivers/net/wan/wanxl.c:		iounmap(card->plx);
./drivers/net/wan/wanxl.c:	if (card->status)
./drivers/net/wan/wanxl.c:				    card->status, card->status_address);
./drivers/net/wan/wanxl.c:	card->pdev = pdev;
./drivers/net/wan/wanxl.c:	card->status = pci_alloc_consistent(pdev, sizeof(card_status_t),
./drivers/net/wan/wanxl.c:					    &card->status_address);
./drivers/net/wan/wanxl.c:	if (card->status == NULL) {
./drivers/net/wan/wanxl.c:	       (unsigned long long)card->status_address);
./drivers/net/wan/wanxl.c:	card->plx = ioremap_nocache(plx_phy, 0x70);
./drivers/net/wan/wanxl.c:	if (!card->plx) {
./drivers/net/wan/wanxl.c:	while ((stat = readl(card->plx + PLX_MAILBOX_0)) != 0) {
./drivers/net/wan/wanxl.c:	ramsize = readl(card->plx + PLX_MAILBOX_2) & MBX2_MEMSZ_MASK;
./drivers/net/wan/wanxl.c:		card->rx_skbs[i] = skb;
./drivers/net/wan/wanxl.c:			card->status->rx_descs[i].address =
./drivers/net/wan/wanxl.c:				pci_map_single(card->pdev, skb->data,
./drivers/net/wan/wanxl.c:		writel(card->status_address +
./drivers/net/wan/wanxl.c:		       (void *)&card->status->port_status[i] -
./drivers/net/wan/wanxl.c:		       (void *)card->status, mem + PDM_OFFSET + 4 + i * 4);
./drivers/net/wan/wanxl.c:	writel(card->status_address, mem + PDM_OFFSET + 20);
./drivers/net/wan/wanxl.c:	writel(0, card->plx + PLX_MAILBOX_5);
./drivers/net/wan/wanxl.c:		if ((stat = readl(card->plx + PLX_MAILBOX_5)) != 0)
./drivers/net/wan/wanxl.c:	card->irq = pdev->irq;
./drivers/net/wan/wanxl.c:		port_t *port = &card->ports[i];
./drivers/net/wan/wanxl.c:		card->n_ports++;
./drivers/net/wan/wanxl.c:		       card->ports[i].dev->name);
./drivers/net/wan/wanxl.c:		wanxl_cable_intr(&card->ports[i]); /* get carrier status etc.*/
./drivers/net/wan/pci200syn.c:#define get_port(card, port)	     (&card->ports[port])
./drivers/net/wan/pci200syn.c:		if (card->ports[i].card)
./drivers/net/wan/pci200syn.c:			unregister_hdlc_device(card->ports[i].netdev);
./drivers/net/wan/pci200syn.c:	if (card->irq)
./drivers/net/wan/pci200syn.c:		free_irq(card->irq, card);
./drivers/net/wan/pci200syn.c:	if (card->rambase)
./drivers/net/wan/pci200syn.c:		iounmap(card->rambase);
./drivers/net/wan/pci200syn.c:	if (card->scabase)
./drivers/net/wan/pci200syn.c:		iounmap(card->scabase);
./drivers/net/wan/pci200syn.c:	if (card->plxbase)
./drivers/net/wan/pci200syn.c:		iounmap(card->plxbase);
./drivers/net/wan/pci200syn.c:	if (card->ports[0].netdev)
./drivers/net/wan/pci200syn.c:		free_netdev(card->ports[0].netdev);
./drivers/net/wan/pci200syn.c:	if (card->ports[1].netdev)
./drivers/net/wan/pci200syn.c:		free_netdev(card->ports[1].netdev);
./drivers/net/wan/pci200syn.c:	card->ports[0].netdev = alloc_hdlcdev(&card->ports[0]);
./drivers/net/wan/pci200syn.c:	card->ports[1].netdev = alloc_hdlcdev(&card->ports[1]);
./drivers/net/wan/pci200syn.c:	if (!card->ports[0].netdev || !card->ports[1].netdev) {
./drivers/net/wan/pci200syn.c:	card->plxbase = ioremap(plxphys, PCI200SYN_PLX_SIZE);
./drivers/net/wan/pci200syn.c:	card->scabase = ioremap(scaphys, PCI200SYN_SCA_SIZE);
./drivers/net/wan/pci200syn.c:	card->rambase = pci_ioremap_bar(pdev, 3);
./drivers/net/wan/pci200syn.c:	if (card->plxbase == NULL ||
./drivers/net/wan/pci200syn.c:	    card->scabase == NULL ||
./drivers/net/wan/pci200syn.c:	    card->rambase == NULL) {
./drivers/net/wan/pci200syn.c:	p = &card->plxbase->init_ctrl;
./drivers/net/wan/pci200syn.c:	ramsize = sca_detect_ram(card, card->rambase,
./drivers/net/wan/pci200syn.c:	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
./drivers/net/wan/pci200syn.c:	card->rx_ring_buffers = i - card->tx_ring_buffers;
./drivers/net/wan/pci200syn.c:	card->buff_offset = 2 * sizeof(pkt_desc) * (card->tx_ring_buffers +
./drivers/net/wan/pci200syn.c:						    card->rx_ring_buffers);
./drivers/net/wan/pci200syn.c:	       pdev->irq, card->tx_ring_buffers, card->rx_ring_buffers);
./drivers/net/wan/pci200syn.c:	if (card->tx_ring_buffers < 1) {
./drivers/net/wan/pci200syn.c:	p = &card->plxbase->intr_ctrl_stat;
./drivers/net/wan/pci200syn.c:	card->irq = pdev->irq;
./drivers/net/wan/pci200syn.c:		port_t *port = &card->ports[i];
./drivers/net/wan/pci200syn.c:		dev->irq = card->irq;
./drivers/net/wan/pc300too.c:	u32 __iomem * init_ctrl = &card->plxbase->init_ctrl;
./drivers/net/wan/pc300too.c:	if (port->card->type == PC300_RSV) {
./drivers/net/wan/pc300too.c:			writel(card->init_ctrl_value |
./drivers/net/wan/pc300too.c:			writel(card->init_ctrl_value &
./drivers/net/wan/pc300too.c:	if (port->card->type == PC300_X21 &&
./drivers/net/wan/pc300too.c:	else if (port->card->type == PC300_RSV &&
./drivers/net/wan/pc300too.c:	else if (port->card->type == PC300_RSV &&
./drivers/net/wan/pc300too.c:		if (card->ports[i].card)
./drivers/net/wan/pc300too.c:			unregister_hdlc_device(card->ports[i].netdev);
./drivers/net/wan/pc300too.c:	if (card->irq)
./drivers/net/wan/pc300too.c:		free_irq(card->irq, card);
./drivers/net/wan/pc300too.c:	if (card->rambase)
./drivers/net/wan/pc300too.c:		iounmap(card->rambase);
./drivers/net/wan/pc300too.c:	if (card->scabase)
./drivers/net/wan/pc300too.c:		iounmap(card->scabase);
./drivers/net/wan/pc300too.c:	if (card->plxbase)
./drivers/net/wan/pc300too.c:		iounmap(card->plxbase);
./drivers/net/wan/pc300too.c:	if (card->ports[0].netdev)
./drivers/net/wan/pc300too.c:		free_netdev(card->ports[0].netdev);
./drivers/net/wan/pc300too.c:	if (card->ports[1].netdev)
./drivers/net/wan/pc300too.c:		free_netdev(card->ports[1].netdev);
./drivers/net/wan/pc300too.c:	card->plxbase = ioremap(plxphys, PC300_PLX_SIZE);
./drivers/net/wan/pc300too.c:	card->scabase = ioremap(scaphys, PC300_SCA_SIZE);
./drivers/net/wan/pc300too.c:	card->rambase = pci_ioremap_bar(pdev, 3);
./drivers/net/wan/pc300too.c:	if (card->plxbase == NULL ||
./drivers/net/wan/pc300too.c:	    card->scabase == NULL ||
./drivers/net/wan/pc300too.c:	    card->rambase == NULL) {
./drivers/net/wan/pc300too.c:	card->init_ctrl_value = readl(&((plx9050 __iomem *)card->scabase)->init_ctrl);
./drivers/net/wan/pc300too.c:		card->type = PC300_TE; /* not fully supported */
./drivers/net/wan/pc300too.c:	else if (card->init_ctrl_value & PC300_CTYPE_MASK)
./drivers/net/wan/pc300too.c:		card->type = PC300_X21;
./drivers/net/wan/pc300too.c:		card->type = PC300_RSV;
./drivers/net/wan/pc300too.c:		card->n_ports = 1;
./drivers/net/wan/pc300too.c:		card->n_ports = 2;
./drivers/net/wan/pc300too.c:	for (i = 0; i < card->n_ports; i++)
./drivers/net/wan/pc300too.c:		if (!(card->ports[i].netdev = alloc_hdlcdev(&card->ports[i]))) {
./drivers/net/wan/pc300too.c:	p = &card->plxbase->init_ctrl;
./drivers/net/wan/pc300too.c:	writel(card->init_ctrl_value | 0x40000000, p);
./drivers/net/wan/pc300too.c:	writel(card->init_ctrl_value, p);
./drivers/net/wan/pc300too.c:	writel(card->init_ctrl_value | 0x20000000, p);
./drivers/net/wan/pc300too.c:	writel(card->init_ctrl_value, p);
./drivers/net/wan/pc300too.c:	ramsize = sca_detect_ram(card, card->rambase,
./drivers/net/wan/pc300too.c:		card->init_ctrl_value &= ~PC300_CLKSEL_MASK;
./drivers/net/wan/pc300too.c:		card->init_ctrl_value |= PC300_CLKSEL_MASK;
./drivers/net/wan/pc300too.c:	writel(card->init_ctrl_value, &card->plxbase->init_ctrl);
./drivers/net/wan/pc300too.c:	i = ramsize / (card->n_ports * (sizeof(pkt_desc) + HDLC_MAX_MRU));
./drivers/net/wan/pc300too.c:	card->tx_ring_buffers = min(i / 2, MAX_TX_BUFFERS);
./drivers/net/wan/pc300too.c:	card->rx_ring_buffers = i - card->tx_ring_buffers;
./drivers/net/wan/pc300too.c:	card->buff_offset = card->n_ports * sizeof(pkt_desc) *
./drivers/net/wan/pc300too.c:		(card->tx_ring_buffers + card->rx_ring_buffers);
./drivers/net/wan/pc300too.c:	       card->type == PC300_X21 ? "X21" :
./drivers/net/wan/pc300too.c:	       card->type == PC300_TE ? "TE" : "RSV",
./drivers/net/wan/pc300too.c:	       card->tx_ring_buffers, card->rx_ring_buffers);
./drivers/net/wan/pc300too.c:	if (card->tx_ring_buffers < 1) {
./drivers/net/wan/pc300too.c:	writew(0x0041, &card->plxbase->intr_ctrl_stat);
./drivers/net/wan/pc300too.c:	card->irq = pdev->irq;
./drivers/net/wan/pc300too.c:	for (i = 0; i < card->n_ports; i++) {
./drivers/net/wan/pc300too.c:		port_t *port = &card->ports[i];
./drivers/net/wan/pc300too.c:		dev->irq = card->irq;
./drivers/net/wan/pc300too.c:		if (card->type == PC300_X21)
./drivers/net/wan/hd64572.c: * Packet buffer descriptor rings - starting from card->rambase:
./drivers/net/wan/hd64572.c: * Packet data buffers - starting from card->rambase + buff_offset:
./drivers/net/wan/hd64572.c:#define sca_in(reg, card)	     readb(card->scabase + (reg))
./drivers/net/wan/hd64572.c:#define sca_out(value, reg, card)    writeb(value, card->scabase + (reg))
./drivers/net/wan/hd64572.c:#define sca_inw(reg, card)	     readw(card->scabase + (reg))
./drivers/net/wan/hd64572.c:#define sca_outw(value, reg, card)   writew(value, card->scabase + (reg))
./drivers/net/wan/hd64572.c:#define sca_inl(reg, card)	     readl(card->scabase + (reg))
./drivers/net/wan/hd64572.c:#define sca_outl(value, reg, card)   writel(value, card->scabase + (reg))
./drivers/net/wan/hd64572.c:	u16 rx_buffs = port->card->rx_ring_buffers;
./drivers/net/wan/hd64572.c:	u16 tx_buffs = port->card->tx_ring_buffers;
./drivers/net/wan/hd64572.c:	return (pkt_desc __iomem *)(port->card->rambase +
./drivers/net/wan/hd64572.c:	return port->card->buff_offset +
./drivers/net/wan/hd64572.c:		u16 buffs = transmit ? card->tx_ring_buffers
./drivers/net/wan/hd64572.c:			: card->rx_ring_buffers;
./drivers/net/wan/hd64572.c:	sca_outl(desc_offset(port, card->tx_ring_buffers - 1, 0),
./drivers/net/wan/hd64572.c:	memcpy_fromio(skb->data, card->rambase + buff, len);
./drivers/net/wan/hd64572.c:		port->rxin = (port->rxin + 1) % card->rx_ring_buffers;
./drivers/net/wan/hd64572.c:		port->txlast = (port->txlast + 1) % card->tx_ring_buffers;
./drivers/net/wan/hd64572.c:	for (cnt = 0; cnt < port->card->rx_ring_buffers; cnt++)
./drivers/net/wan/hd64572.c:	for (cnt = 0; cnt < port->card->tx_ring_buffers; cnt++)
./drivers/net/wan/hd64572.c:	memcpy_toio(card->rambase + buff, skb->data, len);
./drivers/net/wan/hd64572.c:	port->txin = (port->txin + 1) % card->tx_ring_buffers;
./drivers/net/wan/cycx_main.c:		struct wan_device *wandev = &card->wandev;
./drivers/net/wan/cycx_main.c:		sprintf(card->devname, "%s%d", cycx_drvname, cnt + 1);
./drivers/net/wan/cycx_main.c:		wandev->name     = card->devname;
./drivers/net/wan/cycx_main.c:					cycx_drvname, card->devname, err);
./drivers/net/wan/cycx_main.c:		unregister_wan_device(card->devname);
./drivers/net/wan/cycx_main.c:	memset(&card->hw, 0, sizeof(card->hw));
./drivers/net/wan/cycx_main.c:	card->hw.irq	 = irq;
./drivers/net/wan/cycx_main.c:	card->hw.dpmsize = CYCX_WINDOWSIZE;
./drivers/net/wan/cycx_main.c:	card->hw.fwid	 = CFID_X25_2X;
./drivers/net/wan/cycx_main.c:	spin_lock_init(&card->lock);
./drivers/net/wan/cycx_main.c:	init_waitqueue_head(&card->wait_stats);
./drivers/net/wan/cycx_main.c:	rc = cycx_setup(&card->hw, conf->data, conf->data_size, conf->maddr);
./drivers/net/wan/cycx_main.c:	wandev->maddr     = (unsigned long)card->hw.dpmbase;
./drivers/net/wan/cycx_main.c:	wandev->msize     = card->hw.dpmsize;
./drivers/net/wan/cycx_main.c:	wandev->hw_opt[3] = card->hw.fwid;
./drivers/net/wan/cycx_main.c:	switch (card->hw.fwid) {
./drivers/net/wan/cycx_main.c:		cycx_down(&card->hw);
./drivers/net/wan/cycx_main.c:	cycx_down(&card->hw);
./drivers/net/wan/cycx_main.c:	if (card->wandev.state == WAN_UNCONFIGURED)
./drivers/net/wan/cycx_main.c:	if (card->in_isr) {
./drivers/net/wan/cycx_main.c:				    card->devname, card->wandev.irq);
./drivers/net/wan/cycx_main.c:	if (card->isr)
./drivers/net/wan/cycx_main.c:		card->isr(card);
./drivers/net/wan/cycx_main.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/net/wan/cycx_main.c:	if (card->wandev.state != state) {
./drivers/net/wan/cycx_main.c:		printk(KERN_INFO "%s: link %s\n", card->devname, string_state);
./drivers/net/wan/cycx_main.c:		card->wandev.state = state;
./drivers/net/wan/cycx_main.c:	card->state_tick = jiffies;
./drivers/net/wan/cycx_main.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/net/wan/dscc4.c: * II. Board-specific settings
./drivers/net/wan/dscc4.c:	/* Cf application hint. Beware of hard-lock condition on threshold. */
./drivers/net/ne-h8300.c:   Reading the SAPROM from a word-wide card with the 8390 set in byte-wide
./drivers/net/smc-ultra.c:		ultra_open()		The card-specific details of starting, stopping
./drivers/usb/serial/whiteheat.c:		response = ezusb_writememory (serial, be32_to_cpu(record->addr),
./drivers/usb/serial/whiteheat.c:					      (unsigned char *)record->data,
./drivers/usb/serial/whiteheat.c:					      be16_to_cpu(record->len), 0xa0);
./drivers/usb/serial/whiteheat.c:				__func__, response, be32_to_cpu(record->addr),
./drivers/usb/serial/whiteheat.c:				record->data, be16_to_cpu(record->len));
./drivers/usb/serial/whiteheat.c:	while (record && be32_to_cpu(record->addr) < 0x1b40)
./drivers/usb/serial/whiteheat.c:		response = ezusb_writememory (serial, be32_to_cpu(record->addr),
./drivers/usb/serial/whiteheat.c:					      (unsigned char *)record->data,
./drivers/usb/serial/whiteheat.c:					      be16_to_cpu(record->len), 0xa3);
./drivers/usb/serial/whiteheat.c:				be32_to_cpu(record->addr), record->data,
./drivers/usb/serial/whiteheat.c:				be16_to_cpu(record->len));
./drivers/usb/serial/whiteheat.c:	while (record && be32_to_cpu(record->addr) < 0x1b40) {
./drivers/usb/serial/whiteheat.c:		response = ezusb_writememory (serial, be32_to_cpu(record->addr),
./drivers/usb/serial/whiteheat.c:					      (unsigned char *)record->data,
./drivers/usb/serial/whiteheat.c:					      be16_to_cpu(record->len), 0xa0);
./drivers/usb/serial/whiteheat.c:				be32_to_cpu(record->addr), record->data,
./drivers/usb/serial/whiteheat.c:				be16_to_cpu(record->len));
./drivers/usb/serial/keyspan.c:		response = ezusb_writememory(serial, be32_to_cpu(record->addr),
./drivers/usb/serial/keyspan.c:					     (unsigned char *)record->data,
./drivers/usb/serial/keyspan.c:					     be16_to_cpu(record->len), 0xa0);
./drivers/usb/serial/keyspan.c:				response, be32_to_cpu(record->addr),
./drivers/usb/serial/keyspan.c:				record->data, be16_to_cpu(record->len));
./drivers/usb/serial/keyspan_pda.c:		response = ezusb_writememory(serial, be32_to_cpu(record->addr),
./drivers/usb/serial/keyspan_pda.c:					     (unsigned char *)record->data,
./drivers/usb/serial/keyspan_pda.c:					     be16_to_cpu(record->len), 0xa0);
./drivers/usb/serial/keyspan_pda.c:				response, be32_to_cpu(record->addr),
./drivers/usb/serial/keyspan_pda.c:				record->data, be16_to_cpu(record->len));
./drivers/usb/musb/musb_core.c: *	- platform_data is mostly for board-specific informarion
./drivers/usb/musb/musb_core.c:		/* assume ID pin is hard-wired to ground */
./drivers/usb/musb/musb_core.c: * The silicon either has hard-wired endpoint configurations, or else
./drivers/usb/musb/tusb6010.c:	 * The actual current usage would be very board-specific.  For now,
./drivers/usb/musb/tusb6010.c:	 * it's simpler to just use an aggregate (also board-specific).
./drivers/usb/musb/tusb6010_omap.c:	/* REVISIT: Get dmareq lines used from board-*.c */
./drivers/usb/gadget/f_audio_source.c:	strlcpy(card->driver, "audio_source", sizeof(card->driver));
./drivers/usb/gadget/f_audio_source.c:	strlcpy(card->shortname, card->driver, sizeof(card->shortname));
./drivers/usb/gadget/f_audio_source.c:	strlcpy(card->longname, "USB accessory audio source",
./drivers/usb/gadget/f_audio_source.c:		sizeof(card->longname));
./drivers/usb/gadget/f_audio_source.c:	config->card = pcm->card->number;
./drivers/usb/gadget/at91_udc.c:	/* read and ack SETUP; hard-fail for bogus packets */
./drivers/usb/gadget/ether.c: * drivers that need to hard-wire endpoint numbers have a hook.
./drivers/usb/gadget/u_audio.c:	struct gaudio_snd_dev	*snd = &card->playback;
./drivers/usb/gadget/u_audio.c:	return card->playback.channels;
./drivers/usb/gadget/u_audio.c:	return card->playback.rate;
./drivers/usb/gadget/u_audio.c:	snd = &card->control;
./drivers/usb/gadget/u_audio.c:	snd = &card->playback;
./drivers/usb/gadget/u_audio.c:	snd = &card->capture;
./drivers/usb/gadget/gmidi.c:	strcpy(card->driver, longname);
./drivers/usb/gadget/gmidi.c:	strcpy(card->longname, longname);
./drivers/usb/gadget/gmidi.c:	strcpy(card->shortname, shortname);
./drivers/usb/gadget/gmidi.c:	strcpy(rmidi->name, card->shortname);
./drivers/usb/host/ohci-da8xx.c:	 * Since we're providing a board-specific root hub port power control
./drivers/usb/host/isp116x-hcd.c:	if (board->sel15Kres)
./drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable)
./drivers/usb/host/isp116x-hcd.c:	if (board->oc_enable)
./drivers/usb/host/isp116x-hcd.c:	if (board->int_act_high)
./drivers/usb/host/isp116x-hcd.c:	if (board->int_edge_triggered)
./drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable) {
./drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable)
./drivers/usb/host/isp116x-hcd.c:	if (board->remote_wakeup_enable)
./drivers/usb/host/ohci-at91.c:	ohci->num_ports = board->ports;
./drivers/usb/host/ohci-hub.c: * The short timeout is safe for non-root hubs, and is backward-compatible
./drivers/usb/host/sl811-hcd.c:	if (sl811->board && sl811->board->port_power) {
./drivers/usb/host/sl811-hcd.c:		sl811->board->port_power(hcd->self.controller, is_on);
./drivers/usb/host/sl811-hcd.c:	if (sl811->board && sl811->board->reset)
./drivers/usb/host/sl811-hcd.c:		sl811->board->reset(hcd->self.controller);
./drivers/usb/host/sl811-hcd.c:	if (sl811->board && sl811->board->port_power) {
./drivers/usb/host/sl811-hcd.c:		desc->bPwrOn2PwrGood = sl811->board->potpg;
./drivers/usb/host/sl811-hcd.c:				sl811->board->can_wakeup);
./drivers/usb/host/sl811-hcd.c:		hcd->power_budget = sl811->board->power * 2;
./drivers/usb/host/sl811-hcd.c:	/* basic sanity checks first.  board-specific init logic should
./drivers/usb/host/isp1362-hcd.c:	if (isp1362_hcd->board && isp1362_hcd->board->reset) {
./drivers/usb/host/isp1362-hcd.c:		isp1362_hcd->board->reset(hcd->self.controller, 1);
./drivers/usb/host/isp1362-hcd.c:		if (isp1362_hcd->board->clock)
./drivers/usb/host/isp1362-hcd.c:			isp1362_hcd->board->clock(hcd->self.controller, 1);
./drivers/usb/host/isp1362-hcd.c:		isp1362_hcd->board->reset(hcd->self.controller, 0);
./drivers/usb/host/isp1362-hcd.c:	if (isp1362_hcd->board && isp1362_hcd->board->reset)
./drivers/usb/host/isp1362-hcd.c:		isp1362_hcd->board->reset(hcd->self.controller, 1);
./drivers/usb/host/isp1362-hcd.c:	if (isp1362_hcd->board && isp1362_hcd->board->clock)
./drivers/usb/host/isp1362-hcd.c:		isp1362_hcd->board->clock(hcd->self.controller, 0);
./drivers/usb/host/isp1362-hcd.c:	if (board->sel15Kres)
./drivers/usb/host/isp1362-hcd.c:	if (board->clknotstop)
./drivers/usb/host/isp1362-hcd.c:	if (board->oc_enable)
./drivers/usb/host/isp1362-hcd.c:	if (board->int_act_high)
./drivers/usb/host/isp1362-hcd.c:	if (board->int_edge_triggered)
./drivers/usb/host/isp1362-hcd.c:	if (board->dreq_act_high)
./drivers/usb/host/isp1362-hcd.c:	if (board->dack_act_high)
./drivers/usb/host/isp1362-hcd.c:	if (board->no_power_switching)
./drivers/usb/host/isp1362-hcd.c:	if (board->power_switching_mode)
./drivers/usb/host/isp1362-hcd.c:	if (board->potpg)
./drivers/usb/host/isp1362-hcd.c:		isp1362_hcd->rhdesca |= (board->potpg << 24) & RH_A_POTPGT;
./drivers/usb/host/isp1362-hcd.c:	/* basic sanity checks first.  board-specific init logic should
./drivers/usb/host/isp1362-hcd.c:	if (!isp1362_hcd->board->delay) {
./drivers/usb/host/ohci-omap.c:	/* board-specific power switching and overcurrent support */
./drivers/usb/otg/isp1301_omap.c:/* board-specific PM hooks */
./drivers/usb/otg/isp1301_omap.c: * not everything is guarded by board-specific checks, or even using
./drivers/usb/otg/isp1301_omap.c:	/* some of these values are board-specific... */
./drivers/mfd/dm355evm_msp.c: * Because this firmware is entirely board-specific, this file embeds
./drivers/mfd/ucb1x00-core.c: * hard-coded machine dependencies.  For reference, the expected
./drivers/mfd/tps65010.c:	if (board && board->teardown) {
./drivers/mfd/tps65010.c:		int status = board->teardown(client, board->context);
./drivers/mfd/tps65010.c:	if (board && board->base != 0) {
./drivers/mfd/tps65010.c:		tps->outmask = board->outmask;
./drivers/mfd/tps65010.c:		tps->chip.base = board->base;
./drivers/mfd/tps65010.c:		else if (board->setup) {
./drivers/mfd/tps65010.c:			status = board->setup(client, board->context);
./drivers/uwb/whci.c:	struct pci_dev *pci_dev = card->pci;
./drivers/uwb/whci.c:	umc = umc_device_create(&card->pci->dev, n);
./drivers/uwb/whci.c:	capdata = le_readq(card->uwbbase + UWBCAPDATA(n));
./drivers/uwb/whci.c:	umc->resource.start  = pci_resource_start(card->pci, bar)
./drivers/uwb/whci.c:	umc->resource.flags  = card->pci->resource[bar].flags;
./drivers/uwb/whci.c:	umc->resource.parent = &card->pci->resource[bar];
./drivers/uwb/whci.c:	umc->irq             = card->pci->irq;
./drivers/uwb/whci.c:	card->devs[n] = umc;
./drivers/uwb/whci.c:	struct umc_dev *umc = card->devs[n];
./drivers/uwb/whci.c:	card->pci = pci;
./drivers/uwb/whci.c:	card->n_caps = n_caps;
./drivers/uwb/whci.c:				UWBCAPDATA_SIZE(card->n_caps),
./drivers/uwb/whci.c:	card->uwbbase = pci_iomap(pci, 0, UWBCAPDATA_SIZE(card->n_caps));
./drivers/uwb/whci.c:	if (!card->uwbbase)
./drivers/uwb/whci.c:	for (n = 0; n <= card->n_caps; n++) {
./drivers/uwb/whci.c:	pci_iounmap(pci, card->uwbbase);
./drivers/uwb/whci.c:	release_mem_region(pci_resource_start(pci, 0), UWBCAPDATA_SIZE(card->n_caps));
./drivers/uwb/whci.c:	for (n = card->n_caps; n >= 0 ; n--)
./drivers/uwb/whci.c:	pci_iounmap(pci, card->uwbbase);
./drivers/uwb/whci.c:	release_mem_region(pci_resource_start(pci, 0), UWBCAPDATA_SIZE(card->n_caps));
./drivers/uwb/scan.c: *        10/28/2005 No clear answer heard--maybe we'll hack the API
./drivers/of/fdt.c:	prop = of_get_flat_dt_prop(node, "linux,initrd-start", &len);
./drivers/of/fdt.c:	prop = of_get_flat_dt_prop(node, "linux,initrd-end", &len);
./drivers/macintosh/windfarm_lm75_sensor.c:		name = "hard-drive-temp";
./drivers/macintosh/windfarm_smu_controls.c:		fct->ctrl.name = "hard-drive-fan";
./drivers/macintosh/windfarm_pm121.c: * controls with a tiny difference. The control-ids of hard-drive-fan
./drivers/macintosh/windfarm_pm121.c: *   ref	: hard-drive-fan
./drivers/macintosh/windfarm_pm121.c: *   control        : hard-drive-fan
./drivers/macintosh/windfarm_pm121.c: *   sensor         : hard-drive-temp
./drivers/macintosh/windfarm_pm121.c: *   control        : hard-drive-fan
./drivers/macintosh/windfarm_pm121.c: *   sensor         : hard-drive-temp
./drivers/macintosh/windfarm_pm121.c: *   control        : hard-drive-fan
./drivers/macintosh/windfarm_pm121.c: *   control        : hard-drive-fan
./drivers/macintosh/windfarm_pm121.c:	all = pm121_register_control(ct, "hard-drive-fan", FAN_HD) && all;
./drivers/macintosh/windfarm_pm121.c:	all = pm121_register_sensor(sr, "hard-drive-temp",
./drivers/macintosh/smu.c:	/* Doorbell buffer is currently hard-coded, I didn't find a proper
./drivers/atm/solos-pci.c:#define RX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2)
./drivers/atm/solos-pci.c:#define TX_BUF(card, nr) ((card->buffers) + (nr)*(card->buffer_size)*2 + (card->buffer_size))
./drivers/atm/solos-pci.c:#define FLASH_BUF ((card->buffers) + 4*(card->buffer_size)*2)
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_show()\n");
./drivers/atm/solos-pci.c:	spin_lock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:	list_add(&prm.list, &card->param_queue);
./drivers/atm/solos-pci.c:	spin_unlock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:	wait_event_timeout(card->param_wq, prm.response, 5 * HZ);
./drivers/atm/solos-pci.c:	spin_lock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:	spin_unlock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_store()\n");
./drivers/atm/solos-pci.c:	spin_lock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:	list_add(&prm.list, &card->param_queue);
./drivers/atm/solos-pci.c:	spin_unlock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:	wait_event_timeout(card->param_wq, prm.response, 5 * HZ);
./drivers/atm/solos-pci.c:	spin_lock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:	spin_unlock_irq(&card->param_queue_lock);
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Unexpected parameter response: '%s'\n",
./drivers/atm/solos-pci.c:	if (!card->atmdev[port])
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Unexpected status interrupt version %d\n",
./drivers/atm/solos-pci.c:		dev_dbg(&card->dev->dev, "Status packet indicated Solos error on port %d (starting up?)\n",
./drivers/atm/solos-pci.c:		atm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_LOST);
./drivers/atm/solos-pci.c:		dev_info(&card->dev->dev, "Port %d: %s\n", port, state_str);
./drivers/atm/solos-pci.c:	dev_info(&card->dev->dev, "Port %d: %s @%d/%d kb/s%s%s%s%s\n",
./drivers/atm/solos-pci.c:	card->atmdev[port]->link_rate = rate_down / 424;
./drivers/atm/solos-pci.c:	atm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_FOUND);
./drivers/atm/solos-pci.c:	spin_lock_irqsave(&card->param_queue_lock, flags);
./drivers/atm/solos-pci.c:	list_for_each_entry(prm, &card->param_queue, list) {
./drivers/atm/solos-pci.c:			wake_up(&card->param_wq);
./drivers/atm/solos-pci.c:	spin_unlock_irqrestore(&card->param_queue_lock, flags);
./drivers/atm/solos-pci.c:	spin_lock(&card->cli_queue_lock);
./drivers/atm/solos-pci.c:	skb = skb_dequeue(&card->cli_queue[SOLOS_CHAN(atmdev)]);
./drivers/atm/solos-pci.c:	spin_unlock(&card->cli_queue_lock);
./drivers/atm/solos-pci.c:	dev_dbg(&card->dev->dev, "len: %d\n", len);
./drivers/atm/solos-pci.c:		dev_dbg(&card->dev->dev, "Command is too big.  Dropping request\n");
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in send_command()\n");
./drivers/atm/solos-pci.c:		if (card->fpga_version > LEGACY_BUFFERS){
./drivers/atm/solos-pci.c:			dev_info(&card->dev->dev, "FPGA version doesn't support"
./drivers/atm/solos-pci.c:		if (card->fpga_version > LEGACY_BUFFERS){
./drivers/atm/solos-pci.c:			dev_info(&card->dev->dev, "FPGA version doesn't support"
./drivers/atm/solos-pci.c:	if (request_firmware(&fw, fw_name, &card->dev->dev))
./drivers/atm/solos-pci.c:	dev_info(&card->dev->dev, "Flash upgrade starting\n");
./drivers/atm/solos-pci.c:	dev_info(&card->dev->dev, "Firmware size: %zd\n", fw->size);
./drivers/atm/solos-pci.c:	dev_info(&card->dev->dev, "Number of blocks: %d\n", numblocks);
./drivers/atm/solos-pci.c:	dev_info(&card->dev->dev, "Changing FPGA to Update mode\n");
./drivers/atm/solos-pci.c:	iowrite32(1, card->config_regs + FPGA_MODE);
./drivers/atm/solos-pci.c:	(void) ioread32(card->config_regs + FPGA_MODE); 
./drivers/atm/solos-pci.c:		dev_info(&card->dev->dev, "Set FPGA Flash mode to FPGA Chip Erase\n");
./drivers/atm/solos-pci.c:		dev_info(&card->dev->dev, "Set FPGA Flash mode to Solos Chip Erase\n");
./drivers/atm/solos-pci.c:	iowrite32((chip * 2), card->config_regs + FLASH_MODE);
./drivers/atm/solos-pci.c:	iowrite32(1, card->config_regs + WRITE_FLASH);
./drivers/atm/solos-pci.c:	wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
./drivers/atm/solos-pci.c:		iowrite32(0, card->config_regs + WRITE_FLASH);
./drivers/atm/solos-pci.c:		/* dev_info(&card->dev->dev, "Set FPGA Flash mode to Block Write\n"); */
./drivers/atm/solos-pci.c:		iowrite32(((chip * 2) + 1), card->config_regs + FLASH_MODE);
./drivers/atm/solos-pci.c:			if(card->fpga_version > LEGACY_BUFFERS)
./drivers/atm/solos-pci.c:		iowrite32(offset / blocksize, card->config_regs + FLASH_BLOCK);
./drivers/atm/solos-pci.c:		iowrite32(1, card->config_regs + WRITE_FLASH);
./drivers/atm/solos-pci.c:		wait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));
./drivers/atm/solos-pci.c:	iowrite32(0, card->config_regs + WRITE_FLASH);
./drivers/atm/solos-pci.c:	iowrite32(0, card->config_regs + FPGA_MODE);
./drivers/atm/solos-pci.c:	iowrite32(0, card->config_regs + FLASH_MODE);
./drivers/atm/solos-pci.c:	dev_info(&card->dev->dev, "Returning FPGA to Data mode\n");
./drivers/atm/solos-pci.c:	iowrite32(0, card->config_regs + IRQ_CLEAR);
./drivers/atm/solos-pci.c:	if (card->atmdev[0])
./drivers/atm/solos-pci.c:		tasklet_schedule(&card->tlet);
./drivers/atm/solos-pci.c:		wake_up(&card->fw_wq);
./drivers/atm/solos-pci.c:	for (port = 0; port < card->nr_ports; port++) {
./drivers/atm/solos-pci.c:			if (card->using_dma) {
./drivers/atm/solos-pci.c:				skb = card->rx_skb[port];
./drivers/atm/solos-pci.c:				card->rx_skb[port] = NULL;
./drivers/atm/solos-pci.c:				pci_unmap_single(card->dev, SKB_CB(skb)->dma_addr,
./drivers/atm/solos-pci.c:				if (size > (card->buffer_size - sizeof(*header))){
./drivers/atm/solos-pci.c:					dev_warn(&card->dev->dev, "Invalid buffer size\n");
./drivers/atm/solos-pci.c:						dev_warn(&card->dev->dev, "Failed to allocate sk_buff for RX\n");
./drivers/atm/solos-pci.c:				dev_info(&card->dev->dev, "Received: port %d\n", port);
./drivers/atm/solos-pci.c:				dev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",
./drivers/atm/solos-pci.c:				vcc = find_vcc(card->atmdev[port], le16_to_cpu(header->vpi),
./drivers/atm/solos-pci.c:						dev_warn(&card->dev->dev, "Received packet for unknown VPI.VCI %d.%d on port %d\n",
./drivers/atm/solos-pci.c:					dev_warn(&card->dev->dev, "Bad status packet of %d bytes on port %d:\n", skb->len, port);
./drivers/atm/solos-pci.c:				spin_lock(&card->cli_queue_lock);
./drivers/atm/solos-pci.c:				if (skb_queue_len(&card->cli_queue[port]) > 10) {
./drivers/atm/solos-pci.c:						dev_warn(&card->dev->dev, "Dropping console response on port %d\n",
./drivers/atm/solos-pci.c:					skb_queue_tail(&card->cli_queue[port], skb);
./drivers/atm/solos-pci.c:				spin_unlock(&card->cli_queue_lock);
./drivers/atm/solos-pci.c:		if (card->using_dma && card->atmdev[port] &&
./drivers/atm/solos-pci.c:		    !card->rx_skb[port]) {
./drivers/atm/solos-pci.c:					pci_map_single(card->dev, skb->data,
./drivers/atm/solos-pci.c:					  card->config_regs + RX_DMA_ADDR(port));
./drivers/atm/solos-pci.c:				card->rx_skb[port] = skb;
./drivers/atm/solos-pci.c:					dev_warn(&card->dev->dev, "Failed to allocate RX skb");
./drivers/atm/solos-pci.c:				tasklet_schedule(&card->tlet);
./drivers/atm/solos-pci.c:		iowrite32(rx_done, card->config_regs + FLAGS_ADDR);
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Unsupported ATM type %d\n",
./drivers/atm/solos-pci.c:			dev_warn(&card->dev->dev, "Failed to allocate sk_buff in popen()\n");
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Failed to allocate sk_buff in pclose()\n");
./drivers/atm/solos-pci.c:	tasklet_unlock_wait(&card->tlet);
./drivers/atm/solos-pci.c:	spin_lock_irqsave(&card->tx_queue_lock, flags);
./drivers/atm/solos-pci.c:	old_len = skb_queue_len(&card->tx_queue[port]);
./drivers/atm/solos-pci.c:	skb_queue_tail(&card->tx_queue[port], skb);
./drivers/atm/solos-pci.c:		card->tx_mask |= (1 << port);
./drivers/atm/solos-pci.c:	spin_unlock_irqrestore(&card->tx_queue_lock, flags);
./drivers/atm/solos-pci.c:	spin_lock_irqsave(&card->tx_lock, flags);
./drivers/atm/solos-pci.c:	card_flags = ioread32(card->config_regs + FLAGS_ADDR);
./drivers/atm/solos-pci.c:	tx_pending = card->tx_mask & ~card_flags;
./drivers/atm/solos-pci.c:			struct sk_buff *oldskb = card->tx_skb[port];
./drivers/atm/solos-pci.c:				pci_unmap_single(card->dev, SKB_CB(oldskb)->dma_addr,
./drivers/atm/solos-pci.c:			spin_lock(&card->tx_queue_lock);
./drivers/atm/solos-pci.c:			skb = skb_dequeue(&card->tx_queue[port]);
./drivers/atm/solos-pci.c:				card->tx_mask &= ~(1 << port);
./drivers/atm/solos-pci.c:			spin_unlock(&card->tx_queue_lock);
./drivers/atm/solos-pci.c:			if (skb && !card->using_dma) {
./drivers/atm/solos-pci.c:			} else if (skb && card->using_dma) {
./drivers/atm/solos-pci.c:				SKB_CB(skb)->dma_addr = pci_map_single(card->dev, skb->data,
./drivers/atm/solos-pci.c:				card->tx_skb[port] = skb;
./drivers/atm/solos-pci.c:					  card->config_regs + TX_DMA_ADDR(port));
./drivers/atm/solos-pci.c:				dev_info(&card->dev->dev, "Transmitted: port %d\n",
./drivers/atm/solos-pci.c:				dev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",
./drivers/atm/solos-pci.c:		iowrite32(tx_started, card->config_regs + FLAGS_ADDR);
./drivers/atm/solos-pci.c:	spin_unlock_irqrestore(&card->tx_lock, flags);
./drivers/atm/solos-pci.c:		dev_warn(&card->dev->dev, "Length of PDU is too large. Dropping PDU.\n");
./drivers/atm/solos-pci.c:			dev_warn(&card->dev->dev, "pskb_expand_head failed.\n");
./drivers/atm/solos-pci.c:	card->dev = dev;
./drivers/atm/solos-pci.c:	init_waitqueue_head(&card->fw_wq);
./drivers/atm/solos-pci.c:	init_waitqueue_head(&card->param_wq);
./drivers/atm/solos-pci.c:	card->config_regs = pci_iomap(dev, 0, CONFIG_RAM_SIZE);
./drivers/atm/solos-pci.c:	if (!card->config_regs) {
./drivers/atm/solos-pci.c:	card->buffers = pci_iomap(dev, 1, DATA_RAM_SIZE);
./drivers/atm/solos-pci.c:	if (!card->buffers) {
./drivers/atm/solos-pci.c:		iowrite32(1, card->config_regs + FPGA_MODE);
./drivers/atm/solos-pci.c:		data32 = ioread32(card->config_regs + FPGA_MODE); 
./drivers/atm/solos-pci.c:		iowrite32(0, card->config_regs + FPGA_MODE);
./drivers/atm/solos-pci.c:		data32 = ioread32(card->config_regs + FPGA_MODE); 
./drivers/atm/solos-pci.c:	data32 = ioread32(card->config_regs + FPGA_VER);
./drivers/atm/solos-pci.c:	card->fpga_version = FPGA_VERSION(major_ver,minor_ver);
./drivers/atm/solos-pci.c:	if (card->fpga_version > LEGACY_BUFFERS)
./drivers/atm/solos-pci.c:		card->buffer_size = BUF_SIZE;
./drivers/atm/solos-pci.c:		card->buffer_size = OLD_BUF_SIZE;
./drivers/atm/solos-pci.c:	if (card->fpga_version >= DMA_SUPPORTED) {
./drivers/atm/solos-pci.c:		card->using_dma = 1;
./drivers/atm/solos-pci.c:		card->using_dma = 0;
./drivers/atm/solos-pci.c:		iowrite32(0xF0, card->config_regs + FLAGS_ADDR);
./drivers/atm/solos-pci.c:	data32 = ioread32(card->config_regs + PORTS);
./drivers/atm/solos-pci.c:	card->nr_ports = (data32 & 0x000000FF);
./drivers/atm/solos-pci.c:	tasklet_init(&card->tlet, solos_bh, (unsigned long)card);
./drivers/atm/solos-pci.c:	spin_lock_init(&card->tx_lock);
./drivers/atm/solos-pci.c:	spin_lock_init(&card->tx_queue_lock);
./drivers/atm/solos-pci.c:	spin_lock_init(&card->cli_queue_lock);
./drivers/atm/solos-pci.c:	spin_lock_init(&card->param_queue_lock);
./drivers/atm/solos-pci.c:	INIT_LIST_HEAD(&card->param_queue);
./drivers/atm/solos-pci.c:		dev_dbg(&card->dev->dev, "Failed to request interrupt IRQ: %d\n", dev->irq);
./drivers/atm/solos-pci.c:	iowrite32(1, card->config_regs + IRQ_EN_ADDR);
./drivers/atm/solos-pci.c:	iowrite32(0, card->config_regs + IRQ_EN_ADDR);
./drivers/atm/solos-pci.c:	tasklet_kill(&card->tlet);
./drivers/atm/solos-pci.c:	pci_iounmap(dev, card->config_regs);
./drivers/atm/solos-pci.c:	pci_iounmap(dev, card->buffers);
./drivers/atm/solos-pci.c:	for (i = 0; i < card->nr_ports; i++) {
./drivers/atm/solos-pci.c:		skb_queue_head_init(&card->tx_queue[i]);
./drivers/atm/solos-pci.c:		skb_queue_head_init(&card->cli_queue[i]);
./drivers/atm/solos-pci.c:		card->atmdev[i] = atm_dev_register("solos-pci", parent, &fpga_ops, -1, NULL);
./drivers/atm/solos-pci.c:		if (!card->atmdev[i]) {
./drivers/atm/solos-pci.c:			dev_err(&card->dev->dev, "Could not register ATM device %d\n", i);
./drivers/atm/solos-pci.c:		if (device_create_file(&card->atmdev[i]->class_dev, &dev_attr_console))
./drivers/atm/solos-pci.c:			dev_err(&card->dev->dev, "Could not register console for ATM device %d\n", i);
./drivers/atm/solos-pci.c:		if (sysfs_create_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group))
./drivers/atm/solos-pci.c:			dev_err(&card->dev->dev, "Could not register parameter group for ATM device %d\n", i);
./drivers/atm/solos-pci.c:		dev_info(&card->dev->dev, "Registered ATM device %d\n", card->atmdev[i]->number);
./drivers/atm/solos-pci.c:		card->atmdev[i]->ci_range.vpi_bits = 8;
./drivers/atm/solos-pci.c:		card->atmdev[i]->ci_range.vci_bits = 16;
./drivers/atm/solos-pci.c:		card->atmdev[i]->dev_data = card;
./drivers/atm/solos-pci.c:		card->atmdev[i]->phy_data = (void *)(unsigned long)i;
./drivers/atm/solos-pci.c:		atm_dev_signal_change(card->atmdev[i], ATM_PHY_SIG_FOUND);
./drivers/atm/solos-pci.c:			dev_warn(&card->dev->dev, "Failed to allocate sk_buff in atm_init()\n");
./drivers/atm/solos-pci.c:	for (i = 0; i < card->nr_ports; i++) {
./drivers/atm/solos-pci.c:		if (card->atmdev[i]) {
./drivers/atm/solos-pci.c:			dev_info(&card->dev->dev, "Unregistering ATM device %d\n", card->atmdev[i]->number);
./drivers/atm/solos-pci.c:			sysfs_remove_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group);
./drivers/atm/solos-pci.c:			atm_dev_deregister(card->atmdev[i]);
./drivers/atm/solos-pci.c:			skb = card->rx_skb[i];
./drivers/atm/solos-pci.c:				pci_unmap_single(card->dev, SKB_CB(skb)->dma_addr,
./drivers/atm/solos-pci.c:			skb = card->tx_skb[i];
./drivers/atm/solos-pci.c:				pci_unmap_single(card->dev, SKB_CB(skb)->dma_addr,
./drivers/atm/solos-pci.c:			while ((skb = skb_dequeue(&card->tx_queue[i])))
./drivers/atm/solos-pci.c:	iowrite32(0, card->config_regs + IRQ_EN_ADDR);
./drivers/atm/solos-pci.c:	iowrite32(1, card->config_regs + FPGA_MODE);
./drivers/atm/solos-pci.c:	(void)ioread32(card->config_regs + FPGA_MODE); 
./drivers/atm/solos-pci.c:	tasklet_kill(&card->tlet);
./drivers/atm/solos-pci.c:	iowrite32(0, card->config_regs + FPGA_MODE);
./drivers/atm/solos-pci.c:	(void)ioread32(card->config_regs + FPGA_MODE); 
./drivers/atm/solos-pci.c:	pci_iounmap(dev, card->buffers);
./drivers/atm/solos-pci.c:	pci_iounmap(dev, card->config_regs);
./drivers/atm/lanai.c: * This is the card-specific per-vcc data.  Note that unlike some other
./drivers/atm/lanai.c:		printk(KERN_ERR DEV_LABEL ": Found %s board-id %d -- not a "
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	    (((addr > card->tst[0] + card->tst_size - 2) &&
./drivers/atm/idt77252.c:	      (addr < card->tst[0] + card->tst_size)) ||
./drivers/atm/idt77252.c:	     ((addr > card->tst[1] + card->tst_size - 2) &&
./drivers/atm/idt77252.c:	      (addr < card->tst[1] + card->tst_size)))) {
./drivers/atm/idt77252.c:		       card->name, addr, value);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	tct = (unsigned long) (card->tct_base + index * SAR_SRAM_TCT_SIZE);
./drivers/atm/idt77252.c:	printk("%s: TCT %x:", card->name, index);
./drivers/atm/idt77252.c:	for (i = 0; i < card->tct_size; i++) {
./drivers/atm/idt77252.c:		vc = card->vcs[i];
./drivers/atm/idt77252.c:		printk("%s: Connection %d:\n", card->name, vc->index);
./drivers/atm/idt77252.c:	struct sb_pool *pool = &card->sbpool[queue];
./drivers/atm/idt77252.c:	card->sbpool[queue].skb[index] = NULL;
./drivers/atm/idt77252.c:	return card->sbpool[queue].skb[index];
./drivers/atm/idt77252.c:	scq->base = pci_alloc_consistent(card->pcidev, SCQ_SIZE,
./drivers/atm/idt77252.c:	pci_free_consistent(card->pcidev, SCQ_SIZE,
./drivers/atm/idt77252.c:		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:	TXPRINTK("%s: SCQ: next 0x%p\n", card->name, scq->next);
./drivers/atm/idt77252.c:		card->name, atomic_read(&scq->used),
./drivers/atm/idt77252.c:		       card->name, vc->tx_vcc->vpi, vc->tx_vcc->vci);
./drivers/atm/idt77252.c:		 card->name, atomic_read(&scq->used), scq->next);
./drivers/atm/idt77252.c:		TXPRINTK("%s: freeing skb at %p.\n", card->name, skb);
./drivers/atm/idt77252.c:		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:		printk("%s: invalid skb->len (%d)\n", card->name, skb->len);
./drivers/atm/idt77252.c:		 card->name, skb->len);
./drivers/atm/idt77252.c:	IDT77252_PRV_PADDR(skb) = pci_map_single(card->pcidev, skb->data,
./drivers/atm/idt77252.c:			vc = card->vcs[0];
./drivers/atm/idt77252.c:		printk("%s: Trying to transmit on reserved VC\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: Traffic type not supported.\n", card->name);
./drivers/atm/idt77252.c:	pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:	for (i = 0; i < card->scd_size; i++) {
./drivers/atm/idt77252.c:		if (!card->scd2vc[i]) {
./drivers/atm/idt77252.c:			card->scd2vc[i] = vc;
./drivers/atm/idt77252.c:			return card->scd_base + i * SAR_SRAM_SCD_SIZE;
./drivers/atm/idt77252.c:	card->rsq.base = pci_alloc_consistent(card->pcidev, RSQSIZE,
./drivers/atm/idt77252.c:					      &card->rsq.paddr);
./drivers/atm/idt77252.c:	if (card->rsq.base == NULL) {
./drivers/atm/idt77252.c:		printk("%s: can't allocate RSQ.\n", card->name);
./drivers/atm/idt77252.c:	memset(card->rsq.base, 0, RSQSIZE);
./drivers/atm/idt77252.c:	card->rsq.last = card->rsq.base + RSQ_NUM_ENTRIES - 1;
./drivers/atm/idt77252.c:	card->rsq.next = card->rsq.last;
./drivers/atm/idt77252.c:	for (rsqe = card->rsq.base; rsqe <= card->rsq.last; rsqe++)
./drivers/atm/idt77252.c:	writel((unsigned long) card->rsq.last - (unsigned long) card->rsq.base,
./drivers/atm/idt77252.c:	writel(card->rsq.paddr, SAR_REG_RSQB);
./drivers/atm/idt77252.c:	IPRINTK("%s: RSQ base at 0x%lx (0x%x).\n", card->name,
./drivers/atm/idt77252.c:		(unsigned long) card->rsq.base,
./drivers/atm/idt77252.c:		card->name,
./drivers/atm/idt77252.c:	pci_free_consistent(card->pcidev, RSQSIZE,
./drivers/atm/idt77252.c:			    card->rsq.base, card->rsq.paddr);
./drivers/atm/idt77252.c:			 card->name);
./drivers/atm/idt77252.c:		       card->name, __func__,
./drivers/atm/idt77252.c:		 card->name, vpi, vci, skb, skb->data);
./drivers/atm/idt77252.c:	if ((vpi >= (1 << card->vpibits)) || (vci != (vci & card->vcimask))) {
./drivers/atm/idt77252.c:		       card->name, vpi, vci);
./drivers/atm/idt77252.c:	vc = card->vcs[VPCI2VC(card, vpi, vci)];
./drivers/atm/idt77252.c:		       card->name, vpi, vci);
./drivers/atm/idt77252.c:	pci_dma_sync_single_for_cpu(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:				       card->name);
./drivers/atm/idt77252.c:					 card->name);
./drivers/atm/idt77252.c:		       card->name, vcc->qos.aal);
./drivers/atm/idt77252.c:		RXPRINTK("%s: PDU has %d bytes.\n", card->name, len);
./drivers/atm/idt77252.c:			         card->name, len, rpp->len, readl(SAR_REG_CDC));
./drivers/atm/idt77252.c:			RXPRINTK("%s: AAL5 CRC error.\n", card->name);
./drivers/atm/idt77252.c:					 card->name);
./drivers/atm/idt77252.c:		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:	if (card->rsq.next == card->rsq.last)
./drivers/atm/idt77252.c:		rsqe = card->rsq.base;
./drivers/atm/idt77252.c:		rsqe = card->rsq.next + 1;
./drivers/atm/idt77252.c:		RXPRINTK("%s: no entry in RSQ.\n", card->name);
./drivers/atm/idt77252.c:		card->rsq.next = rsqe;
./drivers/atm/idt77252.c:		if (card->rsq.next == card->rsq.last)
./drivers/atm/idt77252.c:			rsqe = card->rsq.base;
./drivers/atm/idt77252.c:			rsqe = card->rsq.next + 1;
./drivers/atm/idt77252.c:	writel((unsigned long) card->rsq.next - (unsigned long) card->rsq.base,
./drivers/atm/idt77252.c:	if (card->raw_cell_head == NULL) {
./drivers/atm/idt77252.c:		u32 handle = le32_to_cpu(*(card->raw_cell_hnd + 1));
./drivers/atm/idt77252.c:		card->raw_cell_head = sb_pool_skb(card, handle);
./drivers/atm/idt77252.c:	queue = card->raw_cell_head;
./drivers/atm/idt77252.c:	pci_dma_sync_single_for_cpu(card->pcidev, IDT77252_PRV_PADDR(queue),
./drivers/atm/idt77252.c:			       card->name, (header >> 28) & 0x000f,
./drivers/atm/idt77252.c:		if (vpi >= (1<<card->vpibits) || vci >= (1<<card->vcibits)) {
./drivers/atm/idt77252.c:				card->name, vpi, vci);
./drivers/atm/idt77252.c:		vc = card->vcs[VPCI2VC(card, vpi, vci)];
./drivers/atm/idt77252.c:				card->name, vpi, vci);
./drivers/atm/idt77252.c:				card->name, vpi, vci);
./drivers/atm/idt77252.c:			       card->name);
./drivers/atm/idt77252.c:				 card->name);
./drivers/atm/idt77252.c:				card->raw_cell_head = next;
./drivers/atm/idt77252.c:				queue = card->raw_cell_head;
./drivers/atm/idt77252.c:				pci_dma_sync_single_for_cpu(card->pcidev,
./drivers/atm/idt77252.c:				card->raw_cell_head = NULL;
./drivers/atm/idt77252.c:				       card->name);
./drivers/atm/idt77252.c:	card->tsq.base = pci_alloc_consistent(card->pcidev, RSQSIZE,
./drivers/atm/idt77252.c:					      &card->tsq.paddr);
./drivers/atm/idt77252.c:	if (card->tsq.base == NULL) {
./drivers/atm/idt77252.c:		printk("%s: can't allocate TSQ.\n", card->name);
./drivers/atm/idt77252.c:	memset(card->tsq.base, 0, TSQSIZE);
./drivers/atm/idt77252.c:	card->tsq.last = card->tsq.base + TSQ_NUM_ENTRIES - 1;
./drivers/atm/idt77252.c:	card->tsq.next = card->tsq.last;
./drivers/atm/idt77252.c:	for (tsqe = card->tsq.base; tsqe <= card->tsq.last; tsqe++)
./drivers/atm/idt77252.c:	writel(card->tsq.paddr, SAR_REG_TSQB);
./drivers/atm/idt77252.c:	writel((unsigned long) card->tsq.next - (unsigned long) card->tsq.base,
./drivers/atm/idt77252.c:	pci_free_consistent(card->pcidev, TSQSIZE,
./drivers/atm/idt77252.c:			    card->tsq.base, card->tsq.paddr);
./drivers/atm/idt77252.c:	if (card->tsq.next == card->tsq.last)
./drivers/atm/idt77252.c:		tsqe = card->tsq.base;
./drivers/atm/idt77252.c:		tsqe = card->tsq.next + 1;
./drivers/atm/idt77252.c:		 card->tsq.base, card->tsq.next, card->tsq.last);
./drivers/atm/idt77252.c:			TXPRINTK("%s: Timer RollOver detected.\n", card->name);
./drivers/atm/idt77252.c:				       card->name,
./drivers/atm/idt77252.c:			vc = card->vcs[conn & 0x1fff];
./drivers/atm/idt77252.c:				       card->name, conn & 0x1fff);
./drivers/atm/idt77252.c:			       card->name, vc->index);
./drivers/atm/idt77252.c:			vc = card->vcs[conn & 0x1fff];
./drivers/atm/idt77252.c:				       card->name,
./drivers/atm/idt77252.c:			if (vpi >= (1 << card->vpibits) ||
./drivers/atm/idt77252.c:			    vci >= (1 << card->vcibits)) {
./drivers/atm/idt77252.c:				       card->name, vpi, vci);
./drivers/atm/idt77252.c:			vc = card->vcs[VPCI2VC(card, vpi, vci)];
./drivers/atm/idt77252.c:				       card->name, vpi, vci);
./drivers/atm/idt77252.c:		card->tsq.next = tsqe;
./drivers/atm/idt77252.c:		if (card->tsq.next == card->tsq.last)
./drivers/atm/idt77252.c:			tsqe = card->tsq.base;
./drivers/atm/idt77252.c:			tsqe = card->tsq.next + 1;
./drivers/atm/idt77252.c:			 card->tsq.base, card->tsq.next, card->tsq.last);
./drivers/atm/idt77252.c:	writel((unsigned long)card->tsq.next - (unsigned long)card->tsq.base,
./drivers/atm/idt77252.c:		card->index, readl(SAR_REG_TSQH),
./drivers/atm/idt77252.c:		readl(SAR_REG_TSQT), card->tsq.next);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	base = card->tst[card->tst_index];
./drivers/atm/idt77252.c:	idle = card->tst[card->tst_index ^ 1];
./drivers/atm/idt77252.c:	if (test_bit(TST_SWITCH_WAIT, &card->tst_state)) {
./drivers/atm/idt77252.c:		jump = base + card->tst_size - 2;
./drivers/atm/idt77252.c:		if ((pc ^ idle) & ~(card->tst_size - 1)) {
./drivers/atm/idt77252.c:			mod_timer(&card->tst_timer, jiffies + 1);
./drivers/atm/idt77252.c:		clear_bit(TST_SWITCH_WAIT, &card->tst_state);
./drivers/atm/idt77252.c:		card->tst_index ^= 1;
./drivers/atm/idt77252.c:		base = card->tst[card->tst_index];
./drivers/atm/idt77252.c:		idle = card->tst[card->tst_index ^ 1];
./drivers/atm/idt77252.c:		for (e = 0; e < card->tst_size - 2; e++) {
./drivers/atm/idt77252.c:			if (card->soft_tst[e].tste & TSTE_PUSH_IDLE) {
./drivers/atm/idt77252.c:					   card->soft_tst[e].tste & TSTE_MASK);
./drivers/atm/idt77252.c:				card->soft_tst[e].tste &= ~(TSTE_PUSH_IDLE);
./drivers/atm/idt77252.c:	if (test_and_clear_bit(TST_SWITCH_PENDING, &card->tst_state)) {
./drivers/atm/idt77252.c:		for (e = 0; e < card->tst_size - 2; e++) {
./drivers/atm/idt77252.c:			if (card->soft_tst[e].tste & TSTE_PUSH_ACTIVE) {
./drivers/atm/idt77252.c:					   card->soft_tst[e].tste & TSTE_MASK);
./drivers/atm/idt77252.c:				card->soft_tst[e].tste &= ~(TSTE_PUSH_ACTIVE);
./drivers/atm/idt77252.c:				card->soft_tst[e].tste |= TSTE_PUSH_IDLE;
./drivers/atm/idt77252.c:		jump = base + card->tst_size - 2;
./drivers/atm/idt77252.c:		set_bit(TST_SWITCH_WAIT, &card->tst_state);
./drivers/atm/idt77252.c:		mod_timer(&card->tst_timer, jiffies + 1);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	avail = card->tst_size - 2;
./drivers/atm/idt77252.c:		if (card->soft_tst[e].vc == NULL)
./drivers/atm/idt77252.c:		printk("%s: No free TST entries found\n", card->name);
./drivers/atm/idt77252.c:		card->name, vc ? vc->index : -1, e);
./drivers/atm/idt77252.c:	idle = card->tst[card->tst_index ^ 1];
./drivers/atm/idt77252.c:		if ((cl >= avail) && (card->soft_tst[e].vc == NULL)) {
./drivers/atm/idt77252.c:				card->soft_tst[e].vc = vc;
./drivers/atm/idt77252.c:				card->soft_tst[e].vc = (void *)-1;
./drivers/atm/idt77252.c:			card->soft_tst[e].tste = data;
./drivers/atm/idt77252.c:			if (timer_pending(&card->tst_timer))
./drivers/atm/idt77252.c:				card->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;
./drivers/atm/idt77252.c:				card->soft_tst[e].tste |= TSTE_PUSH_IDLE;
./drivers/atm/idt77252.c:			cl -= card->tst_size;
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	set_bit(TST_SWITCH_PENDING, &card->tst_state);
./drivers/atm/idt77252.c:	if (!timer_pending(&card->tst_timer))
./drivers/atm/idt77252.c:		mod_timer(&card->tst_timer, jiffies + 1);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	idle = card->tst[card->tst_index ^ 1];
./drivers/atm/idt77252.c:	for (e = 0; e < card->tst_size - 2; e++) {
./drivers/atm/idt77252.c:		if (card->soft_tst[e].vc == vc) {
./drivers/atm/idt77252.c:			card->soft_tst[e].vc = NULL;
./drivers/atm/idt77252.c:			card->soft_tst[e].tste = TSTE_OPC_VAR;
./drivers/atm/idt77252.c:			if (timer_pending(&card->tst_timer))
./drivers/atm/idt77252.c:				card->soft_tst[e].tste |= TSTE_PUSH_ACTIVE;
./drivers/atm/idt77252.c:				card->soft_tst[e].tste |= TSTE_PUSH_IDLE;
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	set_bit(TST_SWITCH_PENDING, &card->tst_state);
./drivers/atm/idt77252.c:	if (!timer_pending(&card->tst_timer))
./drivers/atm/idt77252.c:		mod_timer(&card->tst_timer, jiffies + 1);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	set_bit(TST_SWITCH_PENDING, &card->tst_state);
./drivers/atm/idt77252.c:	if (!timer_pending(&card->tst_timer))
./drivers/atm/idt77252.c:		mod_timer(&card->tst_timer, jiffies + 1);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->tst_lock, flags);
./drivers/atm/idt77252.c:	tct = (unsigned long) (card->tct_base + vc->index * SAR_SRAM_TCT_SIZE);
./drivers/atm/idt77252.c:		        card->name, tct, vc->scq->scd);
./drivers/atm/idt77252.c:		        card->name, tct, vc->scq->scd);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	writel(handle, card->fbq[queue]);
./drivers/atm/idt77252.c:	writel(addr, card->fbq[queue]);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:		paddr = pci_map_single(card->pcidev, skb->data,
./drivers/atm/idt77252.c:	pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:	card->sbpool[POOL_QUEUE(handle)].skb[POOL_INDEX(handle)] = NULL;
./drivers/atm/idt77252.c:	pci_dma_sync_single_for_device(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:		pci_unmap_single(card->pcidev, IDT77252_PRV_PADDR(skb),
./drivers/atm/idt77252.c:		printk("%s: NULL connection in send().\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: Trying to transmit on a non-tx VC.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);
./drivers/atm/idt77252.c:		printk("%s: No scatter-gather yet.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: Out of memory in send_oam().\n", card->name);
./drivers/atm/idt77252.c:		       card->name);
./drivers/atm/idt77252.c:	tst_free = card->tst_free;
./drivers/atm/idt77252.c:	TXPRINTK("%s: CBR target cell rate = %d\n", card->name, tcra);
./drivers/atm/idt77252.c:	tmpl = (unsigned long) tcra * ((unsigned long) card->tst_size - 2);
./drivers/atm/idt77252.c:	modl = tmpl % (unsigned long)card->utopia_pcr;
./drivers/atm/idt77252.c:	tst_entries = (int) (tmpl / card->utopia_pcr);
./drivers/atm/idt77252.c:			printk("%s: no CBR bandwidth free.\n", card->name);
./drivers/atm/idt77252.c:		       card->name);
./drivers/atm/idt77252.c:		printk("%s: not enough CBR bandwidth free.\n", card->name);
./drivers/atm/idt77252.c:	card->tst_free = tst_free - tst_entries;
./drivers/atm/idt77252.c:			card->name, tst_used, tst_entries);
./drivers/atm/idt77252.c:	OPRINTK("%s: setting %d entries in TST.\n", card->name, tst_entries);
./drivers/atm/idt77252.c:		tcr = card->link_pcr;
./drivers/atm/idt77252.c:		printk("%s: can't get SCQ.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: no SCD available.\n", card->name);
./drivers/atm/idt77252.c:		       card->name, qos->txtp.traffic_class);
./drivers/atm/idt77252.c:		card->scd2vc[vc->scd_index] = NULL;
./drivers/atm/idt77252.c:				card->scd2vc[vc->scd_index] = NULL;
./drivers/atm/idt77252.c:				card->scd2vc[vc->scd_index] = NULL;
./drivers/atm/idt77252.c:	addr = card->rct_base + (vc->index << 2);
./drivers/atm/idt77252.c:	OPRINTK("%s: writing RCT at 0x%lx\n", card->name, addr);
./drivers/atm/idt77252.c:	spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	if (vpi >= (1 << card->vpibits)) {
./drivers/atm/idt77252.c:		printk("%s: unsupported VPI: %d\n", card->name, vpi);
./drivers/atm/idt77252.c:	if (vci >= (1 << card->vcibits)) {
./drivers/atm/idt77252.c:		printk("%s: unsupported VCI: %d\n", card->name, vci);
./drivers/atm/idt77252.c:	mutex_lock(&card->mutex);
./drivers/atm/idt77252.c:	OPRINTK("%s: opening vpi.vci: %d.%d\n", card->name, vpi, vci);
./drivers/atm/idt77252.c:		printk("%s: Unsupported AAL: %d\n", card->name, vcc->qos.aal);
./drivers/atm/idt77252.c:		mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:	if (!card->vcs[index]) {
./drivers/atm/idt77252.c:		card->vcs[index] = kzalloc(sizeof(struct vc_map), GFP_KERNEL);
./drivers/atm/idt77252.c:		if (!card->vcs[index]) {
./drivers/atm/idt77252.c:			printk("%s: can't alloc vc in open()\n", card->name);
./drivers/atm/idt77252.c:			mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:		card->vcs[index]->card = card;
./drivers/atm/idt77252.c:		card->vcs[index]->index = index;
./drivers/atm/idt77252.c:		spin_lock_init(&card->vcs[index]->lock);
./drivers/atm/idt77252.c:	vc = card->vcs[index];
./drivers/atm/idt77252.c:	        card->name, vc->index, vcc->vpi, vcc->vci,
./drivers/atm/idt77252.c:		printk("%s: %s vci already in use.\n", card->name,
./drivers/atm/idt77252.c:		mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:			mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:			mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:	mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:	mutex_lock(&card->mutex);
./drivers/atm/idt77252.c:		card->name, vc->index, vcc->vpi, vcc->vci);
./drivers/atm/idt77252.c:		addr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;
./drivers/atm/idt77252.c:		spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:		spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:				card->name);
./drivers/atm/idt77252.c:			       card->name, atomic_read(&vc->scq->used));
./drivers/atm/idt77252.c:			card->tst_free += vc->ntste;
./drivers/atm/idt77252.c:		card->scd2vc[vc->scd_index] = NULL;
./drivers/atm/idt77252.c:	mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:	mutex_lock(&card->mutex);
./drivers/atm/idt77252.c:	mutex_unlock(&card->mutex);
./drivers/atm/idt77252.c:		return sprintf(page, "TSIF:  %lu\n", card->irqstat[15]);
./drivers/atm/idt77252.c:		return sprintf(page, "TXICP: %lu\n", card->irqstat[14]);
./drivers/atm/idt77252.c:		return sprintf(page, "TSQF:  %lu\n", card->irqstat[12]);
./drivers/atm/idt77252.c:		return sprintf(page, "TMROF: %lu\n", card->irqstat[11]);
./drivers/atm/idt77252.c:		return sprintf(page, "PHYI:  %lu\n", card->irqstat[10]);
./drivers/atm/idt77252.c:		return sprintf(page, "FBQ3A: %lu\n", card->irqstat[8]);
./drivers/atm/idt77252.c:		return sprintf(page, "FBQ2A: %lu\n", card->irqstat[7]);
./drivers/atm/idt77252.c:		return sprintf(page, "RSQF:  %lu\n", card->irqstat[6]);
./drivers/atm/idt77252.c:		return sprintf(page, "EPDU:  %lu\n", card->irqstat[5]);
./drivers/atm/idt77252.c:		return sprintf(page, "RAWCF: %lu\n", card->irqstat[4]);
./drivers/atm/idt77252.c:		return sprintf(page, "FBQ1A: %lu\n", card->irqstat[3]);
./drivers/atm/idt77252.c:		return sprintf(page, "FBQ0A: %lu\n", card->irqstat[2]);
./drivers/atm/idt77252.c:		return sprintf(page, "RSQAF: %lu\n", card->irqstat[1]);
./drivers/atm/idt77252.c:	for (i = 0; i < card->tct_size; i++) {
./drivers/atm/idt77252.c:		vc = card->vcs[i];
./drivers/atm/idt77252.c:		tct = (unsigned long) (card->tct_base + i * SAR_SRAM_TCT_SIZE);
./drivers/atm/idt77252.c:	if (test_and_set_bit(IDT77252_BIT_INTERRUPT, &card->flags)) {
./drivers/atm/idt77252.c:		printk("%s: Re-entering irq_handler()\n", card->name);
./drivers/atm/idt77252.c:		INTPRINTK("%s: TSIF\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[15]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: TXICP\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[14]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: TSQF\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[12]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: TMROF\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[11]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: EPDU\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[5]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: RSQAF\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[1]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: RSQF\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[6]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: RAWCF\n", card->name);
./drivers/atm/idt77252.c:		card->irqstat[4]++;
./drivers/atm/idt77252.c:		INTPRINTK("%s: PHYI", card->name);
./drivers/atm/idt77252.c:		card->irqstat[10]++;
./drivers/atm/idt77252.c:		if (card->atmdev->phy && card->atmdev->phy->interrupt)
./drivers/atm/idt77252.c:			card->atmdev->phy->interrupt(card->atmdev);
./drivers/atm/idt77252.c:		INTPRINTK("%s: FBQA: %04x\n", card->name, stat);
./drivers/atm/idt77252.c:			card->irqstat[2]++;
./drivers/atm/idt77252.c:			card->irqstat[3]++;
./drivers/atm/idt77252.c:			card->irqstat[7]++;
./drivers/atm/idt77252.c:			card->irqstat[8]++;
./drivers/atm/idt77252.c:		schedule_work(&card->tqueue);
./drivers/atm/idt77252.c:	clear_bit(IDT77252_BIT_INTERRUPT, &card->flags);
./drivers/atm/idt77252.c:	for (vpi = 0; vpi < (1 << card->vpibits); vpi++) {
./drivers/atm/idt77252.c:				printk("%s: can't alloc vc\n", card->name);
./drivers/atm/idt77252.c:			card->vcs[index] = vc;
./drivers/atm/idt77252.c:			addr = card->rct_base + (vc->index << 2);
./drivers/atm/idt77252.c:			spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:			spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:	for (vpi = 0; vpi < (1 << card->vpibits); vpi++) {
./drivers/atm/idt77252.c:			vc = card->vcs[index];
./drivers/atm/idt77252.c:			addr = card->rct_base + vc->index * SAR_SRAM_RCT_SIZE;
./drivers/atm/idt77252.c:			spin_lock_irqsave(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:			spin_unlock_irqrestore(&card->cmd_lock, flags);
./drivers/atm/idt77252.c:					card->name);
./drivers/atm/idt77252.c:		printk("%s: can't alloc vc\n", card->name);
./drivers/atm/idt77252.c:	card->vcs[0] = vc;
./drivers/atm/idt77252.c:		printk("%s: can't get SCQ.\n", card->name);
./drivers/atm/idt77252.c:	card->scd2vc[0] = vc;
./drivers/atm/idt77252.c:	vc->scq->scd = card->scd_base;
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 0, TCT_UBR | card->scd_base);
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 1, 0);
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 2, 0);
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 3, 0);
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 4, 0);
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 5, 0);
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 6, 0);
./drivers/atm/idt77252.c:	write_sram(card, card->tct_base + 7, TCT_FLAG_UBR);
./drivers/atm/idt77252.c:	if (!test_bit(IDT77252_BIT_INIT, &card->flags)) {
./drivers/atm/idt77252.c:		printk("%s: SAR not yet initialized.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: Error initializing OAM.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: Error initializing UBR0.\n", card->name);
./drivers/atm/idt77252.c:	IPRINTK("%s: opened IDT77252 ABR SAR.\n", card->name);
./drivers/atm/idt77252.c:	DIPRINTK("%s: closed IDT77252 ABR SAR.\n", card->name);
./drivers/atm/idt77252.c:	if (!test_bit(IDT77252_BIT_INIT, &card->flags)) {
./drivers/atm/idt77252.c:		printk("%s: SAR not yet initialized.\n", card->name);
./drivers/atm/idt77252.c:	DIPRINTK("idt77252: deinitialize card %u\n", card->index);
./drivers/atm/idt77252.c:	if (card->atmdev)
./drivers/atm/idt77252.c:		atm_dev_deregister(card->atmdev);
./drivers/atm/idt77252.c:			skb = card->sbpool[i].skb[j];
./drivers/atm/idt77252.c:				pci_unmap_single(card->pcidev,
./drivers/atm/idt77252.c:				card->sbpool[i].skb[j] = NULL;
./drivers/atm/idt77252.c:	vfree(card->soft_tst);
./drivers/atm/idt77252.c:	vfree(card->scd2vc);
./drivers/atm/idt77252.c:	vfree(card->vcs);
./drivers/atm/idt77252.c:	if (card->raw_cell_hnd) {
./drivers/atm/idt77252.c:		pci_free_consistent(card->pcidev, 2 * sizeof(u32),
./drivers/atm/idt77252.c:				    card->raw_cell_hnd, card->raw_cell_paddr);
./drivers/atm/idt77252.c:	if (card->rsq.base) {
./drivers/atm/idt77252.c:		DIPRINTK("%s: Release RSQ ...\n", card->name);
./drivers/atm/idt77252.c:	if (card->tsq.base) {
./drivers/atm/idt77252.c:		DIPRINTK("%s: Release TSQ ...\n", card->name);
./drivers/atm/idt77252.c:	free_irq(card->pcidev->irq, card);
./drivers/atm/idt77252.c:		if (card->fbq[i])
./drivers/atm/idt77252.c:			iounmap(card->fbq[i]);
./drivers/atm/idt77252.c:	if (card->membase)
./drivers/atm/idt77252.c:		iounmap(card->membase);
./drivers/atm/idt77252.c:	clear_bit(IDT77252_BIT_INIT, &card->flags);
./drivers/atm/idt77252.c:	DIPRINTK("%s: Card deinitialized.\n", card->name);
./drivers/atm/idt77252.c:	for (i = 0; i < card->sramsize; i += 4)
./drivers/atm/idt77252.c:	if (card->sramsize == (512 * 1024)) {
./drivers/atm/idt77252.c:		card->tct_base = SAR_SRAM_TCT_128_BASE;
./drivers/atm/idt77252.c:		card->tct_size = (SAR_SRAM_TCT_128_TOP - card->tct_base + 1)
./drivers/atm/idt77252.c:		card->rct_base = SAR_SRAM_RCT_128_BASE;
./drivers/atm/idt77252.c:		card->rct_size = (SAR_SRAM_RCT_128_TOP - card->rct_base + 1)
./drivers/atm/idt77252.c:		card->rt_base = SAR_SRAM_RT_128_BASE;
./drivers/atm/idt77252.c:		card->scd_base = SAR_SRAM_SCD_128_BASE;
./drivers/atm/idt77252.c:		card->scd_size = (SAR_SRAM_SCD_128_TOP - card->scd_base + 1)
./drivers/atm/idt77252.c:		card->tst[0] = SAR_SRAM_TST1_128_BASE;
./drivers/atm/idt77252.c:		card->tst[1] = SAR_SRAM_TST2_128_BASE;
./drivers/atm/idt77252.c:		card->tst_size = SAR_SRAM_TST1_128_TOP - card->tst[0] + 1;
./drivers/atm/idt77252.c:		card->abrst_base = SAR_SRAM_ABRSTD_128_BASE;
./drivers/atm/idt77252.c:		card->abrst_size = SAR_ABRSTD_SIZE_8K;
./drivers/atm/idt77252.c:		card->fifo_base = SAR_SRAM_FIFO_128_BASE;
./drivers/atm/idt77252.c:		card->fifo_size = SAR_RXFD_SIZE_32K;
./drivers/atm/idt77252.c:		card->tct_base = SAR_SRAM_TCT_32_BASE;
./drivers/atm/idt77252.c:		card->tct_size = (SAR_SRAM_TCT_32_TOP - card->tct_base + 1)
./drivers/atm/idt77252.c:		card->rct_base = SAR_SRAM_RCT_32_BASE;
./drivers/atm/idt77252.c:		card->rct_size = (SAR_SRAM_RCT_32_TOP - card->rct_base + 1)
./drivers/atm/idt77252.c:		card->rt_base = SAR_SRAM_RT_32_BASE;
./drivers/atm/idt77252.c:		card->scd_base = SAR_SRAM_SCD_32_BASE;
./drivers/atm/idt77252.c:		card->scd_size = (SAR_SRAM_SCD_32_TOP - card->scd_base + 1)
./drivers/atm/idt77252.c:		card->tst[0] = SAR_SRAM_TST1_32_BASE;
./drivers/atm/idt77252.c:		card->tst[1] = SAR_SRAM_TST2_32_BASE;
./drivers/atm/idt77252.c:		card->tst_size = (SAR_SRAM_TST1_32_TOP - card->tst[0] + 1);
./drivers/atm/idt77252.c:		card->abrst_base = SAR_SRAM_ABRSTD_32_BASE;
./drivers/atm/idt77252.c:		card->abrst_size = SAR_ABRSTD_SIZE_1K;
./drivers/atm/idt77252.c:		card->fifo_base = SAR_SRAM_FIFO_32_BASE;
./drivers/atm/idt77252.c:		card->fifo_size = SAR_RXFD_SIZE_4K;
./drivers/atm/idt77252.c:	for (i = 0; i < card->tct_size; i++) {
./drivers/atm/idt77252.c:	for (i = 0; i < card->rct_size; i++) {
./drivers/atm/idt77252.c:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE,
./drivers/atm/idt77252.c:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 1,
./drivers/atm/idt77252.c:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 2,
./drivers/atm/idt77252.c:		write_sram(card, card->rct_base + i * SAR_SRAM_RCT_SIZE + 3,
./drivers/atm/idt77252.c:		write_sram(card, card->rt_base + i, log_to_rate[i]);
./drivers/atm/idt77252.c:		write_sram(card, card->rt_base + 256 + i, tmp);
./drivers/atm/idt77252.c:		write_sram(card, card->rt_base + 512 + i, tmp);
./drivers/atm/idt77252.c:		write_sram(card, card->rt_base + 640 + i, tmp);
./drivers/atm/idt77252.c:	IPRINTK("%s: initialize rate table ...\n", card->name);
./drivers/atm/idt77252.c:	writel(card->rt_base << 2, SAR_REG_RTBL);
./drivers/atm/idt77252.c:	IPRINTK("%s: initialize TST ...\n", card->name);
./drivers/atm/idt77252.c:	card->tst_free = card->tst_size - 2;	/* last two are jumps */
./drivers/atm/idt77252.c:	for (i = card->tst[0]; i < card->tst[0] + card->tst_size - 2; i++)
./drivers/atm/idt77252.c:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));
./drivers/atm/idt77252.c:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));
./drivers/atm/idt77252.c:	for (i = card->tst[1]; i < card->tst[1] + card->tst_size - 2; i++)
./drivers/atm/idt77252.c:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[1] << 2));
./drivers/atm/idt77252.c:	write_sram(card, i++, TSTE_OPC_JMP | (card->tst[0] << 2));
./drivers/atm/idt77252.c:	card->tst_index = 0;
./drivers/atm/idt77252.c:	writel(card->tst[0] << 2, SAR_REG_TSTB);
./drivers/atm/idt77252.c:	IPRINTK("%s: initialize ABRSTD ...\n", card->name);
./drivers/atm/idt77252.c:	writel(card->abrst_size | (card->abrst_base << 2),
./drivers/atm/idt77252.c:	IPRINTK("%s: initialize receive fifo ...\n", card->name);
./drivers/atm/idt77252.c:	writel(card->fifo_size | (card->fifo_base << 2),
./drivers/atm/idt77252.c:	IPRINTK("%s: SRAM initialization complete.\n", card->name);
./drivers/atm/idt77252.c:	struct pci_dev *pcidev = card->pcidev;
./drivers/atm/idt77252.c:	if (test_bit(IDT77252_BIT_INIT, &card->flags)) {
./drivers/atm/idt77252.c:	IPRINTK("%s: Checking PCI retries.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: can't read PCI retry timeout.\n", card->name);
./drivers/atm/idt77252.c:			card->name, pci_byte);
./drivers/atm/idt77252.c:			       card->name);
./drivers/atm/idt77252.c:	IPRINTK("%s: Checking PCI TRDY.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: can't read PCI TRDY timeout.\n", card->name);
./drivers/atm/idt77252.c:		        card->name, pci_byte);
./drivers/atm/idt77252.c:			printk("%s: can't set PCI TRDY timeout.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: resetting timer overflow.\n", card->name);
./drivers/atm/idt77252.c:	IPRINTK("%s: Request IRQ ... ", card->name);
./drivers/atm/idt77252.c:			card->name, card) != 0) {
./drivers/atm/idt77252.c:		printk("%s: can't allocate IRQ.\n", card->name);
./drivers/atm/idt77252.c:	IPRINTK("%s: Initializing SRAM\n", card->name);
./drivers/atm/idt77252.c:	if (card->sramsize == (512 * 1024))
./drivers/atm/idt77252.c:	card->vpibits = vpibits;
./drivers/atm/idt77252.c:	if (card->sramsize == (512 * 1024)) {
./drivers/atm/idt77252.c:		card->vcibits = 10 - card->vpibits;
./drivers/atm/idt77252.c:		card->vcibits = 9 - card->vpibits;
./drivers/atm/idt77252.c:	card->vcimask = 0;
./drivers/atm/idt77252.c:	for (k = 0, i = 1; k < card->vcibits; k++) {
./drivers/atm/idt77252.c:		card->vcimask |= i;
./drivers/atm/idt77252.c:	IPRINTK("%s: Setting VPI/VCI mask to zero.\n", card->name);
./drivers/atm/idt77252.c:	card->raw_cell_hnd = pci_alloc_consistent(card->pcidev, 2 * sizeof(u32),
./drivers/atm/idt77252.c:						  &card->raw_cell_paddr);
./drivers/atm/idt77252.c:	if (!card->raw_cell_hnd) {
./drivers/atm/idt77252.c:		printk("%s: memory allocation failure.\n", card->name);
./drivers/atm/idt77252.c:	memset(card->raw_cell_hnd, 0, 2 * sizeof(u32));
./drivers/atm/idt77252.c:	writel(card->raw_cell_paddr, SAR_REG_RAWHND);
./drivers/atm/idt77252.c:	IPRINTK("%s: raw cell handle is at 0x%p.\n", card->name,
./drivers/atm/idt77252.c:		card->raw_cell_hnd);
./drivers/atm/idt77252.c:	size = sizeof(struct vc_map *) * card->tct_size;
./drivers/atm/idt77252.c:	IPRINTK("%s: allocate %d byte for VC map.\n", card->name, size);
./drivers/atm/idt77252.c:	if (NULL == (card->vcs = vmalloc(size))) {
./drivers/atm/idt77252.c:		printk("%s: memory allocation failure.\n", card->name);
./drivers/atm/idt77252.c:	memset(card->vcs, 0, size);
./drivers/atm/idt77252.c:	size = sizeof(struct vc_map *) * card->scd_size;
./drivers/atm/idt77252.c:	        card->name, size);
./drivers/atm/idt77252.c:	if (NULL == (card->scd2vc = vmalloc(size))) {
./drivers/atm/idt77252.c:		printk("%s: memory allocation failure.\n", card->name);
./drivers/atm/idt77252.c:	memset(card->scd2vc, 0, size);
./drivers/atm/idt77252.c:	size = sizeof(struct tst_info) * (card->tst_size - 2);
./drivers/atm/idt77252.c:		card->name, size);
./drivers/atm/idt77252.c:	if (NULL == (card->soft_tst = vmalloc(size))) {
./drivers/atm/idt77252.c:		printk("%s: memory allocation failure.\n", card->name);
./drivers/atm/idt77252.c:	for (i = 0; i < card->tst_size - 2; i++) {
./drivers/atm/idt77252.c:		card->soft_tst[i].tste = TSTE_OPC_VAR;
./drivers/atm/idt77252.c:		card->soft_tst[i].vc = NULL;
./drivers/atm/idt77252.c:		printk("%s: No LT device defined.\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: LT had no IOCTL function defined.\n", card->name);
./drivers/atm/idt77252.c:	card->link_pcr = (linkrate / 8 / 53);
./drivers/atm/idt77252.c:	       card->name, linkrate, card->link_pcr);
./drivers/atm/idt77252.c:	card->utopia_pcr = card->link_pcr;
./drivers/atm/idt77252.c:	card->utopia_pcr = (160000000 / 8 / 54);
./drivers/atm/idt77252.c:	if (card->utopia_pcr > card->link_pcr)
./drivers/atm/idt77252.c:		rsvdcr = card->utopia_pcr - card->link_pcr;
./drivers/atm/idt77252.c:	tmpl = (unsigned long) rsvdcr * ((unsigned long) card->tst_size - 2);
./drivers/atm/idt77252.c:	modl = tmpl % (unsigned long)card->utopia_pcr;
./drivers/atm/idt77252.c:	tst_entries = (int) (tmpl / (unsigned long)card->utopia_pcr);
./drivers/atm/idt77252.c:	card->tst_free -= tst_entries;
./drivers/atm/idt77252.c:	printk("%s: EEPROM: %02x:", card->name,
./drivers/atm/idt77252.c:	sprintf(tname, "eth%d", card->index);
./drivers/atm/idt77252.c:		memcpy(card->atmdev->esi, tmp->dev_addr, 6);
./drivers/atm/idt77252.c:		printk("%s: ESI %pM\n", card->name, card->atmdev->esi);
./drivers/atm/idt77252.c:	set_bit(IDT77252_BIT_INIT, &card->flags);
./drivers/atm/idt77252.c:	XPRINTK("%s: IDT77252 ABR SAR initialization complete.\n", card->name);
./drivers/atm/idt77252.c:		card->name);
./drivers/atm/idt77252.c:	if (pci_read_config_word(card->pcidev, PCI_COMMAND, &pci_command)) {
./drivers/atm/idt77252.c:		printk("%s: can't read PCI_COMMAND.\n", card->name);
./drivers/atm/idt77252.c:		       card->name, pci_command);
./drivers/atm/idt77252.c:	if (pci_write_config_word(card->pcidev, PCI_COMMAND, pci_command)) {
./drivers/atm/idt77252.c:		printk("%s: can't write PCI_COMMAND.\n", card->name);
./drivers/atm/idt77252.c:	IPRINTK("%s: Software resetted.\n", card->name);
./drivers/atm/idt77252.c:	card->revision = pcidev->revision;
./drivers/atm/idt77252.c:	card->index = index;
./drivers/atm/idt77252.c:	card->pcidev = pcidev;
./drivers/atm/idt77252.c:	sprintf(card->name, "idt77252-%d", card->index);
./drivers/atm/idt77252.c:	INIT_WORK(&card->tqueue, idt77252_softint);
./drivers/atm/idt77252.c:	mutex_init(&card->mutex);
./drivers/atm/idt77252.c:	spin_lock_init(&card->cmd_lock);
./drivers/atm/idt77252.c:	spin_lock_init(&card->tst_lock);
./drivers/atm/idt77252.c:	init_timer(&card->tst_timer);
./drivers/atm/idt77252.c:	card->tst_timer.data = (unsigned long)card;
./drivers/atm/idt77252.c:	card->tst_timer.function = tst_timer;
./drivers/atm/idt77252.c:	card->membase = ioremap(membase, 1024);
./drivers/atm/idt77252.c:	if (!card->membase) {
./drivers/atm/idt77252.c:		printk("%s: can't ioremap() membase\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: preset failed\n", card->name);
./drivers/atm/idt77252.c:		printk("%s: can't register atm device\n", card->name);
./drivers/atm/idt77252.c:	card->atmdev = dev;
./drivers/atm/idt77252.c:		printk("%s: can't init SUNI\n", card->name);
./drivers/atm/idt77252.c:	card->sramsize = probe_sram(card);
./drivers/atm/idt77252.c:		card->fbq[i] = ioremap(srambase | 0x200000 | (i << 18), 4);
./drivers/atm/idt77252.c:		if (!card->fbq[i]) {
./drivers/atm/idt77252.c:			printk("%s: can't ioremap() FBQ%d\n", card->name, i);
./drivers/atm/idt77252.c:	       card->name, ((card->revision > 1) && (card->revision < 25)) ?
./drivers/atm/idt77252.c:	       'A' + card->revision - 1 : '?', membase, srambase,
./drivers/atm/idt77252.c:	       card->sramsize / 1024);
./drivers/atm/idt77252.c:		printk("%s: init_card failed\n", card->name);
./drivers/atm/idt77252.c:	dev->ci_range.vpi_bits = card->vpibits;
./drivers/atm/idt77252.c:	dev->ci_range.vci_bits = card->vcibits;
./drivers/atm/idt77252.c:	dev->link_rate = card->link_pcr;
./drivers/atm/idt77252.c:		printk("%s: dev_open failed\n", card->name);
./drivers/atm/idt77252.c:	last = &card->next;
./drivers/atm/idt77252.c:	iounmap(card->membase);
./drivers/atm/idt77252.c:		dev = card->atmdev;
./drivers/atm/idt77252.c:		idt77252_chain = card->next;
./drivers/atm/idt77252.c:		pci_disable_device(card->pcidev);
./drivers/atm/nicstar.c:	i = card->index;
./drivers/atm/nicstar.c:	if (card->atmdev->phy && card->atmdev->phy->stop)
./drivers/atm/nicstar.c:		card->atmdev->phy->stop(card->atmdev);
./drivers/atm/nicstar.c:	writel(0x00000000, card->membase + CFG);
./drivers/atm/nicstar.c:	atm_dev_deregister(card->atmdev);
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: freeing %d huge buffers.\n", i, card->hbpool.count);
./drivers/atm/nicstar.c:	while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL) {
./drivers/atm/nicstar.c:	       card->iovpool.count);
./drivers/atm/nicstar.c:	while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL) {
./drivers/atm/nicstar.c:	while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
./drivers/atm/nicstar.c:	while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
./drivers/atm/nicstar.c:	free_scq(card, card->scq0, NULL);
./drivers/atm/nicstar.c:		if (card->scd2vc[j] != NULL)
./drivers/atm/nicstar.c:			free_scq(card, card->scd2vc[j]->scq, card->scd2vc[j]->tx_vcc);
./drivers/atm/nicstar.c:	idr_remove_all(&card->idr);
./drivers/atm/nicstar.c:	idr_destroy(&card->idr);
./drivers/atm/nicstar.c:	pci_free_consistent(card->pcidev, NS_RSQSIZE + NS_RSQ_ALIGNMENT,
./drivers/atm/nicstar.c:			    card->rsq.org, card->rsq.dma);
./drivers/atm/nicstar.c:	pci_free_consistent(card->pcidev, NS_TSQSIZE + NS_TSQ_ALIGNMENT,
./drivers/atm/nicstar.c:			    card->tsq.org, card->tsq.dma);
./drivers/atm/nicstar.c:	free_irq(card->pcidev->irq, card);
./drivers/atm/nicstar.c:	iounmap(card->membase);
./drivers/atm/nicstar.c:	spin_lock_irqsave(&card->res_lock, flags);
./drivers/atm/nicstar.c:	writel(sram_address, card->membase + CMD);
./drivers/atm/nicstar.c:	data = readl(card->membase + DR0);
./drivers/atm/nicstar.c:	spin_unlock_irqrestore(&card->res_lock, flags);
./drivers/atm/nicstar.c:	spin_lock_irqsave(&card->res_lock, flags);
./drivers/atm/nicstar.c:		writel(*(value++), card->membase + i);
./drivers/atm/nicstar.c:	   so card->membase + DR0 == card->membase */
./drivers/atm/nicstar.c:	writel(sram_address, card->membase + CMD);
./drivers/atm/nicstar.c:	spin_unlock_irqrestore(&card->res_lock, flags);
./drivers/atm/nicstar.c:	spin_lock_init(&card->int_lock);
./drivers/atm/nicstar.c:	spin_lock_init(&card->res_lock);
./drivers/atm/nicstar.c:	card->index = i;
./drivers/atm/nicstar.c:	card->atmdev = NULL;
./drivers/atm/nicstar.c:	card->pcidev = pcidev;
./drivers/atm/nicstar.c:	card->membase = ioremap(membase, NS_IOREMAP_SIZE);
./drivers/atm/nicstar.c:	if (!card->membase) {
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: membase at 0x%p.\n", i, card->membase);
./drivers/atm/nicstar.c:	data = readl(card->membase + STAT);
./drivers/atm/nicstar.c:		writel(NS_STAT_TMROF, card->membase + STAT);
./drivers/atm/nicstar.c:	writel(NS_CFG_SWRST, card->membase + CFG);
./drivers/atm/nicstar.c:	writel(0x00000000, card->membase + CFG);
./drivers/atm/nicstar.c:	writel(0x00000008, card->membase + GP);
./drivers/atm/nicstar.c:	writel(0x00000001, card->membase + GP);
./drivers/atm/nicstar.c:	writel(NS_CMD_WRITE_UTILITY | 0x00000100, card->membase + CMD);	/* Sync UTOPIA with SAR clock */
./drivers/atm/nicstar.c:	writel(NS_CMD_READ_UTILITY | 0x00000200, card->membase + CMD);
./drivers/atm/nicstar.c:	data = readl(card->membase + DR0);
./drivers/atm/nicstar.c:		card->max_pcr = ATM_25_PCR;
./drivers/atm/nicstar.c:		writel(0x00000008, card->membase + DR0);
./drivers/atm/nicstar.c:		writel(NS_CMD_WRITE_UTILITY | 0x00000200, card->membase + CMD);
./drivers/atm/nicstar.c:		writel(NS_STAT_SFBQF, card->membase + STAT);
./drivers/atm/nicstar.c:		writel(0x00000022, card->membase + DR0);
./drivers/atm/nicstar.c:		writel(NS_CMD_WRITE_UTILITY | 0x00000202, card->membase + CMD);
./drivers/atm/nicstar.c:		card->max_pcr = ATM_OC3_PCR;
./drivers/atm/nicstar.c:		writel(0x00000002, card->membase + DR0);
./drivers/atm/nicstar.c:		writel(NS_CMD_WRITE_UTILITY | 0x00000205, card->membase + CMD);
./drivers/atm/nicstar.c:	writel(0x00000000, card->membase + GP);
./drivers/atm/nicstar.c:		card->sram_size = 128;
./drivers/atm/nicstar.c:		card->sram_size = 32;
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: %dK x 32bit SRAM size.\n", i, card->sram_size);
./drivers/atm/nicstar.c:	card->rct_size = NS_MAX_RCTSIZE;
./drivers/atm/nicstar.c:	if (card->sram_size == 128)
./drivers/atm/nicstar.c:	if (card->sram_size == 32) {
./drivers/atm/nicstar.c:		card->rct_size = 4096;
./drivers/atm/nicstar.c:	card->vpibits = NS_VPIBITS;
./drivers/atm/nicstar.c:	if (card->rct_size == 4096)
./drivers/atm/nicstar.c:		card->vcibits = 12 - NS_VPIBITS;
./drivers/atm/nicstar.c:	else			/* card->rct_size == 16384 */
./drivers/atm/nicstar.c:		card->vcibits = 14 - NS_VPIBITS;
./drivers/atm/nicstar.c:		nicstar_init_eprom(card->membase);
./drivers/atm/nicstar.c:	writel(0x00000000, card->membase + VPM);
./drivers/atm/nicstar.c:	card->tsq.org = pci_alloc_consistent(card->pcidev,
./drivers/atm/nicstar.c:					     &card->tsq.dma);
./drivers/atm/nicstar.c:	if (card->tsq.org == NULL) {
./drivers/atm/nicstar.c:	card->tsq.base = PTR_ALIGN(card->tsq.org, NS_TSQ_ALIGNMENT);
./drivers/atm/nicstar.c:	card->tsq.next = card->tsq.base;
./drivers/atm/nicstar.c:	card->tsq.last = card->tsq.base + (NS_TSQ_NUM_ENTRIES - 1);
./drivers/atm/nicstar.c:		ns_tsi_init(card->tsq.base + j);
./drivers/atm/nicstar.c:	writel(0x00000000, card->membase + TSQH);
./drivers/atm/nicstar.c:	writel(ALIGN(card->tsq.dma, NS_TSQ_ALIGNMENT), card->membase + TSQB);
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: TSQ base at 0x%p.\n", i, card->tsq.base);
./drivers/atm/nicstar.c:	card->rsq.org = pci_alloc_consistent(card->pcidev,
./drivers/atm/nicstar.c:					     &card->rsq.dma);
./drivers/atm/nicstar.c:	if (card->rsq.org == NULL) {
./drivers/atm/nicstar.c:	card->rsq.base = PTR_ALIGN(card->rsq.org, NS_RSQ_ALIGNMENT);
./drivers/atm/nicstar.c:	card->rsq.next = card->rsq.base;
./drivers/atm/nicstar.c:	card->rsq.last = card->rsq.base + (NS_RSQ_NUM_ENTRIES - 1);
./drivers/atm/nicstar.c:		ns_rsqe_init(card->rsq.base + j);
./drivers/atm/nicstar.c:	writel(0x00000000, card->membase + RSQH);
./drivers/atm/nicstar.c:	writel(ALIGN(card->rsq.dma, NS_RSQ_ALIGNMENT), card->membase + RSQB);
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: RSQ base at 0x%p.\n", i, card->rsq.base);
./drivers/atm/nicstar.c:	card->scq1 = NULL;
./drivers/atm/nicstar.c:	card->scq2 = NULL;
./drivers/atm/nicstar.c:	card->scq0 = get_scq(card, VBR_SCQSIZE, NS_VRSCD0);
./drivers/atm/nicstar.c:	if (card->scq0 == NULL) {
./drivers/atm/nicstar.c:	u32d[0] = scq_virt_to_bus(card->scq0, card->scq0->base);
./drivers/atm/nicstar.c:	card->scq0->scd = NS_VRSCD0;
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: VBR-SCQ0 base at 0x%p.\n", i, card->scq0->base);
./drivers/atm/nicstar.c:	card->tst_addr = NS_TST0;
./drivers/atm/nicstar.c:	card->tst_free_entries = NS_TST_NUM_ENTRIES;
./drivers/atm/nicstar.c:		card->tste2vc[j] = NULL;
./drivers/atm/nicstar.c:	writel(NS_TST0 << 2, card->membase + TSTB);
./drivers/atm/nicstar.c:	for (j = 0; j < card->rct_size; j++)
./drivers/atm/nicstar.c:	memset(card->vcmap, 0, NS_MAX_RCTSIZE * sizeof(vc_map));
./drivers/atm/nicstar.c:		card->scd2vc[j] = NULL;
./drivers/atm/nicstar.c:	card->sbnr.min = MIN_SB;
./drivers/atm/nicstar.c:	card->sbnr.init = NUM_SB;
./drivers/atm/nicstar.c:	card->sbnr.max = MAX_SB;
./drivers/atm/nicstar.c:	card->lbnr.min = MIN_LB;
./drivers/atm/nicstar.c:	card->lbnr.init = NUM_LB;
./drivers/atm/nicstar.c:	card->lbnr.max = MAX_LB;
./drivers/atm/nicstar.c:	card->iovnr.min = MIN_IOVB;
./drivers/atm/nicstar.c:	card->iovnr.init = NUM_IOVB;
./drivers/atm/nicstar.c:	card->iovnr.max = MAX_IOVB;
./drivers/atm/nicstar.c:	card->hbnr.min = MIN_HB;
./drivers/atm/nicstar.c:	card->hbnr.init = NUM_HB;
./drivers/atm/nicstar.c:	card->hbnr.max = MAX_HB;
./drivers/atm/nicstar.c:	card->sm_handle = 0x00000000;
./drivers/atm/nicstar.c:	card->sm_addr = 0x00000000;
./drivers/atm/nicstar.c:	card->lg_handle = 0x00000000;
./drivers/atm/nicstar.c:	card->lg_addr = 0x00000000;
./drivers/atm/nicstar.c:	card->efbie = 1;	/* To prevent push_rxbufs from enabling the interrupt */
./drivers/atm/nicstar.c:	idr_init(&card->idr);
./drivers/atm/nicstar.c:	skb_queue_head_init(&card->hbpool.queue);
./drivers/atm/nicstar.c:	card->hbpool.count = 0;
./drivers/atm/nicstar.c:		skb_queue_tail(&card->hbpool.queue, hb);
./drivers/atm/nicstar.c:		card->hbpool.count++;
./drivers/atm/nicstar.c:	skb_queue_head_init(&card->lbpool.queue);
./drivers/atm/nicstar.c:	card->lbpool.count = 0;	/* Not used */
./drivers/atm/nicstar.c:		skb_queue_tail(&card->lbpool.queue, lb);
./drivers/atm/nicstar.c:			card->rcbuf = lb;
./drivers/atm/nicstar.c:			card->rawcell = (struct ns_rcqe *) lb->data;
./drivers/atm/nicstar.c:			card->rawch = NS_PRV_DMA(lb);
./drivers/atm/nicstar.c:	     ns_stat_lfbqc_get(readl(card->membase + STAT))) < card->lbnr.min) {
./drivers/atm/nicstar.c:	skb_queue_head_init(&card->sbpool.queue);
./drivers/atm/nicstar.c:	card->sbpool.count = 0;	/* Not used */
./drivers/atm/nicstar.c:		skb_queue_tail(&card->sbpool.queue, sb);
./drivers/atm/nicstar.c:	     ns_stat_sfbqc_get(readl(card->membase + STAT))) < card->sbnr.min) {
./drivers/atm/nicstar.c:	skb_queue_head_init(&card->iovpool.queue);
./drivers/atm/nicstar.c:	card->iovpool.count = 0;
./drivers/atm/nicstar.c:		skb_queue_tail(&card->iovpool.queue, iovb);
./drivers/atm/nicstar.c:		card->iovpool.count++;
./drivers/atm/nicstar.c:	if (card->rct_size == 4096)
./drivers/atm/nicstar.c:	else			/* (card->rct_size == 16384) */
./drivers/atm/nicstar.c:	card->efbie = 1;
./drivers/atm/nicstar.c:	card->intcnt = 0;
./drivers/atm/nicstar.c:	card->atmdev = atm_dev_register("nicstar", &card->pcidev->dev, &atm_ops,
./drivers/atm/nicstar.c:	if (card->atmdev == NULL) {
./drivers/atm/nicstar.c:	if (ns_parse_mac(mac[i], card->atmdev->esi)) {
./drivers/atm/nicstar.c:		nicstar_read_eprom(card->membase, NICSTAR_EPROM_MAC_ADDR_OFFSET,
./drivers/atm/nicstar.c:				   card->atmdev->esi, 6);
./drivers/atm/nicstar.c:		if (memcmp(card->atmdev->esi, "\x00\x00\x00\x00\x00\x00", 6) ==
./drivers/atm/nicstar.c:			nicstar_read_eprom(card->membase,
./drivers/atm/nicstar.c:					   card->atmdev->esi, 6);
./drivers/atm/nicstar.c:	printk("nicstar%d: MAC address %pM\n", i, card->atmdev->esi);
./drivers/atm/nicstar.c:	card->atmdev->dev_data = card;
./drivers/atm/nicstar.c:	card->atmdev->ci_range.vpi_bits = card->vpibits;
./drivers/atm/nicstar.c:	card->atmdev->ci_range.vci_bits = card->vcibits;
./drivers/atm/nicstar.c:	card->atmdev->link_rate = card->max_pcr;
./drivers/atm/nicstar.c:	card->atmdev->phy = NULL;
./drivers/atm/nicstar.c:	if (card->max_pcr == ATM_OC3_PCR)
./drivers/atm/nicstar.c:		suni_init(card->atmdev);
./drivers/atm/nicstar.c:	if (card->max_pcr == ATM_25_PCR)
./drivers/atm/nicstar.c:		idt77105_init(card->atmdev);
./drivers/atm/nicstar.c:	if (card->atmdev->phy && card->atmdev->phy->start)
./drivers/atm/nicstar.c:		card->atmdev->phy->start(card->atmdev);
./drivers/atm/nicstar.c:	       NS_CFG_PHYIE, card->membase + CFG);
./drivers/atm/nicstar.c:		writel(0x00000000, card->membase + CFG);
./drivers/atm/nicstar.c:		while ((iovb = skb_dequeue(&card->iovpool.queue)) != NULL)
./drivers/atm/nicstar.c:		while ((sb = skb_dequeue(&card->sbpool.queue)) != NULL)
./drivers/atm/nicstar.c:		free_scq(card, card->scq0, NULL);
./drivers/atm/nicstar.c:		while ((lb = skb_dequeue(&card->lbpool.queue)) != NULL)
./drivers/atm/nicstar.c:		while ((hb = skb_dequeue(&card->hbpool.queue)) != NULL)
./drivers/atm/nicstar.c:		kfree(card->rsq.org);
./drivers/atm/nicstar.c:		kfree(card->tsq.org);
./drivers/atm/nicstar.c:		free_irq(card->pcidev->irq, card);
./drivers/atm/nicstar.c:		iounmap(card->membase);
./drivers/atm/nicstar.c:		pci_disable_device(card->pcidev);
./drivers/atm/nicstar.c:        scq->org = pci_alloc_consistent(card->pcidev, 2 * size, &scq->dma);
./drivers/atm/nicstar.c:	pci_free_consistent(card->pcidev,
./drivers/atm/nicstar.c:	addr1 = pci_map_single(card->pcidev,
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:	stat = readl(card->membase + STAT);
./drivers/atm/nicstar.c:	card->sbfqc = ns_stat_sfbqc_get(stat);
./drivers/atm/nicstar.c:	card->lbfqc = ns_stat_lfbqc_get(stat);
./drivers/atm/nicstar.c:			if (card->sm_addr) {
./drivers/atm/nicstar.c:				addr2 = card->sm_addr;
./drivers/atm/nicstar.c:				handle2 = card->sm_handle;
./drivers/atm/nicstar.c:				card->sm_addr = 0x00000000;
./drivers/atm/nicstar.c:				card->sm_handle = 0x00000000;
./drivers/atm/nicstar.c:				card->sm_addr = addr1;
./drivers/atm/nicstar.c:				card->sm_handle = handle1;
./drivers/atm/nicstar.c:			if (card->lg_addr) {
./drivers/atm/nicstar.c:				addr2 = card->lg_addr;
./drivers/atm/nicstar.c:				handle2 = card->lg_handle;
./drivers/atm/nicstar.c:				card->lg_addr = 0x00000000;
./drivers/atm/nicstar.c:				card->lg_handle = 0x00000000;
./drivers/atm/nicstar.c:				card->lg_addr = addr1;
./drivers/atm/nicstar.c:				card->lg_handle = handle1;
./drivers/atm/nicstar.c:			if (card->sbfqc >= card->sbnr.max) {
./drivers/atm/nicstar.c:				skb_unlink(handle1, &card->sbpool.queue);
./drivers/atm/nicstar.c:				skb_unlink(handle2, &card->sbpool.queue);
./drivers/atm/nicstar.c:				card->sbfqc += 2;
./drivers/atm/nicstar.c:			if (card->lbfqc >= card->lbnr.max) {
./drivers/atm/nicstar.c:				skb_unlink(handle1, &card->lbpool.queue);
./drivers/atm/nicstar.c:				skb_unlink(handle2, &card->lbpool.queue);
./drivers/atm/nicstar.c:				card->lbfqc += 2;
./drivers/atm/nicstar.c:			if (!idr_pre_get(&card->idr, GFP_ATOMIC)) {
./drivers/atm/nicstar.c:				       card->index);
./drivers/atm/nicstar.c:				err = idr_get_new_above(&card->idr, handle1, 0, &id1);
./drivers/atm/nicstar.c:				err = idr_get_new_above(&card->idr, handle2, 0, &id2);
./drivers/atm/nicstar.c:		spin_lock_irqsave(&card->res_lock, flags);
./drivers/atm/nicstar.c:		writel(addr2, card->membase + DR3);
./drivers/atm/nicstar.c:		writel(id2, card->membase + DR2);
./drivers/atm/nicstar.c:		writel(addr1, card->membase + DR1);
./drivers/atm/nicstar.c:		writel(id1, card->membase + DR0);
./drivers/atm/nicstar.c:		       card->membase + CMD);
./drivers/atm/nicstar.c:		spin_unlock_irqrestore(&card->res_lock, flags);
./drivers/atm/nicstar.c:			card->index,
./drivers/atm/nicstar.c:	if (!card->efbie && card->sbfqc >= card->sbnr.min &&
./drivers/atm/nicstar.c:	    card->lbfqc >= card->lbnr.min) {
./drivers/atm/nicstar.c:		card->efbie = 1;
./drivers/atm/nicstar.c:		writel((readl(card->membase + CFG) | NS_CFG_EFBIE),
./drivers/atm/nicstar.c:		       card->membase + CFG);
./drivers/atm/nicstar.c:	dev = card->atmdev;
./drivers/atm/nicstar.c:	card->intcnt++;
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: NICStAR generated an interrupt\n", card->index);
./drivers/atm/nicstar.c:	spin_lock_irqsave(&card->int_lock, flags);
./drivers/atm/nicstar.c:	stat_r = readl(card->membase + STAT);
./drivers/atm/nicstar.c:		TXPRINTK("nicstar%d: TSI interrupt\n", card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_TSIF, card->membase + STAT);
./drivers/atm/nicstar.c:		writel(NS_STAT_TXICP, card->membase + STAT);
./drivers/atm/nicstar.c:			 card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_TSQF, card->membase + STAT);
./drivers/atm/nicstar.c:		PRINTK("nicstar%d: TSQ full.\n", card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_TMROF, card->membase + STAT);
./drivers/atm/nicstar.c:		PRINTK("nicstar%d: Timer overflow.\n", card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_PHYI, card->membase + STAT);
./drivers/atm/nicstar.c:		PRINTK("nicstar%d: PHY interrupt.\n", card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_SFBQF, card->membase + STAT);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_LFBQF, card->membase + STAT);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_RSQF, card->membase + STAT);
./drivers/atm/nicstar.c:		printk("nicstar%d: RSQ full.\n", card->index);
./drivers/atm/nicstar.c:		RXPRINTK("nicstar%d: End of CS-PDU received.\n", card->index);
./drivers/atm/nicstar.c:		writel(NS_STAT_EOPDU, card->membase + STAT);
./drivers/atm/nicstar.c:		writel(NS_STAT_RAWCF, card->membase + STAT);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		while (readl(card->membase + RAWCT) != card->rawch) {
./drivers/atm/nicstar.c:			if (ns_rcqe_islast(card->rawcell)) {
./drivers/atm/nicstar.c:				oldbuf = card->rcbuf;
./drivers/atm/nicstar.c:				card->rcbuf = idr_find(&card->idr,
./drivers/atm/nicstar.c:						       ns_rcqe_nextbufhandle(card->rawcell));
./drivers/atm/nicstar.c:				card->rawch = NS_PRV_DMA(card->rcbuf);
./drivers/atm/nicstar.c:				card->rawcell = (struct ns_rcqe *)
./drivers/atm/nicstar.c:						card->rcbuf->data;
./drivers/atm/nicstar.c:				card->rawch += NS_RCQE_SIZE;
./drivers/atm/nicstar.c:				card->rawcell++;
./drivers/atm/nicstar.c:		writel(NS_STAT_SFBQE, card->membase + STAT);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		for (i = 0; i < card->sbnr.min; i++) {
./drivers/atm/nicstar.c:				writel(readl(card->membase + CFG) &
./drivers/atm/nicstar.c:				       ~NS_CFG_EFBIE, card->membase + CFG);
./drivers/atm/nicstar.c:				card->efbie = 0;
./drivers/atm/nicstar.c:			skb_queue_tail(&card->sbpool.queue, sb);
./drivers/atm/nicstar.c:		card->sbfqc = i;
./drivers/atm/nicstar.c:		writel(NS_STAT_LFBQE, card->membase + STAT);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		for (i = 0; i < card->lbnr.min; i++) {
./drivers/atm/nicstar.c:				writel(readl(card->membase + CFG) &
./drivers/atm/nicstar.c:				       ~NS_CFG_EFBIE, card->membase + CFG);
./drivers/atm/nicstar.c:				card->efbie = 0;
./drivers/atm/nicstar.c:			skb_queue_tail(&card->lbpool.queue, lb);
./drivers/atm/nicstar.c:		card->lbfqc = i;
./drivers/atm/nicstar.c:		writel(NS_STAT_RSQAF, card->membase + STAT);
./drivers/atm/nicstar.c:		RXPRINTK("nicstar%d: RSQ almost full.\n", card->index);
./drivers/atm/nicstar.c:	spin_unlock_irqrestore(&card->int_lock, flags);
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: end of interrupt service\n", card->index);
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: opening vpi.vci %d.%d \n", card->index, (int)vpi,
./drivers/atm/nicstar.c:		PRINTK("nicstar%d: unsupported AAL.\n", card->index);
./drivers/atm/nicstar.c:	vc = &(card->vcmap[vpi << card->vcibits | vci]);
./drivers/atm/nicstar.c:		printk("nicstar%d: %s vci already in use.\n", card->index,
./drivers/atm/nicstar.c:				     card->index);
./drivers/atm/nicstar.c:			       card->index, vcc->qos.txtp.max_pcr);
./drivers/atm/nicstar.c:			modl = tmpl % card->max_pcr;
./drivers/atm/nicstar.c:			n = (int)(tmpl / card->max_pcr);
./drivers/atm/nicstar.c:				     (card->tst_free_entries -
./drivers/atm/nicstar.c:					     card->index);
./drivers/atm/nicstar.c:				     card->index);
./drivers/atm/nicstar.c:			if (n > (card->tst_free_entries - NS_TST_RESERVED)) {
./drivers/atm/nicstar.c:				     card->index);
./drivers/atm/nicstar.c:				card->tst_free_entries -= n;
./drivers/atm/nicstar.c:				card->index, n);
./drivers/atm/nicstar.c:				if (card->scd2vc[frscdi] == NULL) {
./drivers/atm/nicstar.c:					card->scd2vc[frscdi] = vc;
./drivers/atm/nicstar.c:				     card->index);
./drivers/atm/nicstar.c:				card->tst_free_entries += n;
./drivers/atm/nicstar.c:				       card->index);
./drivers/atm/nicstar.c:				card->scd2vc[frscdi] = NULL;
./drivers/atm/nicstar.c:				card->tst_free_entries += n;
./drivers/atm/nicstar.c:			vc->scq = card->scq0;
./drivers/atm/nicstar.c:				      (vpi << card->vcibits | vci) *
./drivers/atm/nicstar.c:	PRINTK("nicstar%d: closing vpi.vci %d.%d \n", card->index,
./drivers/atm/nicstar.c:		    (vcc->vpi << card->vcibits | vcc->vci) * NS_RCT_ENTRY_SIZE;
./drivers/atm/nicstar.c:		spin_lock_irqsave(&card->res_lock, flags);
./drivers/atm/nicstar.c:		       card->membase + CMD);
./drivers/atm/nicstar.c:		spin_unlock_irqrestore(&card->res_lock, flags);
./drivers/atm/nicstar.c:			stat = readl(card->membase + STAT);
./drivers/atm/nicstar.c:			card->sbfqc = ns_stat_sfbqc_get(stat);
./drivers/atm/nicstar.c:			card->lbfqc = ns_stat_lfbqc_get(stat);
./drivers/atm/nicstar.c:			     card->index);
./drivers/atm/nicstar.c:			spin_lock_irqsave(&card->int_lock, flags);
./drivers/atm/nicstar.c:			spin_unlock_irqrestore(&card->int_lock, flags);
./drivers/atm/nicstar.c:			if (card->tste2vc[i] == vc) {
./drivers/atm/nicstar.c:				ns_write_sram(card, card->tst_addr + i, &data,
./drivers/atm/nicstar.c:				card->tste2vc[i] = NULL;
./drivers/atm/nicstar.c:				card->tst_free_entries++;
./drivers/atm/nicstar.c:		card->scd2vc[(vc->cbr_scd - NS_FRSCD) / NS_FRSCD_SIZE] = NULL;
./drivers/atm/nicstar.c:		scq_info *scq = card->scq0;
./drivers/atm/nicstar.c:		stat = readl(card->membase + STAT);
./drivers/atm/nicstar.c:		cfg = readl(card->membase + CFG);
./drivers/atm/nicstar.c:		     card->tsq.base, card->tsq.next,
./drivers/atm/nicstar.c:		     card->tsq.last, readl(card->membase + TSQT));
./drivers/atm/nicstar.c:		     card->rsq.base, card->rsq.next,
./drivers/atm/nicstar.c:		     card->rsq.last, readl(card->membase + RSQT));
./drivers/atm/nicstar.c:		       card->efbie ? "enabled" : "disabled");
./drivers/atm/nicstar.c:		       ns_stat_sfbqc_get(stat), card->sbpool.count,
./drivers/atm/nicstar.c:		       ns_stat_lfbqc_get(stat), card->lbpool.count);
./drivers/atm/nicstar.c:		       card->hbpool.count, card->iovpool.count);
./drivers/atm/nicstar.c:	new_tst = card->tst_addr;
./drivers/atm/nicstar.c:		if (card->tste2vc[e] == NULL)
./drivers/atm/nicstar.c:		printk("nicstar%d: No free TST entries found. \n", card->index);
./drivers/atm/nicstar.c:		if (cl >= NS_TST_NUM_ENTRIES && card->tste2vc[e] == NULL) {
./drivers/atm/nicstar.c:			card->tste2vc[e] = vc;
./drivers/atm/nicstar.c:	ns_write_sram(card, card->tst_addr + NS_TST_NUM_ENTRIES, &data, 1);
./drivers/atm/nicstar.c:	card->tst_addr = new_tst;
./drivers/atm/nicstar.c:	TXPRINTK("nicstar%d: ns_send() called.\n", card->index);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:		printk("nicstar%d: No scatter-gather yet.\n", card->index);
./drivers/atm/nicstar.c:	NS_PRV_DMA(skb) = pci_map_single(card->pcidev, skb->data,
./drivers/atm/nicstar.c:		scq = card->scq0;
./drivers/atm/nicstar.c:			printk("nicstar%d: Error pushing TBD.\n", card->index);
./drivers/atm/nicstar.c:			       card->index);
./drivers/atm/nicstar.c:		card->index, skb, index);
./drivers/atm/nicstar.c:		card->index, le32_to_cpu(tbd->word_1), le32_to_cpu(tbd->word_2),
./drivers/atm/nicstar.c:				       card->index);
./drivers/atm/nicstar.c:			     card->index, le32_to_cpu(tsr.word_1),
./drivers/atm/nicstar.c:			       card->index);
./drivers/atm/nicstar.c:	if (card->tsq.next == card->tsq.last)
./drivers/atm/nicstar.c:		one_ahead = card->tsq.base;
./drivers/atm/nicstar.c:		one_ahead = card->tsq.next + 1;
./drivers/atm/nicstar.c:	if (one_ahead == card->tsq.last)
./drivers/atm/nicstar.c:		two_ahead = card->tsq.base;
./drivers/atm/nicstar.c:	while (!ns_tsi_isempty(card->tsq.next) || !ns_tsi_isempty(one_ahead) ||
./drivers/atm/nicstar.c:		while (ns_tsi_isempty(card->tsq.next)) {
./drivers/atm/nicstar.c:			if (card->tsq.next == card->tsq.last)
./drivers/atm/nicstar.c:				card->tsq.next = card->tsq.base;
./drivers/atm/nicstar.c:				card->tsq.next++;
./drivers/atm/nicstar.c:		if (!ns_tsi_tmrof(card->tsq.next)) {
./drivers/atm/nicstar.c:			scdi = ns_tsi_getscdindex(card->tsq.next);
./drivers/atm/nicstar.c:				scq = card->scq0;
./drivers/atm/nicstar.c:				if (card->scd2vc[scdi] == NULL) {
./drivers/atm/nicstar.c:					     card->index);
./drivers/atm/nicstar.c:					ns_tsi_init(card->tsq.next);
./drivers/atm/nicstar.c:				scq = card->scd2vc[scdi]->scq;
./drivers/atm/nicstar.c:			drain_scq(card, scq, ns_tsi_getscqpos(card->tsq.next));
./drivers/atm/nicstar.c:		ns_tsi_init(card->tsq.next);
./drivers/atm/nicstar.c:		previous = card->tsq.next;
./drivers/atm/nicstar.c:		if (card->tsq.next == card->tsq.last)
./drivers/atm/nicstar.c:			card->tsq.next = card->tsq.base;
./drivers/atm/nicstar.c:			card->tsq.next++;
./drivers/atm/nicstar.c:		if (card->tsq.next == card->tsq.last)
./drivers/atm/nicstar.c:			one_ahead = card->tsq.base;
./drivers/atm/nicstar.c:			one_ahead = card->tsq.next + 1;
./drivers/atm/nicstar.c:		if (one_ahead == card->tsq.last)
./drivers/atm/nicstar.c:			two_ahead = card->tsq.base;
./drivers/atm/nicstar.c:		writel(PTR_DIFF(previous, card->tsq.base),
./drivers/atm/nicstar.c:		       card->membase + TSQH);
./drivers/atm/nicstar.c:		card->index, scq, pos);
./drivers/atm/nicstar.c:		printk("nicstar%d: Bad index on drain_scq().\n", card->index);
./drivers/atm/nicstar.c:			card->index, skb, i);
./drivers/atm/nicstar.c:			pci_unmap_single(card->pcidev,
./drivers/atm/nicstar.c:	if (!ns_rsqe_valid(card->rsq.next))
./drivers/atm/nicstar.c:		dequeue_rx(card, card->rsq.next);
./drivers/atm/nicstar.c:		ns_rsqe_init(card->rsq.next);
./drivers/atm/nicstar.c:		previous = card->rsq.next;
./drivers/atm/nicstar.c:		if (card->rsq.next == card->rsq.last)
./drivers/atm/nicstar.c:			card->rsq.next = card->rsq.base;
./drivers/atm/nicstar.c:			card->rsq.next++;
./drivers/atm/nicstar.c:	} while (ns_rsqe_valid(card->rsq.next));
./drivers/atm/nicstar.c:	writel(PTR_DIFF(previous, card->rsq.base), card->membase + RSQH);
./drivers/atm/nicstar.c:	stat = readl(card->membase + STAT);
./drivers/atm/nicstar.c:	card->sbfqc = ns_stat_sfbqc_get(stat);
./drivers/atm/nicstar.c:	card->lbfqc = ns_stat_lfbqc_get(stat);
./drivers/atm/nicstar.c:	skb = idr_find(&card->idr, id);
./drivers/atm/nicstar.c:			 "nicstar%d: idr_find() failed!\n", card->index);
./drivers/atm/nicstar.c:	idr_remove(&card->idr, id);
./drivers/atm/nicstar.c:        pci_dma_sync_single_for_cpu(card->pcidev,
./drivers/atm/nicstar.c:	pci_unmap_single(card->pcidev,
./drivers/atm/nicstar.c:	if (vpi >= 1UL << card->vpibits || vci >= 1UL << card->vcibits) {
./drivers/atm/nicstar.c:		       card->index, vpi, vci);
./drivers/atm/nicstar.c:	vc = &(card->vcmap[vpi << card->vcibits | vci]);
./drivers/atm/nicstar.c:			 card->index, vpi, vci);
./drivers/atm/nicstar.c:				     card->index);
./drivers/atm/nicstar.c:				     card->index);
./drivers/atm/nicstar.c:		iovb = skb_dequeue(&(card->iovpool.queue));
./drivers/atm/nicstar.c:				       card->index);
./drivers/atm/nicstar.c:		} else if (--card->iovpool.count < card->iovnr.min) {
./drivers/atm/nicstar.c:				skb_queue_tail(&card->iovpool.queue, new_iovb);
./drivers/atm/nicstar.c:				card->iovpool.count++;
./drivers/atm/nicstar.c:		printk("nicstar%d: received too big AAL5 SDU.\n", card->index);
./drivers/atm/nicstar.c:			     card->index);
./drivers/atm/nicstar.c:			     card->index);
./drivers/atm/nicstar.c:			printk("nicstar%d: AAL5 CRC error", card->index);
./drivers/atm/nicstar.c:			hb = skb_dequeue(&(card->hbpool.queue));
./drivers/atm/nicstar.c:					     card->index);
./drivers/atm/nicstar.c:				} else if (card->hbpool.count < card->hbnr.min) {
./drivers/atm/nicstar.c:						skb_queue_tail(&card->hbpool.
./drivers/atm/nicstar.c:						card->hbpool.count++;
./drivers/atm/nicstar.c:			} else if (--card->hbpool.count < card->hbnr.min) {
./drivers/atm/nicstar.c:					skb_queue_tail(&card->hbpool.queue,
./drivers/atm/nicstar.c:					card->hbpool.count++;
./drivers/atm/nicstar.c:				if (card->hbpool.count < card->hbnr.min) {
./drivers/atm/nicstar.c:						skb_queue_tail(&card->hbpool.
./drivers/atm/nicstar.c:						card->hbpool.count++;
./drivers/atm/nicstar.c:				if (card->hbpool.count < card->hbnr.max) {
./drivers/atm/nicstar.c:					skb_queue_tail(&card->hbpool.queue, hb);
./drivers/atm/nicstar.c:					card->hbpool.count++;
./drivers/atm/nicstar.c:					     card->index);
./drivers/atm/nicstar.c:	stat = readl(card->membase + STAT);
./drivers/atm/nicstar.c:	card->sbfqc = ns_stat_sfbqc_get(stat);
./drivers/atm/nicstar.c:	card->lbfqc = ns_stat_lfbqc_get(stat);
./drivers/atm/nicstar.c:		skb_queue_tail(&card->sbpool.queue, sb);
./drivers/atm/nicstar.c:	} while (card->sbfqc < card->sbnr.min);
./drivers/atm/nicstar.c:	stat = readl(card->membase + STAT);
./drivers/atm/nicstar.c:	card->sbfqc = ns_stat_sfbqc_get(stat);
./drivers/atm/nicstar.c:	card->lbfqc = ns_stat_lfbqc_get(stat);
./drivers/atm/nicstar.c:		skb_queue_tail(&card->lbpool.queue, lb);
./drivers/atm/nicstar.c:	} while (card->lbfqc < card->lbnr.min);
./drivers/atm/nicstar.c:	while (card->hbpool.count < card->hbnr.init) {
./drivers/atm/nicstar.c:		skb_queue_tail(&card->hbpool.queue, hb);
./drivers/atm/nicstar.c:		card->hbpool.count++;
./drivers/atm/nicstar.c:		       card->index);
./drivers/atm/nicstar.c:	if (card->iovpool.count < card->iovnr.max) {
./drivers/atm/nicstar.c:		skb_queue_tail(&card->iovpool.queue, iovb);
./drivers/atm/nicstar.c:		card->iovpool.count++;
./drivers/atm/nicstar.c:	skb_unlink(sb, &card->sbpool.queue);
./drivers/atm/nicstar.c:	if (card->sbfqc < card->sbnr.min)
./drivers/atm/nicstar.c:	if (card->sbfqc < card->sbnr.init) {
./drivers/atm/nicstar.c:			skb_queue_tail(&card->sbpool.queue, new_sb);
./drivers/atm/nicstar.c:	if (card->sbfqc < card->sbnr.init)
./drivers/atm/nicstar.c:			skb_queue_tail(&card->sbpool.queue, new_sb);
./drivers/atm/nicstar.c:	skb_unlink(lb, &card->lbpool.queue);
./drivers/atm/nicstar.c:	if (card->lbfqc < card->lbnr.min)
./drivers/atm/nicstar.c:	if (card->lbfqc < card->lbnr.init) {
./drivers/atm/nicstar.c:			skb_queue_tail(&card->lbpool.queue, new_lb);
./drivers/atm/nicstar.c:	if (card->lbfqc < card->lbnr.init)
./drivers/atm/nicstar.c:			skb_queue_tail(&card->lbpool.queue, new_lb);
./drivers/atm/nicstar.c:	stat = readl(card->membase + STAT);
./drivers/atm/nicstar.c:			       ns_stat_sfbqc_get(stat), card->sbnr.min,
./drivers/atm/nicstar.c:			       card->sbnr.init, card->sbnr.max);
./drivers/atm/nicstar.c:			       ns_stat_lfbqc_get(stat), card->lbnr.min,
./drivers/atm/nicstar.c:			       card->lbnr.init, card->lbnr.max);
./drivers/atm/nicstar.c:			       card->hbpool.count, card->hbnr.min,
./drivers/atm/nicstar.c:			       card->hbnr.init, card->hbnr.max);
./drivers/atm/nicstar.c:			       card->iovpool.count, card->iovnr.min,
./drivers/atm/nicstar.c:			       card->iovnr.init, card->iovnr.max);
./drivers/atm/nicstar.c:		    sprintf(page, "Interrupt counter: %u \n", card->intcnt);
./drivers/atm/nicstar.c:		card->intcnt = 0;
./drivers/atm/nicstar.c:	if (card->max_pcr == ATM_25_PCR && !left--) {
./drivers/atm/nicstar.c:			       card->membase + CMD);
./drivers/atm/nicstar.c:			phy_regs[i] = readl(card->membase + DR0) & 0x000000FF;
./drivers/atm/nicstar.c:		if (card->tste2vc[left + 1] == NULL)
./drivers/atm/nicstar.c:				       card->tste2vc[left + 1]->tx_vcc->vpi,
./drivers/atm/nicstar.c:				       card->tste2vc[left + 1]->tx_vcc->vci);
./drivers/atm/nicstar.c:			    ns_stat_sfbqc_get(readl(card->membase + STAT));
./drivers/atm/nicstar.c:			pl.level.min = card->sbnr.min;
./drivers/atm/nicstar.c:			pl.level.init = card->sbnr.init;
./drivers/atm/nicstar.c:			pl.level.max = card->sbnr.max;
./drivers/atm/nicstar.c:			    ns_stat_lfbqc_get(readl(card->membase + STAT));
./drivers/atm/nicstar.c:			pl.level.min = card->lbnr.min;
./drivers/atm/nicstar.c:			pl.level.init = card->lbnr.init;
./drivers/atm/nicstar.c:			pl.level.max = card->lbnr.max;
./drivers/atm/nicstar.c:			pl.count = card->hbpool.count;
./drivers/atm/nicstar.c:			pl.level.min = card->hbnr.min;
./drivers/atm/nicstar.c:			pl.level.init = card->hbnr.init;
./drivers/atm/nicstar.c:			pl.level.max = card->hbnr.max;
./drivers/atm/nicstar.c:			pl.count = card->iovpool.count;
./drivers/atm/nicstar.c:			pl.level.min = card->iovnr.min;
./drivers/atm/nicstar.c:			pl.level.init = card->iovnr.init;
./drivers/atm/nicstar.c:			pl.level.max = card->iovnr.max;
./drivers/atm/nicstar.c:			card->sbnr.min = pl.level.min;
./drivers/atm/nicstar.c:			card->sbnr.init = pl.level.init;
./drivers/atm/nicstar.c:			card->sbnr.max = pl.level.max;
./drivers/atm/nicstar.c:			card->lbnr.min = pl.level.min;
./drivers/atm/nicstar.c:			card->lbnr.init = pl.level.init;
./drivers/atm/nicstar.c:			card->lbnr.max = pl.level.max;
./drivers/atm/nicstar.c:			card->hbnr.min = pl.level.min;
./drivers/atm/nicstar.c:			card->hbnr.init = pl.level.init;
./drivers/atm/nicstar.c:			card->hbnr.max = pl.level.max;
./drivers/atm/nicstar.c:			card->iovnr.min = pl.level.min;
./drivers/atm/nicstar.c:			card->iovnr.init = pl.level.init;
./drivers/atm/nicstar.c:			card->iovnr.max = pl.level.max;
./drivers/atm/nicstar.c:			while (card->sbfqc < card->sbnr.init) {
./drivers/atm/nicstar.c:				skb_queue_tail(&card->sbpool.queue, sb);
./drivers/atm/nicstar.c:			while (card->lbfqc < card->lbnr.init) {
./drivers/atm/nicstar.c:				skb_queue_tail(&card->lbpool.queue, lb);
./drivers/atm/nicstar.c:			while (card->hbpool.count > card->hbnr.init) {
./drivers/atm/nicstar.c:				spin_lock_irqsave(&card->int_lock, flags);
./drivers/atm/nicstar.c:				hb = skb_dequeue(&card->hbpool.queue);
./drivers/atm/nicstar.c:				card->hbpool.count--;
./drivers/atm/nicstar.c:				spin_unlock_irqrestore(&card->int_lock, flags);
./drivers/atm/nicstar.c:					     card->index);
./drivers/atm/nicstar.c:			while (card->hbpool.count < card->hbnr.init) {
./drivers/atm/nicstar.c:				spin_lock_irqsave(&card->int_lock, flags);
./drivers/atm/nicstar.c:				skb_queue_tail(&card->hbpool.queue, hb);
./drivers/atm/nicstar.c:				card->hbpool.count++;
./drivers/atm/nicstar.c:				spin_unlock_irqrestore(&card->int_lock, flags);
./drivers/atm/nicstar.c:			while (card->iovpool.count > card->iovnr.init) {
./drivers/atm/nicstar.c:				spin_lock_irqsave(&card->int_lock, flags);
./drivers/atm/nicstar.c:				iovb = skb_dequeue(&card->iovpool.queue);
./drivers/atm/nicstar.c:				card->iovpool.count--;
./drivers/atm/nicstar.c:				spin_unlock_irqrestore(&card->int_lock, flags);
./drivers/atm/nicstar.c:					     card->index);
./drivers/atm/nicstar.c:			while (card->iovpool.count < card->iovnr.init) {
./drivers/atm/nicstar.c:				spin_lock_irqsave(&card->int_lock, flags);
./drivers/atm/nicstar.c:				skb_queue_tail(&card->iovpool.queue, iovb);
./drivers/atm/nicstar.c:				card->iovpool.count++;
./drivers/atm/nicstar.c:				spin_unlock_irqrestore(&card->int_lock, flags);
./drivers/atm/nicstar.c:			printk("nicstar%d: %s == NULL \n", card->index,
./drivers/atm/nicstar.c:		if (spin_is_locked(&card->int_lock)) {
./drivers/atm/nicstar.c:		spin_lock_irqsave(&card->int_lock, flags);
./drivers/atm/nicstar.c:		stat_r = readl(card->membase + STAT);
./drivers/atm/nicstar.c:		writel(stat_w, card->membase + STAT);
./drivers/atm/nicstar.c:		spin_unlock_irqrestore(&card->int_lock, flags);
./drivers/atm/nicstar.c:	spin_lock_irqsave(&card->res_lock, flags);
./drivers/atm/nicstar.c:	writel((u32) value, card->membase + DR0);
./drivers/atm/nicstar.c:	       card->membase + CMD);
./drivers/atm/nicstar.c:	spin_unlock_irqrestore(&card->res_lock, flags);
./drivers/atm/nicstar.c:	spin_lock_irqsave(&card->res_lock, flags);
./drivers/atm/nicstar.c:	       card->membase + CMD);
./drivers/atm/nicstar.c:	data = readl(card->membase + DR0) & 0x000000FF;
./drivers/atm/nicstar.c:	spin_unlock_irqrestore(&card->res_lock, flags);
./drivers/hid/hid-roccat-kone.c: * Is called for keyboard- and mousepart.
./drivers/hid/hid-prodikeys.c:	strncpy(card->driver, shortname, sizeof(card->driver));
./drivers/hid/hid-prodikeys.c:	strncpy(card->shortname, shortname, sizeof(card->shortname));
./drivers/hid/hid-prodikeys.c:	strncpy(card->longname, longname, sizeof(card->longname));
./drivers/hid/hid-prodikeys.c:	err = snd_rawmidi_new(card, card->shortname, 0,
./drivers/hid/hid-prodikeys.c:	strncpy(rwmidi->name, card->shortname, sizeof(rwmidi->name));
./drivers/ide/at91_ide.c:	if (board->det_pin && at91_get_gpio_value(board->det_pin) != 0) {
./drivers/ide/at91_ide.c:	pdbg("chipselect %u irq %u res %08lx\n", board->chipselect,
./drivers/ide/at91_ide.c:	     board->irq_pin, (unsigned long) res->start);
./drivers/ide/at91_ide.c:	if (board->flags & AT91_IDE_SWAP_A0_A2) {
./drivers/ide/at91_ide.c:	hw.irq = board->irq_pin;
./drivers/ide/at91_ide.c:	apply_timings(board->chipselect, 0, ide_timing_find_mode(XFER_PIO_0), 0);
./drivers/ide/at91_ide.c:	if (board->irq_pin >= PIN_BASE)
./drivers/ide/at91_ide.c:	host->ports[0]->select_data = board->chipselect;
./drivers/ide/macide.c: * not word-aligned like virtually every other hardware register
./drivers/ata/sata_fsl.c:			prd->dba = cpu_to_le32(indirect_ext_segment_paddr);
./drivers/ata/sata_fsl.c:		prd->dba = cpu_to_le32(sg_addr);
./drivers/ata/sata_fsl.c:		prd->ddc_and_ext = cpu_to_le32(data_snoop | (sg_len & ~0x03));
./drivers/ata/sata_fsl.c:			ttl_dwords, prd->dba, prd->ddc_and_ext);
./drivers/ata/pata_at91.c:	irq = board->irq_pin;
./drivers/ata/pata_at91.c:	info->cs    = board->chipselect;
./drivers/ata/sata_inic162x.c:		prd->mad = cpu_to_le32(sg_dma_address(sg));
./drivers/ata/sata_inic162x.c:		prd->len = cpu_to_le16(sg_dma_len(sg));
./drivers/ata/sata_inic162x.c:		prd->flags = flags;
./drivers/ata/sata_inic162x.c:		prd->mad = cpu_to_le32(pp->pkt_dma +
./drivers/ata/sata_inic162x.c:		prd->len = cpu_to_le16(cdb_len);
./drivers/ata/sata_inic162x.c:		prd->flags = PRD_CDB | PRD_WRITE;
./drivers/ata/sata_inic162x.c:			prd->flags |= PRD_END;
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/sata_sx4.c:	/* hard-code chip #0 */
./drivers/ata/pata_at32.c:	info->cs  = board->cs;
./drivers/ata/sata_nv.c:	aprd->addr  = cpu_to_le64(((u64)sg_dma_address(sg)));
./drivers/ata/sata_nv.c:	aprd->len   = cpu_to_le32(((u32)sg_dma_len(sg))); /* len in bytes */
./drivers/ata/sata_nv.c:	aprd->flags = flags;
./drivers/ata/sata_nv.c:	aprd->packet_len = 0;
./drivers/ata/libata-pmp.c: *	always be performed in hard->soft sequence and recovery
./drivers/ata/sata_sil.c:		prd->addr = cpu_to_le32(addr);
./drivers/ata/sata_sil.c:		prd->flags_len = cpu_to_le32(sg_len);
./drivers/ata/sata_sil.c:		last_prd->flags_len |= cpu_to_le32(ATA_PRD_EOT);
./drivers/ata/acard-ahci.c: *  acard-ahci.c - ACard AHCI SATA support
./drivers/ata/acard-ahci.c:#define DRV_NAME	"acard-ahci"
./drivers/ata/acard-ahci.c:	AHCI_SHT("acard-ahci"),
./drivers/ata/pata_macio.c:	/* hard-reset the controller */
./drivers/isdn/i4l/isdn_tty.c:/* Need own toupper() because standard-toupper is not available
./drivers/isdn/hisax/gazel.c:	if (readreg_ipac(card->para[1], IPAC_ID) == 1)
./drivers/isdn/hisax/gazel.c:	cs->hw.gazel.cfg_reg = card->para[1] + 0xC000;
./drivers/isdn/hisax/gazel.c:	cs->hw.gazel.ipac = card->para[1];
./drivers/isdn/hisax/gazel.c:	cs->hw.gazel.isac = card->para[1] + 0x8000;
./drivers/isdn/hisax/gazel.c:	cs->hw.gazel.hscx[0] = card->para[1];
./drivers/isdn/hisax/gazel.c:	cs->hw.gazel.hscx[1] = card->para[1] + 0x4000;
./drivers/isdn/hisax/gazel.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/gazel.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/gazel.c:	if (card->para[0]) {
./drivers/isdn/hisax/sedlbauer.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/sedlbauer.c:				card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/sedlbauer.c:				card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/sedlbauer.c:				if (!card->para[0] || !card->para[1]) {
./drivers/isdn/hisax/sedlbauer.c:						card->para[0], card->para[1]);
./drivers/isdn/hisax/sedlbauer.c:				cs->hw.sedl.cfg_reg = card->para[1];
./drivers/isdn/hisax/sedlbauer.c:				cs->irq = card->para[0];
./drivers/isdn/hisax/sedlbauer.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/sedlbauer.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/sedlbauer.c:	if (card->para[1]) {
./drivers/isdn/hisax/sedlbauer.c:		cs->hw.sedl.cfg_reg = card->para[1];
./drivers/isdn/hisax/sedlbauer.c:		cs->irq = card->para[0];
./drivers/isdn/hisax/sedlbauer.c:			CardType[card->typ],
./drivers/isdn/hisax/hfcscard.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/hfcscard.c:	if (!card->para[1] && isapnp_present()) {
./drivers/isdn/hisax/hfcscard.c:					card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/hfcscard.c:					card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/hfcscard.c:					if (!card->para[0] || !card->para[1]) {
./drivers/isdn/hisax/hfcscard.c:							card->para[0], card->para[1]);
./drivers/isdn/hisax/hfcscard.c:	cs->hw.hfcD.addr = card->para[1] & 0xfffe;
./drivers/isdn/hisax/hfcscard.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/hfcscard.c:		       CardType[card->typ],
./drivers/isdn/hisax/w6692.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/hfc_pci.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/hfc_pci.c:			if ((card->para[0]) && (card->para[0] != (tmp_hfcpci->resource[ 0].start & PCI_BASE_ADDRESS_IO_MASK)))
./drivers/isdn/hisax/asuscom.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/asuscom.c:	if (!card->para[1] && isapnp_present()) {
./drivers/isdn/hisax/asuscom.c:					card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/asuscom.c:					card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/asuscom.c:					if (!card->para[0] || !card->para[1]) {
./drivers/isdn/hisax/asuscom.c:							card->para[0], card->para[1]);
./drivers/isdn/hisax/asuscom.c:	cs->hw.asus.cfg_reg = card->para[1];
./drivers/isdn/hisax/asuscom.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/sportster.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/sportster.c:	cs->hw.spt.cfg_reg = card->para[1];
./drivers/isdn/hisax/sportster.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/config.c:	switch (card->typ) {
./drivers/isdn/hisax/config.c:		       CardType[card->typ]);
./drivers/isdn/hisax/config.c:	card->cs = cs;
./drivers/isdn/hisax/config.c:	if (card->protocol == ISDN_PTYPE_NI1)
./drivers/isdn/hisax/config.c:	cs->protocol = card->protocol;
./drivers/isdn/hisax/config.c:	if (card->typ <= 0 || card->typ > ISDN_CTYPE_COUNT) {
./drivers/isdn/hisax/config.c:		       "HiSax: Card Type %d out of range\n", card->typ);
./drivers/isdn/hisax/config.c:	cs->typ = card->typ;
./drivers/isdn/hisax/config.c:	card->cs = NULL;
./drivers/isdn/hisax/config.c:	switch (card->typ) {
./drivers/isdn/hisax/config.c:	card->cs = NULL;
./drivers/isdn/hisax/config.c:	       (card->protocol == ISDN_PTYPE_1TR6) ? "1TR6" :
./drivers/isdn/hisax/config.c:	       (card->protocol == ISDN_PTYPE_EURO) ? "EDSS1" :
./drivers/isdn/hisax/config.c:	       (card->protocol == ISDN_PTYPE_LEASED) ? "LEASED" :
./drivers/isdn/hisax/config.c:	       (card->protocol == ISDN_PTYPE_NI1) ? "NI1" :
./drivers/isdn/hisax/config.c:	card->cs = NULL;
./drivers/isdn/hisax/teles0.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/teles0.c:		cs->hw.teles0.cfg_reg = card->para[2];
./drivers/isdn/hisax/teles0.c:	if (card->para[1] < 0x10000) {
./drivers/isdn/hisax/teles0.c:		card->para[1] <<= 4;
./drivers/isdn/hisax/teles0.c:		       (unsigned long) card->para[1]);
./drivers/isdn/hisax/teles0.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/teles0.c:			       CardType[card->typ],
./drivers/isdn/hisax/teles0.c:	cs->hw.teles0.phymem = card->para[1];
./drivers/isdn/hisax/teles0.c:			CardType[card->typ],
./drivers/isdn/hisax/hfc_sx.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/hfc_sx.c:	if (!card->para[1] && isapnp_present()) {
./drivers/isdn/hisax/hfc_sx.c:					card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/hfc_sx.c:					card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/hfc_sx.c:					if (!card->para[0] || !card->para[1]) {
./drivers/isdn/hisax/hfc_sx.c:							card->para[0], card->para[1]);
./drivers/isdn/hisax/hfc_sx.c:	cs->hw.hfcsx.base = card->para[1] & 0xfffe;
./drivers/isdn/hisax/hfc_sx.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/avm_a1.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/avm_a1.c:	cs->hw.avm.cfg_reg = card->para[1] + 0x1800;
./drivers/isdn/hisax/avm_a1.c:	cs->hw.avm.isac = card->para[1] + 0x1400 - 0x20;
./drivers/isdn/hisax/avm_a1.c:	cs->hw.avm.hscx[0] = card->para[1] + 0x400 - 0x20;
./drivers/isdn/hisax/avm_a1.c:	cs->hw.avm.hscx[1] = card->para[1] + 0xc00 - 0x20;
./drivers/isdn/hisax/avm_a1.c:	cs->hw.avm.isacfifo = card->para[1] + 0x1000;
./drivers/isdn/hisax/avm_a1.c:	cs->hw.avm.hscxfifo[0] = card->para[1];
./drivers/isdn/hisax/avm_a1.c:	cs->hw.avm.hscxfifo[1] = card->para[1] + 0x800;
./drivers/isdn/hisax/avm_a1.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/amd7930_fn.c: * 1. Load hisax with card-specific parameters, this example ist for
./drivers/isdn/hisax/bkm_a8.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/bkm_a8.c:	if (card->para[0] >= SCT_1 && card->para[0] <= SCT_4)
./drivers/isdn/hisax/bkm_a8.c:		cs->subtyp = card->para[0];
./drivers/isdn/hisax/mic.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/mic.c:	cs->hw.mic.cfg_reg = card->para[1];
./drivers/isdn/hisax/mic.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/diva.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/diva.c:	if (!card->para[1])
./drivers/isdn/hisax/diva.c:	cs->hw.diva.cfg_reg = card->para[1];
./drivers/isdn/hisax/diva.c:		cs->hw.diva.isac = card->para[1] + DIVA_IPAC_DATA;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.hscx = card->para[1] + DIVA_IPAC_DATA;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.isac_adr = card->para[1] + DIVA_IPAC_ADR;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.hscx_adr = card->para[1] + DIVA_IPAC_ADR;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.ctrl = card->para[1] + DIVA_ISA_CTRL;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.isac = card->para[1] + DIVA_ISA_ISAC_DATA;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.hscx = card->para[1] + DIVA_HSCX_DATA;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.isac_adr = card->para[1] + DIVA_ISA_ISAC_ADR;
./drivers/isdn/hisax/diva.c:		cs->hw.diva.hscx_adr = card->para[1] + DIVA_HSCX_ADR;
./drivers/isdn/hisax/diva.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/diva.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/diva.c:				card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/diva.c:				card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/diva.c:				if (!card->para[0] || !card->para[1]) {
./drivers/isdn/hisax/diva.c:						card->para[0], card->para[1]);
./drivers/isdn/hisax/diva.c:				cs->hw.diva.cfg_reg  = card->para[1];
./drivers/isdn/hisax/diva.c:				cs->irq = card->para[0];
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_IPAC_DATA;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_IPAC_DATA;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_IPAC_ADR;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_IPAC_ADR;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_ISA_CTRL;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_ISA_ISAC_DATA;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_HSCX_DATA;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_ISA_ISAC_ADR;
./drivers/isdn/hisax/diva.c:						card->para[1] + DIVA_HSCX_ADR;
./drivers/isdn/hisax/diva.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/diva.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/diva.c:	return setup_diva_common(card->cs);
./drivers/isdn/hisax/teleint.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/teleint.c:	cs->hw.hfc.addr = card->para[1] & 0x3fe;
./drivers/isdn/hisax/teleint.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/isurf.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/isurf.c:	if (card->para[1] && card->para[2]) {
./drivers/isdn/hisax/isurf.c:		cs->hw.isurf.reset = card->para[1];
./drivers/isdn/hisax/isurf.c:		cs->hw.isurf.phymem = card->para[2];
./drivers/isdn/hisax/isurf.c:		cs->irq = card->para[0];
./drivers/isdn/hisax/avm_pci.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/avm_pci.c:	if (card->para[1]) {
./drivers/isdn/hisax/avm_pci.c:		cs->hw.avm.cfg_reg = card->para[1];
./drivers/isdn/hisax/avm_pci.c:		cs->irq = card->para[0];
./drivers/isdn/hisax/avm_a1p.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/avm_a1p.c:	cs->hw.avm.cfg_reg = card->para[1];
./drivers/isdn/hisax/avm_a1p.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/niccy.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/niccy.c:	if (!card->para[1] && isapnp_present()) {
./drivers/isdn/hisax/niccy.c:			card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/niccy.c:			card->para[2] = pnp_port_start(pnp_d, 1);
./drivers/isdn/hisax/niccy.c:			card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/niccy.c:			if (!card->para[0] || !card->para[1] ||
./drivers/isdn/hisax/niccy.c:					!card->para[2]) {
./drivers/isdn/hisax/niccy.c:					card->para[0], card->para[1],
./drivers/isdn/hisax/niccy.c:					card->para[2]);
./drivers/isdn/hisax/niccy.c:	if (card->para[1]) {
./drivers/isdn/hisax/niccy.c:		cs->hw.niccy.isac = card->para[1] + ISAC_PNP;
./drivers/isdn/hisax/niccy.c:		cs->hw.niccy.hscx = card->para[1] + HSCX_PNP;
./drivers/isdn/hisax/niccy.c:		cs->hw.niccy.isac_ale = card->para[2] + ISAC_PNP;
./drivers/isdn/hisax/niccy.c:		cs->hw.niccy.hscx_ale = card->para[2] + HSCX_PNP;
./drivers/isdn/hisax/niccy.c:		cs->irq = card->para[0];
./drivers/isdn/hisax/elsa.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/elsa.c:	cs->hw.elsa.base = card->para[0];
./drivers/isdn/hisax/elsa.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/elsa.c:	if (!card->para[1] && isapnp_present()) {
./drivers/isdn/hisax/elsa.c:					card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/elsa.c:					card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/elsa.c:					if (!card->para[0] || !card->para[1]) {
./drivers/isdn/hisax/elsa.c:							card->para[0], card->para[1]);
./drivers/isdn/hisax/elsa.c:	if (card->para[1] && card->para[0]) { 
./drivers/isdn/hisax/elsa.c:		cs->hw.elsa.base = card->para[1];
./drivers/isdn/hisax/elsa.c:		cs->irq = card->para[0];
./drivers/isdn/hisax/elsa.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/elsa.c:	cs->hw.elsa.base = card->para[1];
./drivers/isdn/hisax/elsa.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/elsa.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/elsa.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/elsa.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/saphir.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/saphir.c:	cs->hw.saphir.cfg_reg = card->para[1];
./drivers/isdn/hisax/saphir.c:	cs->hw.saphir.isac = card->para[1] + ISAC_DATA;
./drivers/isdn/hisax/saphir.c:	cs->hw.saphir.hscx = card->para[1] + HSCX_DATA;
./drivers/isdn/hisax/saphir.c:	cs->hw.saphir.ale = card->para[1] + ADDRESS_REG;
./drivers/isdn/hisax/saphir.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/bkm_a4t.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/nj_s.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/teles3.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/teles3.c:	if (!card->para[1] && isapnp_present()) {
./drivers/isdn/hisax/teles3.c:					card->para[3] = pnp_port_start(pnp_d, 2);
./drivers/isdn/hisax/teles3.c:					card->para[2] = pnp_port_start(pnp_d, 1);
./drivers/isdn/hisax/teles3.c:					card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/teles3.c:					card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/teles3.c:					if (!card->para[0] || !card->para[1] || !card->para[2]) {
./drivers/isdn/hisax/teles3.c:							card->para[0], card->para[1], card->para[2]);
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.cfg_reg = card->para[1];
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.hscx[0] = card->para[1] - 0x20;
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.hscx[1] = card->para[1];
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.isac = card->para[1] + 0x20;
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.cfg_reg = card->para[3];
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.isac = card->para[2] - 32;
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.hscx[0] = card->para[1] - 32;
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.hscx[1] = card->para[1];
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.isac = card->para[1] - 32;
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.hscx[0] = card->para[2] - 32;
./drivers/isdn/hisax/teles3.c:		cs->hw.teles3.hscx[1] = card->para[2];
./drivers/isdn/hisax/teles3.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/teles3.c:						CardType[card->typ],
./drivers/isdn/hisax/teles3.c:					       CardType[card->typ],
./drivers/isdn/hisax/nj_u.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/telespci.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/ix1_micro.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/ix1_micro.c:	if (!card->para[1] && isapnp_present()) {
./drivers/isdn/hisax/ix1_micro.c:					card->para[1] = pnp_port_start(pnp_d, 0);
./drivers/isdn/hisax/ix1_micro.c:					card->para[0] = pnp_irq(pnp_d, 0);
./drivers/isdn/hisax/ix1_micro.c:					if (!card->para[0] || !card->para[1]) {
./drivers/isdn/hisax/ix1_micro.c:							card->para[0], card->para[1]);
./drivers/isdn/hisax/ix1_micro.c:	cs->hw.ix1.isac_ale = card->para[1] + ISAC_COMMAND_OFFSET;
./drivers/isdn/hisax/ix1_micro.c:	cs->hw.ix1.hscx_ale = card->para[1] + HSCX_COMMAND_OFFSET;
./drivers/isdn/hisax/ix1_micro.c:	cs->hw.ix1.isac = card->para[1] + ISAC_DATA_OFFSET;
./drivers/isdn/hisax/ix1_micro.c:	cs->hw.ix1.hscx = card->para[1] + HSCX_DATA_OFFSET;
./drivers/isdn/hisax/ix1_micro.c:	cs->hw.ix1.cfg_reg = card->para[1];
./drivers/isdn/hisax/ix1_micro.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/s0box.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/hisax/s0box.c:	cs->hw.teles3.cfg_reg = card->para[1];
./drivers/isdn/hisax/s0box.c:	cs->irq = card->para[0];
./drivers/isdn/hisax/enternow_pci.c: * enternow_pci.c       Card-specific routines for
./drivers/isdn/hisax/enternow_pci.c: * 1. Load hisax with card-specific parameters, this example ist for
./drivers/isdn/hisax/enternow_pci.c:	struct IsdnCardState *cs = card->cs;
./drivers/isdn/act2000/capi.c:	skb_queue_tail(&card->sndq, skb); \
./drivers/isdn/act2000/capi.c:		eazmask |= card->bch[i].eazmask;
./drivers/isdn/act2000/capi.c:	m->msg.manufacturer_req_net.nettype = (card->ptype == ISDN_PTYPE_EURO)?1:0;
./drivers/isdn/act2000/capi.c:	       card->interface.id, (card->ptype == ISDN_PTYPE_EURO)?"euro":"1tr6");
./drivers/isdn/act2000/capi.c:	card->interface.features &=
./drivers/isdn/act2000/capi.c:	card->interface.features |=
./drivers/isdn/act2000/capi.c:		((card->ptype == ISDN_PTYPE_EURO)?ISDN_FEATURE_P_EURO:ISDN_FEATURE_P_1TR6);
./drivers/isdn/act2000/capi.c:	msn_entry *p = card->msn_list;
./drivers/isdn/act2000/capi.c:		if (card->bch[i].plci == 0x8000) {
./drivers/isdn/act2000/capi.c:			card->bch[i].plci = plci;
./drivers/isdn/act2000/capi.c:		if (card->bch[i].plci == plci)
./drivers/isdn/act2000/capi.c:		if (card->bch[i].ncci == ncci)
./drivers/isdn/act2000/capi.c:		if ((card->bch[i].callref == callref) &&
./drivers/isdn/act2000/capi.c:		    (card->bch[i].fsm_state == ACT2000_STATE_OCALL))
./drivers/isdn/act2000/capi.c:	if (card->bch[chan].fsm_state != ACT2000_STATE_ACTIVE)
./drivers/isdn/act2000/capi.c:	if (card->bch[chan].plci != plci)
./drivers/isdn/act2000/capi.c:	card->interface.rcvcallb_skb(card->myid, chan, skb);
./drivers/isdn/act2000/capi.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/capi.c:	skb = skb_peek(&card->ackq);
./drivers/isdn/act2000/capi.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/capi.c:                        skb_unlink(tmp, &card->ackq);
./drivers/isdn/act2000/capi.c:                spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/capi.c:                spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/capi.c:	while ((skb = skb_dequeue(&card->rcvq))) {
./drivers/isdn/act2000/capi.c:				if ((chan >= 0) && (card->bch[chan].fsm_state == ACT2000_STATE_ACTIVE)) {
./drivers/isdn/act2000/capi.c:					len = handle_ack(card, &card->bch[chan],
./drivers/isdn/act2000/capi.c:						cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:						card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:						card->bch[chan].fsm_state = ACT2000_STATE_NULL;
./drivers/isdn/act2000/capi.c:						cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:						card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:						card->bch[chan].fsm_state = ACT2000_STATE_OWAIT;
./drivers/isdn/act2000/capi.c:						card->bch[chan].plci = msg->msg.connect_conf.plci;
./drivers/isdn/act2000/capi.c:					actcapi_connect_resp(card, ctmp, 0x11); /* All Card-Cannels busy */
./drivers/isdn/act2000/capi.c:					card->bch[chan].fsm_state = ACT2000_STATE_ICALL;
./drivers/isdn/act2000/capi.c:					cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:					if (card->ptype == ISDN_PTYPE_EURO)
./drivers/isdn/act2000/capi.c:					if (card->interface.statcallb(&cmd) == 2)
./drivers/isdn/act2000/capi.c:						actcapi_connect_resp(card, &card->bch[chan], 0x15); /* Reject Call */
./drivers/isdn/act2000/capi.c:					switch (card->bch[chan].fsm_state) {
./drivers/isdn/act2000/capi.c:							actcapi_connect_active_resp(card, &card->bch[chan]);
./drivers/isdn/act2000/capi.c:							actcapi_connect_active_resp(card, &card->bch[chan]);
./drivers/isdn/act2000/capi.c:							actcapi_select_b2_protocol_req(card, &card->bch[chan]);
./drivers/isdn/act2000/capi.c:				if ((chan >= 0) && (card->bch[chan].fsm_state == ACT2000_STATE_IBWAIT)) {
./drivers/isdn/act2000/capi.c:					card->bch[chan].ncci = msg->msg.connect_b3_ind.ncci;
./drivers/isdn/act2000/capi.c:					actcapi_connect_b3_resp(card, &card->bch[chan], 0);
./drivers/isdn/act2000/capi.c:					actcapi_connect_b3_resp(card, ctmp, 0x11); /* All Card-Cannels busy */
./drivers/isdn/act2000/capi.c:				if ((chan >= 0) && (card->bch[chan].fsm_state == ACT2000_STATE_BWAIT)) {
./drivers/isdn/act2000/capi.c:					actcapi_connect_b3_active_resp(card, &card->bch[chan]);
./drivers/isdn/act2000/capi.c:					cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:					card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:					ctmp = &card->bch[chan];
./drivers/isdn/act2000/capi.c:							cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:							card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:							cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:							card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:					ctmp = &card->bch[chan];
./drivers/isdn/act2000/capi.c:					cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:					card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:					switch (card->bch[chan].fsm_state) {
./drivers/isdn/act2000/capi.c:							ctmp = &card->bch[chan];
./drivers/isdn/act2000/capi.c:								cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:								card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:					switch (card->bch[chan].fsm_state) {
./drivers/isdn/act2000/capi.c:							ctmp = &card->bch[chan];
./drivers/isdn/act2000/capi.c:								cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:								card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:					switch (card->bch[chan].fsm_state) {
./drivers/isdn/act2000/capi.c:							ctmp = &card->bch[chan];
./drivers/isdn/act2000/capi.c:								cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:								card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:							ctmp = &card->bch[chan];
./drivers/isdn/act2000/capi.c:								cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:								card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:								cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:								card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:				if ((chan >= 0) && (card->bch[chan].fsm_state == ACT2000_STATE_OBWAIT)) {
./drivers/isdn/act2000/capi.c:					ctmp = &card->bch[chan];
./drivers/isdn/act2000/capi.c:						cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:						card->interface.statcallb(&cmd);
./drivers/isdn/act2000/capi.c:				if ((chan >= 0) && (card->bch[chan].fsm_state == ACT2000_STATE_BHWAIT))
./drivers/isdn/act2000/capi.c:					card->bch[chan].fsm_state = ACT2000_STATE_BHWAIT2;
./drivers/isdn/act2000/capi.c:					actcapi_info_resp(card, &card->bch[chan]);
./drivers/isdn/act2000/capi.c:							card->flags |= ACT2000_FLAGS_RUNNING;
./drivers/isdn/act2000/capi.c:							cmd.driver = card->myid;
./drivers/isdn/act2000/capi.c:							card->interface.statcallb(&cmd);
./drivers/isdn/act2000/module.c:        	return &(card->bch[channel]);
./drivers/isdn/act2000/module.c:	struct msn_entry *p = card->msn_list;
./drivers/isdn/act2000/module.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/module.c:	card->msn_list = NULL;
./drivers/isdn/act2000/module.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/module.c:        struct msn_entry *p = card->msn_list;
./drivers/isdn/act2000/module.c:        struct msn_entry *p = card->msn_list;
./drivers/isdn/act2000/module.c:        struct msn_entry *p = card->msn_list;
./drivers/isdn/act2000/module.c:				spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/module.c:					card->msn_list = p->next;
./drivers/isdn/act2000/module.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/module.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/module.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/module.c:	p->next = card->msn_list;
./drivers/isdn/act2000/module.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/module.c:	card->msn_list = p;
./drivers/isdn/act2000/module.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/module.c:	switch (card->bus) {
./drivers/isdn/act2000/module.c:			       "act2000_transmit: Illegal bustype %d\n", card->bus);
./drivers/isdn/act2000/module.c:	switch (card->bus) {
./drivers/isdn/act2000/module.c:			       "act2000_receive: Illegal bustype %d\n", card->bus);
./drivers/isdn/act2000/module.c:	act2000_receive(&card->poll_tq);
./drivers/isdn/act2000/module.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/module.c:	mod_timer(&card->ptimer, jiffies+3);
./drivers/isdn/act2000/module.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/module.c:					switch (card->bus) {
./drivers/isdn/act2000/module.c:								card->flags |= ACT2000_FLAGS_LOADED;
./drivers/isdn/act2000/module.c:								if (!(card->flags & ACT2000_FLAGS_IVALID)) {
./drivers/isdn/act2000/module.c:									card->ptimer.expires = jiffies + 3;
./drivers/isdn/act2000/module.c:									card->ptimer.function = act2000_poll;
./drivers/isdn/act2000/module.c:									card->ptimer.data = (unsigned long)card;
./drivers/isdn/act2000/module.c:									add_timer(&card->ptimer);
./drivers/isdn/act2000/module.c:							       card->bus);
./drivers/isdn/act2000/module.c:					card->ptype = a?ISDN_PTYPE_EURO:ISDN_PTYPE_1TR6;
./drivers/isdn/act2000/module.c:					if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:					if (card->flags & ACT2000_FLAGS_RUNNING)
./drivers/isdn/act2000/module.c:					if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/module.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/module.c:			if (card->ptype == ISDN_PTYPE_EURO)
./drivers/isdn/act2000/module.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/module.c:				cmd.driver = card->myid;
./drivers/isdn/act2000/module.c:				card->interface.statcallb(&cmd);
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:				if (card->ptype == ISDN_PTYPE_EURO) {
./drivers/isdn/act2000/module.c:				if (card->ptype == ISDN_PTYPE_1TR6) {
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:			if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:	skb_queue_tail(&card->sndq, xmit_skb);
./drivers/isdn/act2000/module.c:                if (card->status_buf_read == card->status_buf_write)
./drivers/isdn/act2000/module.c:		put_user(*card->status_buf_read++, p);
./drivers/isdn/act2000/module.c:                if (card->status_buf_read > card->status_buf_end)
./drivers/isdn/act2000/module.c:                        card->status_buf_read = card->status_buf;
./drivers/isdn/act2000/module.c:                if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:                if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c:                if (!(card->flags & ACT2000_FLAGS_RUNNING))
./drivers/isdn/act2000/module.c: * Allocate a new card-struct, initialize it
./drivers/isdn/act2000/module.c:		       "act2000: (%s) Could not allocate card-struct.\n", id);
./drivers/isdn/act2000/module.c:        spin_lock_init(&card->lock);
./drivers/isdn/act2000/module.c:        spin_lock_init(&card->mnlock);
./drivers/isdn/act2000/module.c:	skb_queue_head_init(&card->sndq);
./drivers/isdn/act2000/module.c:	skb_queue_head_init(&card->rcvq);
./drivers/isdn/act2000/module.c:	skb_queue_head_init(&card->ackq);
./drivers/isdn/act2000/module.c:	INIT_WORK(&card->snd_tq, act2000_transmit);
./drivers/isdn/act2000/module.c:	INIT_WORK(&card->rcv_tq, actcapi_dispatch);
./drivers/isdn/act2000/module.c:	INIT_WORK(&card->poll_tq, act2000_receive);
./drivers/isdn/act2000/module.c:	init_timer(&card->ptimer);
./drivers/isdn/act2000/module.c:	card->interface.owner = THIS_MODULE;
./drivers/isdn/act2000/module.c:        card->interface.channels = ACT2000_BCH;
./drivers/isdn/act2000/module.c:        card->interface.maxbufsize = 4000;
./drivers/isdn/act2000/module.c:        card->interface.command = if_command;
./drivers/isdn/act2000/module.c:        card->interface.writebuf_skb = if_sendbuf;
./drivers/isdn/act2000/module.c:        card->interface.writecmd = if_writecmd;
./drivers/isdn/act2000/module.c:        card->interface.readstat = if_readstatus;
./drivers/isdn/act2000/module.c:        card->interface.features =
./drivers/isdn/act2000/module.c:        card->interface.hl_hdrlen = 20;
./drivers/isdn/act2000/module.c:        card->ptype = ISDN_PTYPE_EURO;
./drivers/isdn/act2000/module.c:        strlcpy(card->interface.id, id, sizeof(card->interface.id));
./drivers/isdn/act2000/module.c:                card->bch[i].plci = 0x8000;
./drivers/isdn/act2000/module.c:                card->bch[i].ncci = 0x8000;
./drivers/isdn/act2000/module.c:                card->bch[i].l2prot = ISDN_PROTO_L2_X75I;
./drivers/isdn/act2000/module.c:                card->bch[i].l3prot = ISDN_PROTO_L3_TRANS;
./drivers/isdn/act2000/module.c:        card->myid = -1;
./drivers/isdn/act2000/module.c:        card->bus = bus;
./drivers/isdn/act2000/module.c:        card->port = port;
./drivers/isdn/act2000/module.c:        card->irq = irq;
./drivers/isdn/act2000/module.c:        card->next = cards;
./drivers/isdn/act2000/module.c:        switch (card->bus) {
./drivers/isdn/act2000/module.c:			       card->bus);
./drivers/isdn/act2000/module.c:        if (!register_isdn(&card->interface)) {
./drivers/isdn/act2000/module.c:                       card->interface.id);
./drivers/isdn/act2000/module.c:        card->myid = card->interface.channels;
./drivers/isdn/act2000/module.c:        sprintf(card->regname, "act2000-isdn (%s)", card->interface.id);
./drivers/isdn/act2000/module.c:        cmd.driver = card->myid;
./drivers/isdn/act2000/module.c:        card->interface.statcallb(&cmd);
./drivers/isdn/act2000/module.c:        switch (card->bus) {
./drivers/isdn/act2000/module.c:			       card->bus);
./drivers/isdn/act2000/module.c:		del_timer(&card->ptimer);
./drivers/isdn/act2000/module.c:                card = card->next;
./drivers/isdn/act2000/module.c:                card = card->next;
./drivers/isdn/act2000/act2000_isa.c:		printk(KERN_DEBUG "act2000: ?IRQ %d %02x\n", card->irq, istatus);
./drivers/isdn/act2000/act2000_isa.c:	switch (card->irq) {
./drivers/isdn/act2000/act2000_isa.c:        if (card->flags & ACT2000_FLAGS_IVALID) {
./drivers/isdn/act2000/act2000_isa.c:                free_irq(card->irq, card);
./drivers/isdn/act2000/act2000_isa.c:        card->flags &= ~ACT2000_FLAGS_IVALID;
./drivers/isdn/act2000/act2000_isa.c:	old_irq = card->irq;
./drivers/isdn/act2000/act2000_isa.c:	card->irq = irq;
./drivers/isdn/act2000/act2000_isa.c:	if (request_irq(irq, &act2000_isa_interrupt, 0, card->regname, card)) {
./drivers/isdn/act2000/act2000_isa.c:		card->irq = old_irq;
./drivers/isdn/act2000/act2000_isa.c:		card->flags |= ACT2000_FLAGS_IVALID;
./drivers/isdn/act2000/act2000_isa.c:        if (card->flags & ACT2000_FLAGS_PVALID) {
./drivers/isdn/act2000/act2000_isa.c:                release_region(card->port, ISA_REGION);
./drivers/isdn/act2000/act2000_isa.c:                card->flags &= ~ACT2000_FLAGS_PVALID;
./drivers/isdn/act2000/act2000_isa.c:	if (request_region(portbase, ACT2000_PORTLEN, card->regname) == NULL)
./drivers/isdn/act2000/act2000_isa.c:                card->port = portbase;
./drivers/isdn/act2000/act2000_isa.c:                card->flags |= ACT2000_FLAGS_PVALID;
./drivers/isdn/act2000/act2000_isa.c:        spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/act2000_isa.c:        if (card->flags & ACT2000_FLAGS_IVALID)
./drivers/isdn/act2000/act2000_isa.c:                free_irq(card->irq, card);
./drivers/isdn/act2000/act2000_isa.c:        card->flags &= ~ACT2000_FLAGS_IVALID;
./drivers/isdn/act2000/act2000_isa.c:        if (card->flags & ACT2000_FLAGS_PVALID)
./drivers/isdn/act2000/act2000_isa.c:                release_region(card->port, ISA_REGION);
./drivers/isdn/act2000/act2000_isa.c:        card->flags &= ~ACT2000_FLAGS_PVALID;
./drivers/isdn/act2000/act2000_isa.c:        spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/act2000_isa.c:        if (test_and_set_bit(ACT2000_LOCK_RX, (void *) &card->ilock) != 0)
./drivers/isdn/act2000/act2000_isa.c:		if (card->idat.isa.rcvidx < 8) {
./drivers/isdn/act2000/act2000_isa.c:                        card->idat.isa.rcvhdr[card->idat.isa.rcvidx++] = c;
./drivers/isdn/act2000/act2000_isa.c:			if (card->idat.isa.rcvidx == 8) {
./drivers/isdn/act2000/act2000_isa.c:				int valid = actcapi_chkhdr(card, (actcapi_msghdr *)&card->idat.isa.rcvhdr);
./drivers/isdn/act2000/act2000_isa.c:					card->idat.isa.rcvlen = ((actcapi_msghdr *)&card->idat.isa.rcvhdr)->len;
./drivers/isdn/act2000/act2000_isa.c:					card->idat.isa.rcvskb = dev_alloc_skb(card->idat.isa.rcvlen);
./drivers/isdn/act2000/act2000_isa.c:					if (card->idat.isa.rcvskb == NULL) {
./drivers/isdn/act2000/act2000_isa.c:						card->idat.isa.rcvignore = 1;
./drivers/isdn/act2000/act2000_isa.c:						test_and_clear_bit(ACT2000_LOCK_RX, (void *) &card->ilock);
./drivers/isdn/act2000/act2000_isa.c:					memcpy(skb_put(card->idat.isa.rcvskb, 8), card->idat.isa.rcvhdr, 8);
./drivers/isdn/act2000/act2000_isa.c:					card->idat.isa.rcvptr = skb_put(card->idat.isa.rcvskb, card->idat.isa.rcvlen - 8);
./drivers/isdn/act2000/act2000_isa.c:					card->idat.isa.rcvidx = 0;
./drivers/isdn/act2000/act2000_isa.c:						for (i = 0, p = (__u8 *)&card->idat.isa.rcvhdr, t = tmp; i < 8; i++)
./drivers/isdn/act2000/act2000_isa.c:			if (!card->idat.isa.rcvignore)
./drivers/isdn/act2000/act2000_isa.c:				*card->idat.isa.rcvptr++ = c;
./drivers/isdn/act2000/act2000_isa.c:			if (++card->idat.isa.rcvidx >= card->idat.isa.rcvlen) {
./drivers/isdn/act2000/act2000_isa.c:				if (!card->idat.isa.rcvignore) {
./drivers/isdn/act2000/act2000_isa.c:					skb_queue_tail(&card->rcvq, card->idat.isa.rcvskb);
./drivers/isdn/act2000/act2000_isa.c:				card->idat.isa.rcvidx = 0;
./drivers/isdn/act2000/act2000_isa.c:				card->idat.isa.rcvlen = 8;
./drivers/isdn/act2000/act2000_isa.c:				card->idat.isa.rcvignore = 0;
./drivers/isdn/act2000/act2000_isa.c:				card->idat.isa.rcvskb = NULL;
./drivers/isdn/act2000/act2000_isa.c:				card->idat.isa.rcvptr = card->idat.isa.rcvhdr;
./drivers/isdn/act2000/act2000_isa.c:	if (!(card->flags & ACT2000_FLAGS_IVALID)) {
./drivers/isdn/act2000/act2000_isa.c:		if ((card->idat.isa.rcvidx) &&
./drivers/isdn/act2000/act2000_isa.c:		    (card->idat.isa.rcvignore ||
./drivers/isdn/act2000/act2000_isa.c:		     (card->idat.isa.rcvidx < card->idat.isa.rcvlen)))
./drivers/isdn/act2000/act2000_isa.c:	test_and_clear_bit(ACT2000_LOCK_RX, (void *) &card->ilock);
./drivers/isdn/act2000/act2000_isa.c:        if (test_and_set_bit(ACT2000_LOCK_TX, (void *) &card->ilock) != 0)
./drivers/isdn/act2000/act2000_isa.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/act2000/act2000_isa.c:		if (!(card->sbuf)) {
./drivers/isdn/act2000/act2000_isa.c:			if ((card->sbuf = skb_dequeue(&card->sndq))) {
./drivers/isdn/act2000/act2000_isa.c:				card->ack_msg = card->sbuf->data;
./drivers/isdn/act2000/act2000_isa.c:				msg = (actcapi_msg *)card->sbuf->data;
./drivers/isdn/act2000/act2000_isa.c:					card->need_b3ack = msg->msg.data_b3_req.flags;
./drivers/isdn/act2000/act2000_isa.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/act2000/act2000_isa.c:		if (!(card->sbuf)) {
./drivers/isdn/act2000/act2000_isa.c:			test_and_clear_bit(ACT2000_LOCK_TX, (void *) &card->ilock);
./drivers/isdn/act2000/act2000_isa.c:		skb = card->sbuf;
./drivers/isdn/act2000/act2000_isa.c:				test_and_clear_bit(ACT2000_LOCK_TX, (void *) &card->ilock);
./drivers/isdn/act2000/act2000_isa.c:		msg = (actcapi_msg *)card->ack_msg;
./drivers/isdn/act2000/act2000_isa.c:			skb->data = card->ack_msg;
./drivers/isdn/act2000/act2000_isa.c:			msg->msg.data_b3_req.flags = card->need_b3ack;
./drivers/isdn/act2000/act2000_isa.c:			skb_queue_tail(&card->ackq, skb);
./drivers/isdn/act2000/act2000_isa.c:		card->sbuf = NULL;
./drivers/isdn/act2000/act2000_isa.c:	if (card->flags & ACT2000_FLAGS_IVALID) {
./drivers/isdn/act2000/act2000_isa.c:        if (!act2000_isa_reset(card->port))
./drivers/isdn/hardware/eicon/capifunc.c:		if (ControllerMap[card->Id] == controller) {
./drivers/isdn/hardware/eicon/capifunc.c:			if (card->remove_in_progress)
./drivers/isdn/hardware/eicon/capifunc.c:	capi_ctr_handle_message(&card->capi_ctrl, appl->Id, dmb);
./drivers/isdn/hardware/eicon/capifunc.c:		if (card->d.request == d->request) {
./drivers/isdn/hardware/eicon/capifunc.c:			card->remove_in_progress = 1;
./drivers/isdn/hardware/eicon/capifunc.c:		detach_capi_ctr(&card->capi_ctrl);
./drivers/isdn/hardware/eicon/capifunc.c:		clean_adapter(card->Id - 1, &free_mem_q);
./drivers/isdn/hardware/eicon/capifunc.c:				ControllerMap[card->Id], card->Id))
./drivers/isdn/hardware/eicon/capifunc.c:				ControllerMap[card->Id] = 0;
./drivers/isdn/hardware/eicon/capifunc.c:		d.request = card->d.request;
./drivers/isdn/hardware/eicon/capifunc.c:	memcpy(&card->d, d, sizeof(DESCRIPTOR));
./drivers/isdn/hardware/eicon/capifunc.c:	card->d.request((ENTITY *) & sync_req);
./drivers/isdn/hardware/eicon/capifunc.c:	strlcpy(card->name, sync_req.GetName.name, sizeof(card->name));
./drivers/isdn/hardware/eicon/capifunc.c:	ctrl = &card->capi_ctrl;
./drivers/isdn/hardware/eicon/capifunc.c:	strcpy(ctrl->name, card->name);
./drivers/isdn/hardware/eicon/capifunc.c:	card->Id = find_free_id();
./drivers/isdn/hardware/eicon/capifunc.c:	card->d.request((ENTITY *) & sync_req);
./drivers/isdn/hardware/eicon/capifunc.c:	a = &adapter[card->Id - 1];
./drivers/isdn/hardware/eicon/capifunc.c:	card->adapter = a;
./drivers/isdn/hardware/eicon/capifunc.c:	ControllerMap[card->Id] = (byte) (ctrl->cnr);
./drivers/isdn/hardware/eicon/capifunc.c:	DBG_TRC(("AddAdapterMap (%d) -> (%d)", ctrl->cnr, card->Id))
./drivers/isdn/hardware/eicon/capifunc.c:	card->d.request((ENTITY *) & sync_req);
./drivers/isdn/hardware/eicon/capifunc.c:	a->request = DIRequest;	/* card->d.request; */
./drivers/isdn/hardware/eicon/capifunc.c:	a->max_plci = card->d.channels + 30;
./drivers/isdn/hardware/eicon/capifunc.c:	a->max_listen = (card->d.channels > 2) ? 8 : 2;
./drivers/isdn/hardware/eicon/capifunc.c:		a->Id = (byte) card->Id;
./drivers/isdn/hardware/eicon/capifunc.c:		a->plci[k].Sig.user[0] = (word) (card->Id - 1);
./drivers/isdn/hardware/eicon/capifunc.c:		a->plci[k].NL.user[0] = (word) ((card->Id - 1) | 0x8000);
./drivers/isdn/hardware/eicon/capifunc.c:	a->profile.Number = card->Id;
./drivers/isdn/hardware/eicon/capifunc.c:	a->profile.Channels = card->d.channels;
./drivers/isdn/hardware/eicon/capifunc.c:	if (card->d.features & DI_FAX3) {
./drivers/isdn/hardware/eicon/capifunc.c:		if (card->d.features & DI_CODEC)
./drivers/isdn/hardware/eicon/capifunc.c:		if (card->d.features & DI_CODEC)
./drivers/isdn/hardware/eicon/capifunc.c:	for (i = card->Id; i < max_adapter; i++) {
./drivers/isdn/hardware/eicon/capifunc.c:	list_add(&(card->list), &cards);
./drivers/isdn/hardware/eicon/capifunc.c:	PUT_WORD(&ctrl->profile.nbchannel, card->d.channels);
./drivers/isdn/hardware/eicon/capifunc.c:	if (card->remove_in_progress) {
./drivers/isdn/hardware/eicon/capifunc.c:	msg->header.controller = ControllerMap[card->Id]
./drivers/isdn/hardware/eicon/capifunc.c:	(*(os_card->d.request)) (e);
./drivers/isdn/hardware/eicon/capimain.c:	seq_printf(m, "Id         : %d\n", card->Id);
./drivers/isdn/hardware/eicon/capimain.c:	seq_printf(m, "Channels   : %d\n", card->d.channels);
./drivers/isdn/hardware/eicon/idifunc.c:		if (card->d.request == d->request) {
./drivers/isdn/hardware/eicon/idifunc.c:	memcpy(&card->d, d, sizeof(DESCRIPTOR));
./drivers/isdn/hardware/eicon/idifunc.c:	card->d.request((ENTITY *) & sync_req);
./drivers/isdn/hardware/eicon/idifunc.c:	card->Id = adapter_nr;
./drivers/isdn/hardware/eicon/idifunc.c:		list_add_tail(&card->list, &cards);
./drivers/isdn/hardware/eicon/idifunc.c:	diva_user_mode_idi_remove_adapter(card->Id);
./drivers/isdn/hardware/eicon/idifunc.c:	list_del(&card->list);
./drivers/isdn/hardware/eicon/idifunc.c:	DBG_LOG(("idi proc entry removed for card %d", card->Id));
./drivers/isdn/hardware/eicon/idifunc.c:		list_del(&card->list);
./drivers/isdn/hardware/eicon/idifunc.c:		diva_user_mode_idi_remove_adapter(card->Id);
./drivers/isdn/hardware/eicon/diva.c:	card--;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isac.dch.debug = debug;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.ch[0].bch.debug = debug;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.ch[1].bch.debug = debug;
./drivers/isdn/hardware/mISDN/speedfax.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/speedfax.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isac.release(&card->isac);
./drivers/isdn/hardware/mISDN/speedfax.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.release(&card->isar);
./drivers/isdn/hardware/mISDN/speedfax.c:	mISDN_unregister_device(&card->isac.dch.dev);
./drivers/isdn/hardware/mISDN/speedfax.c:	release_region(card->cfg, 256);
./drivers/isdn/hardware/mISDN/speedfax.c:	pci_disable_device(card->pdev);
./drivers/isdn/hardware/mISDN/speedfax.c:	pci_set_drvdata(card->pdev, NULL);
./drivers/isdn/hardware/mISDN/speedfax.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/speedfax.c:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "Speedfax.%d", sfax_cnt + 1);
./drivers/isdn/hardware/mISDN/speedfax.c:	list_add_tail(&card->list, &Cards);
./drivers/isdn/hardware/mISDN/speedfax.c:	spin_lock_init(&card->lock);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isac.hwlock = &card->lock;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.hwlock = &card->lock;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.ctrl = (void *)&sfax_ctrl;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isac.name = card->name;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.name = card->name;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.owner = THIS_MODULE;
./drivers/isdn/hardware/mISDN/speedfax.c:	err = request_firmware(&firmware, "isdn/ISAR.BIN", &card->pdev->dev);
./drivers/isdn/hardware/mISDN/speedfax.c:			card->name, err);
./drivers/isdn/hardware/mISDN/speedfax.c:			card->name, firmware->size);
./drivers/isdn/hardware/mISDN/speedfax.c:	mISDNisac_init(&card->isac, card);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isac.dch.dev.D.ctrl = sfax_dctrl;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isac.dch.dev.Bprotocols =
./drivers/isdn/hardware/mISDN/speedfax.c:		mISDNisar_init(&card->isar, card);
./drivers/isdn/hardware/mISDN/speedfax.c:		set_channelmap(i + 1, card->isac.dch.dev.channelmap);
./drivers/isdn/hardware/mISDN/speedfax.c:		list_add(&card->isar.ch[i].bch.ch.list,
./drivers/isdn/hardware/mISDN/speedfax.c:			&card->isac.dch.dev.bchannels);
./drivers/isdn/hardware/mISDN/speedfax.c:	err = card->isar.init(&card->isar);
./drivers/isdn/hardware/mISDN/speedfax.c:	err = mISDN_register_device(&card->isac.dch.dev,
./drivers/isdn/hardware/mISDN/speedfax.c:		&card->pdev->dev, card->name);
./drivers/isdn/hardware/mISDN/speedfax.c:	err = card->isar.firmware(&card->isar, firmware->data, firmware->size);
./drivers/isdn/hardware/mISDN/speedfax.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/speedfax.c:	mISDN_unregister_device(&card->isac.dch.dev);
./drivers/isdn/hardware/mISDN/speedfax.c:	release_region(card->cfg, 256);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isac.release(&card->isac);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->isar.release(&card->isar);
./drivers/isdn/hardware/mISDN/speedfax.c:	pci_disable_device(card->pdev);
./drivers/isdn/hardware/mISDN/speedfax.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->pdev = pdev;
./drivers/isdn/hardware/mISDN/speedfax.c:	card->cfg = pci_resource_start(pdev, 0);
./drivers/isdn/hardware/mISDN/speedfax.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.debug = debug;
./drivers/isdn/hardware/mISDN/w6692.c:	card->bc[0].bch.debug = debug;
./drivers/isdn/hardware/mISDN/w6692.c:	card->bc[1].bch.debug = debug;
./drivers/isdn/hardware/mISDN/w6692.c:	return inb(card->addr + offset);
./drivers/isdn/hardware/mISDN/w6692.c:	outb(value, card->addr + offset);
./drivers/isdn/hardware/mISDN/w6692.c:	WriteW6692(card, W_IMASK, card->imask);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_notice("%s: Winbond W6692 version: %s\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:	if ((!(card->fmask & led)) || card->subtype == W6692_USR)
./drivers/isdn/hardware/mISDN/w6692.c:		card->xdata &= 0xfb;	/*  LED ON */
./drivers/isdn/hardware/mISDN/w6692.c:		WriteW6692(card, W_XDATA, card->xdata);
./drivers/isdn/hardware/mISDN/w6692.c:		card->xdata |= 0x04;	/*  LED OFF */
./drivers/isdn/hardware/mISDN/w6692.c:		WriteW6692(card, W_XDATA, card->xdata);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: ph_command %x\n", card->name, cmd);
./drivers/isdn/hardware/mISDN/w6692.c:	if (card->state == W_L1CMD_RST)
./drivers/isdn/hardware/mISDN/w6692.c:	schedule_event(&card->dch, FLG_PHCHANGE);
./drivers/isdn/hardware/mISDN/w6692.c:	switch (card->state) {
./drivers/isdn/hardware/mISDN/w6692.c:			card->name, card->state, dch->state);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: TE newstate %02x\n", card->name, dch->state);
./drivers/isdn/hardware/mISDN/w6692.c:	struct dchannel *dch = &card->dch;
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: empty_Dfifo %d\n", card->name, count);
./drivers/isdn/hardware/mISDN/w6692.c:		dch->rx_skb = mI_alloc_skb(card->dch.maxlen, GFP_ATOMIC);
./drivers/isdn/hardware/mISDN/w6692.c:			pr_info("%s: D receive out of memory\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: empty_Dfifo overrun %d\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:	insb(card->addr + W_D_RFIFO, ptr, count);
./drivers/isdn/hardware/mISDN/w6692.c:		snprintf(card->log, 63, "D-recv %s %d ",
./drivers/isdn/hardware/mISDN/w6692.c:			card->name, count);
./drivers/isdn/hardware/mISDN/w6692.c:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./drivers/isdn/hardware/mISDN/w6692.c:	struct dchannel *dch = &card->dch;
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: fill_Dfifo\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:	outsb(card->addr + W_D_XFIFO, ptr, count);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: fill_Dfifo dbusytimer running\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		snprintf(card->log, 63, "D-send %s %d ",
./drivers/isdn/hardware/mISDN/w6692.c:			card->name, count);
./drivers/isdn/hardware/mISDN/w6692.c:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./drivers/isdn/hardware/mISDN/w6692.c:	struct dchannel *dch = &card->dch;
./drivers/isdn/hardware/mISDN/w6692.c:		pr_info("%s: %s without TX_BUSY\n", card->name, __func__);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_info("%s: XDU no TX_BUSY\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: D-channel RDOV\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:			card->dch.err_rx++;
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: D-channel CRC error\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:			card->dch.err_crc++;
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: D-channel ABORT\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:			card->dch.err_rx++;
./drivers/isdn/hardware/mISDN/w6692.c:		if (card->dch.rx_skb)
./drivers/isdn/hardware/mISDN/w6692.c:			dev_kfree_skb(card->dch.rx_skb);
./drivers/isdn/hardware/mISDN/w6692.c:		card->dch.rx_skb = NULL;
./drivers/isdn/hardware/mISDN/w6692.c:		recv_Dchannel(&card->dch);
./drivers/isdn/hardware/mISDN/w6692.c:	if (test_and_clear_bit(FLG_BUSY_TIMER, &card->dch.Flags))
./drivers/isdn/hardware/mISDN/w6692.c:		del_timer(&card->dch.timer);
./drivers/isdn/hardware/mISDN/w6692.c:	if (card->dch.tx_skb && card->dch.tx_idx < card->dch.tx_skb->len) {
./drivers/isdn/hardware/mISDN/w6692.c:		if (card->dch.tx_skb)
./drivers/isdn/hardware/mISDN/w6692.c:			dev_kfree_skb(card->dch.tx_skb);
./drivers/isdn/hardware/mISDN/w6692.c:		if (get_next_dframe(&card->dch))
./drivers/isdn/hardware/mISDN/w6692.c:	struct dchannel *dch = &card->dch;
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: D_EXIR %02x\n", card->name, exval);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: D-channel underrun/collision\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: D-channel RDOV\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: spurious TIN2 interrupt\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:			card->name, v1);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: ISC CIR %02X\n", card->name, cir);
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: ph_state_change %x -> %x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:			card->state = v1;
./drivers/isdn/hardware/mISDN/w6692.c:			if (card->fmask & led) {
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: SCC SQR %02X\n", card->name, v1);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: spurious WEXP interrupt!\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: spurious TEXP interrupt!\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: empty_Bfifo %d\n", card->name, count);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: empty_Bfifo ISDN_P_NONE\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:			pr_info("%s: B receive out of memory\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:			card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		snprintf(card->log, 63, "B%1d-recv %s %d ",
./drivers/isdn/hardware/mISDN/w6692.c:			wch->bch.nr, card->name, count);
./drivers/isdn/hardware/mISDN/w6692.c:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: fill Bfifo\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: fill Bfifo%d/%d\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:		snprintf(card->log, 63, "B%1d-send %s %d ",
./drivers/isdn/hardware/mISDN/w6692.c:			wch->bch.nr, card->name, count);
./drivers/isdn/hardware/mISDN/w6692.c:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, ptr, count);
./drivers/isdn/hardware/mISDN/w6692.c:	if ((!(card->fmask & pots)) ||
./drivers/isdn/hardware/mISDN/w6692.c:		card->xaddr &= 0xc7;
./drivers/isdn/hardware/mISDN/w6692.c:		card->xaddr &= 0xf8;
./drivers/isdn/hardware/mISDN/w6692.c:	card->xaddr |= val;
./drivers/isdn/hardware/mISDN/w6692.c:	WriteW6692(card, W_XADDR, card->xaddr);
./drivers/isdn/hardware/mISDN/w6692.c:	if ((!(card->fmask & pots)) ||
./drivers/isdn/hardware/mISDN/w6692.c:	card->pctl |= ((wch->bch.nr & 2) ? W_PCTL_PCX : 0);
./drivers/isdn/hardware/mISDN/w6692.c:	WriteW6692(card, W_PCTL, card->pctl);
./drivers/isdn/hardware/mISDN/w6692.c:	if (!(card->fmask & pots))
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: B%d protocol %x-->%x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:		if ((card->fmask & pots) && (wch->b_mode & W_B_MODE_EPCM))
./drivers/isdn/hardware/mISDN/w6692.c:		pr_info("%s: protocol %x not known\n", card->name, pr);
./drivers/isdn/hardware/mISDN/w6692.c:	struct w6692_ch	*wch = &card->bc[ch];
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: B%d EXIR %02x\n", card->name, wch->bch.nr, stat);
./drivers/isdn/hardware/mISDN/w6692.c:				pr_debug("%s: B%d RDOV proto=%x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:						card->name, wch->bch.nr);
./drivers/isdn/hardware/mISDN/w6692.c:						card->name, wch->bch.nr);
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: B%d RDOV proto=%x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: B%d RDOV IRQ proto=%x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: B%d star %02x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:			pr_debug("%s: B%d XDOW proto=%x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: B%d XDUN proto=%x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:	spin_lock(&card->lock);
./drivers/isdn/hardware/mISDN/w6692.c:	if ((ista | card->imask) == card->imask) {
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock(&card->lock);
./drivers/isdn/hardware/mISDN/w6692.c:	card->irqcnt++;
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: ista %02x\n", card->name, ista);
./drivers/isdn/hardware/mISDN/w6692.c:	ista &= ~card->imask;
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: W6692 spurious XINT!\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:	spin_unlock(&card->lock);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			card->name, rbch, star);
./drivers/isdn/hardware/mISDN/w6692.c:					card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.timer.function = (void *)dbusy_timer_handler;
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.timer.data = (u_long)&card->dch;
./drivers/isdn/hardware/mISDN/w6692.c:	init_timer(&card->dch.timer);
./drivers/isdn/hardware/mISDN/w6692.c:	w6692_mode(&card->bc[0], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/w6692.c:	w6692_mode(&card->bc[1], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/w6692.c:	card->state = W_L1CMD_RST;
./drivers/isdn/hardware/mISDN/w6692.c:	card->imask = 0x18;
./drivers/isdn/hardware/mISDN/w6692.c:	WriteW6692B(&card->bc[0], W_B_EXIM, 0);
./drivers/isdn/hardware/mISDN/w6692.c:	WriteW6692B(&card->bc[1], W_B_EXIM, 0);
./drivers/isdn/hardware/mISDN/w6692.c:	WriteW6692B(&card->bc[0], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);
./drivers/isdn/hardware/mISDN/w6692.c:	WriteW6692B(&card->bc[1], W_B_CMDR, W_B_CMDR_RRST | W_B_CMDR_XRST);
./drivers/isdn/hardware/mISDN/w6692.c:	if (card->subtype == W6692_USR) {
./drivers/isdn/hardware/mISDN/w6692.c:		card->pctl = 0x80;
./drivers/isdn/hardware/mISDN/w6692.c:		card->xdata = 0;
./drivers/isdn/hardware/mISDN/w6692.c:		WriteW6692(card, W_PCTL, card->pctl);
./drivers/isdn/hardware/mISDN/w6692.c:		WriteW6692(card, W_XDATA, card->xdata);
./drivers/isdn/hardware/mISDN/w6692.c:		card->pctl = W_PCTL_OE5 | W_PCTL_OE4 | W_PCTL_OE2 |
./drivers/isdn/hardware/mISDN/w6692.c:		card->xaddr = 0x00;/* all sw off */
./drivers/isdn/hardware/mISDN/w6692.c:		if (card->fmask & pots)
./drivers/isdn/hardware/mISDN/w6692.c:			card->xdata |= 0x06;	/*  POWER UP/ LED OFF / ALAW */
./drivers/isdn/hardware/mISDN/w6692.c:		if (card->fmask & led)
./drivers/isdn/hardware/mISDN/w6692.c:			card->xdata |= 0x04;	/* LED OFF */
./drivers/isdn/hardware/mISDN/w6692.c:		if ((card->fmask & pots) || (card->fmask & led)) {
./drivers/isdn/hardware/mISDN/w6692.c:			WriteW6692(card, W_PCTL, card->pctl);
./drivers/isdn/hardware/mISDN/w6692.c:			WriteW6692(card, W_XADDR, card->xaddr);
./drivers/isdn/hardware/mISDN/w6692.c:			WriteW6692(card, W_XDATA, card->xdata);
./drivers/isdn/hardware/mISDN/w6692.c:					card->name, val);
./drivers/isdn/hardware/mISDN/w6692.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:	if (request_irq(card->irq, w6692_irq, IRQF_SHARED, card->name, card)) {
./drivers/isdn/hardware/mISDN/w6692.c:		pr_info("%s: couldn't get interrupt %d\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:			card->irq);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			pr_notice("%s: IRQ %d count %d\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:				card->irq, card->irqcnt);
./drivers/isdn/hardware/mISDN/w6692.c:		if (!card->irqcnt) {
./drivers/isdn/hardware/mISDN/w6692.c:				card->name, card->irq, 3 - cnt);
./drivers/isdn/hardware/mISDN/w6692.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			card->name, __func__, hh->prim, hh->id);
./drivers/isdn/hardware/mISDN/w6692.c:	bch = &card->bc[rq->adr.channel - 1].bch;
./drivers/isdn/hardware/mISDN/w6692.c:		pr_info("%s: unknown CTRL OP %x\n", card->name, cq->op);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);
./drivers/isdn/hardware/mISDN/w6692.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			card->name, __func__, cmd);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: cmd(%x) state(%02x)\n", card->name, cmd, card->state);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		if (card->state != W_L1IND_DRD)
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: %s unknown command %x\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: %s dev(%d) open from %p\n", card->name, __func__,
./drivers/isdn/hardware/mISDN/w6692.c:		card->dch.dev.id, __builtin_return_address(1));
./drivers/isdn/hardware/mISDN/w6692.c:	rq->ch = &card->dch.dev.D;
./drivers/isdn/hardware/mISDN/w6692.c:	if (card->dch.state == 7)
./drivers/isdn/hardware/mISDN/w6692.c:	pr_debug("%s: DCTRL: %x %p\n", card->name, cmd, arg);
./drivers/isdn/hardware/mISDN/w6692.c:			pr_info("%s: cannot get module\n", card->name);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: dev(%d) close from %p\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:		pr_debug("%s: unknown DCTRL command %x\n", card->name, cmd);
./drivers/isdn/hardware/mISDN/w6692.c:	if (!request_region(card->addr, 256, card->name)) {
./drivers/isdn/hardware/mISDN/w6692.c:		pr_info("%s: config port %x-%x already in use\n", card->name,
./drivers/isdn/hardware/mISDN/w6692.c:		       card->addr, card->addr + 255);
./drivers/isdn/hardware/mISDN/w6692.c:	card->bc[0].addr = card->addr;
./drivers/isdn/hardware/mISDN/w6692.c:	card->bc[1].addr = card->addr + 0x40;
./drivers/isdn/hardware/mISDN/w6692.c:		pr_notice("%s ISTA=%02x\n", card->name, val);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_notice("%s IMASK=%02x\n", card->name, val);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_notice("%s D_EXIR=%02x\n", card->name, val);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_notice("%s D_EXIM=%02x\n", card->name, val);
./drivers/isdn/hardware/mISDN/w6692.c:		pr_notice("%s D_RSTA=%02x\n", card->name, val);
./drivers/isdn/hardware/mISDN/w6692.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:	w6692_mode(&card->bc[0], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/w6692.c:	w6692_mode(&card->bc[1], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/w6692.c:	if ((card->fmask & led) || card->subtype == W6692_USR) {
./drivers/isdn/hardware/mISDN/w6692.c:		card->xdata |= 0x04;	/*  LED OFF */
./drivers/isdn/hardware/mISDN/w6692.c:		WriteW6692(card, W_XDATA, card->xdata);
./drivers/isdn/hardware/mISDN/w6692.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/w6692.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/w6692.c:	l1_event(card->dch.l1, CLOSE_CHANNEL);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_unregister_device(&card->dch.dev);
./drivers/isdn/hardware/mISDN/w6692.c:	release_region(card->addr, 256);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_freebchannel(&card->bc[1].bch);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_freebchannel(&card->bc[0].bch);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_freedchannel(&card->dch);
./drivers/isdn/hardware/mISDN/w6692.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/w6692.c:	pci_disable_device(card->pdev);
./drivers/isdn/hardware/mISDN/w6692.c:	pci_set_drvdata(card->pdev, NULL);
./drivers/isdn/hardware/mISDN/w6692.c:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "w6692.%d", w6692_cnt + 1);
./drivers/isdn/hardware/mISDN/w6692.c:	list_add_tail(&card->list, &Cards);
./drivers/isdn/hardware/mISDN/w6692.c:	card->fmask = (1 << w6692_cnt);
./drivers/isdn/hardware/mISDN/w6692.c:	spin_lock_init(&card->lock);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, W6692_ph_bh);
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0);
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.dev.D.send = w6692_l2l1D;
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.dev.D.ctrl = w6692_dctrl;
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.hw = card;
./drivers/isdn/hardware/mISDN/w6692.c:	card->dch.dev.nrbchan = 2;
./drivers/isdn/hardware/mISDN/w6692.c:		mISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM);
./drivers/isdn/hardware/mISDN/w6692.c:		card->bc[i].bch.hw = card;
./drivers/isdn/hardware/mISDN/w6692.c:		card->bc[i].bch.nr = i + 1;
./drivers/isdn/hardware/mISDN/w6692.c:		card->bc[i].bch.ch.nr = i + 1;
./drivers/isdn/hardware/mISDN/w6692.c:		card->bc[i].bch.ch.send = w6692_l2l1B;
./drivers/isdn/hardware/mISDN/w6692.c:		card->bc[i].bch.ch.ctrl = w6692_bctrl;
./drivers/isdn/hardware/mISDN/w6692.c:		set_channelmap(i + 1, card->dch.dev.channelmap);
./drivers/isdn/hardware/mISDN/w6692.c:		list_add(&card->bc[i].bch.ch.list, &card->dch.dev.bchannels);
./drivers/isdn/hardware/mISDN/w6692.c:	err = mISDN_register_device(&card->dch.dev, &card->pdev->dev,
./drivers/isdn/hardware/mISDN/w6692.c:		card->name);
./drivers/isdn/hardware/mISDN/w6692.c:	err = create_l1(&card->dch, w6692_l1callback);
./drivers/isdn/hardware/mISDN/w6692.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_unregister_device(&card->dch.dev);
./drivers/isdn/hardware/mISDN/w6692.c:	release_region(card->addr, 256);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_freebchannel(&card->bc[1].bch);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_freebchannel(&card->bc[0].bch);
./drivers/isdn/hardware/mISDN/w6692.c:	mISDN_freedchannel(&card->dch);
./drivers/isdn/hardware/mISDN/w6692.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/w6692.c:	card->pdev = pdev;
./drivers/isdn/hardware/mISDN/w6692.c:	card->subtype = m->subtype;
./drivers/isdn/hardware/mISDN/w6692.c:	card->addr = pci_resource_start(pdev, 1);
./drivers/isdn/hardware/mISDN/w6692.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->isac.dch.debug = debug;
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->bch[0].debug = debug;
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->bch[1].debug = debug;
./drivers/isdn/hardware/mISDN/avmfritz.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/avmfritz.c:	modehdlc(&card->bch[0], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/avmfritz.c:	modehdlc(&card->bch[1], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/avmfritz.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->isac.release(&card->isac);
./drivers/isdn/hardware/mISDN/avmfritz.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/avmfritz.c:	mISDN_freebchannel(&card->bch[1]);
./drivers/isdn/hardware/mISDN/avmfritz.c:	mISDN_freebchannel(&card->bch[0]);
./drivers/isdn/hardware/mISDN/avmfritz.c:	mISDN_unregister_device(&card->isac.dch.dev);
./drivers/isdn/hardware/mISDN/avmfritz.c:	release_region(card->addr, 32);
./drivers/isdn/hardware/mISDN/avmfritz.c:	pci_disable_device(card->pdev);
./drivers/isdn/hardware/mISDN/avmfritz.c:	pci_set_drvdata(card->pdev, NULL);
./drivers/isdn/hardware/mISDN/avmfritz.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/avmfritz.c:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "AVM.%d", AVM_cnt + 1);
./drivers/isdn/hardware/mISDN/avmfritz.c:	list_add_tail(&card->list, &Cards);
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->isac.name = card->name;
./drivers/isdn/hardware/mISDN/avmfritz.c:	spin_lock_init(&card->lock);
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->isac.hwlock = &card->lock;
./drivers/isdn/hardware/mISDN/avmfritz.c:	mISDNisac_init(&card->isac, card);
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->isac.dch.dev.D.ctrl = avm_dctrl;
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->bch[i].nr = i + 1;
./drivers/isdn/hardware/mISDN/avmfritz.c:		set_channelmap(i + 1, card->isac.dch.dev.channelmap);
./drivers/isdn/hardware/mISDN/avmfritz.c:		mISDN_initbchannel(&card->bch[i], MAX_DATA_MEM);
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->bch[i].hw = card;
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->bch[i].ch.send = avm_l2l1B;
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->bch[i].ch.ctrl = avm_bctrl;
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->bch[i].ch.nr = i + 1;
./drivers/isdn/hardware/mISDN/avmfritz.c:		list_add(&card->bch[i].ch.list, &card->isac.dch.dev.bchannels);
./drivers/isdn/hardware/mISDN/avmfritz.c:	err = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->name);
./drivers/isdn/hardware/mISDN/avmfritz.c:	mISDN_unregister_device(&card->isac.dch.dev);
./drivers/isdn/hardware/mISDN/avmfritz.c:	release_region(card->addr, 32);
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->isac.release(&card->isac);
./drivers/isdn/hardware/mISDN/avmfritz.c:	mISDN_freebchannel(&card->bch[1]);
./drivers/isdn/hardware/mISDN/avmfritz.c:	mISDN_freebchannel(&card->bch[0]);
./drivers/isdn/hardware/mISDN/avmfritz.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->type = AVM_FRITZ_PCIV2;
./drivers/isdn/hardware/mISDN/avmfritz.c:		card->type = AVM_FRITZ_PCI;
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->pdev = pdev;
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->addr = pci_resource_start(pdev, 1);
./drivers/isdn/hardware/mISDN/avmfritz.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/mISDN/netjet.c:	card->isac.dch.debug = debug;
./drivers/isdn/hardware/mISDN/netjet.c:	card->bc[0].bch.debug = debug;
./drivers/isdn/hardware/mISDN/netjet.c:	card->bc[1].bch.debug = debug;
./drivers/isdn/hardware/mISDN/netjet.c:	outb(0, card->base + NJ_IRQMASK0);
./drivers/isdn/hardware/mISDN/netjet.c:	outb(0, card->base + NJ_IRQMASK1);
./drivers/isdn/hardware/mISDN/netjet.c:	card->auxd &= 0xfc;
./drivers/isdn/hardware/mISDN/netjet.c:	card->auxd |= (offset >> 4) & 3;
./drivers/isdn/hardware/mISDN/netjet.c:	outb(card->auxd, card->base + NJ_AUXDATA);
./drivers/isdn/hardware/mISDN/netjet.c:	ret = inb(card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));
./drivers/isdn/hardware/mISDN/netjet.c:	card->auxd &= 0xfc;
./drivers/isdn/hardware/mISDN/netjet.c:	card->auxd |= (offset >> 4) & 3;
./drivers/isdn/hardware/mISDN/netjet.c:	outb(card->auxd, card->base + NJ_AUXDATA);
./drivers/isdn/hardware/mISDN/netjet.c:	outb(value, card->base + NJ_ISAC_OFF + ((offset & 0x0f) << 2));
./drivers/isdn/hardware/mISDN/netjet.c:	card->auxd &= 0xfc;
./drivers/isdn/hardware/mISDN/netjet.c:	outb(card->auxd, card->base + NJ_AUXDATA);
./drivers/isdn/hardware/mISDN/netjet.c:	insb(card->base + NJ_ISAC_OFF, data, size);
./drivers/isdn/hardware/mISDN/netjet.c:	card->auxd &= 0xfc;
./drivers/isdn/hardware/mISDN/netjet.c:	outb(card->auxd, card->base + NJ_AUXDATA);
./drivers/isdn/hardware/mISDN/netjet.c:	outsb(card->base + NJ_ISAC_OFF, data, size);
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: B%1d fill %02x len %d idx %d/%d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		bc->bch.nr, fill, cnt, idx, card->send.idx);
./drivers/isdn/hardware/mISDN/netjet.c:		val = card->send.start[idx];
./drivers/isdn/hardware/mISDN/netjet.c:		card->send.start[idx++] = val;
./drivers/isdn/hardware/mISDN/netjet.c:		if (idx >= card->send.size)
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: B%1d protocol %x-->%x\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		fill_mem(bc, 0, card->send.size, 0xff);
./drivers/isdn/hardware/mISDN/netjet.c:		if ((card->bc[0].bch.state == ISDN_P_NONE) &&
./drivers/isdn/hardware/mISDN/netjet.c:		    (card->bc[1].bch.state == ISDN_P_NONE)) {
./drivers/isdn/hardware/mISDN/netjet.c:			card->dmactrl = 0;
./drivers/isdn/hardware/mISDN/netjet.c:			outb(card->dmactrl, card->base + NJ_DMACTRL);
./drivers/isdn/hardware/mISDN/netjet.c:			outb(0, card->base + NJ_IRQMASK0);
./drivers/isdn/hardware/mISDN/netjet.c:		bc->free = card->send.size/2;
./drivers/isdn/hardware/mISDN/netjet.c:		if (!card->dmactrl) {
./drivers/isdn/hardware/mISDN/netjet.c:			card->dmactrl = 1;
./drivers/isdn/hardware/mISDN/netjet.c:			outb(card->dmactrl, card->base + NJ_DMACTRL);
./drivers/isdn/hardware/mISDN/netjet.c:			outb(0x0f, card->base + NJ_IRQMASK0);
./drivers/isdn/hardware/mISDN/netjet.c:		bc->free = card->send.size/2;
./drivers/isdn/hardware/mISDN/netjet.c:		if (!card->dmactrl) {
./drivers/isdn/hardware/mISDN/netjet.c:			card->dmactrl = 1;
./drivers/isdn/hardware/mISDN/netjet.c:			outb(card->dmactrl, card->base + NJ_DMACTRL);
./drivers/isdn/hardware/mISDN/netjet.c:			outb(0x0f, card->base + NJ_IRQMASK0);
./drivers/isdn/hardware/mISDN/netjet.c:		pr_info("%s: %s protocol %x not handled\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.dmacur = inl(card->base + NJ_DMA_READ_ADR);
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.dmacur = inl(card->base + NJ_DMA_WRITE_ADR);
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;
./drivers/isdn/hardware/mISDN/netjet.c:		card->name, __func__,
./drivers/isdn/hardware/mISDN/netjet.c:		inb(card->base + NJ_DMACTRL),
./drivers/isdn/hardware/mISDN/netjet.c:		inb(card->base + NJ_IRQMASK0),
./drivers/isdn/hardware/mISDN/netjet.c:		inb(card->base + NJ_IRQSTAT0),
./drivers/isdn/hardware/mISDN/netjet.c:		card->send.idx,
./drivers/isdn/hardware/mISDN/netjet.c:		card->recv.idx);
./drivers/isdn/hardware/mISDN/netjet.c:	outb(0xff, card->base + NJ_CTRL); /* Reset On */
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->typ == NETJET_S_TJ320) /* TJ320 */
./drivers/isdn/hardware/mISDN/netjet.c:		card->ctrlreg = 0x40;  /* Reset Off and status read clear */
./drivers/isdn/hardware/mISDN/netjet.c:		card->ctrlreg = 0x00;  /* Reset Off and status read clear */
./drivers/isdn/hardware/mISDN/netjet.c:	outb(card->ctrlreg, card->base + NJ_CTRL);
./drivers/isdn/hardware/mISDN/netjet.c:	card->auxd = 0;
./drivers/isdn/hardware/mISDN/netjet.c:	card->dmactrl = 0;
./drivers/isdn/hardware/mISDN/netjet.c:	outb(~NJ_ISACIRQ, card->base + NJ_AUXCTRL);
./drivers/isdn/hardware/mISDN/netjet.c:	outb(NJ_ISACIRQ,  card->base + NJ_IRQMASK1);
./drivers/isdn/hardware/mISDN/netjet.c:	outb(card->auxd, card->base + NJ_AUXDATA);
./drivers/isdn/hardware/mISDN/netjet.c:	card->dma_p = pci_alloc_consistent(card->pdev, NJ_DMA_SIZE,
./drivers/isdn/hardware/mISDN/netjet.c:			&card->dma);
./drivers/isdn/hardware/mISDN/netjet.c:	if (!card->dma_p) {
./drivers/isdn/hardware/mISDN/netjet.c:		pr_info("%s: No DMA memory\n", card->name);
./drivers/isdn/hardware/mISDN/netjet.c:	if ((u64)card->dma > 0xffffffff) {
./drivers/isdn/hardware/mISDN/netjet.c:		pr_info("%s: DMA outside 32 bit\n", card->name);
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].hsbuf = kmalloc(NJ_DMA_TXSIZE, GFP_ATOMIC);
./drivers/isdn/hardware/mISDN/netjet.c:		if (!card->bc[i].hsbuf) {
./drivers/isdn/hardware/mISDN/netjet.c:			pr_info("%s: no B%d send buffer\n", card->name, i + 1);
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].hrbuf = kmalloc(NJ_DMA_RXSIZE, GFP_ATOMIC);
./drivers/isdn/hardware/mISDN/netjet.c:		if (!card->bc[i].hrbuf) {
./drivers/isdn/hardware/mISDN/netjet.c:			pr_info("%s: no B%d recv buffer\n", card->name, i + 1);
./drivers/isdn/hardware/mISDN/netjet.c:	memset(card->dma_p, 0xff, NJ_DMA_SIZE);
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.start = card->dma_p;
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.dmastart = (u32)card->dma;
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.dmaend = card->send.dmastart +
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.dmairq = card->send.dmastart +
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.size = NJ_DMA_TXSIZE;
./drivers/isdn/hardware/mISDN/netjet.c:			" size %zu u32\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:			card->send.dmastart, card->send.dmairq,
./drivers/isdn/hardware/mISDN/netjet.c:			card->send.dmaend, card->send.start, card->send.size);
./drivers/isdn/hardware/mISDN/netjet.c:	outl(card->send.dmastart, card->base + NJ_DMA_READ_START);
./drivers/isdn/hardware/mISDN/netjet.c:	outl(card->send.dmairq, card->base + NJ_DMA_READ_IRQ);
./drivers/isdn/hardware/mISDN/netjet.c:	outl(card->send.dmaend, card->base + NJ_DMA_READ_END);
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.start = card->dma_p + (NJ_DMA_SIZE / 2);
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.dmastart = (u32)card->dma  + (NJ_DMA_SIZE / 2);
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.dmaend = card->recv.dmastart +
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.dmairq = card->recv.dmastart +
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.size = NJ_DMA_RXSIZE;
./drivers/isdn/hardware/mISDN/netjet.c:			" size %zu u32\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:			card->recv.dmastart, card->recv.dmairq,
./drivers/isdn/hardware/mISDN/netjet.c:			card->recv.dmaend, card->recv.start, card->recv.size);
./drivers/isdn/hardware/mISDN/netjet.c:	outl(card->recv.dmastart, card->base + NJ_DMA_WRITE_START);
./drivers/isdn/hardware/mISDN/netjet.c:	outl(card->recv.dmairq, card->base + NJ_DMA_WRITE_IRQ);
./drivers/isdn/hardware/mISDN/netjet.c:	outl(card->recv.dmaend, card->base + NJ_DMA_WRITE_END);
./drivers/isdn/hardware/mISDN/netjet.c:		pr_info("%s: B%1d overrun at idx %d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:				card->name, bc->bch.nr);
./drivers/isdn/hardware/mISDN/netjet.c:			pr_debug("%s: B%1d overrun %d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		val = card->recv.start[idx++];
./drivers/isdn/hardware/mISDN/netjet.c:		if (idx >= card->recv.size)
./drivers/isdn/hardware/mISDN/netjet.c:				card->name, bc->bch.nr);
./drivers/isdn/hardware/mISDN/netjet.c:				card->name, bc->bch.nr);
./drivers/isdn/hardware/mISDN/netjet.c:				card->name, bc->bch.nr, bc->bch.maxlen);
./drivers/isdn/hardware/mISDN/netjet.c:			snprintf(card->log, LOG_SIZE, "B%1d-recv %s %d ",
./drivers/isdn/hardware/mISDN/netjet.c:				bc->bch.nr, card->name, stat);
./drivers/isdn/hardware/mISDN/netjet.c:			print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET,
./drivers/isdn/hardware/mISDN/netjet.c:					card->name, bc->bch.nr);
./drivers/isdn/hardware/mISDN/netjet.c:	int cnt = card->recv.size / 2;
./drivers/isdn/hardware/mISDN/netjet.c:	card->last_is0 &= ~NJ_IRQM0_WR_MASK;
./drivers/isdn/hardware/mISDN/netjet.c:	card->last_is0 |= (irq_stat & NJ_IRQM0_WR_MASK);
./drivers/isdn/hardware/mISDN/netjet.c:		idx = card->recv.size - 1;
./drivers/isdn/hardware/mISDN/netjet.c:	if (test_bit(FLG_ACTIVE, &card->bc[0].bch.Flags))
./drivers/isdn/hardware/mISDN/netjet.c:		read_dma(&card->bc[0], idx, cnt);
./drivers/isdn/hardware/mISDN/netjet.c:	if (test_bit(FLG_ACTIVE, &card->bc[1].bch.Flags))
./drivers/isdn/hardware/mISDN/netjet.c:		read_dma(&card->bc[1], idx, cnt);
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;
./drivers/isdn/hardware/mISDN/netjet.c:	if (bc->free > card->send.size / 2)
./drivers/isdn/hardware/mISDN/netjet.c:		bc->free = card->send.size / 2;
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->send.idx < ((card->send.size / 2) - 1))
./drivers/isdn/hardware/mISDN/netjet.c:		bc->idx = (card->recv.size / 2) - 1;
./drivers/isdn/hardware/mISDN/netjet.c:		bc->idx = card->recv.size - 1;
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: %s B%1d free %d idx %d/%d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		__func__, bc->bch.nr, bc->free, bc->idx, card->send.idx);
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: %s B%1d %d state %x idx %d/%d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		bc->idx, card->send.idx);
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: B%1d hdlc encoded %d flags\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		if (bc->idx >= card->send.size)
./drivers/isdn/hardware/mISDN/netjet.c:		v = card->send.start[bc->idx];
./drivers/isdn/hardware/mISDN/netjet.c:		card->send.start[bc->idx++] = v;
./drivers/isdn/hardware/mISDN/netjet.c:		snprintf(card->log, LOG_SIZE, "B%1d-send %s %d ",
./drivers/isdn/hardware/mISDN/netjet.c:			bc->bch.nr, card->name, count);
./drivers/isdn/hardware/mISDN/netjet.c:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: %s B%1d %d/%d/%d/%d state %x idx %d/%d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		bc->bch.tx_skb->len, bc->txstate, bc->idx, card->send.idx);
./drivers/isdn/hardware/mISDN/netjet.c:		pr_debug("%s: B%1d hdlc encoded %d in %d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		if (bc->idx >= card->send.size)
./drivers/isdn/hardware/mISDN/netjet.c:		v = card->send.start[bc->idx];
./drivers/isdn/hardware/mISDN/netjet.c:		card->send.start[bc->idx++] = v;
./drivers/isdn/hardware/mISDN/netjet.c:		snprintf(card->log, LOG_SIZE, "B%1d-send %s %d ",
./drivers/isdn/hardware/mISDN/netjet.c:			bc->bch.nr, card->name, count);
./drivers/isdn/hardware/mISDN/netjet.c:		print_hex_dump_bytes(card->log, DUMP_PREFIX_OFFSET, p, count);
./drivers/isdn/hardware/mISDN/netjet.c:	bc->free += card->send.size / 2;
./drivers/isdn/hardware/mISDN/netjet.c:	if (bc->free >= card->send.size) {
./drivers/isdn/hardware/mISDN/netjet.c:			pr_info("%s: B%1d TX underrun state %x\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		bc->free = card->send.size;
./drivers/isdn/hardware/mISDN/netjet.c:		pr_debug("%s: B%1d TX no data free %d idx %d/%d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:			bc->bch.nr, bc->free, bc->idx, card->send.idx);
./drivers/isdn/hardware/mISDN/netjet.c:			if (bc->free == card->send.size)
./drivers/isdn/hardware/mISDN/netjet.c:	if ((irq_stat & card->last_is0) & NJ_IRQM0_RD_MASK) {
./drivers/isdn/hardware/mISDN/netjet.c:			card->name, irq_stat, card->last_is0);
./drivers/isdn/hardware/mISDN/netjet.c:		card->last_is0 &= ~NJ_IRQM0_RD_MASK;
./drivers/isdn/hardware/mISDN/netjet.c:		card->last_is0 |= (irq_stat & NJ_IRQM0_RD_MASK);
./drivers/isdn/hardware/mISDN/netjet.c:		if (test_bit(FLG_ACTIVE, &card->bc[i].bch.Flags))
./drivers/isdn/hardware/mISDN/netjet.c:			send_tiger_bc(card, &card->bc[i]);
./drivers/isdn/hardware/mISDN/netjet.c:	spin_lock(&card->lock);
./drivers/isdn/hardware/mISDN/netjet.c:	s0val = inb(card->base | NJ_IRQSTAT0);
./drivers/isdn/hardware/mISDN/netjet.c:	s1val = inb(card->base | NJ_IRQSTAT1);
./drivers/isdn/hardware/mISDN/netjet.c:		spin_unlock(&card->lock);
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: IRQSTAT0 %02x IRQSTAT1 %02x\n", card->name, s0val, s1val);
./drivers/isdn/hardware/mISDN/netjet.c:	card->irqcnt++;
./drivers/isdn/hardware/mISDN/netjet.c:			mISDNisac_irq(&card->isac, val);
./drivers/isdn/hardware/mISDN/netjet.c:		outb(s0val, card->base | NJ_IRQSTAT0);
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.dmacur = inl(card->base | NJ_DMA_WRITE_ADR);
./drivers/isdn/hardware/mISDN/netjet.c:	card->recv.idx = (card->recv.dmacur - card->recv.dmastart) >> 2;
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->recv.dmacur < card->recv.dmairq)
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.dmacur = inl(card->base | NJ_DMA_READ_ADR);
./drivers/isdn/hardware/mISDN/netjet.c:	card->send.idx = (card->send.dmacur - card->send.dmastart) >> 2;
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->send.dmacur < card->send.dmairq)
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: DMA Status %02x/%02x/%02x %d/%d\n", card->name,
./drivers/isdn/hardware/mISDN/netjet.c:		s1val, s0val, card->last_is0,
./drivers/isdn/hardware/mISDN/netjet.c:		card->recv.idx, card->send.idx);
./drivers/isdn/hardware/mISDN/netjet.c:	if (s0val != card->last_is0) {
./drivers/isdn/hardware/mISDN/netjet.c:		    (card->last_is0 & NJ_IRQM0_RD_MASK))
./drivers/isdn/hardware/mISDN/netjet.c:		    (card->last_is0 & NJ_IRQM0_WR_MASK))
./drivers/isdn/hardware/mISDN/netjet.c:	spin_unlock(&card->lock);
./drivers/isdn/hardware/mISDN/netjet.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		pr_info("%s: %s unknown Op %x\n", card->name, __func__, cq->op);
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);
./drivers/isdn/hardware/mISDN/netjet.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		pr_info("%s: %s unknown prim(%x)\n", card->name, __func__, cmd);
./drivers/isdn/hardware/mISDN/netjet.c:		ret = card->isac.ctrl(&card->isac, HW_TESTLOOP, cq->channel);
./drivers/isdn/hardware/mISDN/netjet.c:		pr_info("%s: %s unknown Op %x\n", card->name, __func__, cq->op);
./drivers/isdn/hardware/mISDN/netjet.c:	bch = &card->bc[rq->adr.channel - 1].bch;
./drivers/isdn/hardware/mISDN/netjet.c:	pr_debug("%s: %s cmd:%x %p\n", card->name, __func__, cmd, arg);
./drivers/isdn/hardware/mISDN/netjet.c:			err = card->isac.open(&card->isac, rq);
./drivers/isdn/hardware/mISDN/netjet.c:			pr_info("%s: cannot get module\n", card->name);
./drivers/isdn/hardware/mISDN/netjet.c:		pr_debug("%s: dev(%d) close from %p\n", card->name, dch->dev.id,
./drivers/isdn/hardware/mISDN/netjet.c:			card->name, __func__, cmd);
./drivers/isdn/hardware/mISDN/netjet.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:	card->irq = card->pdev->irq;
./drivers/isdn/hardware/mISDN/netjet.c:	if (request_irq(card->irq, nj_irq, IRQF_SHARED, card->name, card)) {
./drivers/isdn/hardware/mISDN/netjet.c:			card->name, card->irq);
./drivers/isdn/hardware/mISDN/netjet.c:		card->irq = -1;
./drivers/isdn/hardware/mISDN/netjet.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:	ret = card->isac.init(&card->isac);
./drivers/isdn/hardware/mISDN/netjet.c:	mode_tiger(&card->bc[0], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/netjet.c:	mode_tiger(&card->bc[1], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/netjet.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->base_s) {
./drivers/isdn/hardware/mISDN/netjet.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		mode_tiger(&card->bc[0], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/netjet.c:		mode_tiger(&card->bc[1], ISDN_P_NONE);
./drivers/isdn/hardware/mISDN/netjet.c:		card->isac.release(&card->isac);
./drivers/isdn/hardware/mISDN/netjet.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/netjet.c:		release_region(card->base, card->base_s);
./drivers/isdn/hardware/mISDN/netjet.c:		card->base_s = 0;
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->irq > 0)
./drivers/isdn/hardware/mISDN/netjet.c:		free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->isac.dch.dev.dev.class)
./drivers/isdn/hardware/mISDN/netjet.c:		mISDN_unregister_device(&card->isac.dch.dev);
./drivers/isdn/hardware/mISDN/netjet.c:		mISDN_freebchannel(&card->bc[i].bch);
./drivers/isdn/hardware/mISDN/netjet.c:		kfree(card->bc[i].hsbuf);
./drivers/isdn/hardware/mISDN/netjet.c:		kfree(card->bc[i].hrbuf);
./drivers/isdn/hardware/mISDN/netjet.c:	if (card->dma_p)
./drivers/isdn/hardware/mISDN/netjet.c:		pci_free_consistent(card->pdev, NJ_DMA_SIZE,
./drivers/isdn/hardware/mISDN/netjet.c:			card->dma_p, card->dma);
./drivers/isdn/hardware/mISDN/netjet.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/netjet.c:	pci_clear_master(card->pdev);
./drivers/isdn/hardware/mISDN/netjet.c:	pci_disable_device(card->pdev);
./drivers/isdn/hardware/mISDN/netjet.c:	pci_set_drvdata(card->pdev, NULL);
./drivers/isdn/hardware/mISDN/netjet.c:	card->base = pci_resource_start(card->pdev, 0);
./drivers/isdn/hardware/mISDN/netjet.c:	card->base_s = pci_resource_len(card->pdev, 0);
./drivers/isdn/hardware/mISDN/netjet.c:	if (!request_region(card->base, card->base_s, card->name)) {
./drivers/isdn/hardware/mISDN/netjet.c:			card->name, card->base,
./drivers/isdn/hardware/mISDN/netjet.c:			(u32)(card->base + card->base_s - 1));
./drivers/isdn/hardware/mISDN/netjet.c:		card->base_s = 0;
./drivers/isdn/hardware/mISDN/netjet.c:	ASSIGN_FUNC(nj, ISAC, card->isac);
./drivers/isdn/hardware/mISDN/netjet.c:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "netjet.%d", nj_cnt + 1);
./drivers/isdn/hardware/mISDN/netjet.c:	list_add_tail(&card->list, &Cards);
./drivers/isdn/hardware/mISDN/netjet.c:	card->isac.name = card->name;
./drivers/isdn/hardware/mISDN/netjet.c:	spin_lock_init(&card->lock);
./drivers/isdn/hardware/mISDN/netjet.c:	card->isac.hwlock = &card->lock;
./drivers/isdn/hardware/mISDN/netjet.c:	mISDNisac_init(&card->isac, card);
./drivers/isdn/hardware/mISDN/netjet.c:	card->isac.dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./drivers/isdn/hardware/mISDN/netjet.c:	card->isac.dch.dev.D.ctrl = nj_dctrl;
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].bch.nr = i + 1;
./drivers/isdn/hardware/mISDN/netjet.c:		set_channelmap(i + 1, card->isac.dch.dev.channelmap);
./drivers/isdn/hardware/mISDN/netjet.c:		mISDN_initbchannel(&card->bc[i].bch, MAX_DATA_MEM);
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].bch.hw = card;
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].bch.ch.send = nj_l2l1B;
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].bch.ch.ctrl = nj_bctrl;
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].bch.ch.nr = i + 1;
./drivers/isdn/hardware/mISDN/netjet.c:		list_add(&card->bc[i].bch.ch.list,
./drivers/isdn/hardware/mISDN/netjet.c:			&card->isac.dch.dev.bchannels);
./drivers/isdn/hardware/mISDN/netjet.c:		card->bc[i].bch.hw = card;
./drivers/isdn/hardware/mISDN/netjet.c:	err = mISDN_register_device(&card->isac.dch.dev, &card->pdev->dev,
./drivers/isdn/hardware/mISDN/netjet.c:		card->name);
./drivers/isdn/hardware/mISDN/netjet.c:	card->pdev = pdev;
./drivers/isdn/hardware/mISDN/netjet.c:		card->typ = NETJET_S_TJ320;
./drivers/isdn/hardware/mISDN/netjet.c:		card->typ = NETJET_S_TJ300;
./drivers/isdn/hardware/mISDN/netjet.c:	card->base = pci_resource_start(pdev, 0);
./drivers/isdn/hardware/mISDN/netjet.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->dch.debug = debug;
./drivers/isdn/hardware/mISDN/hfcpci.c:	spin_lock_init(&card->lock);
./drivers/isdn/hardware/mISDN/hfcpci.c:	mISDN_initdchannel(&card->dch, MAX_DFRAME_LEN_L1, ph_state);
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->dch.hw = card;
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->dch.dev.Dprotocols = (1 << ISDN_P_TE_S0) | (1 << ISDN_P_NT_S0);
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->dch.dev.Bprotocols = (1 << (ISDN_P_B_RAW & ISDN_P_B_MASK)) |
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->dch.dev.D.send = hfcpci_l2l1D;
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->dch.dev.D.ctrl = hfc_dctrl;
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->dch.dev.nrbchan = 2;
./drivers/isdn/hardware/mISDN/hfcpci.c:		card->bch[i].nr = i + 1;
./drivers/isdn/hardware/mISDN/hfcpci.c:		set_channelmap(i + 1, card->dch.dev.channelmap);
./drivers/isdn/hardware/mISDN/hfcpci.c:		card->bch[i].debug = debug;
./drivers/isdn/hardware/mISDN/hfcpci.c:		mISDN_initbchannel(&card->bch[i], MAX_DATA_MEM);
./drivers/isdn/hardware/mISDN/hfcpci.c:		card->bch[i].hw = card;
./drivers/isdn/hardware/mISDN/hfcpci.c:		card->bch[i].ch.send = hfcpci_l2l1B;
./drivers/isdn/hardware/mISDN/hfcpci.c:		card->bch[i].ch.ctrl = hfc_bctrl;
./drivers/isdn/hardware/mISDN/hfcpci.c:		card->bch[i].ch.nr = i + 1;
./drivers/isdn/hardware/mISDN/hfcpci.c:		list_add(&card->bch[i].ch.list, &card->dch.dev.bchannels);
./drivers/isdn/hardware/mISDN/hfcpci.c:	err = mISDN_register_device(&card->dch.dev, &card->pdev->dev, name);
./drivers/isdn/hardware/mISDN/hfcpci.c:	mISDN_freebchannel(&card->bch[1]);
./drivers/isdn/hardware/mISDN/hfcpci.c:	mISDN_freebchannel(&card->bch[0]);
./drivers/isdn/hardware/mISDN/hfcpci.c:	mISDN_freedchannel(&card->dch);
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->pdev = pdev;
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->subtype = m->subtype;
./drivers/isdn/hardware/mISDN/hfcpci.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.isac.dch.debug = debug;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.hscx[0].bch.debug = debug;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.hscx[1].bch.debug = debug;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.isac.release(&card->ipac.isac);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	mISDN_unregister_device(&card->ipac.isac.dch.dev);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	switch (card->ci->typ) {
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:			if (card->sc[i])
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:				release_card(card->sc[i]);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:			card->sc[i] = NULL;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:		pci_disable_device(card->pdev);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:		pci_set_drvdata(card->pdev, NULL);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	snprintf(card->name, MISDN_MAX_IDLEN - 1, "%s.%d", card->ci->name,
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	list_add_tail(&card->list, &Cards);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.isac.name = card->name;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.name = card->name;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.owner = THIS_MODULE;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	spin_lock_init(&card->lock);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.isac.hwlock = &card->lock;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.hwlock = &card->lock;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.ctrl = (void *)&inf_ctrl;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.isac.dch.dev.Bprotocols =
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:		mISDNipac_init(&card->ipac, card);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	if (card->ipac.isac.dch.dev.Bprotocols == 0)
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	err = mISDN_register_device(&card->ipac.isac.dch.dev,
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:		&card->pdev->dev, card->name);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	mISDN_unregister_device(&card->ipac.isac.dch.dev);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ipac.release(&card->ipac);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	list_del(&card->list);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->pdev = pdev;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->ci = get_card_info(ent->driver_data);
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	if (!card->ci) {
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:			card->ci->full, pci_name(pdev));
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:			sc->irq = card->irq;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:			sc->pdev = card->pdev;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:			sc->ci = card->ci + i;
./drivers/isdn/hardware/mISDN/mISDNinfineon.c:				card->sc[i - 1] = sc;
./drivers/isdn/hardware/avm/t1pci.c:        card->dma = avmcard_dma_alloc("t1pci", pdev, 2048+128, 2048+128);
./drivers/isdn/hardware/avm/t1pci.c:	if (!card->dma) {
./drivers/isdn/hardware/avm/t1pci.c:	cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/t1pci.c:	sprintf(card->name, "t1pci-%x", p->port);
./drivers/isdn/hardware/avm/t1pci.c:	card->port = p->port;
./drivers/isdn/hardware/avm/t1pci.c:	card->irq = p->irq;
./drivers/isdn/hardware/avm/t1pci.c:	card->membase = p->membase;
./drivers/isdn/hardware/avm/t1pci.c:	card->cardtype = avm_t1pci;
./drivers/isdn/hardware/avm/t1pci.c:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./drivers/isdn/hardware/avm/t1pci.c:		       card->port, card->port + AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/t1pci.c:	card->mbase = ioremap(card->membase, 64);
./drivers/isdn/hardware/avm/t1pci.c:	if (!card->mbase) {
./drivers/isdn/hardware/avm/t1pci.c:		       card->membase);
./drivers/isdn/hardware/avm/t1pci.c:			       card->port, retval);
./drivers/isdn/hardware/avm/t1pci.c:			       card->port, retval);
./drivers/isdn/hardware/avm/t1pci.c:	retval = request_irq(card->irq, b1dma_interrupt, IRQF_SHARED, card->name, card);
./drivers/isdn/hardware/avm/t1pci.c:		printk(KERN_ERR "t1pci: unable to get IRQ %d.\n", card->irq);
./drivers/isdn/hardware/avm/t1pci.c:	strcpy(cinfo->capi_ctrl.name, card->name);
./drivers/isdn/hardware/avm/t1pci.c:	card->cardnr = cinfo->capi_ctrl.cnr;
./drivers/isdn/hardware/avm/t1pci.c:	       card->port, card->irq, card->membase);
./drivers/isdn/hardware/avm/t1pci.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/t1pci.c:	iounmap(card->mbase);
./drivers/isdn/hardware/avm/t1pci.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/t1pci.c:	avmcard_dma_free(card->dma);
./drivers/isdn/hardware/avm/t1pci.c:	avmctrl_info *cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/t1pci.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/t1pci.c:	iounmap(card->mbase);
./drivers/isdn/hardware/avm/t1pci.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/t1pci.c:	avmcard_dma_free(card->dma);
./drivers/isdn/hardware/avm/t1pci.c:		cinfo->card ? cinfo->card->port : 0x0,
./drivers/isdn/hardware/avm/t1pci.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hardware/avm/t1pci.c:		cinfo->card ? cinfo->card->membase : 0
./drivers/isdn/hardware/avm/t1isa.c:	avmctrl_info *cinfo = &card->ctrlinfo[0];
./drivers/isdn/hardware/avm/t1isa.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:	while (b1_rx_full(card->port)) {
./drivers/isdn/hardware/avm/t1isa.c:		b1cmd = b1_get_byte(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			ApplId = (unsigned) b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/t1isa.c:			DataB3Len = t1_get_slice(card->port, card->databuf);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:				memset(card->msgbuf+MsgLen, 0, 30-MsgLen);
./drivers/isdn/hardware/avm/t1isa.c:				CAPIMSG_SETLEN(card->msgbuf, 30);
./drivers/isdn/hardware/avm/t1isa.c:					card->name);
./drivers/isdn/hardware/avm/t1isa.c:				memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/t1isa.c:				memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
./drivers/isdn/hardware/avm/t1isa.c:			ApplId = (unsigned) b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/t1isa.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:						card->name);
./drivers/isdn/hardware/avm/t1isa.c:				memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/t1isa.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			ApplId = b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			NCCI = b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			WindowSize = b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			ApplId = b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			NCCI = b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			b1_put_byte(card->port, SEND_POLLACK);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			cinfo->versionlen = t1_get_slice(card->port, cinfo->versionbuf);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			       card->name,
./drivers/isdn/hardware/avm/t1isa.c:			ApplId = (unsigned) b1_get_word(card->port);
./drivers/isdn/hardware/avm/t1isa.c:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/t1isa.c:			       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/t1isa.c:				   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/t1isa.c:				card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/t1isa.c:					card->name, ApplId, card->msgbuf);
./drivers/isdn/hardware/avm/t1isa.c:			MsgLen = t1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/t1isa.c:			       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/t1isa.c:				   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/t1isa.c:				card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/t1isa.c:			printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			printk(KERN_ERR "%s: card reseted ?\n", card->name);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:					card->name, b1cmd);
./drivers/isdn/hardware/avm/t1isa.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/t1isa.c:					card->name);
./drivers/isdn/hardware/avm/t1isa.c:					card->name);
./drivers/isdn/hardware/avm/t1isa.c:		printk(KERN_ERR "%s: failed to load t4file.\n", card->name);
./drivers/isdn/hardware/avm/t1isa.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:	b1_setinterrupt(port, card->irq, card->cardtype);
./drivers/isdn/hardware/avm/t1isa.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/t1isa.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:	t1_disable_irq(card->port);
./drivers/isdn/hardware/avm/t1isa.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/t1isa.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/t1isa.c:	t1_reset(card->port);
./drivers/isdn/hardware/avm/t1isa.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/t1isa.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/t1isa.c:	cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/t1isa.c:	card->port = pci_resource_start(pdev, 0);
./drivers/isdn/hardware/avm/t1isa.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/avm/t1isa.c:	card->cardtype = avm_t1isa;
./drivers/isdn/hardware/avm/t1isa.c:	card->cardnr = cardnr;
./drivers/isdn/hardware/avm/t1isa.c:	sprintf(card->name, "t1isa-%x", card->port);
./drivers/isdn/hardware/avm/t1isa.c:	if (!(((card->port & 0x7) == 0) && ((card->port & 0x30) != 0x30))) {
./drivers/isdn/hardware/avm/t1isa.c:		printk(KERN_WARNING "t1isa: invalid port 0x%x.\n", card->port);
./drivers/isdn/hardware/avm/t1isa.c:	if (hema_irq_table[card->irq & 0xf] == 0) {
./drivers/isdn/hardware/avm/t1isa.c:		printk(KERN_WARNING "t1isa: irq %d not valid.\n", card->irq);
./drivers/isdn/hardware/avm/t1isa.c:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./drivers/isdn/hardware/avm/t1isa.c:		       card->port, card->port + AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/t1isa.c:	retval = request_irq(card->irq, t1isa_interrupt, 0, card->name, card);
./drivers/isdn/hardware/avm/t1isa.c:		printk(KERN_INFO "t1isa: unable to get IRQ %d.\n", card->irq);
./drivers/isdn/hardware/avm/t1isa.c:        if ((retval = t1_detectandinit(card->port, card->irq, card->cardnr)) != 0) {
./drivers/isdn/hardware/avm/t1isa.c:		       card->port, retval);
./drivers/isdn/hardware/avm/t1isa.c:	t1_disable_irq(card->port);
./drivers/isdn/hardware/avm/t1isa.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/t1isa.c:	strcpy(cinfo->capi_ctrl.name, card->name);
./drivers/isdn/hardware/avm/t1isa.c:	       card->port, card->irq, card->cardnr);
./drivers/isdn/hardware/avm/t1isa.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/t1isa.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/t1isa.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/t1isa.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/t1isa.c:		cinfo->card ? cinfo->card->port : 0x0,
./drivers/isdn/hardware/avm/t1isa.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hardware/avm/t1isa.c:		cinfo->card ? cinfo->card->cardnr : 0
./drivers/isdn/hardware/avm/c4.c:	while (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_PEEK_POKE, off);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_ADDR);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_PEEK_POKE, value);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_DATA | DBELL_ADDR);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_PEEK_POKE, off);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_RNWR | DBELL_ADDR);
./drivers/isdn/hardware/avm/c4.c:	*valuep = c4inmeml(card->mbase+MBOX_PEEK_POKE);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_RESET_ARM);
./drivers/isdn/hardware/avm/c4.c:	while (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {
./drivers/isdn/hardware/avm/c4.c:		c4outmeml(card->mbase+DOORBELL, DBELL_ADDR);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+PCI_OUT_INT_MASK, 0x0c);
./drivers/isdn/hardware/avm/c4.c:	if (c4inmeml(card->mbase+PCI_OUT_INT_MASK) != 0x0c)
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_RESET_ARM);
./drivers/isdn/hardware/avm/c4.c:	while (c4inmeml(card->mbase+DOORBELL) != 0xffffffff) {
./drivers/isdn/hardware/avm/c4.c:		c4outmeml(card->mbase+DOORBELL, DBELL_ADDR);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MAILBOX_0, 0x55aa55aa);
./drivers/isdn/hardware/avm/c4.c:	if (c4inmeml(card->mbase+MAILBOX_0) != 0x55aa55aa) return 3;
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MAILBOX_0, 0xaa55aa55);
./drivers/isdn/hardware/avm/c4.c:	if (c4inmeml(card->mbase+MAILBOX_0) != 0xaa55aa55) return 4;
./drivers/isdn/hardware/avm/c4.c:	avmcard_dmainfo *dma = card->dma;
./drivers/isdn/hardware/avm/c4.c:	if (card->csr & DBELL_DOWN_ARM) { /* tx busy */
./drivers/isdn/hardware/avm/c4.c:		printk(KERN_DEBUG "%s: tx underrun\n", card->name);
./drivers/isdn/hardware/avm/c4.c:		printk(KERN_DEBUG "%s: tx put msg len=%d\n", card->name, txlen);
./drivers/isdn/hardware/avm/c4.c:			printk(KERN_INFO "%s: ack to c4\n", card->name);
./drivers/isdn/hardware/avm/c4.c:				card->name, skb->data[2], txlen);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_DOWN_ADDR, dma->sendbuf.dmaaddr);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_DOWN_LEN, txlen);
./drivers/isdn/hardware/avm/c4.c:	card->csr |= DBELL_DOWN_ARM;
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_DOWN_ARM);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:	skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/c4.c:	avmcard_dmainfo *dma = card->dma;
./drivers/isdn/hardware/avm/c4.c:	printk(KERN_DEBUG "%s: rx 0x%x len=%lu\n", card->name,
./drivers/isdn/hardware/avm/c4.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/c4.c:		DataB3Len = _get_slice(&p, card->databuf);
./drivers/isdn/hardware/avm/c4.c:		cidx = CAPIMSG_CONTROLLER(card->msgbuf)-card->cardnr;
./drivers/isdn/hardware/avm/c4.c:		if (cidx >= card->nlogcontr) cidx = 0;
./drivers/isdn/hardware/avm/c4.c:		ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./drivers/isdn/hardware/avm/c4.c:			memset(card->msgbuf+MsgLen, 0, 30-MsgLen);
./drivers/isdn/hardware/avm/c4.c:			CAPIMSG_SETLEN(card->msgbuf, 30);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/c4.c:			memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
./drivers/isdn/hardware/avm/c4.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/c4.c:		cidx = CAPIMSG_CONTROLLER(card->msgbuf)-card->cardnr;
./drivers/isdn/hardware/avm/c4.c:		if (cidx >= card->nlogcontr) cidx = 0;
./drivers/isdn/hardware/avm/c4.c:		cinfo = &card->ctrlinfo[cidx];
./drivers/isdn/hardware/avm/c4.c:		ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/c4.c:		cidx = (NCCI&0x7f) - card->cardnr;
./drivers/isdn/hardware/avm/c4.c:		if (cidx >= card->nlogcontr) cidx = 0;
./drivers/isdn/hardware/avm/c4.c:		capilib_new_ncci(&card->ctrlinfo[cidx].ncci_head, ApplId, NCCI, WindowSize);
./drivers/isdn/hardware/avm/c4.c:			cidx = (NCCI&0x7f) - card->cardnr;
./drivers/isdn/hardware/avm/c4.c:			if (cidx >= card->nlogcontr) cidx = 0;
./drivers/isdn/hardware/avm/c4.c:			capilib_free_ncci(&card->ctrlinfo[cidx].ncci_head, ApplId, NCCI);
./drivers/isdn/hardware/avm/c4.c:		printk(KERN_INFO "%s: poll from c4\n", card->name);
./drivers/isdn/hardware/avm/c4.c:		for (cidx=0; cidx < card->nr_controllers; cidx++) {
./drivers/isdn/hardware/avm/c4.c:			ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./drivers/isdn/hardware/avm/c4.c:		for (cidx=0; cidx < card->nr_controllers; cidx++) {
./drivers/isdn/hardware/avm/c4.c:			ctrl = &card->ctrlinfo[cidx].capi_ctrl;
./drivers/isdn/hardware/avm/c4.c:	        cidx = card->nlogcontr;
./drivers/isdn/hardware/avm/c4.c:		if (cidx >= card->nr_controllers) {
./drivers/isdn/hardware/avm/c4.c:					card->name, cidx+1);
./drivers/isdn/hardware/avm/c4.c:	        card->nlogcontr++;
./drivers/isdn/hardware/avm/c4.c:	        cinfo = &card->ctrlinfo[cidx];
./drivers/isdn/hardware/avm/c4.c:		       card->name,
./drivers/isdn/hardware/avm/c4.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/c4.c:		card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/c4.c:		       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/c4.c:			   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/c4.c:			card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/c4.c:				card->name, ApplId, card->msgbuf);
./drivers/isdn/hardware/avm/c4.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/c4.c:		card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/c4.c:		       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/c4.c:			   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/c4.c:			card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/c4.c:		printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./drivers/isdn/hardware/avm/c4.c:				card->name, b1cmd);
./drivers/isdn/hardware/avm/c4.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	status = c4inmeml(card->mbase+DOORBELL);
./drivers/isdn/hardware/avm/c4.c:		c4outmeml(card->mbase+PCI_OUT_INT_MASK, 0x0c);
./drivers/isdn/hardware/avm/c4.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:		if (card->nlogcontr == 0)
./drivers/isdn/hardware/avm/c4.c:		printk(KERN_ERR "%s: unexpected reset\n", card->name);
./drivers/isdn/hardware/avm/c4.c:                for (i=0; i < card->nr_controllers; i++) {
./drivers/isdn/hardware/avm/c4.c:			avmctrl_info *cinfo = &card->ctrlinfo[i];
./drivers/isdn/hardware/avm/c4.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:		card->nlogcontr = 0;
./drivers/isdn/hardware/avm/c4.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, status);
./drivers/isdn/hardware/avm/c4.c:		card->dma->recvlen = c4inmeml(card->mbase+MBOX_UP_LEN);
./drivers/isdn/hardware/avm/c4.c:		c4outmeml(card->mbase+MBOX_UP_LEN, 0);
./drivers/isdn/hardware/avm/c4.c:		card->dma->recvlen = 0;
./drivers/isdn/hardware/avm/c4.c:		c4outmeml(card->mbase+MBOX_UP_LEN, card->dma->recvbuf.size);
./drivers/isdn/hardware/avm/c4.c:		c4outmeml(card->mbase+DOORBELL, DBELL_UP_ARM);
./drivers/isdn/hardware/avm/c4.c:		card->csr &= ~DBELL_DOWN_ARM;
./drivers/isdn/hardware/avm/c4.c:	} else if (card->csr & DBELL_DOWN_HOST) {
./drivers/isdn/hardware/avm/c4.c:		if (c4inmeml(card->mbase+MBOX_DOWN_LEN) == 0) {
./drivers/isdn/hardware/avm/c4.c:		        card->csr &= ~DBELL_DOWN_ARM;
./drivers/isdn/hardware/avm/c4.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:	_put_word(&p, card->cardnr - 1);
./drivers/isdn/hardware/avm/c4.c:	skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/c4.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:	skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/c4.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:	skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/c4.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:	card->csr = 0;
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_UP_LEN, 0);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_DOWN_LEN, 0);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_INIT);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL,
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+PCI_OUT_INT_MASK, 0x08);
./drivers/isdn/hardware/avm/c4.c:	card->dma->recvlen = 0;
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_UP_ADDR, card->dma->recvbuf.dmaaddr);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+MBOX_UP_LEN, card->dma->recvbuf.size);
./drivers/isdn/hardware/avm/c4.c:	c4outmeml(card->mbase+DOORBELL, DBELL_UP_ARM);
./drivers/isdn/hardware/avm/c4.c:					card->name);
./drivers/isdn/hardware/avm/c4.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:        for (i=0; i < card->nr_controllers; i++) {
./drivers/isdn/hardware/avm/c4.c:		cinfo = &card->ctrlinfo[i];
./drivers/isdn/hardware/avm/c4.c:	card->nlogcontr = 0;
./drivers/isdn/hardware/avm/c4.c:        for (i=0; i < card->nr_controllers; i++) {
./drivers/isdn/hardware/avm/c4.c:		cinfo = &card->ctrlinfo[i];
./drivers/isdn/hardware/avm/c4.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/c4.c:	iounmap(card->mbase);
./drivers/isdn/hardware/avm/c4.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/c4.c:        avmcard_dma_free(card->dma);
./drivers/isdn/hardware/avm/c4.c:	if (ctrl->cnr == card->cardnr) {
./drivers/isdn/hardware/avm/c4.c:						card->name);
./drivers/isdn/hardware/avm/c4.c:		skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/c4.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	if (ctrl->cnr == card->cardnr) {
./drivers/isdn/hardware/avm/c4.c:						card->name);
./drivers/isdn/hardware/avm/c4.c:		skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/c4.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:		skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/c4.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/c4.c:		cinfo->card ? cinfo->card->port : 0x0,
./drivers/isdn/hardware/avm/c4.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hardware/avm/c4.c:		cinfo->card ? cinfo->card->membase : 0
./drivers/isdn/hardware/avm/c4.c:	seq_printf(m, "%-16s %s\n", "name", card->name);
./drivers/isdn/hardware/avm/c4.c:	seq_printf(m, "%-16s 0x%x\n", "io", card->port);
./drivers/isdn/hardware/avm/c4.c:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./drivers/isdn/hardware/avm/c4.c:	seq_printf(m, "%-16s 0x%lx\n", "membase", card->membase);
./drivers/isdn/hardware/avm/c4.c:	switch (card->cardtype) {
./drivers/isdn/hardware/avm/c4.c:	if (card->cardtype != avm_m1) {
./drivers/isdn/hardware/avm/c4.c:	if (card->cardtype != avm_m1) {
./drivers/isdn/hardware/avm/c4.c:        card->dma = avmcard_dma_alloc("c4", dev, 2048+128, 2048+128);
./drivers/isdn/hardware/avm/c4.c:	if (!card->dma) {
./drivers/isdn/hardware/avm/c4.c:	sprintf(card->name, "c%d-%x", nr_controllers, p->port);
./drivers/isdn/hardware/avm/c4.c:	card->port = p->port;
./drivers/isdn/hardware/avm/c4.c:	card->irq = p->irq;
./drivers/isdn/hardware/avm/c4.c:	card->membase = p->membase;
./drivers/isdn/hardware/avm/c4.c:	card->cardtype = (nr_controllers == 4) ? avm_c4 : avm_c2;
./drivers/isdn/hardware/avm/c4.c:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./drivers/isdn/hardware/avm/c4.c:		       card->port, card->port + AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/c4.c:	card->mbase = ioremap(card->membase, 128);
./drivers/isdn/hardware/avm/c4.c:	if (card->mbase == NULL) {
./drivers/isdn/hardware/avm/c4.c:		       card->membase);
./drivers/isdn/hardware/avm/c4.c:		       card->port, retval);
./drivers/isdn/hardware/avm/c4.c:	retval = request_irq(card->irq, c4_interrupt, IRQF_SHARED, card->name, card);
./drivers/isdn/hardware/avm/c4.c:		printk(KERN_ERR "c4: unable to get IRQ %d.\n",card->irq);
./drivers/isdn/hardware/avm/c4.c:		cinfo = &card->ctrlinfo[i];
./drivers/isdn/hardware/avm/c4.c:		strcpy(cinfo->capi_ctrl.name, card->name);
./drivers/isdn/hardware/avm/c4.c:				cinfo = &card->ctrlinfo[i];
./drivers/isdn/hardware/avm/c4.c:			card->cardnr = cinfo->capi_ctrl.cnr;
./drivers/isdn/hardware/avm/c4.c:	       nr_controllers, card->port, card->irq,
./drivers/isdn/hardware/avm/c4.c:	       card->membase);
./drivers/isdn/hardware/avm/c4.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/c4.c:	iounmap(card->mbase);
./drivers/isdn/hardware/avm/c4.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/c4.c:	avmcard_dma_free(card->dma);
./drivers/isdn/hardware/avm/b1pci.c:		cinfo->card ? cinfo->card->port : 0x0,
./drivers/isdn/hardware/avm/b1pci.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hardware/avm/b1pci.c:		cinfo->card ? cinfo->card->revision : 0
./drivers/isdn/hardware/avm/b1pci.c:	cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/b1pci.c:	sprintf(card->name, "b1pci-%x", p->port);
./drivers/isdn/hardware/avm/b1pci.c:	card->port = p->port;
./drivers/isdn/hardware/avm/b1pci.c:	card->irq = p->irq;
./drivers/isdn/hardware/avm/b1pci.c:	card->cardtype = avm_b1pci;
./drivers/isdn/hardware/avm/b1pci.c:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./drivers/isdn/hardware/avm/b1pci.c:		       card->port, card->port + AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1pci.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1pci.c:	retval = b1_detect(card->port, card->cardtype);
./drivers/isdn/hardware/avm/b1pci.c:		       card->port, retval);
./drivers/isdn/hardware/avm/b1pci.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1pci.c:	retval = request_irq(card->irq, b1_interrupt, IRQF_SHARED, card->name, card);
./drivers/isdn/hardware/avm/b1pci.c:		printk(KERN_ERR "b1pci: unable to get IRQ %d.\n", card->irq);
./drivers/isdn/hardware/avm/b1pci.c:	strcpy(cinfo->capi_ctrl.name, card->name);
./drivers/isdn/hardware/avm/b1pci.c:	if (card->revision >= 4) {
./drivers/isdn/hardware/avm/b1pci.c:		       card->port, card->irq, card->revision);
./drivers/isdn/hardware/avm/b1pci.c:		       card->port, card->irq, card->revision);
./drivers/isdn/hardware/avm/b1pci.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1pci.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1pci.c:	avmctrl_info *cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/b1pci.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/b1pci.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1pci.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1pci.c:		cinfo->card ? cinfo->card->port : 0x0,
./drivers/isdn/hardware/avm/b1pci.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hardware/avm/b1pci.c:		cinfo->card ? cinfo->card->membase : 0,
./drivers/isdn/hardware/avm/b1pci.c:		cinfo->card ? cinfo->card->revision : 0
./drivers/isdn/hardware/avm/b1pci.c:        card->dma = avmcard_dma_alloc("b1pci", pdev, 2048+128, 2048+128);
./drivers/isdn/hardware/avm/b1pci.c:	if (!card->dma) {
./drivers/isdn/hardware/avm/b1pci.c:	cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/b1pci.c:	sprintf(card->name, "b1pciv4-%x", p->port);
./drivers/isdn/hardware/avm/b1pci.c:	card->port = p->port;
./drivers/isdn/hardware/avm/b1pci.c:	card->irq = p->irq;
./drivers/isdn/hardware/avm/b1pci.c:	card->membase = p->membase;
./drivers/isdn/hardware/avm/b1pci.c:	card->cardtype = avm_b1pci;
./drivers/isdn/hardware/avm/b1pci.c:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./drivers/isdn/hardware/avm/b1pci.c:		       card->port, card->port + AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1pci.c:	card->mbase = ioremap(card->membase, 64);
./drivers/isdn/hardware/avm/b1pci.c:	if (!card->mbase) {
./drivers/isdn/hardware/avm/b1pci.c:		       card->membase);
./drivers/isdn/hardware/avm/b1pci.c:		       card->port, retval);
./drivers/isdn/hardware/avm/b1pci.c:	retval = request_irq(card->irq, b1dma_interrupt, IRQF_SHARED, card->name, card);
./drivers/isdn/hardware/avm/b1pci.c:		       card->irq);
./drivers/isdn/hardware/avm/b1pci.c:	strcpy(cinfo->capi_ctrl.name, card->name);
./drivers/isdn/hardware/avm/b1pci.c:	card->cardnr = cinfo->capi_ctrl.cnr;
./drivers/isdn/hardware/avm/b1pci.c:	       card->port, card->irq, card->membase, card->revision);
./drivers/isdn/hardware/avm/b1pci.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1pci.c:	iounmap(card->mbase);
./drivers/isdn/hardware/avm/b1pci.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1pci.c:	avmcard_dma_free(card->dma);
./drivers/isdn/hardware/avm/b1pci.c:	avmctrl_info *cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/b1pci.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1pci.c:	iounmap(card->mbase);
./drivers/isdn/hardware/avm/b1pci.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1pci.c:        avmcard_dma_free(card->dma);
./drivers/isdn/hardware/avm/b1pci.c:	if (card->dma)
./drivers/isdn/hardware/avm/b1.c:	card->ctrlinfo = cinfo;
./drivers/isdn/hardware/avm/b1.c:	spin_lock_init(&card->lock);
./drivers/isdn/hardware/avm/b1.c:	card->nr_controllers = nr_controllers;
./drivers/isdn/hardware/avm/b1.c:	kfree(card->ctrlinfo);
./drivers/isdn/hardware/avm/b1.c:    card->class = inb(card->port + B1_ANALYSE);
./drivers/isdn/hardware/avm/b1.c:    card->revision = inb(card->port + B1_REVISION);
./drivers/isdn/hardware/avm/b1.c:	unsigned int base = card->port;
./drivers/isdn/hardware/avm/b1.c:						card->name);
./drivers/isdn/hardware/avm/b1.c:						card->name);
./drivers/isdn/hardware/avm/b1.c:	unsigned int base = card->port;
./drivers/isdn/hardware/avm/b1.c:	unsigned int base = card->port;
./drivers/isdn/hardware/avm/b1.c:				card->name);
./drivers/isdn/hardware/avm/b1.c:					card->name, ans);
./drivers/isdn/hardware/avm/b1.c:	printk(KERN_ERR "%s: b1_loaded: firmware not running\n", card->name);
./drivers/isdn/hardware/avm/b1.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/b1.c:					card->name);
./drivers/isdn/hardware/avm/b1.c:					card->name);
./drivers/isdn/hardware/avm/b1.c:		printk(KERN_ERR "%s: failed to load t4file.\n", card->name);
./drivers/isdn/hardware/avm/b1.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	b1_setinterrupt(port, card->irq, card->cardtype);
./drivers/isdn/hardware/avm/b1.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/b1.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/b1.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/b1.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/b1.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:				card->name, ctrl->cnr, cinfo->cardname);
./drivers/isdn/hardware/avm/b1.c:			card->name,
./drivers/isdn/hardware/avm/b1.c:			card->name,
./drivers/isdn/hardware/avm/b1.c:	avmctrl_info *cinfo = &card->ctrlinfo[0];
./drivers/isdn/hardware/avm/b1.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	if (!b1_rx_full(card->port)) {
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	b1cmd = b1_get_byte(card->port);
./drivers/isdn/hardware/avm/b1.c:		ApplId = (unsigned) b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/b1.c:		DataB3Len = b1_get_slice(card->port, card->databuf);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:			memset(card->msgbuf+MsgLen, 0, 30-MsgLen);
./drivers/isdn/hardware/avm/b1.c:			CAPIMSG_SETLEN(card->msgbuf, 30);
./drivers/isdn/hardware/avm/b1.c:					card->name);
./drivers/isdn/hardware/avm/b1.c:			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/b1.c:			memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
./drivers/isdn/hardware/avm/b1.c:		ApplId = (unsigned) b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/b1.c:					card->name);
./drivers/isdn/hardware/avm/b1.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/b1.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		ApplId = b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		NCCI = b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		WindowSize = b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		ApplId = b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		NCCI = b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:	   	/* b1_put_byte(card->port, SEND_POLLACK); */
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		cinfo->versionlen = b1_get_slice(card->port, cinfo->versionbuf);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		       card->name,
./drivers/isdn/hardware/avm/b1.c:		ApplId = (unsigned) b1_get_word(card->port);
./drivers/isdn/hardware/avm/b1.c:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/b1.c:		       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/b1.c:			   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/b1.c:			card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/b1.c:				card->name, ApplId, card->msgbuf);
./drivers/isdn/hardware/avm/b1.c:		MsgLen = b1_get_slice(card->port, card->msgbuf);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/b1.c:		       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/b1.c:			   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/b1.c:			card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/b1.c:		printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:		printk(KERN_ERR "%s: card removed ?\n", card->name);
./drivers/isdn/hardware/avm/b1.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1.c:				card->name, b1cmd);
./drivers/isdn/hardware/avm/b1.c:	seq_printf(m, "%-16s %s\n", "name", card->name);
./drivers/isdn/hardware/avm/b1.c:	seq_printf(m, "%-16s 0x%x\n", "io", card->port);
./drivers/isdn/hardware/avm/b1.c:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./drivers/isdn/hardware/avm/b1.c:	switch (card->cardtype) {
./drivers/isdn/hardware/avm/b1.c:	if (card->cardtype == avm_t1isa)
./drivers/isdn/hardware/avm/b1.c:		seq_printf(m, "%-16s %d\n", "cardnr", card->cardnr);
./drivers/isdn/hardware/avm/b1.c:	if (card->cardtype != avm_m1) {
./drivers/isdn/hardware/avm/b1.c:	if (card->cardtype != avm_m1) {
./drivers/isdn/hardware/avm/b1pcmcia.c:	unsigned int port = card->port;
./drivers/isdn/hardware/avm/b1pcmcia.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1pcmcia.c:	cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/b1pcmcia.c:		case avm_m1: sprintf(card->name, "m1-%x", port); break;
./drivers/isdn/hardware/avm/b1pcmcia.c:		case avm_m2: sprintf(card->name, "m2-%x", port); break;
./drivers/isdn/hardware/avm/b1pcmcia.c:		default: sprintf(card->name, "b1pcmcia-%x", port); break;
./drivers/isdn/hardware/avm/b1pcmcia.c:	card->port = port;
./drivers/isdn/hardware/avm/b1pcmcia.c:	card->irq = irq;
./drivers/isdn/hardware/avm/b1pcmcia.c:	card->cardtype = cardtype;
./drivers/isdn/hardware/avm/b1pcmcia.c:	retval = request_irq(card->irq, b1_interrupt, IRQF_SHARED, card->name, card);
./drivers/isdn/hardware/avm/b1pcmcia.c:		       card->irq);
./drivers/isdn/hardware/avm/b1pcmcia.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1pcmcia.c:	if ((retval = b1_detect(card->port, card->cardtype)) != 0) {
./drivers/isdn/hardware/avm/b1pcmcia.c:		       card->port, retval);
./drivers/isdn/hardware/avm/b1pcmcia.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1pcmcia.c:	strcpy(cinfo->capi_ctrl.name, card->name);
./drivers/isdn/hardware/avm/b1pcmcia.c:	       cardname, card->port, card->irq, card->revision);
./drivers/isdn/hardware/avm/b1pcmcia.c:	list_add(&card->list, &cards);
./drivers/isdn/hardware/avm/b1pcmcia.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1pcmcia.c:		cinfo->card ? cinfo->card->port : 0x0,
./drivers/isdn/hardware/avm/b1pcmcia.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hardware/avm/b1pcmcia.c:		cinfo->card ? cinfo->card->revision : 0
./drivers/isdn/hardware/avm/b1pcmcia.c:		if (card->port == port && card->irq == irq) {
./drivers/isdn/hardware/avm/b1pcmcia.c:			b1pcmcia_remove_ctr(&card->ctrlinfo[0].capi_ctrl);
./drivers/isdn/hardware/avm/b1isa.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1isa.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1isa.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1isa.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1isa.c:	cinfo = card->ctrlinfo;
./drivers/isdn/hardware/avm/b1isa.c:	card->port = pci_resource_start(pdev, 0);
./drivers/isdn/hardware/avm/b1isa.c:	card->irq = pdev->irq;
./drivers/isdn/hardware/avm/b1isa.c:	card->cardtype = avm_b1isa;
./drivers/isdn/hardware/avm/b1isa.c:	sprintf(card->name, "b1isa-%x", card->port);
./drivers/isdn/hardware/avm/b1isa.c:	if (   card->port != 0x150 && card->port != 0x250
./drivers/isdn/hardware/avm/b1isa.c:	    && card->port != 0x300 && card->port != 0x340) {
./drivers/isdn/hardware/avm/b1isa.c:		printk(KERN_WARNING "b1isa: invalid port 0x%x.\n", card->port);
./drivers/isdn/hardware/avm/b1isa.c:	if (b1_irq_table[card->irq & 0xf] == 0) {
./drivers/isdn/hardware/avm/b1isa.c:		printk(KERN_WARNING "b1isa: irq %d not valid.\n", card->irq);
./drivers/isdn/hardware/avm/b1isa.c:	if (!request_region(card->port, AVMB1_PORTLEN, card->name)) {
./drivers/isdn/hardware/avm/b1isa.c:		       card->port, card->port + AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1isa.c:	retval = request_irq(card->irq, b1_interrupt, 0, card->name, card);
./drivers/isdn/hardware/avm/b1isa.c:		printk(KERN_ERR "b1isa: unable to get IRQ %d.\n", card->irq);
./drivers/isdn/hardware/avm/b1isa.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1isa.c:	if ((retval = b1_detect(card->port, card->cardtype)) != 0) {
./drivers/isdn/hardware/avm/b1isa.c:		       card->port, retval);
./drivers/isdn/hardware/avm/b1isa.c:	b1_reset(card->port);
./drivers/isdn/hardware/avm/b1isa.c:	strcpy(cinfo->capi_ctrl.name, card->name);
./drivers/isdn/hardware/avm/b1isa.c:	       card->port, card->irq, card->revision);
./drivers/isdn/hardware/avm/b1isa.c:	free_irq(card->irq, card);
./drivers/isdn/hardware/avm/b1isa.c:	release_region(card->port, AVMB1_PORTLEN);
./drivers/isdn/hardware/avm/b1isa.c:		cinfo->card ? cinfo->card->port : 0x0,
./drivers/isdn/hardware/avm/b1isa.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hardware/avm/b1isa.c:		cinfo->card ? cinfo->card->revision : 0
./drivers/isdn/hardware/avm/b1dma.c:	writel(value, card->mbase + off);
./drivers/isdn/hardware/avm/b1dma.c:	return readl(card->mbase + off);
./drivers/isdn/hardware/avm/b1dma.c:		while (   !b1dma_tx_empty(card->port)
./drivers/isdn/hardware/avm/b1dma.c:		if (!b1dma_tx_empty(card->port)) 
./drivers/isdn/hardware/avm/b1dma.c:	        t1outp(card->port, 0x01, *s++);
./drivers/isdn/hardware/avm/b1dma.c:		while (   !b1dma_rx_full(card->port)
./drivers/isdn/hardware/avm/b1dma.c:		if (!b1dma_rx_full(card->port)) 
./drivers/isdn/hardware/avm/b1dma.c:	        *s++ = t1inp(card->port, 0x00);
./drivers/isdn/hardware/avm/b1dma.c:	card->csr = 0x0;
./drivers/isdn/hardware/avm/b1dma.c:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x10, 0x00);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x07, 0x00);
./drivers/isdn/hardware/avm/b1dma.c:	if (card->cardtype == avm_t1pci)
./drivers/isdn/hardware/avm/b1dma.c:	card->csr = 0x0;
./drivers/isdn/hardware/avm/b1dma.c:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x10, 0x00);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x07, 0x00);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x02, 0x02);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x03, 0x02);
./drivers/isdn/hardware/avm/b1dma.c:	if (   (t1inp(card->port, 0x02) & 0xFE) != 0x02
./drivers/isdn/hardware/avm/b1dma.c:	    || t1inp(card->port, 0x3) != 0x03)
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x02, 0x00);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x03, 0x00);
./drivers/isdn/hardware/avm/b1dma.c:	if (   (t1inp(card->port, 0x02) & 0xFE) != 0x00
./drivers/isdn/hardware/avm/b1dma.c:	    || t1inp(card->port, 0x3) != 0x01)
./drivers/isdn/hardware/avm/b1dma.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:	skb_queue_tail(&card->dma->send_queue, skb);
./drivers/isdn/hardware/avm/b1dma.c:	if (!(card->csr & EN_TX_TC_INT)) {
./drivers/isdn/hardware/avm/b1dma.c:		b1dma_writel(card, card->csr, AMCC_INTCSR);
./drivers/isdn/hardware/avm/b1dma.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:	avmcard_dmainfo *dma = card->dma;
./drivers/isdn/hardware/avm/b1dma.c:			printk(KERN_INFO "%s: send ack\n", card->name);
./drivers/isdn/hardware/avm/b1dma.c:	card->csr |= EN_TX_TC_INT;
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:	avmctrl_info *cinfo = &card->ctrlinfo[0];
./drivers/isdn/hardware/avm/b1dma.c:	avmcard_dmainfo *dma = card->dma;
./drivers/isdn/hardware/avm/b1dma.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/b1dma.c:		DataB3Len = _get_slice(&p, card->databuf);
./drivers/isdn/hardware/avm/b1dma.c:			memset(card->msgbuf+MsgLen, 0, 30-MsgLen);
./drivers/isdn/hardware/avm/b1dma.c:			CAPIMSG_SETLEN(card->msgbuf, 30);
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/b1dma.c:			memcpy(skb_put(skb, DataB3Len), card->databuf, DataB3Len);
./drivers/isdn/hardware/avm/b1dma.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:			memcpy(skb_put(skb, MsgLen), card->msgbuf, MsgLen);
./drivers/isdn/hardware/avm/b1dma.c:				spin_lock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:				spin_unlock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:		spin_lock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:		spin_unlock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:			spin_lock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:			spin_unlock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:		printk(KERN_INFO "%s: receive poll\n", card->name);
./drivers/isdn/hardware/avm/b1dma.c:		       card->name,
./drivers/isdn/hardware/avm/b1dma.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/b1dma.c:		card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/b1dma.c:		       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/b1dma.c:			   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/b1dma.c:			card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/b1dma.c:				card->name, ApplId, card->msgbuf);
./drivers/isdn/hardware/avm/b1dma.c:		MsgLen = _get_slice(&p, card->msgbuf);
./drivers/isdn/hardware/avm/b1dma.c:		card->msgbuf[MsgLen] = 0;
./drivers/isdn/hardware/avm/b1dma.c:		       && (   card->msgbuf[MsgLen-1] == '\n'
./drivers/isdn/hardware/avm/b1dma.c:			   || card->msgbuf[MsgLen-1] == '\r')) {
./drivers/isdn/hardware/avm/b1dma.c:			card->msgbuf[MsgLen-1] = 0;
./drivers/isdn/hardware/avm/b1dma.c:		printk(KERN_INFO "%s: DEBUG: %s\n", card->name, card->msgbuf);
./drivers/isdn/hardware/avm/b1dma.c:				card->name, b1cmd);
./drivers/isdn/hardware/avm/b1dma.c:	spin_lock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:		spin_unlock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:        newcsr = card->csr | (status & ALL_INT);
./drivers/isdn/hardware/avm/b1dma.c:		struct avmcard_dmainfo *dma = card->dma;
./drivers/isdn/hardware/avm/b1dma.c:	   	if (card->dma->recvlen == 0) {
./drivers/isdn/hardware/avm/b1dma.c:					card->name, rxlen);
./drivers/isdn/hardware/avm/b1dma.c:			spin_unlock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:			spin_lock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:		if (skb_queue_empty(&card->dma->send_queue))
./drivers/isdn/hardware/avm/b1dma.c:			card->csr &= ~EN_TX_TC_INT;
./drivers/isdn/hardware/avm/b1dma.c:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./drivers/isdn/hardware/avm/b1dma.c:	spin_unlock(&card->lock);
./drivers/isdn/hardware/avm/b1dma.c:	unsigned int base = card->port;
./drivers/isdn/hardware/avm/b1dma.c:				card->name);
./drivers/isdn/hardware/avm/b1dma.c:			printk(KERN_ERR "%s: b1dma_loaded: got 0x%x, firmware not running in dword mode\n", card->name, ans);
./drivers/isdn/hardware/avm/b1dma.c:	printk(KERN_ERR "%s: b1dma_loaded: firmware not running\n", card->name);
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:	_put_word(&p, card->cardnr - 1);
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:		printk(KERN_ERR "%s: failed to load t4file.\n", card->name);
./drivers/isdn/hardware/avm/b1dma.c:	card->csr = AVM_FLAG;
./drivers/isdn/hardware/avm/b1dma.c:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x07, 0x30);
./drivers/isdn/hardware/avm/b1dma.c:	t1outp(card->port, 0x10, 0xF0);
./drivers/isdn/hardware/avm/b1dma.c:	card->dma->recvlen = 0;
./drivers/isdn/hardware/avm/b1dma.c:	b1dma_writel(card, card->dma->recvbuf.dmaaddr, AMCC_RXPTR);
./drivers/isdn/hardware/avm/b1dma.c:	card->csr |= EN_RX_TC_INT;
./drivers/isdn/hardware/avm/b1dma.c:	b1dma_writel(card, card->csr, AMCC_INTCSR);
./drivers/isdn/hardware/avm/b1dma.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:					card->name);
./drivers/isdn/hardware/avm/b1dma.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:	seq_printf(m, "%-16s %s\n", "name", card->name);
./drivers/isdn/hardware/avm/b1dma.c:	seq_printf(m, "%-16s 0x%x\n", "io", card->port);
./drivers/isdn/hardware/avm/b1dma.c:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./drivers/isdn/hardware/avm/b1dma.c:	seq_printf(m, "%-16s 0x%lx\n", "membase", card->membase);
./drivers/isdn/hardware/avm/b1dma.c:	switch (card->cardtype) {
./drivers/isdn/hardware/avm/b1dma.c:	if (card->cardtype != avm_m1) {
./drivers/isdn/hardware/avm/b1dma.c:	if (card->cardtype != avm_m1) {
./drivers/isdn/hardware/avm/b1dma.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:	txoff = (dma_addr_t)b1dma_readl(card, AMCC_TXPTR)-card->dma->sendbuf.dmaaddr;
./drivers/isdn/hardware/avm/b1dma.c:	rxoff = (dma_addr_t)b1dma_readl(card, AMCC_RXPTR)-card->dma->recvbuf.dmaaddr;
./drivers/isdn/hardware/avm/b1dma.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/hardware/avm/b1dma.c:	seq_printf(m, "%-16s 0x%lx\n", "csr (cached)", (unsigned long)card->csr);
./drivers/isdn/sc/packet.c:		sc_adapter[card]->card->rcvcallb_skb(sc_adapter[card]->driverId,
./drivers/isdn/sc/event.c:	return sc_adapter[card]->card->statcallb(&cmd);
./drivers/isdn/hysdn/hysdn_sched.c:			if (hynet_enable & (1 << card->myid)) {
./drivers/isdn/hysdn/hysdn_sched.c:			if (card->err_log_state == ERRLOG_STATE_ON)
./drivers/isdn/hysdn/hysdn_sched.c:				card->err_log_state = ERRLOG_STATE_START;	/* start new fetch */
./drivers/isdn/hysdn/hysdn_sched.c:			if (hycapi_enable & (1 << card->myid)) {
./drivers/isdn/hysdn/hysdn_sched.c:	if (card->net_tx_busy) {
./drivers/isdn/hysdn/hysdn_sched.c:		card->net_tx_busy = 0;	/* reset flag */
./drivers/isdn/hysdn/hysdn_sched.c:	if (card->async_busy) {
./drivers/isdn/hysdn/hysdn_sched.c:		if (card->async_len <= maxlen) {
./drivers/isdn/hysdn/hysdn_sched.c:			memcpy(buf, card->async_data, card->async_len);
./drivers/isdn/hysdn/hysdn_sched.c:			*len = card->async_len;
./drivers/isdn/hysdn/hysdn_sched.c:			*chan = card->async_channel;
./drivers/isdn/hysdn/hysdn_sched.c:			card->async_busy = 0;	/* reset request */
./drivers/isdn/hysdn/hysdn_sched.c:		card->async_busy = 0;	/* in case of length error */
./drivers/isdn/hysdn/hysdn_sched.c:	if ((card->err_log_state == ERRLOG_STATE_START) &&
./drivers/isdn/hysdn/hysdn_sched.c:		card->err_log_state = ERRLOG_STATE_ON;	/* new state is on */
./drivers/isdn/hysdn/hysdn_sched.c:	if ((card->err_log_state == ERRLOG_STATE_STOP) &&
./drivers/isdn/hysdn/hysdn_sched.c:		card->err_log_state = ERRLOG_STATE_OFF;		/* new state is off */
./drivers/isdn/hysdn/hysdn_sched.c:	if ((hynet_enable & (1 << card->myid)) && 
./drivers/isdn/hysdn/hysdn_sched.c:			card->net_tx_busy = 1;	/* we are busy sending network data */
./drivers/isdn/hysdn/hysdn_sched.c:	if( ((hycapi_enable & (1 << card->myid))) && 
./drivers/isdn/hysdn/hysdn_sched.c:	if (card->debug_flags & LOG_SCHED_ASYN)
./drivers/isdn/hysdn/hysdn_sched.c:	while (card->async_busy) {
./drivers/isdn/hysdn/hysdn_sched.c:		if (card->debug_flags & LOG_SCHED_ASYN)
./drivers/isdn/hysdn/hysdn_sched.c:	spin_lock_irqsave(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/hysdn_sched.c:	strcpy(card->async_data, line);
./drivers/isdn/hysdn/hysdn_sched.c:	card->async_len = strlen(line) + 1;
./drivers/isdn/hysdn/hysdn_sched.c:	card->async_channel = chan;
./drivers/isdn/hysdn/hysdn_sched.c:	card->async_busy = 1;	/* request transfer */
./drivers/isdn/hysdn/hysdn_sched.c:	schedule_work(&card->irq_queue);
./drivers/isdn/hysdn/hysdn_sched.c:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/hysdn_sched.c:	if (card->debug_flags & LOG_SCHED_ASYN)
./drivers/isdn/hysdn/hysdn_sched.c:	while (card->async_busy) {
./drivers/isdn/hysdn/hysdn_sched.c:		if (card->debug_flags & LOG_SCHED_ASYN)
./drivers/isdn/hysdn/hysdn_sched.c:	if (card->debug_flags & LOG_SCHED_ASYN)
./drivers/isdn/hysdn/hysdn_net.c:	if (!card->mac_addr[0]) {
./drivers/isdn/hysdn/hysdn_net.c:		memcpy(dev->dev_addr, card->mac_addr, ETH_ALEN);
./drivers/isdn/hysdn/hysdn_net.c:	struct net_local *lp = card->netif;
./drivers/isdn/hysdn/hysdn_net.c:	struct net_local *lp = card->netif;
./drivers/isdn/hysdn/hysdn_net.c:	struct net_local *lp = card->netif;
./drivers/isdn/hysdn/hysdn_net.c:		printk(KERN_WARNING "No card-pt in hysdn_net_create!\n");
./drivers/isdn/hysdn/hysdn_net.c:	dev->base_addr = card->iobase;	/* IO address */
./drivers/isdn/hysdn/hysdn_net.c:	dev->irq = card->irq;	/* irq */
./drivers/isdn/hysdn/hysdn_net.c:	card->netif = dev;	/* setup the local pointer */
./drivers/isdn/hysdn/hysdn_net.c:	if (card->debug_flags & LOG_NET_INIT)
./drivers/isdn/hysdn/hysdn_net.c:	struct net_device *dev = card->netif;
./drivers/isdn/hysdn/hysdn_net.c:	card->netif = NULL;	/* clear out pointer */
./drivers/isdn/hysdn/hysdn_net.c:	if (card->debug_flags & LOG_NET_INIT)
./drivers/isdn/hysdn/hysdn_net.c:	struct net_device *dev = card->netif;
./drivers/isdn/hysdn/hysdn_proclog.c:	struct procdata *pd = card->proclog;
./drivers/isdn/hysdn/hysdn_proclog.c:	cp += sprintf(cp, "HYSDN: card %d ", card->myid);
./drivers/isdn/hysdn/hysdn_proclog.c:	if (card->debug_flags & DEB_OUT_SYSLOG)
./drivers/isdn/hysdn/hysdn_proclog.c:	struct procdata *pd = card->proclog;
./drivers/isdn/hysdn/hysdn_proclog.c:	spin_lock_irqsave(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/hysdn_proclog.c:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/hysdn_proclog.c:	rc = kstrtoul(valbuf, 0, &card->debug_flags);
./drivers/isdn/hysdn/hysdn_proclog.c:	hysdn_addlog(card, "debug set to 0x%lx", card->debug_flags);
./drivers/isdn/hysdn/hysdn_proclog.c:			pd = card->proclog;
./drivers/isdn/hysdn/hysdn_proclog.c:			card = card->next;	/* search next entry */
./drivers/isdn/hysdn/hysdn_proclog.c:		pd = card->proclog;
./drivers/isdn/hysdn/hysdn_proclog.c:		card = card->next;	/* search next entry */
./drivers/isdn/hysdn/hysdn_proclog.c:		spin_lock_irqsave(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/hysdn_proclog.c:		spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/hysdn_proclog.c:				pd = card->proclog;
./drivers/isdn/hysdn/hysdn_proclog.c:				card = card->next;	/* search next entry */
./drivers/isdn/hysdn/hysdn_proclog.c:				pd = card->proclog;	/* pointer to procfs log */
./drivers/isdn/hysdn/hysdn_proclog.c:		pd = card->proclog;
./drivers/isdn/hysdn/hysdn_proclog.c:		card = card->next;	/* search next entry */
./drivers/isdn/hysdn/hysdn_proclog.c:		sprintf(pd->log_name, "%s%d", PROC_LOG_BASENAME, card->myid);
./drivers/isdn/hysdn/hysdn_proclog.c:		card->proclog = (void *) pd;	/* remember procfs structure */
./drivers/isdn/hysdn/hysdn_proclog.c:	if ((pd = (struct procdata *) card->proclog) != NULL) {
./drivers/isdn/hysdn/hysdn_proclog.c:		card->proclog = NULL;
./drivers/isdn/hysdn/hysdn_procconf.c:	if (cnf->card->debug_flags & LOG_CNF_LINE)
./drivers/isdn/hysdn/hysdn_procconf.c:			if (cnf->card->debug_flags & LOG_CNF_MISC)
./drivers/isdn/hysdn/hysdn_procconf.c:		if (cnf->card->debug_flags & LOG_CNF_DATA)
./drivers/isdn/hysdn/hysdn_procconf.c:			if (cnf->card->state != CARD_STATE_RUN)
./drivers/isdn/hysdn/hysdn_procconf.c:				cnf->card->state = CARD_STATE_BOOTERR;	/* show boot error */
./drivers/isdn/hysdn/hysdn_procconf.c:		if (cnf->card->state != CARD_STATE_RUN) {
./drivers/isdn/hysdn/hysdn_procconf.c:			if (cnf->card->debug_flags & LOG_CNF_MISC)
./drivers/isdn/hysdn/hysdn_procconf.c:					if (cnf->card->debug_flags & LOG_CNF_MISC)
./drivers/isdn/hysdn/hysdn_procconf.c:			if (cnf->card->debug_flags & LOG_CNF_MISC)
./drivers/isdn/hysdn/hysdn_procconf.c:		pd = card->procconf;
./drivers/isdn/hysdn/hysdn_procconf.c:		card = card->next;	/* search next entry */
./drivers/isdn/hysdn/hysdn_procconf.c:	if (card->debug_flags & (LOG_PROC_OPEN | LOG_PROC_ALL))
./drivers/isdn/hysdn/hysdn_procconf.c:			card->myid,
./drivers/isdn/hysdn/hysdn_procconf.c:			card->bus,
./drivers/isdn/hysdn/hysdn_procconf.c:			PCI_SLOT(card->devfn),
./drivers/isdn/hysdn/hysdn_procconf.c:			card->brdtype,
./drivers/isdn/hysdn/hysdn_procconf.c:			card->irq,
./drivers/isdn/hysdn/hysdn_procconf.c:			card->iobase,
./drivers/isdn/hysdn/hysdn_procconf.c:			card->membase,
./drivers/isdn/hysdn/hysdn_procconf.c:			card->bchans,
./drivers/isdn/hysdn/hysdn_procconf.c:			card->faxchans,
./drivers/isdn/hysdn/hysdn_procconf.c:			card->state,
./drivers/isdn/hysdn/hysdn_procconf.c:		pd = card->procconf;
./drivers/isdn/hysdn/hysdn_procconf.c:		card = card->next;	/* search next entry */
./drivers/isdn/hysdn/hysdn_procconf.c:	if (card->debug_flags & (LOG_PROC_OPEN | LOG_PROC_ALL))
./drivers/isdn/hysdn/hysdn_procconf.c:		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
./drivers/isdn/hysdn/hysdn_procconf.c:		if ((card->procconf = (void *) proc_create(conf_name,
./drivers/isdn/hysdn/hysdn_procconf.c:		card = card->next;	/* next entry */
./drivers/isdn/hysdn/hysdn_procconf.c:		sprintf(conf_name, "%s%d", PROC_CONF_BASENAME, card->myid);
./drivers/isdn/hysdn/hysdn_procconf.c:		if (card->procconf)
./drivers/isdn/hysdn/hysdn_procconf.c:		card = card->next;	/* point to next card */
./drivers/isdn/hysdn/boardergo.c:	if (!card->irq_enabled)
./drivers/isdn/hysdn/boardergo.c:	spin_lock_irqsave(&card->hysdn_lock, flags); /* no further irqs allowed */
./drivers/isdn/hysdn/boardergo.c:	if (!(bytein(card->iobase + PCI9050_INTR_REG) & PCI9050_INTR_REG_STAT1)) {
./drivers/isdn/hysdn/boardergo.c:		spin_unlock_irqrestore(&card->hysdn_lock, flags);	/* restore old state */
./drivers/isdn/hysdn/boardergo.c:	dpr = card->dpram;
./drivers/isdn/hysdn/boardergo.c:	if (!card->hw_lock)
./drivers/isdn/hysdn/boardergo.c:		schedule_work(&card->irq_queue);
./drivers/isdn/hysdn/boardergo.c:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:	if (card->state != CARD_STATE_RUN)
./drivers/isdn/hysdn/boardergo.c:	dpr = card->dpram;	/* point to DPRAM */
./drivers/isdn/hysdn/boardergo.c:	spin_lock_irqsave(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:	if (card->hw_lock) {
./drivers/isdn/hysdn/boardergo.c:		spin_unlock_irqrestore(&card->hysdn_lock, flags);	/* hardware currently unavailable */
./drivers/isdn/hysdn/boardergo.c:	card->hw_lock = 1;	/* we now lock the hardware */
./drivers/isdn/hysdn/boardergo.c:			card->hw_lock = 0;	/* free hardware again */
./drivers/isdn/hysdn/boardergo.c:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:	spin_lock_irqsave(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:	val = bytein(card->iobase + PCI9050_INTR_REG);	/* get actual value */
./drivers/isdn/hysdn/boardergo.c:	byteout(card->iobase + PCI9050_INTR_REG, val);
./drivers/isdn/hysdn/boardergo.c:	card->irq_enabled = 0;
./drivers/isdn/hysdn/boardergo.c:	byteout(card->iobase + PCI9050_USER_IO, PCI9050_E1_RESET);	/* reset E1 processor */
./drivers/isdn/hysdn/boardergo.c:	card->state = CARD_STATE_UNUSED;
./drivers/isdn/hysdn/boardergo.c:	card->err_log_state = ERRLOG_STATE_OFF;		/* currently no log active */
./drivers/isdn/hysdn/boardergo.c:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:	if (card->state != CARD_STATE_RUN) {
./drivers/isdn/hysdn/boardergo.c:		card->err_log_state = ERRLOG_STATE_OFF;		/* must be off */
./drivers/isdn/hysdn/boardergo.c:	spin_lock_irqsave(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:	if (((card->err_log_state == ERRLOG_STATE_OFF) && !on) ||
./drivers/isdn/hysdn/boardergo.c:	    ((card->err_log_state == ERRLOG_STATE_ON) && on)) {
./drivers/isdn/hysdn/boardergo.c:		spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:		card->err_log_state = ERRLOG_STATE_START;	/* request start */
./drivers/isdn/hysdn/boardergo.c:		card->err_log_state = ERRLOG_STATE_STOP;	/* request stop */
./drivers/isdn/hysdn/boardergo.c:	spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:	schedule_work(&card->irq_queue);
./drivers/isdn/hysdn/boardergo.c:	tErgDpram *dpr = card->dpram;
./drivers/isdn/hysdn/boardergo.c:	if (card->debug_flags & LOG_POF_CARD)
./drivers/isdn/hysdn/boardergo.c:	dst = card->dpram;	/* pointer to start of DPRAM */
./drivers/isdn/hysdn/boardergo.c:		memset(card->dpram, 0, ERG_DPRAM_FILL_SIZE);	/* fill the DPRAM still not cleared */
./drivers/isdn/hysdn/boardergo.c:		dpram = card->dpram;	/* get pointer to dpram structure */
./drivers/isdn/hysdn/boardergo.c:		byteout(card->iobase + PCI9050_USER_IO, PCI9050_E1_RUN);	/* start E1 processor */
./drivers/isdn/hysdn/boardergo.c:		if (((tDpramBootSpooler *) card->dpram)->Len != DPRAM_SPOOLER_DATA_SIZE) {
./drivers/isdn/hysdn/boardergo.c:			if (card->debug_flags & LOG_POF_CARD)
./drivers/isdn/hysdn/boardergo.c:	tDpramBootSpooler *sp = (tDpramBootSpooler *) card->dpram;
./drivers/isdn/hysdn/boardergo.c:	if (card->debug_flags & LOG_POF_CARD)
./drivers/isdn/hysdn/boardergo.c:			if (card->debug_flags & LOG_POF_CARD)
./drivers/isdn/hysdn/boardergo.c:	tErgDpram *dpr = card->dpram;	/* pointer to DPRAM structure */
./drivers/isdn/hysdn/boardergo.c:	if (card->debug_flags & LOG_POF_CARD)
./drivers/isdn/hysdn/boardergo.c:			if (card->debug_flags & LOG_POF_RECORD)
./drivers/isdn/hysdn/boardergo.c:			spin_lock_irqsave(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:			card->state = CARD_STATE_RUN;	/* now card is running */
./drivers/isdn/hysdn/boardergo.c:			byteout(card->iobase + PCI9050_INTR_REG,
./drivers/isdn/hysdn/boardergo.c:				bytein(card->iobase + PCI9050_INTR_REG) |
./drivers/isdn/hysdn/boardergo.c:			card->irq_enabled = 1;	/* we are ready to receive interrupts */
./drivers/isdn/hysdn/boardergo.c:			spin_unlock_irqrestore(&card->hysdn_lock, flags);
./drivers/isdn/hysdn/boardergo.c:			if ((hynet_enable & (1 << card->myid)) 
./drivers/isdn/hysdn/boardergo.c:				card->state = CARD_STATE_BOOTERR;
./drivers/isdn/hysdn/boardergo.c:	if (card->debug_flags & LOG_POF_CARD)
./drivers/isdn/hysdn/boardergo.c:	free_irq(card->irq, card);	/* release interrupt */
./drivers/isdn/hysdn/boardergo.c:	release_region(card->iobase + PCI9050_INTR_REG, 1);	/* release all io ports */
./drivers/isdn/hysdn/boardergo.c:	release_region(card->iobase + PCI9050_USER_IO, 1);
./drivers/isdn/hysdn/boardergo.c:	iounmap(card->dpram);
./drivers/isdn/hysdn/boardergo.c:	card->dpram = NULL;	/* release shared mem */
./drivers/isdn/hysdn/boardergo.c:	if (!request_region(card->iobase + PCI9050_INTR_REG, 1, "HYSDN")) 
./drivers/isdn/hysdn/boardergo.c:	if (!request_region(card->iobase + PCI9050_USER_IO, 1, "HYSDN")) {
./drivers/isdn/hysdn/boardergo.c:		release_region(card->iobase + PCI9050_INTR_REG, 1);
./drivers/isdn/hysdn/boardergo.c:	card->memend = card->membase + ERG_DPRAM_PAGE_SIZE - 1;
./drivers/isdn/hysdn/boardergo.c:	if (!(card->dpram = ioremap(card->membase, ERG_DPRAM_PAGE_SIZE))) {
./drivers/isdn/hysdn/boardergo.c:		release_region(card->iobase + PCI9050_INTR_REG, 1);
./drivers/isdn/hysdn/boardergo.c:		release_region(card->iobase + PCI9050_USER_IO, 1);
./drivers/isdn/hysdn/boardergo.c:	if (request_irq(card->irq, ergo_interrupt, IRQF_SHARED, "HYSDN", card)) {
./drivers/isdn/hysdn/boardergo.c:	card->stopcard = ergo_stopcard;
./drivers/isdn/hysdn/boardergo.c:	card->releasehardware = ergo_releasehardware;
./drivers/isdn/hysdn/boardergo.c:	card->testram = ergo_testram;
./drivers/isdn/hysdn/boardergo.c:	card->writebootimg = ergo_writebootimg;
./drivers/isdn/hysdn/boardergo.c:	card->writebootseq = ergo_writebootseq;
./drivers/isdn/hysdn/boardergo.c:	card->waitpofready = ergo_waitpofready;
./drivers/isdn/hysdn/boardergo.c:	card->set_errlog_state = ergo_set_errlog_state;
./drivers/isdn/hysdn/boardergo.c:	INIT_WORK(&card->irq_queue, ergo_irq_bh);
./drivers/isdn/hysdn/boardergo.c:	spin_lock_init(&card->hysdn_lock);
./drivers/isdn/hysdn/hysdn_boot.c:	struct boot_data *boot = card->boot;	/* pointer to boot specific data */
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_RECORD)
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_RECORD)
./drivers/isdn/hysdn/hysdn_boot.c:				     card->writebootimg(card, imgp,
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_RECORD)
./drivers/isdn/hysdn/hysdn_boot.c:			if ((boot->last_error = card->writebootseq(card, boot->buf.BootBuf, datlen)) < 0)
./drivers/isdn/hysdn/hysdn_boot.c:				return (card->waitpofready(card));	/* data completely spooled, wait for ready */
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_RECORD)
./drivers/isdn/hysdn/hysdn_boot.c:	struct boot_data *boot = card->boot;	/* pointer to boot specific data */
./drivers/isdn/hysdn/hysdn_boot.c:	if (card->debug_flags & LOG_POF_WRITE)
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_WRITE)
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_WRITE)
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_RECORD)
./drivers/isdn/hysdn/hysdn_boot.c:			if (card->debug_flags & LOG_POF_WRITE)
./drivers/isdn/hysdn/hysdn_boot.c:	if (card->boot) {
./drivers/isdn/hysdn/hysdn_boot.c:		if (card->debug_flags & LOG_POF_OPEN)
./drivers/isdn/hysdn/hysdn_boot.c:		if (card->debug_flags & LOG_MEM_ERR)
./drivers/isdn/hysdn/hysdn_boot.c:	card->boot = boot;
./drivers/isdn/hysdn/hysdn_boot.c:	card->state = CARD_STATE_BOOTING;
./drivers/isdn/hysdn/hysdn_boot.c:	card->stopcard(card);	/* first stop the card */
./drivers/isdn/hysdn/hysdn_boot.c:	if (card->testram(card)) {
./drivers/isdn/hysdn/hysdn_boot.c:		if (card->debug_flags & LOG_POF_OPEN)
./drivers/isdn/hysdn/hysdn_boot.c:		card->state = CARD_STATE_BOOTERR;	/* show boot error */
./drivers/isdn/hysdn/hysdn_boot.c:	if (card->debug_flags & LOG_POF_OPEN)
./drivers/isdn/hysdn/hysdn_boot.c:	struct boot_data *boot = card->boot;	/* pointer to boot specific data */
./drivers/isdn/hysdn/hysdn_boot.c:	card->boot = NULL;	/* no boot active */
./drivers/isdn/hysdn/hysdn_boot.c:	if (card->state == CARD_STATE_RUN)
./drivers/isdn/hysdn/hysdn_boot.c:		card->set_errlog_state(card, 1);	/* activate error log */
./drivers/isdn/hysdn/hysdn_boot.c:	if (card->debug_flags & LOG_POF_OPEN)
./drivers/isdn/hysdn/hysdn_boot.c:	if (card->debug_flags & LOG_POF_RECORD)
./drivers/isdn/hysdn/hysdn_boot.c:				card->bchans = *(cp + 2);
./drivers/isdn/hysdn/hysdn_boot.c:				card->faxchans = *(cp + 2);
./drivers/isdn/hysdn/hysdn_boot.c:				memcpy(card->mac_addr, cp + 2, 6);
./drivers/isdn/hysdn/hycapi.c:	kfree(card->hyctrlinfo);
./drivers/isdn/hysdn/hycapi.c:	card->hyctrlinfo = NULL;
./drivers/isdn/hysdn/hycapi.c:		       card->myid);	
./drivers/isdn/hysdn/hycapi.c:	schedule_work(&card->irq_queue);
./drivers/isdn/hysdn/hycapi.c:		       card->myid);
./drivers/isdn/hysdn/hycapi.c:		MaxLogicalConnections = card->bchans * -MaxLogicalConnections; 
./drivers/isdn/hysdn/hycapi.c:		MaxLogicalConnections = card->bchans;
./drivers/isdn/hysdn/hycapi.c:		       card->myid);
./drivers/isdn/hysdn/hycapi.c:	hycapictrl_info *cinfo = card->hyctrlinfo;
./drivers/isdn/hysdn/hycapi.c:	hycapictrl_info *cinfo = card->hyctrlinfo;
./drivers/isdn/hysdn/hycapi.c:	seq_printf(m, "%-16s 0x%x\n", "io", card->iobase);
./drivers/isdn/hysdn/hycapi.c:	seq_printf(m, "%-16s %d\n", "irq", card->irq);
./drivers/isdn/hysdn/hycapi.c:	switch (card->brdtype) {
./drivers/isdn/hysdn/hycapi.c:		cinfo->card ? cinfo->card->iobase : 0x0,
./drivers/isdn/hysdn/hycapi.c:		cinfo->card ? cinfo->card->irq : 0,
./drivers/isdn/hysdn/hycapi.c:	hycapictrl_info *cinfo = card->hyctrlinfo;
./drivers/isdn/hysdn/hycapi.c:		       card->myid, len);
./drivers/isdn/hysdn/hycapi.c:			       card->myid);
./drivers/isdn/hysdn/hycapi.c:			       card->myid);
./drivers/isdn/hysdn/hycapi.c:					       "protocol. NCPI ignored.\n", card->myid);
./drivers/isdn/hysdn/hycapi.c:					       " current state\n", card->myid);
./drivers/isdn/hysdn/hycapi.c:					printk(KERN_ERR "HYSDN Card%d: invalid PLCI\n", card->myid);
./drivers/isdn/hysdn/hycapi.c:					printk(KERN_ERR "HYSDN Card%d: out of NCCI\n", card->myid);
./drivers/isdn/hysdn/hycapi.c:					       card->myid);
./drivers/isdn/hysdn/hycapi.c:					       card->myid, info);
./drivers/isdn/hysdn/hycapi.c:	hycapictrl_info *cinfo = card->hyctrlinfo;
./drivers/isdn/hysdn/hycapi.c:	hycapictrl_info *cinfo = card->hyctrlinfo;
./drivers/isdn/hysdn/hycapi.c:	cinfo = card->hyctrlinfo;
./drivers/isdn/hysdn/hycapi.c:	ctrl->profile.ncontroller = card->myid;
./drivers/isdn/hysdn/hycapi.c:	ctrl->profile.nbchannel = card->bchans;
./drivers/isdn/hysdn/hycapi.c:		(card->faxchans ? B1_PROT_T30 : 0) |
./drivers/isdn/hysdn/hycapi.c:		(card->faxchans ? B2_PROT_T30 : 0) |
./drivers/isdn/hysdn/hycapi.c:		(card->faxchans ? B3_PROT_T30 : 0) |
./drivers/isdn/hysdn/hycapi.c:		(card->faxchans ? B3_PROT_T30EXT : 0) |
./drivers/isdn/hysdn/hycapi.c:	if((hycapi_enable & (1 << card->myid)) == 0) {
./drivers/isdn/hysdn/hycapi.c:	if (!card->hyctrlinfo) {
./drivers/isdn/hysdn/hycapi.c:		card->hyctrlinfo = cinfo;
./drivers/isdn/hysdn/hycapi.c:		switch (card->brdtype) {
./drivers/isdn/hysdn/hycapi.c:		ctrl = &card->hyctrlinfo->capi_ctrl;
./drivers/isdn/hysdn/hysdn_init.c:	card->myid = cardmax;	/* set own id */
./drivers/isdn/hysdn/hysdn_init.c:	card->bus = akt_pcidev->bus->number;
./drivers/isdn/hysdn/hysdn_init.c:	card->devfn = akt_pcidev->devfn;	/* slot + function */
./drivers/isdn/hysdn/hysdn_init.c:	card->subsysid = akt_pcidev->subsystem_device;
./drivers/isdn/hysdn/hysdn_init.c:	card->irq = akt_pcidev->irq;
./drivers/isdn/hysdn/hysdn_init.c:	card->iobase = pci_resource_start(akt_pcidev, PCI_REG_PLX_IO_BASE);
./drivers/isdn/hysdn/hysdn_init.c:	card->plxbase = pci_resource_start(akt_pcidev, PCI_REG_PLX_MEM_BASE);
./drivers/isdn/hysdn/hysdn_init.c:	card->membase = pci_resource_start(akt_pcidev, PCI_REG_MEMORY_BASE);
./drivers/isdn/hysdn/hysdn_init.c:	card->brdtype = BD_NONE;	/* unknown */
./drivers/isdn/hysdn/hysdn_init.c:	card->debug_flags = DEF_DEB_FLAGS;	/* set default debug */
./drivers/isdn/hysdn/hysdn_init.c:	card->faxchans = 0;	/* default no fax channels */
./drivers/isdn/hysdn/hysdn_init.c:	card->bchans = 2;	/* and 2 b-channels */
./drivers/isdn/hysdn/hysdn_init.c:	card->brdtype = ent->driver_data;
./drivers/isdn/hysdn/hysdn_init.c:		printk(KERN_WARNING "HYSDN: card at io 0x%04x already in use\n", card->iobase);
./drivers/isdn/hysdn/hysdn_init.c:	card->next = NULL;	/*end of chain */
./drivers/isdn/hysdn/hysdn_init.c:	if (card->stopcard)
./drivers/isdn/hysdn/hysdn_init.c:		card->stopcard(card);
./drivers/isdn/hysdn/hysdn_init.c:	if (card->releasehardware)
./drivers/isdn/hysdn/hysdn_init.c:		card->releasehardware(card);   /* free all hardware resources */
./drivers/isdn/hysdn/hysdn_init.c:				tmp->next = card->next;
./drivers/isdn/isdnloop/isdnloop.c:	struct sk_buff_head *queue = &card->bqueue[channel];
./drivers/isdn/isdnloop/isdnloop.c:	card->sndcount[channel] = 0;
./drivers/isdn/isdnloop/isdnloop.c:	isdnloop_card *rcard = card->rcard[ch];
./drivers/isdn/isdnloop/isdnloop.c:	int rch = card->rch[ch], len, ack;
./drivers/isdn/isdnloop/isdnloop.c:	while (card->sndcount[ch]) {
./drivers/isdn/isdnloop/isdnloop.c:		if ((skb = skb_dequeue(&card->bqueue[ch]))) {
./drivers/isdn/isdnloop/isdnloop.c:			card->sndcount[ch] -= len;
./drivers/isdn/isdnloop/isdnloop.c:			cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:				rcard->interface.rcvcallb_skb(rcard->myid, rch, skb);
./drivers/isdn/isdnloop/isdnloop.c:			card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:			card->sndcount[ch] = 0;
./drivers/isdn/isdnloop/isdnloop.c:	if (card->flags & ISDNLOOP_FLAGS_B1ACTIVE)
./drivers/isdn/isdnloop/isdnloop.c:	if (card->flags & ISDNLOOP_FLAGS_B2ACTIVE)
./drivers/isdn/isdnloop/isdnloop.c:	if (card->flags & (ISDNLOOP_FLAGS_B1ACTIVE | ISDNLOOP_FLAGS_B2ACTIVE)) {
./drivers/isdn/isdnloop/isdnloop.c:		spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:		card->rb_timer.expires = jiffies + ISDNLOOP_TIMER_BCREAD;
./drivers/isdn/isdnloop/isdnloop.c:		add_timer(&card->rb_timer);
./drivers/isdn/isdnloop/isdnloop.c:		card->flags |= ISDNLOOP_FLAGS_RBTIMER;
./drivers/isdn/isdnloop/isdnloop.c:		spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:		card->flags &= ~ISDNLOOP_FLAGS_RBTIMER;
./drivers/isdn/isdnloop/isdnloop.c:	cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:			card->flags |= (channel) ?
./drivers/isdn/isdnloop/isdnloop.c:			card->flags &= ~((channel) ?
./drivers/isdn/isdnloop/isdnloop.c:			sprintf(cmd.parm.setup.phone, "LEASED%d", card->myid);
./drivers/isdn/isdnloop/isdnloop.c:			card->flags &= ~ISDNLOOP_FLAGS_B1ACTIVE;
./drivers/isdn/isdnloop/isdnloop.c:			cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:			card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:			cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:			card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:			card->flags &= ~ISDNLOOP_FLAGS_B2ACTIVE;
./drivers/isdn/isdnloop/isdnloop.c:			cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:			card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:			cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	*card->msg_buf_write++ = (c == 0xff) ? '\n' : c;
./drivers/isdn/isdnloop/isdnloop.c:	if (card->msg_buf_write == card->msg_buf_read) {
./drivers/isdn/isdnloop/isdnloop.c:		if (++card->msg_buf_read > card->msg_buf_end)
./drivers/isdn/isdnloop/isdnloop.c:			card->msg_buf_read = card->msg_buf;
./drivers/isdn/isdnloop/isdnloop.c:	if (card->msg_buf_write > card->msg_buf_end)
./drivers/isdn/isdnloop/isdnloop.c:		card->msg_buf_write = card->msg_buf;
./drivers/isdn/isdnloop/isdnloop.c:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	if ((skb = skb_dequeue(&card->dqueue)))
./drivers/isdn/isdnloop/isdnloop.c:		card->imsg[card->iptr] = c;
./drivers/isdn/isdnloop/isdnloop.c:		if (card->iptr < 59)
./drivers/isdn/isdnloop/isdnloop.c:			card->iptr++;
./drivers/isdn/isdnloop/isdnloop.c:			card->imsg[card->iptr] = 0;
./drivers/isdn/isdnloop/isdnloop.c:			card->iptr = 0;
./drivers/isdn/isdnloop/isdnloop.c:			if (card->imsg[0] == '0' && card->imsg[1] >= '0' &&
./drivers/isdn/isdnloop/isdnloop.c:			  card->imsg[1] <= '2' && card->imsg[2] == ';') {
./drivers/isdn/isdnloop/isdnloop.c:				ch = (card->imsg[1] - '0') - 1;
./drivers/isdn/isdnloop/isdnloop.c:				p = &card->imsg[3];
./drivers/isdn/isdnloop/isdnloop.c:				p = card->imsg;
./drivers/isdn/isdnloop/isdnloop.c:						card->ptype = ISDN_PTYPE_1TR6;
./drivers/isdn/isdnloop/isdnloop.c:						card->interface.features |= ISDN_FEATURE_P_1TR6;
./drivers/isdn/isdnloop/isdnloop.c:						card->ptype = ISDN_PTYPE_EURO;
./drivers/isdn/isdnloop/isdnloop.c:						card->interface.features |= ISDN_FEATURE_P_EURO;
./drivers/isdn/isdnloop/isdnloop.c:		cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:		card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:	if (card->flags & (ISDNLOOP_FLAGS_B1ACTIVE | ISDNLOOP_FLAGS_B2ACTIVE))
./drivers/isdn/isdnloop/isdnloop.c:		if (!(card->flags & ISDNLOOP_FLAGS_RBTIMER)) {
./drivers/isdn/isdnloop/isdnloop.c:			card->flags |= ISDNLOOP_FLAGS_RBTIMER;
./drivers/isdn/isdnloop/isdnloop.c:			spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:			del_timer(&card->rb_timer);
./drivers/isdn/isdnloop/isdnloop.c:			card->rb_timer.function = isdnloop_pollbchan;
./drivers/isdn/isdnloop/isdnloop.c:			card->rb_timer.data = (unsigned long) card;
./drivers/isdn/isdnloop/isdnloop.c:			card->rb_timer.expires = jiffies + ISDNLOOP_TIMER_BCREAD;
./drivers/isdn/isdnloop/isdnloop.c:			add_timer(&card->rb_timer);
./drivers/isdn/isdnloop/isdnloop.c:			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	card->st_timer.expires = jiffies + ISDNLOOP_TIMER_DCREAD;
./drivers/isdn/isdnloop/isdnloop.c:	add_timer(&card->st_timer);
./drivers/isdn/isdnloop/isdnloop.c:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c: *   card    = pointer to card-struct
./drivers/isdn/isdnloop/isdnloop.c:		if (!(card->flags & (channel) ? ISDNLOOP_FLAGS_B2ACTIVE : ISDNLOOP_FLAGS_B1ACTIVE))
./drivers/isdn/isdnloop/isdnloop.c:		if (card->sndcount[channel] > ISDNLOOP_MAX_SQUEUE)
./drivers/isdn/isdnloop/isdnloop.c:		spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:			skb_queue_tail(&card->bqueue[channel], nskb);
./drivers/isdn/isdnloop/isdnloop.c:		card->sndcount[channel] += len;
./drivers/isdn/isdnloop/isdnloop.c:		spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:		if (card->msg_buf_read == card->msg_buf_write)
./drivers/isdn/isdnloop/isdnloop.c:		if (put_user(*card->msg_buf_read++, p))
./drivers/isdn/isdnloop/isdnloop.c:		if (card->msg_buf_read > card->msg_buf_end)
./drivers/isdn/isdnloop/isdnloop.c:			card->msg_buf_read = card->msg_buf;
./drivers/isdn/isdnloop/isdnloop.c:	skb_queue_tail(&card->dqueue, skb);
./drivers/isdn/isdnloop/isdnloop.c:	sprintf(buf, "E%s", card->omsg);
./drivers/isdn/isdnloop/isdnloop.c:	switch (card->ptype) {
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	if (card->rcard) {
./drivers/isdn/isdnloop/isdnloop.c:		isdnloop_fake(card->rcard[ch], "DDIS_I", card->rch[ch] + 1);
./drivers/isdn/isdnloop/isdnloop.c:		card->rcard[ch]->rcard[card->rch[ch]] = NULL;
./drivers/isdn/isdnloop/isdnloop.c:		card->rcard[ch] = NULL;
./drivers/isdn/isdnloop/isdnloop.c:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	init_timer(&card->c_timer[ch]);
./drivers/isdn/isdnloop/isdnloop.c:	card->c_timer[ch].expires = jiffies + ISDNLOOP_TIMER_ALERTWAIT;
./drivers/isdn/isdnloop/isdnloop.c:		card->c_timer[ch].function = isdnloop_atimeout1;
./drivers/isdn/isdnloop/isdnloop.c:		card->c_timer[ch].function = isdnloop_atimeout0;
./drivers/isdn/isdnloop/isdnloop.c:	card->c_timer[ch].data = (unsigned long) card;
./drivers/isdn/isdnloop/isdnloop.c:	add_timer(&card->c_timer[ch]);
./drivers/isdn/isdnloop/isdnloop.c:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	del_timer(&card->c_timer[ch]);
./drivers/isdn/isdnloop/isdnloop.c:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:				spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:						spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:					card->rcard[lch] = cc;
./drivers/isdn/isdnloop/isdnloop.c:					card->rch[lch] = ch;
./drivers/isdn/isdnloop/isdnloop.c:					spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:					spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	switch (card->ptype) {
./drivers/isdn/isdnloop/isdnloop.c:					if (!(strcmp(card->s0num[i], phone)))
./drivers/isdn/isdnloop/isdnloop.c:				return (card->s0num[0]);
./drivers/isdn/isdnloop/isdnloop.c:				sprintf(nphone, "%s%c", card->s0num[0], phone[0]);
./drivers/isdn/isdnloop/isdnloop.c:	char *p = card->omsg;
./drivers/isdn/isdnloop/isdnloop.c:	if ((card->omsg[0] != '0') && (card->omsg[2] != ';')) {
./drivers/isdn/isdnloop/isdnloop.c:	ch = card->omsg[1] - '0';
./drivers/isdn/isdnloop/isdnloop.c:			if (card->rcard[ch - 1]) {
./drivers/isdn/isdnloop/isdnloop.c:				isdnloop_fake(card->rcard[ch - 1], "BCON_I",
./drivers/isdn/isdnloop/isdnloop.c:					      card->rch[ch - 1] + 1);
./drivers/isdn/isdnloop/isdnloop.c:			if (card->rcard[ch - 1]) {
./drivers/isdn/isdnloop/isdnloop.c:				isdnloop_fake(card->rcard[ch - 1], "BCON_C",
./drivers/isdn/isdnloop/isdnloop.c:					      card->rch[ch - 1] + 1);
./drivers/isdn/isdnloop/isdnloop.c:			if (card->rcard[ch - 1]) {
./drivers/isdn/isdnloop/isdnloop.c:				isdnloop_fake(card->rcard[ch - 1], "BDIS_I",
./drivers/isdn/isdnloop/isdnloop.c:					      card->rch[ch - 1] + 1);
./drivers/isdn/isdnloop/isdnloop.c:			if (card->rcard[ch - 1]) {
./drivers/isdn/isdnloop/isdnloop.c:				isdnloop_kill_ctimer(card->rcard[ch - 1], card->rch[ch - 1]);
./drivers/isdn/isdnloop/isdnloop.c:				isdnloop_fake(card->rcard[ch - 1], "DCON_C",
./drivers/isdn/isdnloop/isdnloop.c:					      card->rch[ch - 1] + 1);
./drivers/isdn/isdnloop/isdnloop.c:			if (card->rcard[ch - 1]) {
./drivers/isdn/isdnloop/isdnloop.c:				isdnloop_kill_ctimer(card->rcard[ch - 1], card->rch[ch - 1]);
./drivers/isdn/isdnloop/isdnloop.c:				isdnloop_fake(card->rcard[ch - 1], "DDIS_I",
./drivers/isdn/isdnloop/isdnloop.c:					      card->rch[ch - 1] + 1);
./drivers/isdn/isdnloop/isdnloop.c:				card->rcard[ch - 1] = NULL;
./drivers/isdn/isdnloop/isdnloop.c:			if (card->ptype != ISDN_PTYPE_1TR6) {
./drivers/isdn/isdnloop/isdnloop.c:					isdnloop_vstphone(card->rcard[ch - 1],
./drivers/isdn/isdnloop/isdnloop.c:					isdnloop_fake(card->rcard[ch - 1], buf, card->rch[ch - 1] + 1);
./drivers/isdn/isdnloop/isdnloop.c:			card->eazlist[ch - 1][0] = '\0';
./drivers/isdn/isdnloop/isdnloop.c:			strcpy(card->eazlist[ch - 1], p);
./drivers/isdn/isdnloop/isdnloop.c:			sprintf(buf, "EAZ-LIST: %s", card->eazlist[ch - 1]);
./drivers/isdn/isdnloop/isdnloop.c:					card->sil[ch - 1] |= si2bit[*p - '0'];
./drivers/isdn/isdnloop/isdnloop.c:				if (card->sil[ch - 1] & (1 << i))
./drivers/isdn/isdnloop/isdnloop.c:			card->sil[ch - 1] = 0;
./drivers/isdn/isdnloop/isdnloop.c:			card->omsg[card->optr] = *p;
./drivers/isdn/isdnloop/isdnloop.c:				card->omsg[card->optr] = '\0';
./drivers/isdn/isdnloop/isdnloop.c:				card->optr = 0;
./drivers/isdn/isdnloop/isdnloop.c:				if (card->optr < 59)
./drivers/isdn/isdnloop/isdnloop.c:					card->optr++;
./drivers/isdn/isdnloop/isdnloop.c:	cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	if (card->flags & ISDNLOOP_FLAGS_RUNNING) {
./drivers/isdn/isdnloop/isdnloop.c:		card->flags &= ~ISDNLOOP_FLAGS_RUNNING;
./drivers/isdn/isdnloop/isdnloop.c:		del_timer(&card->st_timer);
./drivers/isdn/isdnloop/isdnloop.c:		del_timer(&card->rb_timer);
./drivers/isdn/isdnloop/isdnloop.c:		del_timer(&card->c_timer[0]);
./drivers/isdn/isdnloop/isdnloop.c:		del_timer(&card->c_timer[1]);
./drivers/isdn/isdnloop/isdnloop.c:		cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:		card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	if (card->flags & ISDNLOOP_FLAGS_RUNNING)
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_irqsave(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:			card->sil[0] = card->sil[1] = 4;
./drivers/isdn/isdnloop/isdnloop.c:				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:				strcpy(card->s0num[i], sdef.num[i]);
./drivers/isdn/isdnloop/isdnloop.c:				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:			card->sil[0] = card->sil[1] = 4;
./drivers/isdn/isdnloop/isdnloop.c:				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:			strcpy(card->s0num[0], sdef.num[0]);
./drivers/isdn/isdnloop/isdnloop.c:			card->s0num[1][0] = '\0';
./drivers/isdn/isdnloop/isdnloop.c:			card->s0num[2][0] = '\0';
./drivers/isdn/isdnloop/isdnloop.c:			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:	init_timer(&card->st_timer);
./drivers/isdn/isdnloop/isdnloop.c:	card->st_timer.expires = jiffies + ISDNLOOP_TIMER_DCREAD;
./drivers/isdn/isdnloop/isdnloop.c:	card->st_timer.function = isdnloop_polldchan;
./drivers/isdn/isdnloop/isdnloop.c:	card->st_timer.data = (unsigned long) card;
./drivers/isdn/isdnloop/isdnloop.c:	add_timer(&card->st_timer);
./drivers/isdn/isdnloop/isdnloop.c:	card->flags |= ISDNLOOP_FLAGS_RUNNING;
./drivers/isdn/isdnloop/isdnloop.c:	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
./drivers/isdn/isdnloop/isdnloop.c:						if (!card->leased) {
./drivers/isdn/isdnloop/isdnloop.c:							card->leased = 1;
./drivers/isdn/isdnloop/isdnloop.c:							while (card->ptype == ISDN_PTYPE_UNKNOWN)
./drivers/isdn/isdnloop/isdnloop.c:							cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:							card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:						if (card->leased) {
./drivers/isdn/isdnloop/isdnloop.c:							card->leased = 0;
./drivers/isdn/isdnloop/isdnloop.c:							cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:							card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:			if (card->leased)
./drivers/isdn/isdnloop/isdnloop.c:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:				switch (card->l2_proto[a - 1]) {
./drivers/isdn/isdnloop/isdnloop.c:			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:				switch (card->l2_proto[a - 1]) {
./drivers/isdn/isdnloop/isdnloop.c:				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:				if (card->leased)
./drivers/isdn/isdnloop/isdnloop.c:					if (card->ptype == ISDN_PTYPE_EURO) {
./drivers/isdn/isdnloop/isdnloop.c:				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:				if (card->leased)
./drivers/isdn/isdnloop/isdnloop.c:					if (card->ptype == ISDN_PTYPE_EURO)
./drivers/isdn/isdnloop/isdnloop.c:				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:					card->l2_proto[a & 255] = (a >> 8);
./drivers/isdn/isdnloop/isdnloop.c:				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c:		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
./drivers/isdn/isdnloop/isdnloop.c: * Allocate a new card-struct, initialize it
./drivers/isdn/isdnloop/isdnloop.c:		 "isdnloop: (%s) Could not allocate card-struct.\n", id);
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.owner = THIS_MODULE;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.channels = ISDNLOOP_BCH;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.hl_hdrlen  = 1; /* scratch area for storing ack flag*/ 
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.maxbufsize = 4000;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.command = if_command;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.writebuf_skb = if_sendbuf;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.writecmd = if_writecmd;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.readstat = if_readstatus;
./drivers/isdn/isdnloop/isdnloop.c:	card->interface.features = ISDN_FEATURE_L2_X75I |
./drivers/isdn/isdnloop/isdnloop.c:	card->ptype = ISDN_PTYPE_UNKNOWN;
./drivers/isdn/isdnloop/isdnloop.c:	strlcpy(card->interface.id, id, sizeof(card->interface.id));
./drivers/isdn/isdnloop/isdnloop.c:	card->msg_buf_write = card->msg_buf;
./drivers/isdn/isdnloop/isdnloop.c:	card->msg_buf_read = card->msg_buf;
./drivers/isdn/isdnloop/isdnloop.c:	card->msg_buf_end = &card->msg_buf[sizeof(card->msg_buf) - 1];
./drivers/isdn/isdnloop/isdnloop.c:		card->l2_proto[i] = ISDN_PROTO_L2_X75I;
./drivers/isdn/isdnloop/isdnloop.c:		skb_queue_head_init(&card->bqueue[i]);
./drivers/isdn/isdnloop/isdnloop.c:	skb_queue_head_init(&card->dqueue);
./drivers/isdn/isdnloop/isdnloop.c:	spin_lock_init(&card->isdnloop_lock);
./drivers/isdn/isdnloop/isdnloop.c:	card->next = cards;
./drivers/isdn/isdnloop/isdnloop.c:	if (!register_isdn(&card->interface)) {
./drivers/isdn/isdnloop/isdnloop.c:	card->myid = card->interface.channels;
./drivers/isdn/isdnloop/isdnloop.c:	       card->interface.id);
./drivers/isdn/isdnloop/isdnloop.c:		cmd.driver = card->myid;
./drivers/isdn/isdnloop/isdnloop.c:		card->interface.statcallb(&cmd);
./drivers/isdn/isdnloop/isdnloop.c:		card = card->next;
./drivers/isdn/isdnloop/isdnloop.c:		skb_queue_purge(&card->dqueue);
./drivers/isdn/isdnloop/isdnloop.c:		card = card->next;
./drivers/isdn/icn/icn.c:	struct sk_buff_head *queue = &card->spqueue[channel];
./drivers/isdn/icn/icn.c:	card->xlen[channel] = 0;
./drivers/isdn/icn/icn.c:	card->sndcount[channel] = 0;
./drivers/isdn/icn/icn.c:	if ((skb = card->xskb[channel])) {
./drivers/isdn/icn/icn.c:		card->xskb[channel] = NULL;
./drivers/isdn/icn/icn.c:	int mch = channel + ((card->secondhalf) ? 2 : 0);
./drivers/isdn/icn/icn.c:			if ((card->rcvidx[channel] + cnt) > 4000) {
./drivers/isdn/icn/icn.c:				card->rcvidx[channel] = 0;
./drivers/isdn/icn/icn.c:				memcpy_fromio(&card->rcvbuf[channel][card->rcvidx[channel]],
./drivers/isdn/icn/icn.c:				card->rcvidx[channel] += cnt;
./drivers/isdn/icn/icn.c:				if ((cnt = card->rcvidx[channel])) {
./drivers/isdn/icn/icn.c:					memcpy(skb_put(skb, cnt), card->rcvbuf[channel], cnt);
./drivers/isdn/icn/icn.c:					card->rcvidx[channel] = 0;
./drivers/isdn/icn/icn.c:					card->interface.rcvcallb_skb(card->myid, channel, skb);
./drivers/isdn/icn/icn.c:	int mch = channel + ((card->secondhalf) ? 2 : 0);
./drivers/isdn/icn/icn.c:	if (!(card->sndcount[channel] || card->xskb[channel] ||
./drivers/isdn/icn/icn.c:	      !skb_queue_empty(&card->spqueue[channel])))
./drivers/isdn/icn/icn.c:		       (card->sndcount[channel] ||
./drivers/isdn/icn/icn.c:			!skb_queue_empty(&card->spqueue[channel]) ||
./drivers/isdn/icn/icn.c:			card->xskb[channel])) {
./drivers/isdn/icn/icn.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:			if (card->xmit_lock[channel]) {
./drivers/isdn/icn/icn.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:			card->xmit_lock[channel]++;
./drivers/isdn/icn/icn.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:			skb = card->xskb[channel];
./drivers/isdn/icn/icn.c:				skb = skb_dequeue(&card->spqueue[channel]);
./drivers/isdn/icn/icn.c:						card->xlen[channel] = skb->len;
./drivers/isdn/icn/icn.c:						card->xlen[channel] = 0;
./drivers/isdn/icn/icn.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:			card->sndcount[channel] -= cnt;
./drivers/isdn/icn/icn.c:				if (card->xskb[channel])
./drivers/isdn/icn/icn.c:					card->xskb[channel] = NULL;
./drivers/isdn/icn/icn.c:				card->xmit_lock[channel] = 0;
./drivers/isdn/icn/icn.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:				if (card->xlen[channel]) {
./drivers/isdn/icn/icn.c:					cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:					cmd.parm.length = card->xlen[channel];
./drivers/isdn/icn/icn.c:					card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:				card->xskb[channel] = skb;
./drivers/isdn/icn/icn.c:				card->xmit_lock[channel] = 0;
./drivers/isdn/icn/icn.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:	if (card->flags & ICN_FLAGS_B1ACTIVE) {
./drivers/isdn/icn/icn.c:	if (card->flags & ICN_FLAGS_B2ACTIVE) {
./drivers/isdn/icn/icn.c:	if (card->flags & (ICN_FLAGS_B1ACTIVE | ICN_FLAGS_B2ACTIVE)) {
./drivers/isdn/icn/icn.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:		mod_timer(&card->rb_timer, jiffies+ICN_TIMER_BCREAD);
./drivers/isdn/icn/icn.c:		card->flags |= ICN_FLAGS_RBTIMER;
./drivers/isdn/icn/icn.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:		card->flags &= ~ICN_FLAGS_RBTIMER;
./drivers/isdn/icn/icn.c:	cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:			card->rcvidx[channel] = 0;
./drivers/isdn/icn/icn.c:			if (card->flags & 
./drivers/isdn/icn/icn.c:				card->flags &= ~((channel)?
./drivers/isdn/icn/icn.c:				ncmd.driver = card->myid;
./drivers/isdn/icn/icn.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:				card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:			card->flags |= (channel) ?
./drivers/isdn/icn/icn.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:			card->flags &= ~((channel) ?
./drivers/isdn/icn/icn.c:			card->rcvidx[channel] = 0;
./drivers/isdn/icn/icn.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:			sprintf(cmd.parm.setup.phone, "LEASED%d", card->myid);
./drivers/isdn/icn/icn.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:			card->flags &= ~ICN_FLAGS_B1ACTIVE;
./drivers/isdn/icn/icn.c:			card->rcvidx[0] = 0;
./drivers/isdn/icn/icn.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:			cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:			card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:			cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:			card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:			spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:			card->flags &= ~ICN_FLAGS_B2ACTIVE;
./drivers/isdn/icn/icn.c:			card->rcvidx[1] = 0;
./drivers/isdn/icn/icn.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:			cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:			card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:			cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:	card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:	*card->msg_buf_write++ = (c == 0xff) ? '\n' : c;
./drivers/isdn/icn/icn.c:	if (card->msg_buf_write == card->msg_buf_read) {
./drivers/isdn/icn/icn.c:		if (++card->msg_buf_read > card->msg_buf_end)
./drivers/isdn/icn/icn.c:			card->msg_buf_read = card->msg_buf;
./drivers/isdn/icn/icn.c:	if (card->msg_buf_write > card->msg_buf_end)
./drivers/isdn/icn/icn.c:		card->msg_buf_write = card->msg_buf;
./drivers/isdn/icn/icn.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:	int mch = card->secondhalf ? 2 : 0;
./drivers/isdn/icn/icn.c:				card->imsg[card->iptr] = 0;
./drivers/isdn/icn/icn.c:				card->iptr = 0;
./drivers/isdn/icn/icn.c:				if (card->imsg[0] == '0' && card->imsg[1] >= '0' &&
./drivers/isdn/icn/icn.c:				    card->imsg[1] <= '2' && card->imsg[2] == ';') {
./drivers/isdn/icn/icn.c:					ch = (card->imsg[1] - '0') - 1;
./drivers/isdn/icn/icn.c:					p = &card->imsg[3];
./drivers/isdn/icn/icn.c:					p = card->imsg;
./drivers/isdn/icn/icn.c:							card->ptype = ISDN_PTYPE_1TR6;
./drivers/isdn/icn/icn.c:							card->interface.features |= ISDN_FEATURE_P_1TR6;
./drivers/isdn/icn/icn.c:							card->ptype = ISDN_PTYPE_EURO;
./drivers/isdn/icn/icn.c:							card->interface.features |= ISDN_FEATURE_P_EURO;
./drivers/isdn/icn/icn.c:						p = strstr(card->imsg, "BRV") + 3;
./drivers/isdn/icn/icn.c:						card->fw_rev = (int) simple_strtoul(vstr, NULL, 10);
./drivers/isdn/icn/icn.c:				card->imsg[card->iptr] = c;
./drivers/isdn/icn/icn.c:				if (card->iptr < 59)
./drivers/isdn/icn/icn.c:					card->iptr++;
./drivers/isdn/icn/icn.c:		cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:		card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:	if (card->flags & (ICN_FLAGS_B1ACTIVE | ICN_FLAGS_B2ACTIVE))
./drivers/isdn/icn/icn.c:		if (!(card->flags & ICN_FLAGS_RBTIMER)) {
./drivers/isdn/icn/icn.c:			card->flags |= ICN_FLAGS_RBTIMER;
./drivers/isdn/icn/icn.c:			del_timer(&card->rb_timer);
./drivers/isdn/icn/icn.c:			card->rb_timer.function = icn_pollbchan;
./drivers/isdn/icn/icn.c:			card->rb_timer.data = (unsigned long) card;
./drivers/isdn/icn/icn.c:			card->rb_timer.expires = jiffies + ICN_TIMER_BCREAD;
./drivers/isdn/icn/icn.c:			add_timer(&card->rb_timer);
./drivers/isdn/icn/icn.c:	mod_timer(&card->st_timer, jiffies+ICN_TIMER_DCREAD);
./drivers/isdn/icn/icn.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c: *   card    = pointer to card-struct
./drivers/isdn/icn/icn.c:		if (!(card->flags & (channel) ? ICN_FLAGS_B2ACTIVE : ICN_FLAGS_B1ACTIVE))
./drivers/isdn/icn/icn.c:		if (card->sndcount[channel] > ICN_MAX_SQUEUE)
./drivers/isdn/icn/icn.c:			skb_queue_tail(&card->spqueue[channel], nskb);
./drivers/isdn/icn/icn.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:		card->sndcount[channel] += len;
./drivers/isdn/icn/icn.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:	if (!card->rvalid) {
./drivers/isdn/icn/icn.c:		if (!request_region(card->port, ICN_PORTLEN, card->regname)) {
./drivers/isdn/icn/icn.c:			       card->port,
./drivers/isdn/icn/icn.c:			       card->port + ICN_PORTLEN);
./drivers/isdn/icn/icn.c:		card->rvalid = 1;
./drivers/isdn/icn/icn.c:		if (card->doubleS0)
./drivers/isdn/icn/icn.c:			card->other->rvalid = 1;
./drivers/isdn/icn/icn.c:	if (card->doubleS0) {
./drivers/isdn/icn/icn.c:	if ((ret = icn_check_loader(card->doubleS0 ? 2 : 1))) {
./drivers/isdn/icn/icn.c:	if (!card->doubleS0) {
./drivers/isdn/icn/icn.c:	if (card->secondhalf) {
./drivers/isdn/icn/icn.c:			if ((card->secondhalf) || (!card->doubleS0)) {
./drivers/isdn/icn/icn.c:				       card->secondhalf);
./drivers/isdn/icn/icn.c:				spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:				init_timer(&card->st_timer);
./drivers/isdn/icn/icn.c:				card->st_timer.expires = jiffies + ICN_TIMER_DCREAD;
./drivers/isdn/icn/icn.c:				card->st_timer.function = icn_polldchan;
./drivers/isdn/icn/icn.c:				card->st_timer.data = (unsigned long) card;
./drivers/isdn/icn/icn.c:				add_timer(&card->st_timer);
./drivers/isdn/icn/icn.c:				card->flags |= ICN_FLAGS_RUNNING;
./drivers/isdn/icn/icn.c:				if (card->doubleS0) {
./drivers/isdn/icn/icn.c:					init_timer(&card->other->st_timer);
./drivers/isdn/icn/icn.c:					card->other->st_timer.expires = jiffies + ICN_TIMER_DCREAD;
./drivers/isdn/icn/icn.c:					card->other->st_timer.function = icn_polldchan;
./drivers/isdn/icn/icn.c:					card->other->st_timer.data = (unsigned long) card->other;
./drivers/isdn/icn/icn.c:					add_timer(&card->other->st_timer);
./drivers/isdn/icn/icn.c:					card->other->flags |= ICN_FLAGS_RUNNING;
./drivers/isdn/icn/icn.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:		if (card->msg_buf_read == card->msg_buf_write)
./drivers/isdn/icn/icn.c:		if (put_user(*card->msg_buf_read++, p))
./drivers/isdn/icn/icn.c:		if (card->msg_buf_read > card->msg_buf_end)
./drivers/isdn/icn/icn.c:			card->msg_buf_read = card->msg_buf;
./drivers/isdn/icn/icn.c:	int mch = card->secondhalf ? 2 : 0;
./drivers/isdn/icn/icn.c:	cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:	card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:	if (card->flags & ICN_FLAGS_RUNNING) {
./drivers/isdn/icn/icn.c:		card->flags &= ~ICN_FLAGS_RUNNING;
./drivers/isdn/icn/icn.c:		del_timer(&card->st_timer);
./drivers/isdn/icn/icn.c:		del_timer(&card->rb_timer);
./drivers/isdn/icn/icn.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:		cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:		card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:		if (card->doubleS0)
./drivers/isdn/icn/icn.c:			icn_stopcard(card->other);
./drivers/isdn/icn/icn.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:		if (!request_region(card->port, ICN_PORTLEN, "icn-isdn")) {
./drivers/isdn/icn/icn.c:			       card->port,
./drivers/isdn/icn/icn.c:			       card->port + ICN_PORTLEN);
./drivers/isdn/icn/icn.c:			release_region(card->port, ICN_PORTLEN);
./drivers/isdn/icn/icn.c:		card = card->next;
./drivers/isdn/icn/icn.c:						spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:						spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:						if (card->port != (unsigned short) a) {
./drivers/isdn/icn/icn.c:							spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:							if (card->rvalid)
./drivers/isdn/icn/icn.c:								release_region(card->port, ICN_PORTLEN);
./drivers/isdn/icn/icn.c:							card->port = (unsigned short) a;
./drivers/isdn/icn/icn.c:							card->rvalid = 0;
./drivers/isdn/icn/icn.c:							if (card->doubleS0) {
./drivers/isdn/icn/icn.c:								card->other->port = (unsigned short) a;
./drivers/isdn/icn/icn.c:								card->other->rvalid = 0;
./drivers/isdn/icn/icn.c:							spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:							CID, card->port);
./drivers/isdn/icn/icn.c:					return (int) card->port;
./drivers/isdn/icn/icn.c:					return (int) card->doubleS0;
./drivers/isdn/icn/icn.c:					if (card->doubleS0)
./drivers/isdn/icn/icn.c:						i = icn_loadproto(arg + ICN_CODE_STAGE2, card->other);
./drivers/isdn/icn/icn.c:						if (!card->leased) {
./drivers/isdn/icn/icn.c:							card->leased = 1;
./drivers/isdn/icn/icn.c:							while (card->ptype == ISDN_PTYPE_UNKNOWN) {
./drivers/isdn/icn/icn.c:							cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:							card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:						if (card->leased) {
./drivers/isdn/icn/icn.c:							card->leased = 0;
./drivers/isdn/icn/icn.c:							cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:							card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:			if (card->leased)
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:				if (card->fw_rev >= 300) {
./drivers/isdn/icn/icn.c:					switch (card->l2_proto[a - 1]) {
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:				if (card->fw_rev >= 300)
./drivers/isdn/icn/icn.c:					switch (card->l2_proto[a - 1]) {
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:			if (card->leased)
./drivers/isdn/icn/icn.c:				if (card->ptype == ISDN_PTYPE_EURO) {
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:			if (card->leased)
./drivers/isdn/icn/icn.c:				if (card->ptype == ISDN_PTYPE_EURO)
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:				card->l2_proto[a & 255] = (a >> 8);
./drivers/isdn/icn/icn.c:			if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:		if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:		if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c:		if (!(card->flags & ICN_FLAGS_RUNNING))
./drivers/isdn/icn/icn.c: * Allocate a new card-struct, initialize it
./drivers/isdn/icn/icn.c:		       "icn: (%s) Could not allocate card-struct.\n", id);
./drivers/isdn/icn/icn.c:	spin_lock_init(&card->lock);
./drivers/isdn/icn/icn.c:	card->port = port;
./drivers/isdn/icn/icn.c:	card->interface.owner = THIS_MODULE;
./drivers/isdn/icn/icn.c:	card->interface.hl_hdrlen = 1;
./drivers/isdn/icn/icn.c:	card->interface.channels = ICN_BCH;
./drivers/isdn/icn/icn.c:	card->interface.maxbufsize = 4000;
./drivers/isdn/icn/icn.c:	card->interface.command = if_command;
./drivers/isdn/icn/icn.c:	card->interface.writebuf_skb = if_sendbuf;
./drivers/isdn/icn/icn.c:	card->interface.writecmd = if_writecmd;
./drivers/isdn/icn/icn.c:	card->interface.readstat = if_readstatus;
./drivers/isdn/icn/icn.c:	card->interface.features = ISDN_FEATURE_L2_X75I |
./drivers/isdn/icn/icn.c:	card->ptype = ISDN_PTYPE_UNKNOWN;
./drivers/isdn/icn/icn.c:	strlcpy(card->interface.id, id, sizeof(card->interface.id));
./drivers/isdn/icn/icn.c:	card->msg_buf_write = card->msg_buf;
./drivers/isdn/icn/icn.c:	card->msg_buf_read = card->msg_buf;
./drivers/isdn/icn/icn.c:	card->msg_buf_end = &card->msg_buf[sizeof(card->msg_buf) - 1];
./drivers/isdn/icn/icn.c:		card->l2_proto[i] = ISDN_PROTO_L2_X75I;
./drivers/isdn/icn/icn.c:		skb_queue_head_init(&card->spqueue[i]);
./drivers/isdn/icn/icn.c:	card->next = cards;
./drivers/isdn/icn/icn.c:	if (!register_isdn(&card->interface)) {
./drivers/isdn/icn/icn.c:	card->myid = card->interface.channels;
./drivers/isdn/icn/icn.c:	sprintf(card->regname, "icn-isdn (%s)", card->interface.id);
./drivers/isdn/icn/icn.c:		       card->interface.id, port);
./drivers/isdn/icn/icn.c:	card->doubleS0 = 1;
./drivers/isdn/icn/icn.c:	card->secondhalf = 0;
./drivers/isdn/icn/icn.c:	card->other = card2;
./drivers/isdn/icn/icn.c:	       card->interface.id, card2->interface.id, port);
./drivers/isdn/icn/icn.c:		cmd.driver = card->myid;
./drivers/isdn/icn/icn.c:		card->interface.statcallb(&cmd);
./drivers/isdn/icn/icn.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/isdn/icn/icn.c:		if (card->rvalid) {
./drivers/isdn/icn/icn.c:			if (card->secondhalf || (!card->doubleS0)) {
./drivers/isdn/icn/icn.c:				release_region(card->port, ICN_PORTLEN);
./drivers/isdn/icn/icn.c:				card->rvalid = 0;
./drivers/isdn/icn/icn.c:		tmpcard = card->next;
./drivers/isdn/icn/icn.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/isdn/icn/icn.c:		card = card->next;
./drivers/isdn/capi/capidrv.c:	plcip->next = card->plci_list;
./drivers/isdn/capi/capidrv.c:	card->plci_list = plcip;
./drivers/isdn/capi/capidrv.c:	card->bchans[chan].plcip = plcip;
./drivers/isdn/capi/capidrv.c:	for (p = card->plci_list; p; p = p->next)
./drivers/isdn/capi/capidrv.c:	for (p = card->plci_list; p; p = p->next)
./drivers/isdn/capi/capidrv.c:	for (p = card->plci_list; p; p = p->next)
./drivers/isdn/capi/capidrv.c:	for (pp = &card->plci_list; *pp; pp = &(*pp)->next) {
./drivers/isdn/capi/capidrv.c:			card->bchans[plcip->chan].plcip = NULL;
./drivers/isdn/capi/capidrv.c:			card->bchans[plcip->chan].disconnecting = 0;
./drivers/isdn/capi/capidrv.c:			card->bchans[plcip->chan].incoming = 0;
./drivers/isdn/capi/capidrv.c:	       card->contrnr, plcip, plcip->plci);
./drivers/isdn/capi/capidrv.c:	card->bchans[plcip->chan].nccip = nccip;
./drivers/isdn/capi/capidrv.c:	card->bchans[nccip->chan].nccip = NULL;
./drivers/isdn/capi/capidrv.c:		if (card->state == p->actstate && p->event == event) {
./drivers/isdn/capi/capidrv.c:				       card->contrnr, card->state, p->nextstate);
./drivers/isdn/capi/capidrv.c:			card->state = p->nextstate;
./drivers/isdn/capi/capidrv.c:	       card->contrnr, card->state, event);
./drivers/isdn/capi/capidrv.c:	card->bchans[plci->chan].contr = NULL;
./drivers/isdn/capi/capidrv.c:	cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:	card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:				  card->contrnr, plci->plci, plci->state, p->nextstate);
./drivers/isdn/capi/capidrv.c:	       card->contrnr, plci->plci, plci->state, event);
./drivers/isdn/capi/capidrv.c:				 card->msgid++,
./drivers/isdn/capi/capidrv.c:	cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:	card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:				  card->contrnr, ncci->ncci, ncci->state, p->nextstate);
./drivers/isdn/capi/capidrv.c:	       card->contrnr, ncci->ncci, ncci->state, event);
./drivers/isdn/capi/capidrv.c:	for (i = 0; i < card->nbchan; i++) {
./drivers/isdn/capi/capidrv.c:		if (card->bchans[i].plcip == NULL) {
./drivers/isdn/capi/capidrv.c:			card->bchans[i].disconnecting = 0;
./drivers/isdn/capi/capidrv.c:			       card->contrnr, cmsg->Info, capi_info2str(cmsg->Info), card->cipmask);
./drivers/isdn/capi/capidrv.c:		} else if (card->cipmask == 0) {
./drivers/isdn/capi/capidrv.c:                        card->contrnr, 
./drivers/isdn/capi/capidrv.c:			card->contrnr,
./drivers/isdn/capi/capidrv.c:		       card->contrnr,
./drivers/isdn/capi/capidrv.c:	       card->contrnr,
./drivers/isdn/capi/capidrv.c:		printk(KERN_ERR "capidrv-%d: incoming call on not existing bchan ?\n", card->contrnr);
./drivers/isdn/capi/capidrv.c:	bchan = &card->bchans[chan];
./drivers/isdn/capi/capidrv.c:		printk(KERN_ERR "capidrv-%d: incoming call: no memory, sorry.\n", card->contrnr);
./drivers/isdn/capi/capidrv.c:	cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:			card->contrnr,
./drivers/isdn/capi/capidrv.c:			card->contrnr,
./drivers/isdn/capi/capidrv.c:	switch (card->interface.statcallb(&cmd)) {
./drivers/isdn/capi/capidrv.c:			card->contrnr,
./drivers/isdn/capi/capidrv.c:				card->contrnr,
./drivers/isdn/capi/capidrv.c:					    card->msgid++,
./drivers/isdn/capi/capidrv.c:				card->contrnr,
./drivers/isdn/capi/capidrv.c:			   card->contrnr,
./drivers/isdn/capi/capidrv.c:		card->bchans[plcip->chan].disconnecting = 1;
./drivers/isdn/capi/capidrv.c:			   card->contrnr,
./drivers/isdn/capi/capidrv.c:		card->bchans[plcip->chan].disconnecting = 1;
./drivers/isdn/capi/capidrv.c:			   card->contrnr,
./drivers/isdn/capi/capidrv.c:			   card->contrnr,
./drivers/isdn/capi/capidrv.c:		if (card->bchans[plcip->chan].incoming) {
./drivers/isdn/capi/capidrv.c:				printk(KERN_ERR "capidrv-%d: no mem for ncci, sorry\n", card->contrnr);
./drivers/isdn/capi/capidrv.c:						 card->msgid++,
./drivers/isdn/capi/capidrv.c:			cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:			card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:				cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:				card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:				card->contrnr, cdb->buf);
./drivers/isdn/capi/capidrv.c:				card->contrnr, cmsg->InfoNumber);
./drivers/isdn/capi/capidrv.c:		       card->contrnr,
./drivers/isdn/capi/capidrv.c:	       card->contrnr,
./drivers/isdn/capi/capidrv.c:	       card->contrnr,
./drivers/isdn/capi/capidrv.c:		cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:		card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:		       card->contrnr, nccip->chan, nccip->ncci);
./drivers/isdn/capi/capidrv.c:							  card->msgid++,
./drivers/isdn/capi/capidrv.c:			printk(KERN_ERR "capidrv-%d: no mem for ncci, sorry\n",							card->contrnr);
./drivers/isdn/capi/capidrv.c:			   card->contrnr,
./drivers/isdn/capi/capidrv.c:					  card->msgid++,
./drivers/isdn/capi/capidrv.c:			   card->contrnr,
./drivers/isdn/capi/capidrv.c:	        cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:	        card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:		card->bchans[nccip->chan].disconnecting = 1;
./drivers/isdn/capi/capidrv.c:			   card->contrnr,
./drivers/isdn/capi/capidrv.c:		       card->contrnr,
./drivers/isdn/capi/capidrv.c:	       card->contrnr,
./drivers/isdn/capi/capidrv.c:	       card->contrnr,
./drivers/isdn/capi/capidrv.c:		       card->contrnr,
./drivers/isdn/capi/capidrv.c:	card->interface.rcvcallb_skb(card->myid, nccip->chan, skb);
./drivers/isdn/capi/capidrv.c:				card->contrnr, len);
./drivers/isdn/capi/capidrv.c:	cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:	card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:				card->contrnr, debugmode);
./drivers/isdn/capi/capidrv.c:				card->contrnr, c->arg);
./drivers/isdn/capi/capidrv.c:					card->contrnr,
./drivers/isdn/capi/capidrv.c:			bchan = &card->bchans[c->arg % card->nbchan];
./drivers/isdn/capi/capidrv.c:					card->contrnr,
./drivers/isdn/capi/capidrv.c:				printk(KERN_ERR "capidrv-%d: WARNING: invalid leased linedefinition \"%s\"\n", card->contrnr, bchan->num);
./drivers/isdn/capi/capidrv.c:					printk(KERN_DEBUG "capidrv-%d: connecting leased line\n", card->contrnr);
./drivers/isdn/capi/capidrv.c:					      card->msgid++,
./drivers/isdn/capi/capidrv.c:					      card->contrnr,	/* adr */
./drivers/isdn/capi/capidrv.c:			if ((plcip = new_plci(card, (c->arg % card->nbchan))) == NULL) {
./drivers/isdn/capi/capidrv.c:				cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:				cmd.arg = (c->arg % card->nbchan);
./drivers/isdn/capi/capidrv.c:				card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:		bchan = &card->bchans[c->arg % card->nbchan];
./drivers/isdn/capi/capidrv.c:			       card->contrnr,
./drivers/isdn/capi/capidrv.c:				       card->msgid++,
./drivers/isdn/capi/capidrv.c:			       card->contrnr,
./drivers/isdn/capi/capidrv.c:			       card->contrnr,
./drivers/isdn/capi/capidrv.c:		bchan = &card->bchans[c->arg % card->nbchan];
./drivers/isdn/capi/capidrv.c:				       card->contrnr,
./drivers/isdn/capi/capidrv.c:						    card->msgid++,
./drivers/isdn/capi/capidrv.c:							 card->msgid++,
./drivers/isdn/capi/capidrv.c:				       card->contrnr,
./drivers/isdn/capi/capidrv.c:				       card->contrnr,
./drivers/isdn/capi/capidrv.c:			       card->contrnr,
./drivers/isdn/capi/capidrv.c:		bchan = &card->bchans[(c->arg & 0xff) % card->nbchan];
./drivers/isdn/capi/capidrv.c:			       card->contrnr,
./drivers/isdn/capi/capidrv.c:		bchan = &card->bchans[(c->arg & 0xff) % card->nbchan];
./drivers/isdn/capi/capidrv.c:			       card->contrnr,
./drivers/isdn/capi/capidrv.c:		bchan = &card->bchans[c->arg % card->nbchan];
./drivers/isdn/capi/capidrv.c:					card->contrnr, c->arg);
./drivers/isdn/capi/capidrv.c:		bchan = &card->bchans[c->arg % card->nbchan];
./drivers/isdn/capi/capidrv.c:					card->contrnr, c->command);
./drivers/isdn/capi/capidrv.c:					card->contrnr, len, skb, doack);
./drivers/isdn/capi/capidrv.c:	bchan = &card->bchans[channel % card->nbchan];
./drivers/isdn/capi/capidrv.c:		       card->contrnr, card->name, channel);
./drivers/isdn/capi/capidrv.c:	capi_fill_DATA_B3_REQ(&sendcmsg, global.ap.applid, card->msgid++,
./drivers/isdn/capi/capidrv.c:				card->contrnr);
./drivers/isdn/capi/capidrv.c:		       card->contrnr, skb_headroom(skb), msglen);
./drivers/isdn/capi/capidrv.c:				card->contrnr, errcode, capi_info2str(errcode));
./drivers/isdn/capi/capidrv.c:				card->contrnr, errcode, capi_info2str(errcode));
./drivers/isdn/capi/capidrv.c:		if (put_user(*card->q931_read++, p))
./drivers/isdn/capi/capidrv.c:	        if (card->q931_read > card->q931_end)
./drivers/isdn/capi/capidrv.c:	                card->q931_read = card->q931_buf;
./drivers/isdn/capi/capidrv.c:	u16 contr = card->contrnr;
./drivers/isdn/capi/capidrv.c:			card->name, errcode);
./drivers/isdn/capi/capidrv.c:			card->name, manufacturer);
./drivers/isdn/capi/capidrv.c:			card->name, errcode);
./drivers/isdn/capi/capidrv.c:		printk(KERN_INFO "%s: D2 trace enabled\n", card->name);
./drivers/isdn/capi/capidrv.c:					   card->msgid++,
./drivers/isdn/capi/capidrv.c:		printk(KERN_INFO "%s: D3 trace enabled\n", card->name);
./drivers/isdn/capi/capidrv.c:					   card->msgid++,
./drivers/isdn/capi/capidrv.c:			     card->msgid++,
./drivers/isdn/capi/capidrv.c:			     card->contrnr, /* controller */
./drivers/isdn/capi/capidrv.c:			     card->cipmask,
./drivers/isdn/capi/capidrv.c:			     card->cipmask2,
./drivers/isdn/capi/capidrv.c:	if (card->state != ST_LISTEN_NONE && card->state != ST_LISTEN_ACTIVE)
./drivers/isdn/capi/capidrv.c:		printk(KERN_ERR "%s: controller dead ??\n", card->name);
./drivers/isdn/capi/capidrv.c:	mod_timer(&card->listentimer, jiffies + 60*HZ);
./drivers/isdn/capi/capidrv.c:	card->owner = THIS_MODULE;
./drivers/isdn/capi/capidrv.c:	init_timer(&card->listentimer);
./drivers/isdn/capi/capidrv.c:	strcpy(card->name, id);
./drivers/isdn/capi/capidrv.c:	card->contrnr = contr;
./drivers/isdn/capi/capidrv.c:	card->nbchan = profp->nbchannel;
./drivers/isdn/capi/capidrv.c:	card->bchans = kmalloc(sizeof(capidrv_bchan) * card->nbchan, GFP_ATOMIC);
./drivers/isdn/capi/capidrv.c:	if (!card->bchans) {
./drivers/isdn/capi/capidrv.c:		module_put(card->owner);
./drivers/isdn/capi/capidrv.c:	card->interface.channels = profp->nbchannel;
./drivers/isdn/capi/capidrv.c:	card->interface.maxbufsize = 2048;
./drivers/isdn/capi/capidrv.c:	card->interface.command = if_command;
./drivers/isdn/capi/capidrv.c:	card->interface.writebuf_skb = if_sendbuf;
./drivers/isdn/capi/capidrv.c:	card->interface.writecmd = NULL;
./drivers/isdn/capi/capidrv.c:	card->interface.readstat = if_readstat;
./drivers/isdn/capi/capidrv.c:	card->interface.features = ISDN_FEATURE_L2_HDLC |
./drivers/isdn/capi/capidrv.c:		card->interface.features |= ISDN_FEATURE_L2_V11096 |
./drivers/isdn/capi/capidrv.c:		card->interface.features |= ISDN_FEATURE_L2_MODEM;
./drivers/isdn/capi/capidrv.c:	card->interface.hl_hdrlen = 22; /* len of DATA_B3_REQ */
./drivers/isdn/capi/capidrv.c:	strncpy(card->interface.id, id, sizeof(card->interface.id) - 1);
./drivers/isdn/capi/capidrv.c:	card->q931_read = card->q931_buf;
./drivers/isdn/capi/capidrv.c:	card->q931_write = card->q931_buf;
./drivers/isdn/capi/capidrv.c:	card->q931_end = card->q931_buf + sizeof(card->q931_buf) - 1;
./drivers/isdn/capi/capidrv.c:	if (!register_isdn(&card->interface)) {
./drivers/isdn/capi/capidrv.c:		kfree(card->bchans);
./drivers/isdn/capi/capidrv.c:		module_put(card->owner);
./drivers/isdn/capi/capidrv.c:	card->myid = card->interface.channels;
./drivers/isdn/capi/capidrv.c:	memset(card->bchans, 0, sizeof(capidrv_bchan) * card->nbchan);
./drivers/isdn/capi/capidrv.c:	for (i = 0; i < card->nbchan; i++) {
./drivers/isdn/capi/capidrv.c:		card->bchans[i].contr = card;
./drivers/isdn/capi/capidrv.c:	card->next = global.contr_list;
./drivers/isdn/capi/capidrv.c:	cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:	card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:	card->cipmask = 0x1FFF03FF;	/* any */
./drivers/isdn/capi/capidrv.c:	card->cipmask2 = 0;
./drivers/isdn/capi/capidrv.c:	card->listentimer.data = (unsigned long)card;
./drivers/isdn/capi/capidrv.c:	card->listentimer.function = listentimerfunc;
./drivers/isdn/capi/capidrv.c:	mod_timer(&card->listentimer, jiffies + 60*HZ);
./drivers/isdn/capi/capidrv.c:		card->name, card->nbchan);
./drivers/isdn/capi/capidrv.c:	for (card = global.contr_list; card; card = card->next) {
./drivers/isdn/capi/capidrv.c:		if (card->contrnr == contr)
./drivers/isdn/capi/capidrv.c:	del_timer(&card->listentimer);
./drivers/isdn/capi/capidrv.c:					card->contrnr, card->myid);
./drivers/isdn/capi/capidrv.c:	cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:	card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:	while (card->nbchan) {
./drivers/isdn/capi/capidrv.c:		cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:		cmd.arg = card->nbchan-1;
./drivers/isdn/capi/capidrv.c:					card->contrnr, card->myid, cmd.arg);
./drivers/isdn/capi/capidrv.c:		card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:		if (card->bchans[card->nbchan-1].nccip)
./drivers/isdn/capi/capidrv.c:			free_ncci(card, card->bchans[card->nbchan-1].nccip);
./drivers/isdn/capi/capidrv.c:		if (card->bchans[card->nbchan-1].plcip)
./drivers/isdn/capi/capidrv.c:			free_plci(card, card->bchans[card->nbchan-1].plcip);
./drivers/isdn/capi/capidrv.c:		if (card->plci_list)
./drivers/isdn/capi/capidrv.c:		card->nbchan--;
./drivers/isdn/capi/capidrv.c:	kfree(card->bchans);
./drivers/isdn/capi/capidrv.c:	card->bchans = NULL;
./drivers/isdn/capi/capidrv.c:					card->contrnr, card->myid);
./drivers/isdn/capi/capidrv.c:	cmd.driver = card->myid;
./drivers/isdn/capi/capidrv.c:	card->interface.statcallb(&cmd);
./drivers/isdn/capi/capidrv.c:					card->contrnr, card->myid);
./drivers/isdn/capi/capidrv.c:			card->next = NULL;
./drivers/isdn/capi/capidrv.c:	module_put(card->owner);
./drivers/isdn/capi/capidrv.c:	printk(KERN_INFO "%s: now down.\n", card->name);
./drivers/i2c/busses/i2c-designware.c:	/* Standard-mode */
./drivers/i2c/busses/i2c-designware.c:	dev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
./drivers/i2c/i2c-boardinfo.c: * while they initialize.  This should be done in board-specific init code
./drivers/leds/leds-ams-delta.c:#include <plat/board-ams-delta.h>
./drivers/leds/leds-sunfire.c:		.name		= "clockboard-left",
./drivers/leds/leds-sunfire.c:		.name		= "clockboard-middle",
./drivers/leds/leds-sunfire.c:		.name		= "clockboard-right",
./drivers/leds/leds-sunfire.c:MODULE_ALIAS("platform:sunfire-clockboard-leds");
./drivers/leds/leds-sunfire.c:		.name	= "sunfire-clockboard-leds",
./drivers/s390/char/vmur.c: * (cdev) using the urd->cdev pointer. Each ccw device has a reference to the
./drivers/s390/char/vmur.c: * - urdev_alloc get a cdev reference (urd->cdev)
./drivers/s390/char/vmur.c: * - urdev_free drops the cdev reference (urd->cdev)
./drivers/s390/char/vmur.c:	urd->reclen = cdev->id.driver_info;
./drivers/s390/char/vmur.c:	ccw_device_get_id(cdev, &urd->dev_id);
./drivers/s390/char/vmur.c:	mutex_init(&urd->io_mutex);
./drivers/s390/char/vmur.c:	init_waitqueue_head(&urd->wait);
./drivers/s390/char/vmur.c:	spin_lock_init(&urd->open_lock);
./drivers/s390/char/vmur.c:	atomic_set(&urd->ref_count,  1);
./drivers/s390/char/vmur.c:	urd->cdev = cdev;
./drivers/s390/char/vmur.c:	if (urd->cdev)
./drivers/s390/char/vmur.c:		put_device(&urd->cdev->dev);
./drivers/s390/char/vmur.c:	atomic_inc(&urd->ref_count);
./drivers/s390/char/vmur.c:	if (atomic_dec_and_test(&urd->ref_count))
./drivers/s390/char/vmur.c:	if (urd->open_flag) {
./drivers/s390/char/vmur.c: * on a completion event it publishes at urd->io_done. The function
./drivers/s390/char/vmur.c:	struct ccw_device *cdev = urd->cdev;
./drivers/s390/char/vmur.c:	rc = mutex_lock_interruptible(&urd->io_mutex);
./drivers/s390/char/vmur.c:	urd->io_done = &event;
./drivers/s390/char/vmur.c:	mutex_unlock(&urd->io_mutex);
./drivers/s390/char/vmur.c:		urd->io_request_rc = PTR_ERR(irb);
./drivers/s390/char/vmur.c:		urd->io_request_rc = 0;
./drivers/s390/char/vmur.c:		urd->io_request_rc = -EIO;
./drivers/s390/char/vmur.c:	complete(urd->io_done);
./drivers/s390/char/vmur.c:	rc = sprintf(buf, "%zu\n", urd->reclen);
./drivers/s390/char/vmur.c:	ur_diag210.vrdcdvno = urd->dev_id.devno;
./drivers/s390/char/vmur.c:	if (urd->io_request_rc) {
./drivers/s390/char/vmur.c:		rc = urd->io_request_rc;
./drivers/s390/char/vmur.c:	rc = diag_position_to_record(urd->dev_id.devno, *offs / PAGE_SIZE + 1);
./drivers/s390/char/vmur.c:		rc = diag_read_file(urd->dev_id.devno, buf);
./drivers/s390/char/vmur.c:	rc = mutex_lock_interruptible(&urd->io_mutex);
./drivers/s390/char/vmur.c:	mutex_unlock(&urd->io_mutex);
./drivers/s390/char/vmur.c:	rc = diag_read_file(urd->dev_id.devno, buf);
./drivers/s390/char/vmur.c:	switch (urd->class) {
./drivers/s390/char/vmur.c:	switch (urd->class) {
./drivers/s390/char/vmur.c:	spin_lock(&urd->open_lock);
./drivers/s390/char/vmur.c:	while (urd->open_flag) {
./drivers/s390/char/vmur.c:		spin_unlock(&urd->open_lock);
./drivers/s390/char/vmur.c:		if (wait_event_interruptible(urd->wait, urd->open_flag == 0)) {
./drivers/s390/char/vmur.c:		spin_lock(&urd->open_lock);
./drivers/s390/char/vmur.c:	urd->open_flag++;
./drivers/s390/char/vmur.c:	spin_unlock(&urd->open_lock);
./drivers/s390/char/vmur.c:	if (((accmode == O_RDONLY) && (urd->class != DEV_CLASS_UR_I)) ||
./drivers/s390/char/vmur.c:	    ((accmode == O_WRONLY) && (urd->class != DEV_CLASS_UR_O))) {
./drivers/s390/char/vmur.c:		TRACE("ur_open: unsupported dev class (%d)\n", urd->class);
./drivers/s390/char/vmur.c:	urf->dev_reclen = urd->reclen;
./drivers/s390/char/vmur.c:	spin_lock(&urd->open_lock);
./drivers/s390/char/vmur.c:	urd->open_flag--;
./drivers/s390/char/vmur.c:	spin_unlock(&urd->open_lock);
./drivers/s390/char/vmur.c:	spin_lock(&urf->urd->open_lock);
./drivers/s390/char/vmur.c:	urf->urd->open_flag--;
./drivers/s390/char/vmur.c:	spin_unlock(&urf->urd->open_lock);
./drivers/s390/char/vmur.c:	wake_up_interruptible(&urf->urd->wait);
./drivers/s390/char/vmur.c: *     urd->char_device is used as indication that the online function has
./drivers/s390/char/vmur.c:	urd->class = get_urd_class(urd);
./drivers/s390/char/vmur.c:	if (urd->class < 0) {
./drivers/s390/char/vmur.c:		rc = urd->class;
./drivers/s390/char/vmur.c:	if ((urd->class != DEV_CLASS_UR_I) && (urd->class != DEV_CLASS_UR_O)) {
./drivers/s390/char/vmur.c:	if (urd->char_device) {
./drivers/s390/char/vmur.c:	minor = urd->dev_id.devno;
./drivers/s390/char/vmur.c:	urd->char_device = cdev_alloc();
./drivers/s390/char/vmur.c:	if (!urd->char_device) {
./drivers/s390/char/vmur.c:	cdev_init(urd->char_device, &ur_fops);
./drivers/s390/char/vmur.c:	urd->char_device->dev = MKDEV(major, minor);
./drivers/s390/char/vmur.c:	urd->char_device->owner = ur_fops.owner;
./drivers/s390/char/vmur.c:	rc = cdev_add(urd->char_device, urd->char_device->dev, 1);
./drivers/s390/char/vmur.c:	if (urd->cdev->id.cu_type == READER_PUNCH_DEVTYPE) {
./drivers/s390/char/vmur.c:		if (urd->class == DEV_CLASS_UR_I)
./drivers/s390/char/vmur.c:		if (urd->class == DEV_CLASS_UR_O)
./drivers/s390/char/vmur.c:	} else if (urd->cdev->id.cu_type == PRINTER_DEVTYPE) {
./drivers/s390/char/vmur.c:	urd->device = device_create(vmur_class, NULL, urd->char_device->dev,
./drivers/s390/char/vmur.c:	if (IS_ERR(urd->device)) {
./drivers/s390/char/vmur.c:		rc = PTR_ERR(urd->device);
./drivers/s390/char/vmur.c:	cdev_del(urd->char_device);
./drivers/s390/char/vmur.c:	urd->char_device = NULL;
./drivers/s390/char/vmur.c:	if (!urd->char_device) {
./drivers/s390/char/vmur.c:	if (!force && (atomic_read(&urd->ref_count) > 2)) {
./drivers/s390/char/vmur.c:	device_destroy(vmur_class, urd->char_device->dev);
./drivers/s390/char/vmur.c:	cdev_del(urd->char_device);
./drivers/s390/char/vmur.c:	urd->char_device = NULL;
./drivers/s390/char/tape_34xx.c:	 * If there is a block with a lower number but the same hard-
./drivers/s390/cio/airq.c:	 * Access indicator array in word-sized chunks to minimize storage
./drivers/s390/net/qeth_l2_main.c:	if ((card->state != CARD_STATE_UP) &&
./drivers/s390/net/qeth_l2_main.c:		(card->state != CARD_STATE_SOFTSETUP))
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_l2_main.c:		if ((card->info.type == QETH_CARD_TYPE_OSD ||
./drivers/s390/net/qeth_l2_main.c:		     card->info.type == QETH_CARD_TYPE_OSM ||
./drivers/s390/net/qeth_l2_main.c:		     card->info.type == QETH_CARD_TYPE_OSX) &&
./drivers/s390/net/qeth_l2_main.c:		    !card->info.guestlan)
./drivers/s390/net/qeth_l2_main.c:		if (card->dev == dev) {
./drivers/s390/net/qeth_l2_main.c:			ndev = card->dev;
./drivers/s390/net/qeth_l2_main.c:		list_add_tail(&mc->list, &card->mc_list);
./drivers/s390/net/qeth_l2_main.c:	spin_lock_bh(&card->mclock);
./drivers/s390/net/qeth_l2_main.c:	list_for_each_entry_safe(mc, tmp, &card->mc_list, list) {
./drivers/s390/net/qeth_l2_main.c:	spin_unlock_bh(&card->mclock);
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_l2_main.c:	spin_lock_bh(&card->vlanlock);
./drivers/s390/net/qeth_l2_main.c:	list_for_each_entry(id, &card->vid_list, list) {
./drivers/s390/net/qeth_l2_main.c:	spin_unlock_bh(&card->vlanlock);
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_OSM) {
./drivers/s390/net/qeth_l2_main.c:		spin_lock_bh(&card->vlanlock);
./drivers/s390/net/qeth_l2_main.c:		list_add_tail(&id->list, &card->vid_list);
./drivers/s390/net/qeth_l2_main.c:		spin_unlock_bh(&card->vlanlock);
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_OSM) {
./drivers/s390/net/qeth_l2_main.c:	spin_lock_bh(&card->vlanlock);
./drivers/s390/net/qeth_l2_main.c:	list_for_each_entry(id, &card->vid_list, list) {
./drivers/s390/net/qeth_l2_main.c:	spin_unlock_bh(&card->vlanlock);
./drivers/s390/net/qeth_l2_main.c:	qeth_l2_set_multicast_list(card->dev);
./drivers/s390/net/qeth_l2_main.c:	if (card->read.state == CH_STATE_UP &&
./drivers/s390/net/qeth_l2_main.c:	    card->write.state == CH_STATE_UP &&
./drivers/s390/net/qeth_l2_main.c:	    (card->state == CARD_STATE_UP)) {
./drivers/s390/net/qeth_l2_main.c:		    card->info.type != QETH_CARD_TYPE_OSN) {
./drivers/s390/net/qeth_l2_main.c:			qeth_l2_stop(card->dev);
./drivers/s390/net/qeth_l2_main.c:			dev_close(card->dev);
./drivers/s390/net/qeth_l2_main.c:		card->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;
./drivers/s390/net/qeth_l2_main.c:		card->state = CARD_STATE_SOFTSETUP;
./drivers/s390/net/qeth_l2_main.c:	if (card->state == CARD_STATE_SOFTSETUP) {
./drivers/s390/net/qeth_l2_main.c:		card->state = CARD_STATE_HARDSETUP;
./drivers/s390/net/qeth_l2_main.c:	if (card->state == CARD_STATE_HARDSETUP) {
./drivers/s390/net/qeth_l2_main.c:		card->state = CARD_STATE_DOWN;
./drivers/s390/net/qeth_l2_main.c:	if (card->state == CARD_STATE_DOWN) {
./drivers/s390/net/qeth_l2_main.c:		qeth_clear_cmd_buffers(&card->read);
./drivers/s390/net/qeth_l2_main.c:		qeth_clear_cmd_buffers(&card->write);
./drivers/s390/net/qeth_l2_main.c:			card->qdio.in_q->bufs[card->rx.b_index].buffer,
./drivers/s390/net/qeth_l2_main.c:			&card->rx.b_element, &card->rx.e_offset, &hdr);
./drivers/s390/net/qeth_l2_main.c:		skb->dev = card->dev;
./drivers/s390/net/qeth_l2_main.c:				*((__u32 *)skb->cb) = ++card->seqno.pkt_seqno;
./drivers/s390/net/qeth_l2_main.c:			if (card->info.type == QETH_CARD_TYPE_OSN) {
./drivers/s390/net/qeth_l2_main.c:				card->osn_info.data_cb(skb);
./drivers/s390/net/qeth_l2_main.c:		card->stats.rx_packets++;
./drivers/s390/net/qeth_l2_main.c:		card->stats.rx_bytes += len;
./drivers/s390/net/qeth_l2_main.c:	if (card->options.performance_stats) {
./drivers/s390/net/qeth_l2_main.c:		card->perf_stats.inbound_cnt++;
./drivers/s390/net/qeth_l2_main.c:		card->perf_stats.inbound_start_time = qeth_get_micros();
./drivers/s390/net/qeth_l2_main.c:		if (!card->rx.b_count) {
./drivers/s390/net/qeth_l2_main.c:			card->rx.qdio_err = 0;
./drivers/s390/net/qeth_l2_main.c:			card->rx.b_count = qdio_get_next_buffers(
./drivers/s390/net/qeth_l2_main.c:				card->data.ccwdev, 0, &card->rx.b_index,
./drivers/s390/net/qeth_l2_main.c:				&card->rx.qdio_err);
./drivers/s390/net/qeth_l2_main.c:			if (card->rx.b_count <= 0) {
./drivers/s390/net/qeth_l2_main.c:				card->rx.b_count = 0;
./drivers/s390/net/qeth_l2_main.c:			card->rx.b_element =
./drivers/s390/net/qeth_l2_main.c:				&card->qdio.in_q->bufs[card->rx.b_index]
./drivers/s390/net/qeth_l2_main.c:			card->rx.e_offset = 0;
./drivers/s390/net/qeth_l2_main.c:		while (card->rx.b_count) {
./drivers/s390/net/qeth_l2_main.c:			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
./drivers/s390/net/qeth_l2_main.c:			if (!(card->rx.qdio_err &&
./drivers/s390/net/qeth_l2_main.c:			    card->rx.qdio_err, "qinerr")))
./drivers/s390/net/qeth_l2_main.c:				if (card->options.performance_stats)
./drivers/s390/net/qeth_l2_main.c:					card->perf_stats.bufs_rec++;
./drivers/s390/net/qeth_l2_main.c:				qeth_queue_input_buffer(card, card->rx.b_index);
./drivers/s390/net/qeth_l2_main.c:				card->rx.b_count--;
./drivers/s390/net/qeth_l2_main.c:				if (card->rx.b_count) {
./drivers/s390/net/qeth_l2_main.c:					card->rx.b_index =
./drivers/s390/net/qeth_l2_main.c:						(card->rx.b_index + 1) %
./drivers/s390/net/qeth_l2_main.c:					card->rx.b_element =
./drivers/s390/net/qeth_l2_main.c:						&card->qdio.in_q
./drivers/s390/net/qeth_l2_main.c:						->bufs[card->rx.b_index]
./drivers/s390/net/qeth_l2_main.c:					card->rx.e_offset = 0;
./drivers/s390/net/qeth_l2_main.c:	if (qdio_start_irq(card->data.ccwdev, 0))
./drivers/s390/net/qeth_l2_main.c:		napi_schedule(&card->napi);
./drivers/s390/net/qeth_l2_main.c:	if (card->options.performance_stats)
./drivers/s390/net/qeth_l2_main.c:		card->perf_stats.inbound_time += qeth_get_micros() -
./drivers/s390/net/qeth_l2_main.c:			card->perf_stats.inbound_start_time;
./drivers/s390/net/qeth_l2_main.c:		card->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;
./drivers/s390/net/qeth_l2_main.c:			dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l2_main.c:			dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l2_main.c:		card->info.mac_bits |= QETH_LAYER2_MAC_REGISTERED;
./drivers/s390/net/qeth_l2_main.c:		memcpy(card->dev->dev_addr, cmd->data.setdelmac.mac,
./drivers/s390/net/qeth_l2_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l2_main.c:			card->dev->dev_addr, card->dev->name);
./drivers/s390/net/qeth_l2_main.c:	card->info.mac_bits &= ~QETH_LAYER2_MAC_REGISTERED;
./drivers/s390/net/qeth_l2_main.c:	if (!(card->info.mac_bits & QETH_LAYER2_MAC_REGISTERED))
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_IQD ||
./drivers/s390/net/qeth_l2_main.c:	    card->info.type == QETH_CARD_TYPE_OSM ||
./drivers/s390/net/qeth_l2_main.c:	    card->info.type == QETH_CARD_TYPE_OSX ||
./drivers/s390/net/qeth_l2_main.c:	    card->info.guestlan) {
./drivers/s390/net/qeth_l2_main.c:		QETH_DBF_HEX(SETUP, 2, card->dev->dev_addr, OSA_ADDR_LEN);
./drivers/s390/net/qeth_l2_main.c:		random_ether_addr(card->dev->dev_addr);
./drivers/s390/net/qeth_l2_main.c:		memcpy(card->dev->dev_addr, vendor_pre, 3);
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN ||
./drivers/s390/net/qeth_l2_main.c:	    card->info.type == QETH_CARD_TYPE_OSM ||
./drivers/s390/net/qeth_l2_main.c:	    card->info.type == QETH_CARD_TYPE_OSX) {
./drivers/s390/net/qeth_l2_main.c:	rc = qeth_l2_send_delmac(card, &card->dev->dev_addr[0]);
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_l2_main.c:	    (card->state != CARD_STATE_UP))
./drivers/s390/net/qeth_l2_main.c:	spin_lock_bh(&card->mclock);
./drivers/s390/net/qeth_l2_main.c:	spin_unlock_bh(&card->mclock);
./drivers/s390/net/qeth_l2_main.c:	struct qeth_qdio_out_q *queue = card->qdio.out_qs
./drivers/s390/net/qeth_l2_main.c:	if ((card->state != CARD_STATE_UP) || !card->lan_online) {
./drivers/s390/net/qeth_l2_main.c:		card->stats.tx_carrier_errors++;
./drivers/s390/net/qeth_l2_main.c:	if ((card->info.type == QETH_CARD_TYPE_OSN) &&
./drivers/s390/net/qeth_l2_main.c:	if (card->options.performance_stats) {
./drivers/s390/net/qeth_l2_main.c:		card->perf_stats.outbound_cnt++;
./drivers/s390/net/qeth_l2_main.c:		card->perf_stats.outbound_start_time = qeth_get_micros();
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_l2_main.c:		if (card->info.type == QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type != QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_l2_main.c:		card->stats.tx_packets++;
./drivers/s390/net/qeth_l2_main.c:		card->stats.tx_bytes += tx_bytes;
./drivers/s390/net/qeth_l2_main.c:	if (card->options.performance_stats)
./drivers/s390/net/qeth_l2_main.c:		card->perf_stats.outbound_time += qeth_get_micros() -
./drivers/s390/net/qeth_l2_main.c:			card->perf_stats.outbound_start_time;
./drivers/s390/net/qeth_l2_main.c:	card->stats.tx_dropped++;
./drivers/s390/net/qeth_l2_main.c:	card->stats.tx_errors++;
./drivers/s390/net/qeth_l2_main.c:	if (card->state == CARD_STATE_UP)
./drivers/s390/net/qeth_l2_main.c:	if (card->state != CARD_STATE_SOFTSETUP)
./drivers/s390/net/qeth_l2_main.c:	if ((card->info.type != QETH_CARD_TYPE_OSN) &&
./drivers/s390/net/qeth_l2_main.c:	     (!(card->info.mac_bits & QETH_LAYER2_MAC_REGISTERED))) {
./drivers/s390/net/qeth_l2_main.c:	card->data.state = CH_STATE_UP;
./drivers/s390/net/qeth_l2_main.c:	card->state = CARD_STATE_UP;
./drivers/s390/net/qeth_l2_main.c:	if (qdio_stop_irq(card->data.ccwdev, 0) >= 0) {
./drivers/s390/net/qeth_l2_main.c:		napi_enable(&card->napi);
./drivers/s390/net/qeth_l2_main.c:		napi_schedule(&card->napi);
./drivers/s390/net/qeth_l2_main.c:	if (card->state == CARD_STATE_UP) {
./drivers/s390/net/qeth_l2_main.c:		card->state = CARD_STATE_SOFTSETUP;
./drivers/s390/net/qeth_l2_main.c:		napi_disable(&card->napi);
./drivers/s390/net/qeth_l2_main.c:	INIT_LIST_HEAD(&card->vid_list);
./drivers/s390/net/qeth_l2_main.c:	INIT_LIST_HEAD(&card->mc_list);
./drivers/s390/net/qeth_l2_main.c:	card->options.layer2 = 1;
./drivers/s390/net/qeth_l2_main.c:	card->info.hwtrap = 0;
./drivers/s390/net/qeth_l2_main.c:	card->discipline.start_poll = qeth_qdio_start_poll;
./drivers/s390/net/qeth_l2_main.c:	card->discipline.input_handler = (qdio_handler_t *)
./drivers/s390/net/qeth_l2_main.c:	card->discipline.output_handler = (qdio_handler_t *)
./drivers/s390/net/qeth_l2_main.c:	card->discipline.recover = qeth_l2_recover;
./drivers/s390/net/qeth_l2_main.c:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./drivers/s390/net/qeth_l2_main.c:	if (card->dev) {
./drivers/s390/net/qeth_l2_main.c:		unregister_netdev(card->dev);
./drivers/s390/net/qeth_l2_main.c:		card->dev = NULL;
./drivers/s390/net/qeth_l2_main.c:	switch (card->info.type) {
./drivers/s390/net/qeth_l2_main.c:		card->dev = alloc_netdev(0, "hsi%d", ether_setup);
./drivers/s390/net/qeth_l2_main.c:		card->dev = alloc_netdev(0, "osn%d", ether_setup);
./drivers/s390/net/qeth_l2_main.c:		card->dev->flags |= IFF_NOARP;
./drivers/s390/net/qeth_l2_main.c:		card->dev = alloc_etherdev(0);
./drivers/s390/net/qeth_l2_main.c:	if (!card->dev)
./drivers/s390/net/qeth_l2_main.c:	card->dev->ml_priv = card;
./drivers/s390/net/qeth_l2_main.c:	card->dev->watchdog_timeo = QETH_TX_TIMEOUT;
./drivers/s390/net/qeth_l2_main.c:	card->dev->mtu = card->info.initial_mtu;
./drivers/s390/net/qeth_l2_main.c:	card->dev->netdev_ops = &qeth_l2_netdev_ops;
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type != QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_l2_main.c:		SET_ETHTOOL_OPS(card->dev, &qeth_l2_ethtool_ops);
./drivers/s390/net/qeth_l2_main.c:		SET_ETHTOOL_OPS(card->dev, &qeth_l2_osn_ops);
./drivers/s390/net/qeth_l2_main.c:	card->dev->features |= NETIF_F_HW_VLAN_FILTER;
./drivers/s390/net/qeth_l2_main.c:	card->info.broadcast_capable = 1;
./drivers/s390/net/qeth_l2_main.c:	SET_NETDEV_DEV(card->dev, &card->gdev->dev);
./drivers/s390/net/qeth_l2_main.c:	netif_napi_add(card->dev, &card->napi, qeth_l2_poll, QETH_NAPI_WEIGHT);
./drivers/s390/net/qeth_l2_main.c:	return register_netdev(card->dev);
./drivers/s390/net/qeth_l2_main.c:	mutex_lock(&card->discipline_mutex);
./drivers/s390/net/qeth_l2_main.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l2_main.c:	recover_flag = card->state;
./drivers/s390/net/qeth_l2_main.c:	if (!card->dev && qeth_l2_setup_netdev(card)) {
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type != QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_l2_main.c:		qeth_l2_send_setmac(card, &card->dev->dev_addr[0]);
./drivers/s390/net/qeth_l2_main.c:		if (card->info.hwtrap &&
./drivers/s390/net/qeth_l2_main.c:			card->info.hwtrap = 0;
./drivers/s390/net/qeth_l2_main.c:		card->info.hwtrap = 0;
./drivers/s390/net/qeth_l2_main.c:	card->state = CARD_STATE_HARDSETUP;
./drivers/s390/net/qeth_l2_main.c:	memset(&card->rx, 0, sizeof(struct qeth_rx));
./drivers/s390/net/qeth_l2_main.c:			dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l2_main.c:			card->lan_online = 0;
./drivers/s390/net/qeth_l2_main.c:		card->lan_online = 1;
./drivers/s390/net/qeth_l2_main.c:	if ((card->info.type == QETH_CARD_TYPE_OSD) ||
./drivers/s390/net/qeth_l2_main.c:	    (card->info.type == QETH_CARD_TYPE_OSX))
./drivers/s390/net/qeth_l2_main.c:	if (card->info.type != QETH_CARD_TYPE_OSN &&
./drivers/s390/net/qeth_l2_main.c:	    card->info.type != QETH_CARD_TYPE_OSM)
./drivers/s390/net/qeth_l2_main.c:	netif_tx_disable(card->dev);
./drivers/s390/net/qeth_l2_main.c:	card->state = CARD_STATE_SOFTSETUP;
./drivers/s390/net/qeth_l2_main.c:	if (card->lan_online)
./drivers/s390/net/qeth_l2_main.c:		netif_carrier_on(card->dev);
./drivers/s390/net/qeth_l2_main.c:		netif_carrier_off(card->dev);
./drivers/s390/net/qeth_l2_main.c:		    card->info.type != QETH_CARD_TYPE_OSN) {
./drivers/s390/net/qeth_l2_main.c:			__qeth_l2_open(card->dev);
./drivers/s390/net/qeth_l2_main.c:			dev_open(card->dev);
./drivers/s390/net/qeth_l2_main.c:		qeth_l2_set_multicast_list(card->dev);
./drivers/s390/net/qeth_l2_main.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l2_main.c:	mutex_unlock(&card->discipline_mutex);
./drivers/s390/net/qeth_l2_main.c:		card->state = CARD_STATE_RECOVER;
./drivers/s390/net/qeth_l2_main.c:		card->state = CARD_STATE_DOWN;
./drivers/s390/net/qeth_l2_main.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l2_main.c:	mutex_unlock(&card->discipline_mutex);
./drivers/s390/net/qeth_l2_main.c:	mutex_lock(&card->discipline_mutex);
./drivers/s390/net/qeth_l2_main.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l2_main.c:	if (card->dev && netif_carrier_ok(card->dev))
./drivers/s390/net/qeth_l2_main.c:		netif_carrier_off(card->dev);
./drivers/s390/net/qeth_l2_main.c:	recover_flag = card->state;
./drivers/s390/net/qeth_l2_main.c:	if ((!recovery_mode && card->info.hwtrap) || card->info.hwtrap == 2) {
./drivers/s390/net/qeth_l2_main.c:		card->info.hwtrap = 1;
./drivers/s390/net/qeth_l2_main.c:		card->state = CARD_STATE_RECOVER;
./drivers/s390/net/qeth_l2_main.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l2_main.c:	mutex_unlock(&card->discipline_mutex);
./drivers/s390/net/qeth_l2_main.c:	dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l2_main.c:	__qeth_l2_set_offline(card->gdev, 1);
./drivers/s390/net/qeth_l2_main.c:	rc = __qeth_l2_set_online(card->gdev, 1);
./drivers/s390/net/qeth_l2_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l2_main.c:		dev_close(card->dev);
./drivers/s390/net/qeth_l2_main.c:		dev_warn(&card->gdev->dev, "The qeth device driver "
./drivers/s390/net/qeth_l2_main.c:	if ((gdev->state == CCWGROUP_ONLINE) && card->info.hwtrap)
./drivers/s390/net/qeth_l2_main.c:	if (card->dev)
./drivers/s390/net/qeth_l2_main.c:		netif_device_detach(card->dev);
./drivers/s390/net/qeth_l2_main.c:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./drivers/s390/net/qeth_l2_main.c:	if (card->state == CARD_STATE_UP) {
./drivers/s390/net/qeth_l2_main.c:		if (card->info.hwtrap)
./drivers/s390/net/qeth_l2_main.c:		__qeth_l2_set_offline(card->gdev, 1);
./drivers/s390/net/qeth_l2_main.c:		__qeth_l2_set_offline(card->gdev, 0);
./drivers/s390/net/qeth_l2_main.c:	if (card->state == CARD_STATE_RECOVER) {
./drivers/s390/net/qeth_l2_main.c:		rc = __qeth_l2_set_online(card->gdev, 1);
./drivers/s390/net/qeth_l2_main.c:			dev_close(card->dev);
./drivers/s390/net/qeth_l2_main.c:		rc = __qeth_l2_set_online(card->gdev, 0);
./drivers/s390/net/qeth_l2_main.c:	if (card->dev)
./drivers/s390/net/qeth_l2_main.c:		netif_device_attach(card->dev);
./drivers/s390/net/qeth_l2_main.c:		dev_warn(&card->gdev->dev, "The qeth device driver "
./drivers/s390/net/qeth_l2_main.c:	wait_event(card->wait_q,
./drivers/s390/net/qeth_l2_main.c:		   atomic_cmpxchg(&card->write.irq_pending, 0, 1) == 0);
./drivers/s390/net/qeth_l2_main.c:	spin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);
./drivers/s390/net/qeth_l2_main.c:	rc = ccw_device_start(card->write.ccwdev, &card->write.ccw,
./drivers/s390/net/qeth_l2_main.c:	spin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);
./drivers/s390/net/qeth_l2_main.c:		atomic_set(&card->write.irq_pending, 0);
./drivers/s390/net/qeth_l2_main.c:		wake_up(&card->wait_q);
./drivers/s390/net/qeth_l2_main.c:	if ((card->state != CARD_STATE_UP) &&
./drivers/s390/net/qeth_l2_main.c:	    (card->state != CARD_STATE_SOFTSETUP))
./drivers/s390/net/qeth_l2_main.c:	iob = qeth_wait_for_buffer(&card->write);
./drivers/s390/net/qeth_l2_main.c:	card->osn_info.assist_cb = assist_cb;
./drivers/s390/net/qeth_l2_main.c:	card->osn_info.data_cb = data_cb;
./drivers/s390/net/qeth_l2_main.c:	card->osn_info.assist_cb = NULL;
./drivers/s390/net/qeth_l2_main.c:	card->osn_info.data_cb = NULL;
./drivers/s390/net/qeth_l3_sys.c:		if (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)
./drivers/s390/net/qeth_l3_sys.c:		if (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)
./drivers/s390/net/qeth_l3_sys.c:		if (card->info.broadcast_capable == QETH_BROADCAST_WITHOUT_ECHO)
./drivers/s390/net/qeth_l3_sys.c:	return qeth_l3_dev_route_show(card, &card->options.route4, buf);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if (((card->state == CARD_STATE_SOFTSETUP) ||
./drivers/s390/net/qeth_l3_sys.c:	     (card->state == CARD_STATE_UP)) &&
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	return qeth_l3_dev_route_store(card, &card->options.route4,
./drivers/s390/net/qeth_l3_sys.c:	return qeth_l3_dev_route_show(card, &card->options.route6, buf);
./drivers/s390/net/qeth_l3_sys.c:	return qeth_l3_dev_route_store(card, &card->options.route6,
./drivers/s390/net/qeth_l3_sys.c:	return sprintf(buf, "%i\n", card->options.fake_broadcast? 1:0);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_l3_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_l3_sys.c:		card->options.fake_broadcast = i;
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||
./drivers/s390/net/qeth_l3_sys.c:	      (card->info.link_type == QETH_LINK_TYPE_LANE_TR)))
./drivers/s390/net/qeth_l3_sys.c:	return sprintf(buf, "%s\n", (card->options.broadcast_mode ==
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_l3_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_l3_sys.c:	if (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||
./drivers/s390/net/qeth_l3_sys.c:	      (card->info.link_type == QETH_LINK_TYPE_LANE_TR))) {
./drivers/s390/net/qeth_l3_sys.c:		card->options.broadcast_mode = QETH_TR_BROADCAST_LOCAL;
./drivers/s390/net/qeth_l3_sys.c:		card->options.broadcast_mode = QETH_TR_BROADCAST_ALLRINGS;
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||
./drivers/s390/net/qeth_l3_sys.c:	      (card->info.link_type == QETH_LINK_TYPE_LANE_TR)))
./drivers/s390/net/qeth_l3_sys.c:	return sprintf(buf, "%i\n", (card->options.macaddr_mode ==
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_l3_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_l3_sys.c:	if (!((card->info.link_type == QETH_LINK_TYPE_HSTR) ||
./drivers/s390/net/qeth_l3_sys.c:	      (card->info.link_type == QETH_LINK_TYPE_LANE_TR))) {
./drivers/s390/net/qeth_l3_sys.c:		card->options.macaddr_mode = i?
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	return sprintf(buf, "%i\n", card->options.sniffer ? 1 : 0);
./drivers/s390/net/qeth_l3_sys.c:	if (card->info.type != QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_l3_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_l3_sys.c:		card->options.sniffer = i;
./drivers/s390/net/qeth_l3_sys.c:		qdio_get_ssqd_desc(CARD_DDEV(card), &card->ssqd);
./drivers/s390/net/qeth_l3_sys.c:		if (card->ssqd.qdioac2 & QETH_SNIFF_AVAIL) {
./drivers/s390/net/qeth_l3_sys.c:			card->options.sniffer = i;
./drivers/s390/net/qeth_l3_sys.c:			if (card->qdio.init_pool.buf_count !=
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	return sprintf(buf, "%i\n", card->ipato.enabled? 1:0);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_l3_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.enabled = (card->ipato.enabled)? 0 : 1;
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.enabled = 1;
./drivers/s390/net/qeth_l3_sys.c:		list_for_each_entry_safe(tmpipa, t, card->ip_tbd_list, entry) {
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.enabled = 0;
./drivers/s390/net/qeth_l3_sys.c:		list_for_each_entry_safe(tmpipa, t, card->ip_tbd_list, entry) {
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	return sprintf(buf, "%i\n", card->ipato.invert4? 1:0);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.invert4 = (card->ipato.invert4)? 0 : 1;
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.invert4 = 1;
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.invert4 = 0;
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_sys.c:	list_for_each_entry(ipatoe, &card->ipato.entries, entry) {
./drivers/s390/net/qeth_l3_sys.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	return sprintf(buf, "%i\n", card->ipato.invert6? 1:0);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.invert6 = (card->ipato.invert6)? 0 : 1;
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.invert6 = 1;
./drivers/s390/net/qeth_l3_sys.c:		card->ipato.invert6 = 0;
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_sys.c:	list_for_each_entry(ipaddr, &card->ip_list, entry) {
./drivers/s390/net/qeth_l3_sys.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_sys.c:	list_for_each_entry(ipaddr, &card->ip_list, entry) {
./drivers/s390/net/qeth_l3_sys.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/lcs.c:	card->lan_type = LCS_FRAME_TYPE_AUTO;
./drivers/s390/net/lcs.c:	card->pkt_seq = 0;
./drivers/s390/net/lcs.c:	card->lancmd_timeout = LCS_LANCMD_TIMEOUT_DEFAULT;
./drivers/s390/net/lcs.c:	rc = lcs_alloc_channel(&card->read);
./drivers/s390/net/lcs.c:	rc = lcs_alloc_channel(&card->write);
./drivers/s390/net/lcs.c:		lcs_cleanup_channel(&card->read);
./drivers/s390/net/lcs.c:	INIT_LIST_HEAD(&card->ipm_list);
./drivers/s390/net/lcs.c:	memset(card->read.ccws, 0, sizeof (struct ccw1) * (LCS_NUM_BUFFS + 1));
./drivers/s390/net/lcs.c:		card->read.ccws[cnt].cmd_code = LCS_CCW_READ;
./drivers/s390/net/lcs.c:		card->read.ccws[cnt].count = LCS_IOBUFFERSIZE;
./drivers/s390/net/lcs.c:		card->read.ccws[cnt].flags =
./drivers/s390/net/lcs.c:		card->read.ccws[cnt].cda =
./drivers/s390/net/lcs.c:			(__u32) __pa(card->read.iob[cnt].data);
./drivers/s390/net/lcs.c:		 card->read.iob[cnt].data)->offset = LCS_ILLEGAL_OFFSET;
./drivers/s390/net/lcs.c:		card->read.iob[cnt].callback = lcs_get_frames_cb;
./drivers/s390/net/lcs.c:		card->read.iob[cnt].state = LCS_BUF_STATE_READY;
./drivers/s390/net/lcs.c:		card->read.iob[cnt].count = LCS_IOBUFFERSIZE;
./drivers/s390/net/lcs.c:	card->read.ccws[0].flags &= ~CCW_FLAG_PCI;
./drivers/s390/net/lcs.c:	card->read.ccws[LCS_NUM_BUFFS - 1].flags &= ~CCW_FLAG_PCI;
./drivers/s390/net/lcs.c:	card->read.ccws[LCS_NUM_BUFFS - 1].flags |= CCW_FLAG_SUSPEND;
./drivers/s390/net/lcs.c:	card->read.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;
./drivers/s390/net/lcs.c:	card->read.ccws[LCS_NUM_BUFFS].cda =
./drivers/s390/net/lcs.c:		(__u32) __pa(card->read.ccws);
./drivers/s390/net/lcs.c:	card->read.state = LCS_CH_STATE_INIT;
./drivers/s390/net/lcs.c:	card->read.io_idx = 0;
./drivers/s390/net/lcs.c:	card->read.buf_idx = 0;
./drivers/s390/net/lcs.c:	card->read.irq_tasklet.data = (unsigned long) &card->read;
./drivers/s390/net/lcs.c:	card->read.irq_tasklet.func = lcs_tasklet;
./drivers/s390/net/lcs.c:	init_waitqueue_head(&card->read.wait_q);
./drivers/s390/net/lcs.c:	memset(card->write.ccws, 0, sizeof(struct ccw1) * LCS_NUM_BUFFS + 1);
./drivers/s390/net/lcs.c:		card->write.ccws[cnt].cmd_code = LCS_CCW_WRITE;
./drivers/s390/net/lcs.c:		card->write.ccws[cnt].count = 0;
./drivers/s390/net/lcs.c:		card->write.ccws[cnt].flags =
./drivers/s390/net/lcs.c:		card->write.ccws[cnt].cda =
./drivers/s390/net/lcs.c:			(__u32) __pa(card->write.iob[cnt].data);
./drivers/s390/net/lcs.c:	card->write.ccws[LCS_NUM_BUFFS].cmd_code = LCS_CCW_TRANSFER;
./drivers/s390/net/lcs.c:	card->write.ccws[LCS_NUM_BUFFS].cda =
./drivers/s390/net/lcs.c:		(__u32) __pa(card->write.ccws);
./drivers/s390/net/lcs.c:	card->read.state = LCS_CH_STATE_INIT;
./drivers/s390/net/lcs.c:	card->write.io_idx = 0;
./drivers/s390/net/lcs.c:	card->write.buf_idx = 0;
./drivers/s390/net/lcs.c:	card->write.irq_tasklet.data = (unsigned long) &card->write;
./drivers/s390/net/lcs.c:	card->write.irq_tasklet.func = lcs_tasklet;
./drivers/s390/net/lcs.c:	init_waitqueue_head(&card->write.wait_q);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:	card->thread_allowed_mask = threads;
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:	wake_up(&card->wait_q);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        rc = (card->thread_running_mask & threads);
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        return wait_event_interruptible(card->wait_q,
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        if ( !(card->thread_allowed_mask & thread) ||
./drivers/s390/net/lcs.c:              (card->thread_start_mask & thread) ) {
./drivers/s390/net/lcs.c:                spin_unlock_irqrestore(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        card->thread_start_mask |= thread;
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        card->thread_running_mask &= ~thread;
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        wake_up(&card->wait_q);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        if (card->thread_start_mask & thread){
./drivers/s390/net/lcs.c:                if ((card->thread_allowed_mask & thread) &&
./drivers/s390/net/lcs.c:                    !(card->thread_running_mask & thread)){
./drivers/s390/net/lcs.c:                        card->thread_start_mask &= ~thread;
./drivers/s390/net/lcs.c:                        card->thread_running_mask |= thread;
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:        wait_event(card->wait_q,
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:                        (u8) card->thread_start_mask,
./drivers/s390/net/lcs.c:                        (u8) card->thread_allowed_mask,
./drivers/s390/net/lcs.c:                        (u8) card->thread_running_mask);
./drivers/s390/net/lcs.c:        rc = (card->thread_start_mask & thread);
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->mask_lock, flags);
./drivers/s390/net/lcs.c:	card->state = DEV_STATE_DOWN;
./drivers/s390/net/lcs.c:	card->tx_buffer = NULL;
./drivers/s390/net/lcs.c:	card->tx_emitted = 0;
./drivers/s390/net/lcs.c:	init_waitqueue_head(&card->wait_q);
./drivers/s390/net/lcs.c:	spin_lock_init(&card->lock);
./drivers/s390/net/lcs.c:	spin_lock_init(&card->ipm_lock);
./drivers/s390/net/lcs.c:	spin_lock_init(&card->mask_lock);
./drivers/s390/net/lcs.c:	INIT_LIST_HEAD(&card->ipm_list);
./drivers/s390/net/lcs.c:	INIT_LIST_HEAD(&card->lancmd_waiters);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	while (!list_empty(&card->ipm_list)){
./drivers/s390/net/lcs.c:		ipm = list_entry(card->ipm_list.next,
./drivers/s390/net/lcs.c:			spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:			spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	if (card->dev != NULL)
./drivers/s390/net/lcs.c:		free_netdev(card->dev);
./drivers/s390/net/lcs.c:	lcs_cleanup_channel(&card->write);
./drivers/s390/net/lcs.c:	lcs_cleanup_channel(&card->read);
./drivers/s390/net/lcs.c:	rc = lcs_start_channel(&card->read);
./drivers/s390/net/lcs.c:	rc = lcs_start_channel(&card->write);
./drivers/s390/net/lcs.c:		lcs_stop_channel(&card->read);
./drivers/s390/net/lcs.c:	lcs_stop_channel(&card->read);
./drivers/s390/net/lcs.c:	lcs_stop_channel(&card->write);
./drivers/s390/net/lcs.c:	wait_event(card->write.wait_q,
./drivers/s390/net/lcs.c:		   ((buffer = lcs_get_buffer(&card->write)) != NULL));
./drivers/s390/net/lcs.c:	spin_lock(&card->lock);
./drivers/s390/net/lcs.c:	list_for_each_safe(l, n, &card->lancmd_waiters) {
./drivers/s390/net/lcs.c:	spin_unlock(&card->lock);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&reply->card->lock, flags);
./drivers/s390/net/lcs.c:				 &reply->card->lancmd_waiters,list) {
./drivers/s390/net/lcs.c:			spin_unlock_irqrestore(&reply->card->lock, flags);
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&reply->card->lock, flags);
./drivers/s390/net/lcs.c:	cmd->sequence_no = card->sequence_no++;
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/s390/net/lcs.c:	list_add_tail(&reply->list, &card->lancmd_waiters);
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/s390/net/lcs.c:	rc = lcs_ready_buffer(&card->write, buffer);
./drivers/s390/net/lcs.c:	timer.expires = jiffies + HZ*card->lancmd_timeout;
./drivers/s390/net/lcs.c:	memcpy(card->mac, cmd->cmd.lcs_lanstat_cmd.mac_addr, LCS_MAC_LENGTH);
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_std_cmd.lan_type = card->lan_type;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_std_cmd.portno = card->portno;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_std_cmd.lan_type = card->lan_type;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_std_cmd.portno = card->portno;
./drivers/s390/net/lcs.c:	card->lan_type = cmd->cmd.lcs_std_cmd.lan_type;
./drivers/s390/net/lcs.c:	card->portno = cmd->cmd.lcs_std_cmd.portno;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_std_cmd.lan_type = card->lan_type;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_std_cmd.portno = card->portno;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_qipassist.lan_type = card->lan_type;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_qipassist.portno = card->portno;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_qipassist.lan_type = card->lan_type;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_qipassist.portno = card->portno;
./drivers/s390/net/lcs.c:	card->ip_assists_supported =
./drivers/s390/net/lcs.c:	card->ip_assists_enabled =
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_qipassist.lan_type = card->lan_type;
./drivers/s390/net/lcs.c:	cmd->cmd.lcs_qipassist.portno = card->portno;
./drivers/s390/net/lcs.c:	if (card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT)
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	list_for_each_entry_safe(ipm, tmp, &card->ipm_list, list){
./drivers/s390/net/lcs.c:			spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:			spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:				list_add_tail(&ipm->list, &card->ipm_list);
./drivers/s390/net/lcs.c:			spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:			spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:		list_move_tail(&ipm->list, &card->ipm_list);
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	list_for_each(l, &card->ipm_list) {
./drivers/s390/net/lcs.c:			lcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	list_for_each(l, &card->ipm_list) {
./drivers/s390/net/lcs.c:	spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:		lcs_get_mac_for_ipm(im4->multiaddr, buf, card->dev);
./drivers/s390/net/lcs.c:		spin_lock_irqsave(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:		list_add(&ipm->list, &card->ipm_list);
./drivers/s390/net/lcs.c:		spin_unlock_irqrestore(&card->ipm_lock, flags);
./drivers/s390/net/lcs.c:	in4_dev = in_dev_get(card->dev);
./drivers/s390/net/lcs.c:	netif_carrier_off(card->dev);
./drivers/s390/net/lcs.c:	netif_tx_disable(card->dev);
./drivers/s390/net/lcs.c:	wait_event(card->write.wait_q,
./drivers/s390/net/lcs.c:			(card->write.state != LCS_CH_STATE_RUNNING));
./drivers/s390/net/lcs.c:	if (card->state == DEV_STATE_UP) {
./drivers/s390/net/lcs.c:		netif_carrier_on(card->dev);
./drivers/s390/net/lcs.c:		netif_wake_queue(card->dev);
./drivers/s390/net/lcs.c:		schedule_work(&card->kernel_thread_starter);
./drivers/s390/net/lcs.c:		schedule_work(&card->kernel_thread_starter);
./drivers/s390/net/lcs.c:	if (card->read.ccwdev == cdev)
./drivers/s390/net/lcs.c:		channel = &card->read;
./drivers/s390/net/lcs.c:		channel = &card->write;
./drivers/s390/net/lcs.c:		wake_up(&card->wait_q);
./drivers/s390/net/lcs.c:	*(__u16 *)(card->tx_buffer->data + card->tx_buffer->count) = 0;
./drivers/s390/net/lcs.c:	card->tx_buffer->count += 2;
./drivers/s390/net/lcs.c:	lcs_ready_buffer(&card->write, card->tx_buffer);
./drivers/s390/net/lcs.c:	card->tx_buffer = NULL;
./drivers/s390/net/lcs.c:	card->tx_emitted++;
./drivers/s390/net/lcs.c:	if (netif_queue_stopped(card->dev) && netif_carrier_ok(card->dev))
./drivers/s390/net/lcs.c:		netif_wake_queue(card->dev);
./drivers/s390/net/lcs.c:	spin_lock(&card->lock);
./drivers/s390/net/lcs.c:	card->tx_emitted--;
./drivers/s390/net/lcs.c:	if (card->tx_emitted <= 0 && card->tx_buffer != NULL)
./drivers/s390/net/lcs.c:	spin_unlock(&card->lock);
./drivers/s390/net/lcs.c:		card->stats.tx_dropped++;
./drivers/s390/net/lcs.c:		card->stats.tx_errors++;
./drivers/s390/net/lcs.c:	if (card->state != DEV_STATE_UP) {
./drivers/s390/net/lcs.c:		card->stats.tx_dropped++;
./drivers/s390/net/lcs.c:		card->stats.tx_errors++;
./drivers/s390/net/lcs.c:		card->stats.tx_carrier_errors++;
./drivers/s390/net/lcs.c:	netif_stop_queue(card->dev);
./drivers/s390/net/lcs.c:	spin_lock(&card->lock);
./drivers/s390/net/lcs.c:	if (card->tx_buffer != NULL &&
./drivers/s390/net/lcs.c:	    card->tx_buffer->count + sizeof(struct lcs_header) +
./drivers/s390/net/lcs.c:	if (card->tx_buffer == NULL) {
./drivers/s390/net/lcs.c:		card->tx_buffer = lcs_get_buffer(&card->write);
./drivers/s390/net/lcs.c:		if (card->tx_buffer == NULL) {
./drivers/s390/net/lcs.c:			card->stats.tx_dropped++;
./drivers/s390/net/lcs.c:		card->tx_buffer->callback = lcs_txbuffer_cb;
./drivers/s390/net/lcs.c:		card->tx_buffer->count = 0;
./drivers/s390/net/lcs.c:		(card->tx_buffer->data + card->tx_buffer->count);
./drivers/s390/net/lcs.c:	card->tx_buffer->count += skb->len + sizeof(struct lcs_header);
./drivers/s390/net/lcs.c:	header->offset = card->tx_buffer->count;
./drivers/s390/net/lcs.c:	header->type = card->lan_type;
./drivers/s390/net/lcs.c:	header->slot = card->portno;
./drivers/s390/net/lcs.c:	spin_unlock(&card->lock);
./drivers/s390/net/lcs.c:	card->stats.tx_bytes += skb->len;
./drivers/s390/net/lcs.c:	card->stats.tx_packets++;
./drivers/s390/net/lcs.c:	netif_wake_queue(card->dev);
./drivers/s390/net/lcs.c:	spin_lock(&card->lock);
./drivers/s390/net/lcs.c:	if (card->tx_emitted <= 0 && card->tx_buffer != NULL)
./drivers/s390/net/lcs.c:	spin_unlock(&card->lock);
./drivers/s390/net/lcs.c:	card->lan_type = LCS_FRAME_TYPE_ENET;
./drivers/s390/net/lcs.c:	card->lan_type = LCS_FRAME_TYPE_TR;
./drivers/s390/net/lcs.c:	card->lan_type = LCS_FRAME_TYPE_FDDI;
./drivers/s390/net/lcs.c:	if (card->portno != LCS_INVALID_PORT_NO) {
./drivers/s390/net/lcs.c:		if (card->lan_type == LCS_FRAME_TYPE_AUTO)
./drivers/s390/net/lcs.c:                        card->portno = i;
./drivers/s390/net/lcs.c:                        if (card->lan_type != LCS_FRAME_TYPE_AUTO)
./drivers/s390/net/lcs.c:	if (card->dev)
./drivers/s390/net/lcs.c:		netif_stop_queue(card->dev);
./drivers/s390/net/lcs.c:		card->state = DEV_STATE_UP;
./drivers/s390/net/lcs.c:		card->state = DEV_STATE_DOWN;
./drivers/s390/net/lcs.c:		card->write.state = LCS_CH_STATE_INIT;
./drivers/s390/net/lcs.c:		card->read.state =  LCS_CH_STATE_INIT;
./drivers/s390/net/lcs.c:	if (card->read.state != LCS_CH_STATE_STOPPED &&
./drivers/s390/net/lcs.c:	    card->write.state != LCS_CH_STATE_STOPPED &&
./drivers/s390/net/lcs.c:	    card->read.state != LCS_CH_STATE_ERROR &&
./drivers/s390/net/lcs.c:	    card->write.state != LCS_CH_STATE_ERROR &&
./drivers/s390/net/lcs.c:	    card->state == DEV_STATE_UP) {
./drivers/s390/net/lcs.c:	card->state = DEV_STATE_DOWN;
./drivers/s390/net/lcs.c:				   card->dev->name);
./drivers/s390/net/lcs.c:			if (card->dev)
./drivers/s390/net/lcs.c:				netif_carrier_off(card->dev);
./drivers/s390/net/lcs.c:	if (card->dev == NULL ||
./drivers/s390/net/lcs.c:	    card->state != DEV_STATE_UP)
./drivers/s390/net/lcs.c:		dev_err(&card->dev->dev,
./drivers/s390/net/lcs.c:			  card->dev->name);
./drivers/s390/net/lcs.c:		card->stats.rx_dropped++;
./drivers/s390/net/lcs.c:	skb->protocol =	card->lan_type_trans(skb, card->dev);
./drivers/s390/net/lcs.c:	card->stats.rx_bytes += skb_len;
./drivers/s390/net/lcs.c:	card->stats.rx_packets++;
./drivers/s390/net/lcs.c:		*((__u32 *)skb->cb) = ++card->pkt_seq;
./drivers/s390/net/lcs.c:			card->stats.rx_length_errors++;
./drivers/s390/net/lcs.c:			card->stats.rx_errors++;
./drivers/s390/net/lcs.c:	lcs_ready_buffer(&card->read, buffer);
./drivers/s390/net/lcs.c:	return &card->stats;
./drivers/s390/net/lcs.c:	wait_event(card->write.wait_q,
./drivers/s390/net/lcs.c:		(card->write.state != LCS_CH_STATE_RUNNING));
./drivers/s390/net/lcs.c:		dev_err(&card->dev->dev,
./drivers/s390/net/lcs.c:		card->state = DEV_STATE_UP;
./drivers/s390/net/lcs.c:        return sprintf(buf, "%d\n", card->portno);
./drivers/s390/net/lcs.c:        card->portno = value;
./drivers/s390/net/lcs.c:	return card ? sprintf(buf, "%u\n", card->lancmd_timeout) : 0;
./drivers/s390/net/lcs.c:        card->lancmd_timeout = value;
./drivers/s390/net/lcs.c:	if (card->state != DEV_STATE_UP)
./drivers/s390/net/lcs.c:	card->gdev = ccwgdev;
./drivers/s390/net/lcs.c:	INIT_WORK(&card->kernel_thread_starter, lcs_start_kernel_thread);
./drivers/s390/net/lcs.c:	card->thread_start_mask = 0;
./drivers/s390/net/lcs.c:	card->thread_allowed_mask = 0;
./drivers/s390/net/lcs.c:	card->thread_running_mask = 0;
./drivers/s390/net/lcs.c:	if (card->dev->reg_state != NETREG_UNINITIALIZED)
./drivers/s390/net/lcs.c:	SET_NETDEV_DEV(card->dev, &ccwgdev->dev);
./drivers/s390/net/lcs.c:	return register_netdev(card->dev);
./drivers/s390/net/lcs.c:	card->read.ccwdev  = ccwgdev->cdev[0];
./drivers/s390/net/lcs.c:	card->write.ccwdev = ccwgdev->cdev[1];
./drivers/s390/net/lcs.c:	recover_state = card->state;
./drivers/s390/net/lcs.c:	rc = ccw_device_set_online(card->read.ccwdev);
./drivers/s390/net/lcs.c:	rc = ccw_device_set_online(card->write.ccwdev);
./drivers/s390/net/lcs.c:		dev_err(&card->dev->dev,
./drivers/s390/net/lcs.c:	if (card->dev) {
./drivers/s390/net/lcs.c:	switch (card->lan_type) {
./drivers/s390/net/lcs.c:		card->lan_type_trans = eth_type_trans;
./drivers/s390/net/lcs.c:		card->lan_type_trans = tr_type_trans;
./drivers/s390/net/lcs.c:		card->lan_type_trans = fddi_type_trans;
./drivers/s390/net/lcs.c:	card->dev = dev;
./drivers/s390/net/lcs.c:	card->dev->ml_priv = card;
./drivers/s390/net/lcs.c:	card->dev->netdev_ops = &lcs_netdev_ops;
./drivers/s390/net/lcs.c:	memcpy(card->dev->dev_addr, card->mac, LCS_MAC_LENGTH);
./drivers/s390/net/lcs.c:		card->dev->netdev_ops = &lcs_mc_netdev_ops;
./drivers/s390/net/lcs.c:		lcs_set_multicast_list(card->dev);
./drivers/s390/net/lcs.c:		card->dev->flags |= IFF_UP;
./drivers/s390/net/lcs.c:		netif_carrier_on(card->dev);
./drivers/s390/net/lcs.c:		netif_wake_queue(card->dev);
./drivers/s390/net/lcs.c:		card->state = DEV_STATE_UP;
./drivers/s390/net/lcs.c:	pr_info("LCS device %s %s IPv6 support\n", card->dev->name,
./drivers/s390/net/lcs.c:		(card->ip_assists_supported & LCS_IPASS_IPV6_SUPPORT) ?
./drivers/s390/net/lcs.c:	pr_info("LCS device %s %s Multicast support\n", card->dev->name,
./drivers/s390/net/lcs.c:		(card->ip_assists_supported & LCS_IPASS_MULTICAST_SUPPORT) ?
./drivers/s390/net/lcs.c:	ccw_device_set_offline(card->write.ccwdev);
./drivers/s390/net/lcs.c:	ccw_device_set_offline(card->read.ccwdev);
./drivers/s390/net/lcs.c:	recover_state = card->state;
./drivers/s390/net/lcs.c:	ret = lcs_stop_device(card->dev);
./drivers/s390/net/lcs.c:	ret = ccw_device_set_offline(card->read.ccwdev);
./drivers/s390/net/lcs.c:	ret = ccw_device_set_offline(card->write.ccwdev);
./drivers/s390/net/lcs.c:		card->state = DEV_STATE_RECOVER;
./drivers/s390/net/lcs.c:	gdev = card->gdev;
./drivers/s390/net/lcs.c:			card->dev->name);
./drivers/s390/net/lcs.c:			card->dev->name);
./drivers/s390/net/lcs.c:	if (card->dev)
./drivers/s390/net/lcs.c:		unregister_netdev(card->dev);
./drivers/s390/net/lcs.c:	if (card->dev)
./drivers/s390/net/lcs.c:		netif_device_detach(card->dev);
./drivers/s390/net/lcs.c:	if (card->state != DEV_STATE_DOWN)
./drivers/s390/net/lcs.c:		__lcs_shutdown_device(card->gdev, 1);
./drivers/s390/net/lcs.c:	if (card->state == DEV_STATE_RECOVER)
./drivers/s390/net/lcs.c:		rc = lcs_new_device(card->gdev);
./drivers/s390/net/lcs.c:	if (card->dev)
./drivers/s390/net/lcs.c:		netif_device_attach(card->dev);
./drivers/s390/net/lcs.c:		dev_warn(&card->gdev->dev, "The lcs device driver "
./drivers/s390/net/qeth_core_sys.c:	switch (card->state) {
./drivers/s390/net/qeth_core_sys.c:		if (card->lan_online)
./drivers/s390/net/qeth_core_sys.c:	return sprintf(buf, "%02X\n", card->info.chpid);
./drivers/s390/net/qeth_core_sys.c:	if (card->qdio.in_buf_size == 16384)
./drivers/s390/net/qeth_core_sys.c:	else if (card->qdio.in_buf_size == 24576)
./drivers/s390/net/qeth_core_sys.c:	else if (card->qdio.in_buf_size == 32768)
./drivers/s390/net/qeth_core_sys.c:	else if (card->qdio.in_buf_size == 40960)
./drivers/s390/net/qeth_core_sys.c:	return sprintf(buf, "%i\n", card->info.portno);
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_core_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_core_sys.c:	limit = (card->ssqd.pcnt ? card->ssqd.pcnt - 1 : card->ssqd.pcnt);
./drivers/s390/net/qeth_core_sys.c:	card->info.portno = portno;
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if (card->info.portname_required) {
./drivers/s390/net/qeth_core_sys.c:		memcpy(portname, card->info.portname + 1, 8);
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_core_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_core_sys.c:	card->info.portname[0] = strlen(tmp);
./drivers/s390/net/qeth_core_sys.c:		card->info.portname[i] = ' ';
./drivers/s390/net/qeth_core_sys.c:	strcpy(card->info.portname + 1, tmp);
./drivers/s390/net/qeth_core_sys.c:	ASCEBC(card->info.portname + 1, 8);
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	switch (card->qdio.do_prio_queueing) {
./drivers/s390/net/qeth_core_sys.c:			       card->qdio.default_out_queue);
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_core_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_core_sys.c:	if (card->qdio.no_out_queues == 1) {
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_PRIO_Q_ING_PREC;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_PRIO_Q_ING_TOS;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.default_out_queue = 0;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.default_out_queue = 1;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.default_out_queue = 2;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.default_out_queue = 3;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.do_prio_queueing = QETH_NO_PRIO_QUEUEING;
./drivers/s390/net/qeth_core_sys.c:		card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	return sprintf(buf, "%i\n", card->qdio.in_buf_pool.buf_count);
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_core_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_core_sys.c:	old_cnt = card->qdio.in_buf_pool.buf_count;
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if (card->state != CARD_STATE_UP)
./drivers/s390/net/qeth_core_sys.c:	return sprintf(buf, "%i\n", card->options.performance_stats ? 1:0);
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:		if (i == card->options.performance_stats)
./drivers/s390/net/qeth_core_sys.c:		card->options.performance_stats = i;
./drivers/s390/net/qeth_core_sys.c:			memset(&card->perf_stats, 0,
./drivers/s390/net/qeth_core_sys.c:		card->perf_stats.initial_rx_packets = card->stats.rx_packets;
./drivers/s390/net/qeth_core_sys.c:		card->perf_stats.initial_tx_packets = card->stats.tx_packets;
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	return sprintf(buf, "%i\n", card->options.layer2);
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->discipline_mutex);
./drivers/s390/net/qeth_core_sys.c:	if (card->state != CARD_STATE_DOWN) {
./drivers/s390/net/qeth_core_sys.c:	if (card->options.layer2 == newdis)
./drivers/s390/net/qeth_core_sys.c:		card->info.mac_bits  = 0;
./drivers/s390/net/qeth_core_sys.c:		if (card->discipline.ccwgdriver) {
./drivers/s390/net/qeth_core_sys.c:			card->discipline.ccwgdriver->remove(card->gdev);
./drivers/s390/net/qeth_core_sys.c:	rc = card->discipline.ccwgdriver->probe(card->gdev);
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->discipline_mutex);
./drivers/s390/net/qeth_core_sys.c:	switch (card->options.isolation) {
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if (card->info.type != QETH_CARD_TYPE_OSD &&
./drivers/s390/net/qeth_core_sys.c:	    card->info.type != QETH_CARD_TYPE_OSX &&
./drivers/s390/net/qeth_core_sys.c:	    card->info.type != QETH_CARD_TYPE_UNKNOWN) {
./drivers/s390/net/qeth_core_sys.c:		dev_err(&card->gdev->dev, "Adapter does not "
./drivers/s390/net/qeth_core_sys.c:	card->options.isolation = isolation;
./drivers/s390/net/qeth_core_sys.c:	if (card->state == CARD_STATE_SOFTSETUP ||
./drivers/s390/net/qeth_core_sys.c:	    card->state == CARD_STATE_UP) {
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if (card->info.hwtrap)
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if (card->state == CARD_STATE_SOFTSETUP || card->state == CARD_STATE_UP)
./drivers/s390/net/qeth_core_sys.c:	if (!strcmp(tmp, "arm") && !card->info.hwtrap) {
./drivers/s390/net/qeth_core_sys.c:					card->info.hwtrap = 1;
./drivers/s390/net/qeth_core_sys.c:			card->info.hwtrap = 1;
./drivers/s390/net/qeth_core_sys.c:	} else if (!strcmp(tmp, "disarm") && card->info.hwtrap) {
./drivers/s390/net/qeth_core_sys.c:				card->info.hwtrap = 0;
./drivers/s390/net/qeth_core_sys.c:			card->info.hwtrap = 0;
./drivers/s390/net/qeth_core_sys.c:	} else if (!strcmp(tmp, "trap") && state && card->info.hwtrap)
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_core_sys.c:	    (card->state != CARD_STATE_RECOVER)) {
./drivers/s390/net/qeth_core_sys.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_core_sys.c:	return qeth_dev_blkt_show(buf, card, card->info.blkt.time_total);
./drivers/s390/net/qeth_core_sys.c:				   &card->info.blkt.time_total, 5000);
./drivers/s390/net/qeth_core_sys.c:	return qeth_dev_blkt_show(buf, card, card->info.blkt.inter_packet);
./drivers/s390/net/qeth_core_sys.c:				   &card->info.blkt.inter_packet, 1000);
./drivers/s390/net/qeth_core_sys.c:				  card->info.blkt.inter_packet_jumbo);
./drivers/s390/net/qeth_core_sys.c:				   &card->info.blkt.inter_packet_jumbo, 1000);
./drivers/s390/net/qeth_core_main.c:	if (card->info.guestlan) {
./drivers/s390/net/qeth_core_main.c:		switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:		switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:	if (card->info.guestlan) {
./drivers/s390/net/qeth_core_main.c:		switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:		switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:			switch (card->info.link_type) {
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	card->thread_allowed_mask = threads;
./drivers/s390/net/qeth_core_main.c:		card->thread_start_mask &= threads;
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	rc = (card->thread_running_mask & threads);
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	return wait_event_interruptible(card->wait_q,
./drivers/s390/net/qeth_core_main.c:			    &card->qdio.in_buf_pool.entry_list, list){
./drivers/s390/net/qeth_core_main.c:	for (i = 0; i < card->qdio.init_pool.buf_count; ++i) {
./drivers/s390/net/qeth_core_main.c:			 &card->qdio.init_pool.entry_list);
./drivers/s390/net/qeth_core_main.c:	if ((card->state != CARD_STATE_DOWN) &&
./drivers/s390/net/qeth_core_main.c:	    (card->state != CARD_STATE_RECOVER))
./drivers/s390/net/qeth_core_main.c:	card->qdio.in_buf_pool.buf_count = bufcnt;
./drivers/s390/net/qeth_core_main.c:	card->qdio.init_pool.buf_count = bufcnt;
./drivers/s390/net/qeth_core_main.c:	if (card->read.state != CH_STATE_UP)
./drivers/s390/net/qeth_core_main.c:	iob = qeth_get_buffer(&card->read);
./drivers/s390/net/qeth_core_main.c:		dev_warn(&card->gdev->dev, "The qeth device driver "
./drivers/s390/net/qeth_core_main.c:			"available\n", dev_name(&card->gdev->dev));
./drivers/s390/net/qeth_core_main.c:	qeth_setup_ccw(&card->read, iob->data, QETH_BUFSIZE);
./drivers/s390/net/qeth_core_main.c:	rc = ccw_device_start(card->read.ccwdev, &card->read.ccw,
./drivers/s390/net/qeth_core_main.c:			"rc=%i\n", dev_name(&card->gdev->dev), rc);
./drivers/s390/net/qeth_core_main.c:		atomic_set(&card->read.irq_pending, 0);
./drivers/s390/net/qeth_core_main.c:		card->read_or_write_problem = 1;
./drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:				ipa_name, com, dev_name(&card->gdev->dev),
./drivers/s390/net/qeth_core_main.c:				ipa_name, com, dev_name(&card->gdev->dev),
./drivers/s390/net/qeth_core_main.c:				dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:					   card->info.chpid);
./drivers/s390/net/qeth_core_main.c:				card->lan_online = 0;
./drivers/s390/net/qeth_core_main.c:				if (card->dev && netif_carrier_ok(card->dev))
./drivers/s390/net/qeth_core_main.c:					netif_carrier_off(card->dev);
./drivers/s390/net/qeth_core_main.c:				dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:					   card->info.chpid);
./drivers/s390/net/qeth_core_main.c:				netif_carrier_on(card->dev);
./drivers/s390/net/qeth_core_main.c:				card->lan_online = 1;
./drivers/s390/net/qeth_core_main.c:				if (card->info.hwtrap)
./drivers/s390/net/qeth_core_main.c:					card->info.hwtrap = 2;
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	list_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	atomic_set(&card->write.irq_pending, 0);
./drivers/s390/net/qeth_core_main.c:			dev_err(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:	if (channel == &card->read)
./drivers/s390/net/qeth_core_main.c:	if ((cmd == NULL) && (card->state != CARD_STATE_DOWN))
./drivers/s390/net/qeth_core_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN &&
./drivers/s390/net/qeth_core_main.c:	    card->osn_info.assist_cb != NULL) {
./drivers/s390/net/qeth_core_main.c:		card->osn_info.assist_cb(card->dev, cmd);
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	list_for_each_entry_safe(reply, r, &card->cmd_waiter_list, list) {
./drivers/s390/net/qeth_core_main.c:			spin_unlock_irqrestore(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:				spin_lock_irqsave(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:					      &card->cmd_waiter_list);
./drivers/s390/net/qeth_core_main.c:				spin_unlock_irqrestore(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	memcpy(&card->seqno.pdu_hdr_ack,
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	if (!(card->thread_allowed_mask & thread) ||
./drivers/s390/net/qeth_core_main.c:	      (card->thread_start_mask & thread)) {
./drivers/s390/net/qeth_core_main.c:		spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	card->thread_start_mask |= thread;
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	card->thread_start_mask &= ~thread;
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	card->thread_running_mask &= ~thread;
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	if (card->thread_start_mask & thread) {
./drivers/s390/net/qeth_core_main.c:		if ((card->thread_allowed_mask & thread) &&
./drivers/s390/net/qeth_core_main.c:		    !(card->thread_running_mask & thread)) {
./drivers/s390/net/qeth_core_main.c:			card->thread_start_mask &= ~thread;
./drivers/s390/net/qeth_core_main.c:			card->thread_running_mask |= thread;
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	wait_event(card->wait_q,
./drivers/s390/net/qeth_core_main.c:		schedule_work(&card->kernel_thread_starter);
./drivers/s390/net/qeth_core_main.c:			if (card && (card->data.ccwdev == cdev)) {
./drivers/s390/net/qeth_core_main.c:				card->data.state = CH_STATE_DOWN;
./drivers/s390/net/qeth_core_main.c:				wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	if (card->read.ccwdev == cdev) {
./drivers/s390/net/qeth_core_main.c:		channel = &card->read;
./drivers/s390/net/qeth_core_main.c:	} else if (card->write.ccwdev == cdev) {
./drivers/s390/net/qeth_core_main.c:		channel = &card->write;
./drivers/s390/net/qeth_core_main.c:		channel = &card->data;
./drivers/s390/net/qeth_core_main.c:	if ((channel == &card->data) && (intparm != 0) &&
./drivers/s390/net/qeth_core_main.c:	if (channel == &card->data)
./drivers/s390/net/qeth_core_main.c:	if (channel == &card->read &&
./drivers/s390/net/qeth_core_main.c:	wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	for (i = 0; i < card->qdio.no_out_queues; ++i)
./drivers/s390/net/qeth_core_main.c:		if (card->qdio.out_qs[i]) {
./drivers/s390/net/qeth_core_main.c:				qeth_clear_output_buffer(card->qdio.out_qs[i],
./drivers/s390/net/qeth_core_main.c:						&card->qdio.out_qs[i]->bufs[j]);
./drivers/s390/net/qeth_core_main.c:				 &card->qdio.init_pool.entry_list, init_list){
./drivers/s390/net/qeth_core_main.c:	if (atomic_xchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED) ==
./drivers/s390/net/qeth_core_main.c:	kfree(card->qdio.in_q);
./drivers/s390/net/qeth_core_main.c:	card->qdio.in_q = NULL;
./drivers/s390/net/qeth_core_main.c:	if (card->qdio.out_qs) {
./drivers/s390/net/qeth_core_main.c:		for (i = 0; i < card->qdio.no_out_queues; ++i) {
./drivers/s390/net/qeth_core_main.c:				qeth_clear_output_buffer(card->qdio.out_qs[i],
./drivers/s390/net/qeth_core_main.c:						&card->qdio.out_qs[i]->bufs[j]);
./drivers/s390/net/qeth_core_main.c:			kfree(card->qdio.out_qs[i]);
./drivers/s390/net/qeth_core_main.c:		kfree(card->qdio.out_qs);
./drivers/s390/net/qeth_core_main.c:		card->qdio.out_qs = NULL;
./drivers/s390/net/qeth_core_main.c:	ccwdev = card->data.ccwdev;
./drivers/s390/net/qeth_core_main.c:			if ((atomic_read(&card->qdio.state) !=
./drivers/s390/net/qeth_core_main.c:			    (card->qdio.no_out_queues == 4))
./drivers/s390/net/qeth_core_main.c:			card->qdio.no_out_queues = 1;
./drivers/s390/net/qeth_core_main.c:			if (card->qdio.default_out_queue != 0)
./drivers/s390/net/qeth_core_main.c:				dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:			card->qdio.default_out_queue = 0;
./drivers/s390/net/qeth_core_main.c:			if ((atomic_read(&card->qdio.state) !=
./drivers/s390/net/qeth_core_main.c:			    (card->qdio.no_out_queues == 1)) {
./drivers/s390/net/qeth_core_main.c:				card->qdio.default_out_queue = 2;
./drivers/s390/net/qeth_core_main.c:			card->qdio.no_out_queues = 4;
./drivers/s390/net/qeth_core_main.c:		card->info.func_level = 0x4100 + chp_dsc->desc;
./drivers/s390/net/qeth_core_main.c:	QETH_DBF_TEXT_(SETUP, 2, "nr:%x", card->qdio.no_out_queues);
./drivers/s390/net/qeth_core_main.c:	QETH_DBF_TEXT_(SETUP, 2, "lvl:%02x", card->info.func_level);
./drivers/s390/net/qeth_core_main.c:	atomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);
./drivers/s390/net/qeth_core_main.c:	card->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;
./drivers/s390/net/qeth_core_main.c:	if (card->info.type == QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_core_main.c:		card->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_HSDEFAULT;
./drivers/s390/net/qeth_core_main.c:		card->qdio.init_pool.buf_count = QETH_IN_BUF_COUNT_DEFAULT;
./drivers/s390/net/qeth_core_main.c:	card->qdio.in_buf_pool.buf_count = card->qdio.init_pool.buf_count;
./drivers/s390/net/qeth_core_main.c:	INIT_LIST_HEAD(&card->qdio.in_buf_pool.entry_list);
./drivers/s390/net/qeth_core_main.c:	INIT_LIST_HEAD(&card->qdio.init_pool.entry_list);
./drivers/s390/net/qeth_core_main.c:	card->options.route4.type = NO_ROUTER;
./drivers/s390/net/qeth_core_main.c:	card->options.route6.type = NO_ROUTER;
./drivers/s390/net/qeth_core_main.c:	card->options.broadcast_mode = QETH_TR_BROADCAST_ALLRINGS;
./drivers/s390/net/qeth_core_main.c:	card->options.macaddr_mode = QETH_TR_MACADDR_NONCANONICAL;
./drivers/s390/net/qeth_core_main.c:	card->options.fake_broadcast = 0;
./drivers/s390/net/qeth_core_main.c:	card->options.add_hhlen = DEFAULT_ADD_HHLEN;
./drivers/s390/net/qeth_core_main.c:	card->options.performance_stats = 0;
./drivers/s390/net/qeth_core_main.c:	card->options.rx_sg_cb = QETH_RX_SG_CB;
./drivers/s390/net/qeth_core_main.c:	card->options.isolation = ISOLATION_MODE_NONE;
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:			(u8) card->thread_start_mask,
./drivers/s390/net/qeth_core_main.c:			(u8) card->thread_allowed_mask,
./drivers/s390/net/qeth_core_main.c:			(u8) card->thread_running_mask);
./drivers/s390/net/qeth_core_main.c:	rc = (card->thread_start_mask & thread);
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
./drivers/s390/net/qeth_core_main.c:	if (card->read.state != CH_STATE_UP &&
./drivers/s390/net/qeth_core_main.c:	    card->write.state != CH_STATE_UP)
./drivers/s390/net/qeth_core_main.c:		kthread_run(card->discipline.recover, (void *) card,
./drivers/s390/net/qeth_core_main.c:	card->read.state  = CH_STATE_DOWN;
./drivers/s390/net/qeth_core_main.c:	card->write.state = CH_STATE_DOWN;
./drivers/s390/net/qeth_core_main.c:	card->data.state  = CH_STATE_DOWN;
./drivers/s390/net/qeth_core_main.c:	card->state = CARD_STATE_DOWN;
./drivers/s390/net/qeth_core_main.c:	card->lan_online = 0;
./drivers/s390/net/qeth_core_main.c:	card->read_or_write_problem = 0;
./drivers/s390/net/qeth_core_main.c:	card->dev = NULL;
./drivers/s390/net/qeth_core_main.c:	spin_lock_init(&card->vlanlock);
./drivers/s390/net/qeth_core_main.c:	spin_lock_init(&card->mclock);
./drivers/s390/net/qeth_core_main.c:	card->vlangrp = NULL;
./drivers/s390/net/qeth_core_main.c:	spin_lock_init(&card->lock);
./drivers/s390/net/qeth_core_main.c:	spin_lock_init(&card->ip_lock);
./drivers/s390/net/qeth_core_main.c:	spin_lock_init(&card->thread_mask_lock);
./drivers/s390/net/qeth_core_main.c:	mutex_init(&card->conf_mutex);
./drivers/s390/net/qeth_core_main.c:	mutex_init(&card->discipline_mutex);
./drivers/s390/net/qeth_core_main.c:	card->thread_start_mask = 0;
./drivers/s390/net/qeth_core_main.c:	card->thread_allowed_mask = 0;
./drivers/s390/net/qeth_core_main.c:	card->thread_running_mask = 0;
./drivers/s390/net/qeth_core_main.c:	INIT_WORK(&card->kernel_thread_starter, qeth_start_kernel_thread);
./drivers/s390/net/qeth_core_main.c:	INIT_LIST_HEAD(&card->ip_list);
./drivers/s390/net/qeth_core_main.c:	INIT_LIST_HEAD(card->ip_tbd_list);
./drivers/s390/net/qeth_core_main.c:	INIT_LIST_HEAD(&card->cmd_waiter_list);
./drivers/s390/net/qeth_core_main.c:	init_waitqueue_head(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	INIT_LIST_HEAD(&card->ipato.entries);
./drivers/s390/net/qeth_core_main.c:	card->ipato.enabled = 0;
./drivers/s390/net/qeth_core_main.c:	card->ipato.invert4 = 0;
./drivers/s390/net/qeth_core_main.c:	card->ipato.invert6 = 0;
./drivers/s390/net/qeth_core_main.c:	if (card->info.mcl_level[0])
./drivers/s390/net/qeth_core_main.c:			CARD_BUS_ID(card), card->info.mcl_level);
./drivers/s390/net/qeth_core_main.c:	card->ip_tbd_list = kmalloc(sizeof(struct list_head), GFP_KERNEL);
./drivers/s390/net/qeth_core_main.c:	if (!card->ip_tbd_list) {
./drivers/s390/net/qeth_core_main.c:	if (qeth_setup_channel(&card->read))
./drivers/s390/net/qeth_core_main.c:	if (qeth_setup_channel(&card->write))
./drivers/s390/net/qeth_core_main.c:	card->options.layer2 = -1;
./drivers/s390/net/qeth_core_main.c:	card->qeth_service_level.seq_print = qeth_core_sl_print;
./drivers/s390/net/qeth_core_main.c:	register_service_level(&card->qeth_service_level);
./drivers/s390/net/qeth_core_main.c:	qeth_clean_channel(&card->read);
./drivers/s390/net/qeth_core_main.c:	kfree(card->ip_tbd_list);
./drivers/s390/net/qeth_core_main.c:	card->qdio.do_prio_queueing = QETH_PRIOQ_DEFAULT;
./drivers/s390/net/qeth_core_main.c:	card->qdio.default_out_queue = QETH_DEFAULT_QUEUE;
./drivers/s390/net/qeth_core_main.c:			card->info.type = known_devices[i][QETH_DEV_MODEL_IND];
./drivers/s390/net/qeth_core_main.c:			card->qdio.no_out_queues =
./drivers/s390/net/qeth_core_main.c:			card->info.is_multicast_different =
./drivers/s390/net/qeth_core_main.c:	card->info.type = QETH_CARD_TYPE_UNKNOWN;
./drivers/s390/net/qeth_core_main.c:	dev_err(&card->gdev->dev, "The adapter hardware is of an "
./drivers/s390/net/qeth_core_main.c:	rc = wait_event_interruptible_timeout(card->wait_q,
./drivers/s390/net/qeth_core_main.c:	rc = wait_event_interruptible_timeout(card->wait_q,
./drivers/s390/net/qeth_core_main.c:	rc1 = qeth_halt_channel(&card->read);
./drivers/s390/net/qeth_core_main.c:	rc2 = qeth_halt_channel(&card->write);
./drivers/s390/net/qeth_core_main.c:	rc3 = qeth_halt_channel(&card->data);
./drivers/s390/net/qeth_core_main.c:	rc1 = qeth_clear_channel(&card->read);
./drivers/s390/net/qeth_core_main.c:	rc2 = qeth_clear_channel(&card->write);
./drivers/s390/net/qeth_core_main.c:	rc3 = qeth_clear_channel(&card->data);
./drivers/s390/net/qeth_core_main.c:	switch (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ESTABLISHED,
./drivers/s390/net/qeth_core_main.c:		if (card->info.type == QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_core_main.c:		atomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);
./drivers/s390/net/qeth_core_main.c:	card->state = CARD_STATE_DOWN;
./drivers/s390/net/qeth_core_main.c:	struct qeth_channel *channel = &card->data;
./drivers/s390/net/qeth_core_main.c:		wait_event(card->wait_q,
./drivers/s390/net/qeth_core_main.c:	card->info.chpid = prcd[30];
./drivers/s390/net/qeth_core_main.c:	card->info.unit_addr2 = prcd[31];
./drivers/s390/net/qeth_core_main.c:	card->info.cula = prcd[63];
./drivers/s390/net/qeth_core_main.c:	card->info.guestlan = ((prcd[0x10] == _ascebc['V']) &&
./drivers/s390/net/qeth_core_main.c:		card->info.blkt.time_total = 250;
./drivers/s390/net/qeth_core_main.c:		card->info.blkt.inter_packet = 5;
./drivers/s390/net/qeth_core_main.c:		card->info.blkt.inter_packet_jumbo = 15;
./drivers/s390/net/qeth_core_main.c:		card->info.blkt.time_total = 0;
./drivers/s390/net/qeth_core_main.c:		card->info.blkt.inter_packet = 0;
./drivers/s390/net/qeth_core_main.c:		card->info.blkt.inter_packet_jumbo = 0;
./drivers/s390/net/qeth_core_main.c:	card->token.issuer_rm_w = 0x00010103UL;
./drivers/s390/net/qeth_core_main.c:	card->token.cm_filter_w = 0x00010108UL;
./drivers/s390/net/qeth_core_main.c:	card->token.cm_connection_w = 0x0001010aUL;
./drivers/s390/net/qeth_core_main.c:	card->token.ulp_filter_w = 0x0001010bUL;
./drivers/s390/net/qeth_core_main.c:	card->token.ulp_connection_w = 0x0001010dUL;
./drivers/s390/net/qeth_core_main.c:	switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:		card->info.func_level =	QETH_IDX_FUNC_LEVEL_IQD;
./drivers/s390/net/qeth_core_main.c:		card->info.func_level = QETH_IDX_FUNC_LEVEL_OSD;
./drivers/s390/net/qeth_core_main.c:	wait_event(card->wait_q,
./drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	rc = wait_event_interruptible_timeout(card->wait_q,
./drivers/s390/net/qeth_core_main.c:	if (channel == &card->write) {
./drivers/s390/net/qeth_core_main.c:		       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);
./drivers/s390/net/qeth_core_main.c:		card->seqno.trans_hdr++;
./drivers/s390/net/qeth_core_main.c:		       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);
./drivers/s390/net/qeth_core_main.c:	tmp = ((__u8)card->info.portno) | 0x80;
./drivers/s390/net/qeth_core_main.c:	       &card->token.issuer_rm_w, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->info.func_level, sizeof(__u16));
./drivers/s390/net/qeth_core_main.c:	temp = (card->info.cula << 8) + card->info.unit_addr2;
./drivers/s390/net/qeth_core_main.c:	wait_event(card->wait_q,
./drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	rc = wait_event_interruptible_timeout(card->wait_q,
./drivers/s390/net/qeth_core_main.c:			dev_err(&card->write.ccwdev->dev,
./drivers/s390/net/qeth_core_main.c:				dev_name(&card->write.ccwdev->dev));
./drivers/s390/net/qeth_core_main.c:	if ((temp & ~0x0100) != qeth_peer_func_level(card->info.func_level)) {
./drivers/s390/net/qeth_core_main.c:			"0x%x)\n", dev_name(&card->write.ccwdev->dev),
./drivers/s390/net/qeth_core_main.c:			card->info.func_level, temp);
./drivers/s390/net/qeth_core_main.c:			dev_err(&card->write.ccwdev->dev,
./drivers/s390/net/qeth_core_main.c:			dev_err(&card->read.ccwdev->dev,
./drivers/s390/net/qeth_core_main.c:				dev_name(&card->read.ccwdev->dev));
./drivers/s390/net/qeth_core_main.c:	     (card->info.type == QETH_CARD_TYPE_OSD))
./drivers/s390/net/qeth_core_main.c:		card->info.portname_required = 1;
./drivers/s390/net/qeth_core_main.c:	if (temp != qeth_peer_func_level(card->info.func_level)) {
./drivers/s390/net/qeth_core_main.c:			dev_name(&card->read.ccwdev->dev),
./drivers/s390/net/qeth_core_main.c:			card->info.func_level, temp);
./drivers/s390/net/qeth_core_main.c:	memcpy(&card->token.issuer_rm_r,
./drivers/s390/net/qeth_core_main.c:	memcpy(&card->info.mcl_level[0],
./drivers/s390/net/qeth_core_main.c:	qeth_setup_ccw(&card->write, iob->data, len);
./drivers/s390/net/qeth_core_main.c:	       &card->seqno.trans_hdr, QETH_SEQ_NO_LENGTH);
./drivers/s390/net/qeth_core_main.c:	card->seqno.trans_hdr++;
./drivers/s390/net/qeth_core_main.c:	       &card->seqno.pdu_hdr, QETH_SEQ_NO_LENGTH);
./drivers/s390/net/qeth_core_main.c:	card->seqno.pdu_hdr++;
./drivers/s390/net/qeth_core_main.c:	       &card->seqno.pdu_hdr_ack, QETH_SEQ_NO_LENGTH);
./drivers/s390/net/qeth_core_main.c:	if (card->read_or_write_problem) {
./drivers/s390/net/qeth_core_main.c:	if (card->state == CARD_STATE_DOWN)
./drivers/s390/net/qeth_core_main.c:		reply->seqno = card->seqno.ipa++;
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	list_add_tail(&reply->list, &card->cmd_waiter_list);
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	while (atomic_cmpxchg(&card->write.irq_pending, 0, 1)) ;
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(get_ccwdev_lock(card->write.ccwdev), flags);
./drivers/s390/net/qeth_core_main.c:	rc = ccw_device_start(card->write.ccwdev, &card->write.ccw,
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(get_ccwdev_lock(card->write.ccwdev), flags);
./drivers/s390/net/qeth_core_main.c:			dev_name(&card->write.ccwdev->dev), rc);
./drivers/s390/net/qeth_core_main.c:		spin_lock_irqsave(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:		spin_unlock_irqrestore(&card->lock, flags);
./drivers/s390/net/qeth_core_main.c:		atomic_set(&card->write.irq_pending, 0);
./drivers/s390/net/qeth_core_main.c:		wake_up(&card->wait_q);
./drivers/s390/net/qeth_core_main.c:	spin_lock_irqsave(&reply->card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	spin_unlock_irqrestore(&reply->card->lock, flags);
./drivers/s390/net/qeth_core_main.c:	atomic_set(&card->write.irq_pending, 0);
./drivers/s390/net/qeth_core_main.c:	card->write.buf_no = (card->write.buf_no + 1) % QETH_CMD_BUFFER_NO;
./drivers/s390/net/qeth_core_main.c:	memcpy(&card->token.cm_filter_r,
./drivers/s390/net/qeth_core_main.c:	iob = qeth_wait_for_buffer(&card->write);
./drivers/s390/net/qeth_core_main.c:	       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->token.cm_filter_w, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	memcpy(&card->token.cm_connection_r,
./drivers/s390/net/qeth_core_main.c:	iob = qeth_wait_for_buffer(&card->write);
./drivers/s390/net/qeth_core_main.c:	       &card->token.issuer_rm_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->token.cm_connection_w, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->token.cm_filter_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:		return card->info.max_mtu;
./drivers/s390/net/qeth_core_main.c:		switch (card->info.link_type) {
./drivers/s390/net/qeth_core_main.c:	switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:			(mtu <= card->info.max_mtu));
./drivers/s390/net/qeth_core_main.c:	memcpy(&card->token.ulp_filter_r,
./drivers/s390/net/qeth_core_main.c:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_core_main.c:		if (card->info.initial_mtu && (card->info.initial_mtu != mtu)) {
./drivers/s390/net/qeth_core_main.c:			if (card->dev &&
./drivers/s390/net/qeth_core_main.c:			    ((card->dev->mtu == card->info.initial_mtu) ||
./drivers/s390/net/qeth_core_main.c:			     (card->dev->mtu > mtu)))
./drivers/s390/net/qeth_core_main.c:				card->dev->mtu = mtu;
./drivers/s390/net/qeth_core_main.c:		card->info.initial_mtu = mtu;
./drivers/s390/net/qeth_core_main.c:		card->info.max_mtu = mtu;
./drivers/s390/net/qeth_core_main.c:		card->qdio.in_buf_size = mtu + 2 * PAGE_SIZE;
./drivers/s390/net/qeth_core_main.c:		card->info.initial_mtu = qeth_get_initial_mtu_for_card(card);
./drivers/s390/net/qeth_core_main.c:		card->info.max_mtu = *(__u16 *)QETH_ULP_ENABLE_RESP_MAX_MTU(
./drivers/s390/net/qeth_core_main.c:		card->qdio.in_buf_size = QETH_IN_BUF_SIZE_DEFAULT;
./drivers/s390/net/qeth_core_main.c:		card->info.link_type = link_type;
./drivers/s390/net/qeth_core_main.c:		card->info.link_type = 0;
./drivers/s390/net/qeth_core_main.c:	QETH_DBF_TEXT_(SETUP, 2, "link%d", card->info.link_type);
./drivers/s390/net/qeth_core_main.c:	iob = qeth_wait_for_buffer(&card->write);
./drivers/s390/net/qeth_core_main.c:		(__u8) card->info.portno;
./drivers/s390/net/qeth_core_main.c:	if (card->options.layer2)
./drivers/s390/net/qeth_core_main.c:		if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_core_main.c:	       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->token.ulp_filter_w, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       card->info.portname, 9);
./drivers/s390/net/qeth_core_main.c:	memcpy(&card->token.ulp_connection_r,
./drivers/s390/net/qeth_core_main.c:		dev_err(&card->gdev->dev, "A connection could not be "
./drivers/s390/net/qeth_core_main.c:	iob = qeth_wait_for_buffer(&card->write);
./drivers/s390/net/qeth_core_main.c:	       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->token.ulp_connection_w, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->token.ulp_filter_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	temp = (card->info.cula << 8) + card->info.unit_addr2;
./drivers/s390/net/qeth_core_main.c:	if (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_UNINITIALIZED,
./drivers/s390/net/qeth_core_main.c:	card->qdio.in_q = kmalloc(sizeof(struct qeth_qdio_q),
./drivers/s390/net/qeth_core_main.c:	if (!card->qdio.in_q)
./drivers/s390/net/qeth_core_main.c:	QETH_DBF_HEX(SETUP, 2, &card->qdio.in_q, sizeof(void *));
./drivers/s390/net/qeth_core_main.c:	memset(card->qdio.in_q, 0, sizeof(struct qeth_qdio_q));
./drivers/s390/net/qeth_core_main.c:		card->qdio.in_q->bufs[i].buffer =
./drivers/s390/net/qeth_core_main.c:			&card->qdio.in_q->qdio_bufs[i];
./drivers/s390/net/qeth_core_main.c:	card->qdio.out_qs =
./drivers/s390/net/qeth_core_main.c:		kmalloc(card->qdio.no_out_queues *
./drivers/s390/net/qeth_core_main.c:	if (!card->qdio.out_qs)
./drivers/s390/net/qeth_core_main.c:	for (i = 0; i < card->qdio.no_out_queues; ++i) {
./drivers/s390/net/qeth_core_main.c:		card->qdio.out_qs[i] = kmalloc(sizeof(struct qeth_qdio_out_q),
./drivers/s390/net/qeth_core_main.c:		if (!card->qdio.out_qs[i])
./drivers/s390/net/qeth_core_main.c:		QETH_DBF_HEX(SETUP, 2, &card->qdio.out_qs[i], sizeof(void *));
./drivers/s390/net/qeth_core_main.c:		memset(card->qdio.out_qs[i], 0, sizeof(struct qeth_qdio_out_q));
./drivers/s390/net/qeth_core_main.c:		card->qdio.out_qs[i]->queue_no = i;
./drivers/s390/net/qeth_core_main.c:			card->qdio.out_qs[i]->bufs[j].buffer =
./drivers/s390/net/qeth_core_main.c:				&card->qdio.out_qs[i]->qdio_bufs[j];
./drivers/s390/net/qeth_core_main.c:			skb_queue_head_init(&card->qdio.out_qs[i]->bufs[j].
./drivers/s390/net/qeth_core_main.c:				&card->qdio.out_qs[i]->bufs[j].skb_list.lock,
./drivers/s390/net/qeth_core_main.c:			INIT_LIST_HEAD(&card->qdio.out_qs[i]->bufs[j].ctx_list);
./drivers/s390/net/qeth_core_main.c:		kfree(card->qdio.out_qs[--i]);
./drivers/s390/net/qeth_core_main.c:	kfree(card->qdio.out_qs);
./drivers/s390/net/qeth_core_main.c:	card->qdio.out_qs = NULL;
./drivers/s390/net/qeth_core_main.c:	kfree(card->qdio.in_q);
./drivers/s390/net/qeth_core_main.c:	card->qdio.in_q = NULL;
./drivers/s390/net/qeth_core_main.c:	atomic_set(&card->qdio.state, QETH_QDIO_UNINITIALIZED);
./drivers/s390/net/qeth_core_main.c:	*((unsigned int *) (&param_field[20])) = card->info.blkt.time_total;
./drivers/s390/net/qeth_core_main.c:	*((unsigned int *) (&param_field[24])) = card->info.blkt.inter_packet;
./drivers/s390/net/qeth_core_main.c:		card->info.blkt.inter_packet_jumbo;
./drivers/s390/net/qeth_core_main.c:	iob = qeth_wait_for_buffer(&card->write);
./drivers/s390/net/qeth_core_main.c:	       &card->token.cm_connection_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	qeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);
./drivers/s390/net/qeth_core_main.c:	sprintf(dbf_text, "%s", card->info.portname + 1);
./drivers/s390/net/qeth_core_main.c:	dev_info(&card->gdev->dev, "Device is a%s card%s%s%s\n"
./drivers/s390/net/qeth_core_main.c:	       (card->info.mcl_level[0]) ? " (level: " : "",
./drivers/s390/net/qeth_core_main.c:	       (card->info.mcl_level[0]) ? card->info.mcl_level : "",
./drivers/s390/net/qeth_core_main.c:	       (card->info.mcl_level[0]) ? ")" : "",
./drivers/s390/net/qeth_core_main.c:	if (card->info.portname[0])
./drivers/s390/net/qeth_core_main.c:		dev_info(&card->gdev->dev, "Device is a%s "
./drivers/s390/net/qeth_core_main.c:		       (card->info.mcl_level[0]) ? " (level: " : "",
./drivers/s390/net/qeth_core_main.c:		       (card->info.mcl_level[0]) ? card->info.mcl_level : "",
./drivers/s390/net/qeth_core_main.c:		       (card->info.mcl_level[0]) ? ")" : "",
./drivers/s390/net/qeth_core_main.c:		dev_info(&card->gdev->dev, "Device is a%s "
./drivers/s390/net/qeth_core_main.c:		       (card->info.mcl_level[0]) ? " (level: " : "",
./drivers/s390/net/qeth_core_main.c:		       (card->info.mcl_level[0]) ? card->info.mcl_level : "",
./drivers/s390/net/qeth_core_main.c:		       (card->info.mcl_level[0]) ? ")" : "",
./drivers/s390/net/qeth_core_main.c:	switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:		if (!card->info.mcl_level[0]) {
./drivers/s390/net/qeth_core_main.c:			sprintf(card->info.mcl_level, "%02x%02x",
./drivers/s390/net/qeth_core_main.c:				card->info.mcl_level[2],
./drivers/s390/net/qeth_core_main.c:				card->info.mcl_level[3]);
./drivers/s390/net/qeth_core_main.c:			card->info.mcl_level[QETH_MCL_LENGTH] = 0;
./drivers/s390/net/qeth_core_main.c:		if ((card->info.guestlan) ||
./drivers/s390/net/qeth_core_main.c:		    (card->info.mcl_level[0] & 0x80)) {
./drivers/s390/net/qeth_core_main.c:			card->info.mcl_level[0] = (char) _ebcasc[(__u8)
./drivers/s390/net/qeth_core_main.c:				card->info.mcl_level[0]];
./drivers/s390/net/qeth_core_main.c:			card->info.mcl_level[1] = (char) _ebcasc[(__u8)
./drivers/s390/net/qeth_core_main.c:				card->info.mcl_level[1]];
./drivers/s390/net/qeth_core_main.c:			card->info.mcl_level[2] = (char) _ebcasc[(__u8)
./drivers/s390/net/qeth_core_main.c:				card->info.mcl_level[2]];
./drivers/s390/net/qeth_core_main.c:			card->info.mcl_level[3] = (char) _ebcasc[(__u8)
./drivers/s390/net/qeth_core_main.c:				card->info.mcl_level[3]];
./drivers/s390/net/qeth_core_main.c:			card->info.mcl_level[QETH_MCL_LENGTH] = 0;
./drivers/s390/net/qeth_core_main.c:		memset(&card->info.mcl_level[0], 0, QETH_MCL_LENGTH + 1);
./drivers/s390/net/qeth_core_main.c:	if (card->info.portname_required)
./drivers/s390/net/qeth_core_main.c:			    &card->qdio.init_pool.entry_list, init_list) {
./drivers/s390/net/qeth_core_main.c:	if (list_empty(&card->qdio.in_buf_pool.entry_list))
./drivers/s390/net/qeth_core_main.c:	list_for_each(plh, &card->qdio.in_buf_pool.entry_list) {
./drivers/s390/net/qeth_core_main.c:	entry = list_entry(card->qdio.in_buf_pool.entry_list.next,
./drivers/s390/net/qeth_core_main.c:				if (card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:					card->perf_stats.sg_alloc_page_rx++;
./drivers/s390/net/qeth_core_main.c:	memset(card->qdio.in_q->qdio_bufs, 0,
./drivers/s390/net/qeth_core_main.c:	for (i = 0; i < card->qdio.in_buf_pool.buf_count - 1; ++i)
./drivers/s390/net/qeth_core_main.c:		qeth_init_input_buffer(card, &card->qdio.in_q->bufs[i]);
./drivers/s390/net/qeth_core_main.c:	card->qdio.in_q->next_buf_to_init =
./drivers/s390/net/qeth_core_main.c:		card->qdio.in_buf_pool.buf_count - 1;
./drivers/s390/net/qeth_core_main.c:		     card->qdio.in_buf_pool.buf_count - 1);
./drivers/s390/net/qeth_core_main.c:	for (i = 0; i < card->qdio.no_out_queues; ++i) {
./drivers/s390/net/qeth_core_main.c:		memset(card->qdio.out_qs[i]->qdio_bufs, 0,
./drivers/s390/net/qeth_core_main.c:			qeth_clear_output_buffer(card->qdio.out_qs[i],
./drivers/s390/net/qeth_core_main.c:					&card->qdio.out_qs[i]->bufs[j]);
./drivers/s390/net/qeth_core_main.c:		card->qdio.out_qs[i]->card = card;
./drivers/s390/net/qeth_core_main.c:		card->qdio.out_qs[i]->next_buf_to_fill = 0;
./drivers/s390/net/qeth_core_main.c:		card->qdio.out_qs[i]->do_pack = 0;
./drivers/s390/net/qeth_core_main.c:		atomic_set(&card->qdio.out_qs[i]->used_buffers, 0);
./drivers/s390/net/qeth_core_main.c:		atomic_set(&card->qdio.out_qs[i]->set_pci_flags_count, 0);
./drivers/s390/net/qeth_core_main.c:		atomic_set(&card->qdio.out_qs[i]->state,
./drivers/s390/net/qeth_core_main.c:	cmd->hdr.seqno = card->seqno.ipa;
./drivers/s390/net/qeth_core_main.c:	cmd->hdr.adapter_type = qeth_get_ipa_adp_type(card->info.link_type);
./drivers/s390/net/qeth_core_main.c:	cmd->hdr.rel_adapter_no = (__u8) card->info.portno;
./drivers/s390/net/qeth_core_main.c:	if (card->options.layer2)
./drivers/s390/net/qeth_core_main.c:	iob = qeth_wait_for_buffer(&card->write);
./drivers/s390/net/qeth_core_main.c:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	if (card->options.layer2)
./drivers/s390/net/qeth_core_main.c:		if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_core_main.c:		card->info.link_type =
./drivers/s390/net/qeth_core_main.c:		QETH_DBF_TEXT_(SETUP, 2, "lnk %d", card->info.link_type);
./drivers/s390/net/qeth_core_main.c:	card->options.adp.supported_funcs =
./drivers/s390/net/qeth_core_main.c:		card->options.ipa4.supported_funcs = cmd->hdr.ipa_supported;
./drivers/s390/net/qeth_core_main.c:		card->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;
./drivers/s390/net/qeth_core_main.c:		card->options.ipa6.supported_funcs = cmd->hdr.ipa_supported;
./drivers/s390/net/qeth_core_main.c:		card->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;
./drivers/s390/net/qeth_core_main.c:		card->info.diagass_support = cmd->data.diagass.ext;
./drivers/s390/net/qeth_core_main.c:	tid->chpid = card->info.chpid;
./drivers/s390/net/qeth_core_main.c:			card->stats.rx_dropped++;
./drivers/s390/net/qeth_core_main.c:	struct qeth_qdio_q *queue = card->qdio.in_q;
./drivers/s390/net/qeth_core_main.c:		card->qdio.in_buf_pool.buf_count -
./drivers/s390/net/qeth_core_main.c:		card->qdio.in_buf_pool.buf_count -
./drivers/s390/net/qeth_core_main.c:			atomic_set(&card->force_alloc_skb, 3);
./drivers/s390/net/qeth_core_main.c:			atomic_add_unless(&card->force_alloc_skb, -1, 0);
./drivers/s390/net/qeth_core_main.c:		if (card->options.performance_stats) {
./drivers/s390/net/qeth_core_main.c:			card->perf_stats.inbound_do_qdio_cnt++;
./drivers/s390/net/qeth_core_main.c:			card->perf_stats.inbound_do_qdio_start_time =
./drivers/s390/net/qeth_core_main.c:		if (card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:			card->perf_stats.inbound_do_qdio_time +=
./drivers/s390/net/qeth_core_main.c:				card->perf_stats.inbound_do_qdio_start_time;
./drivers/s390/net/qeth_core_main.c:			dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_core_main.c:			if (queue->card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:				queue->card->perf_stats.sc_dp_p++;
./drivers/s390/net/qeth_core_main.c:			if (queue->card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:				queue->card->perf_stats.sc_p_dp++;
./drivers/s390/net/qeth_core_main.c:		if (queue->card->info.type == QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_core_main.c:	queue->card->dev->trans_start = jiffies;
./drivers/s390/net/qeth_core_main.c:	if (queue->card->options.performance_stats) {
./drivers/s390/net/qeth_core_main.c:		queue->card->perf_stats.outbound_do_qdio_cnt++;
./drivers/s390/net/qeth_core_main.c:		queue->card->perf_stats.outbound_do_qdio_start_time =
./drivers/s390/net/qeth_core_main.c:	if (queue->card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:		queue->card->perf_stats.outbound_do_qdio_time +=
./drivers/s390/net/qeth_core_main.c:			queue->card->perf_stats.outbound_do_qdio_start_time;
./drivers/s390/net/qeth_core_main.c:		queue->card->stats.tx_errors += count;
./drivers/s390/net/qeth_core_main.c:	if (queue->card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:		queue->card->perf_stats.bufs_sent += count;
./drivers/s390/net/qeth_core_main.c:			netif_stop_queue(queue->card->dev);
./drivers/s390/net/qeth_core_main.c:			if (queue->card->options.performance_stats &&
./drivers/s390/net/qeth_core_main.c:				queue->card->perf_stats.bufs_sent_pack +=
./drivers/s390/net/qeth_core_main.c:	if (card->dev && (card->dev->flags & IFF_UP))
./drivers/s390/net/qeth_core_main.c:		napi_schedule(&card->napi);
./drivers/s390/net/qeth_core_main.c:	struct qeth_qdio_out_q *queue = card->qdio.out_qs[__queue];
./drivers/s390/net/qeth_core_main.c:		netif_stop_queue(card->dev);
./drivers/s390/net/qeth_core_main.c:	if (card->options.performance_stats) {
./drivers/s390/net/qeth_core_main.c:		card->perf_stats.outbound_handler_cnt++;
./drivers/s390/net/qeth_core_main.c:		card->perf_stats.outbound_handler_start_time =
./drivers/s390/net/qeth_core_main.c:	if (card->info.type != QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_core_main.c:	netif_wake_queue(queue->card->dev);
./drivers/s390/net/qeth_core_main.c:	if (card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:		card->perf_stats.outbound_handler_time += qeth_get_micros() -
./drivers/s390/net/qeth_core_main.c:			card->perf_stats.outbound_handler_start_time;
./drivers/s390/net/qeth_core_main.c:	if (!ipv && (card->info.type == QETH_CARD_TYPE_OSD ||
./drivers/s390/net/qeth_core_main.c:		     card->info.type == QETH_CARD_TYPE_OSX))
./drivers/s390/net/qeth_core_main.c:		return card->qdio.default_out_queue;
./drivers/s390/net/qeth_core_main.c:	switch (card->qdio.no_out_queues) {
./drivers/s390/net/qeth_core_main.c:		if (cast_type && card->info.is_multicast_different)
./drivers/s390/net/qeth_core_main.c:			return card->info.is_multicast_different &
./drivers/s390/net/qeth_core_main.c:				(card->qdio.no_out_queues - 1);
./drivers/s390/net/qeth_core_main.c:		if (card->qdio.do_prio_queueing && (ipv == 4)) {
./drivers/s390/net/qeth_core_main.c:			if (card->qdio.do_prio_queueing ==
./drivers/s390/net/qeth_core_main.c:			if (card->qdio.do_prio_queueing ==
./drivers/s390/net/qeth_core_main.c:		} else if (card->qdio.do_prio_queueing && (ipv == 6)) {
./drivers/s390/net/qeth_core_main.c:		return card->qdio.default_out_queue;
./drivers/s390/net/qeth_core_main.c:		return card->qdio.default_out_queue;
./drivers/s390/net/qeth_core_main.c:		if (queue->card->options.performance_stats)
./drivers/s390/net/qeth_core_main.c:			queue->card->perf_stats.skbs_sent_pack++;
./drivers/s390/net/qeth_core_main.c:	if (queue->card->options.performance_stats && do_pack)
./drivers/s390/net/qeth_core_main.c:		queue->card->perf_stats.bufs_sent_pack += flush_count;
./drivers/s390/net/qeth_core_main.c:	card->info.promisc_mode = setparms->data.mode;
./drivers/s390/net/qeth_core_main.c:	struct net_device *dev = card->dev;
./drivers/s390/net/qeth_core_main.c:	     (card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||
./drivers/s390/net/qeth_core_main.c:	     (card->info.promisc_mode == SET_PROMISC_MODE_OFF)))
./drivers/s390/net/qeth_core_main.c:	return &card->stats;
./drivers/s390/net/qeth_core_main.c:	if (!card->options.layer2 ||
./drivers/s390/net/qeth_core_main.c:	    !(card->info.mac_bits & QETH_LAYER2_MAC_READ)) {
./drivers/s390/net/qeth_core_main.c:		memcpy(card->dev->dev_addr,
./drivers/s390/net/qeth_core_main.c:		card->info.mac_bits |= QETH_LAYER2_MAC_READ;
./drivers/s390/net/qeth_core_main.c:	       card->dev->dev_addr, OSA_ADDR_LEN);
./drivers/s390/net/qeth_core_main.c:	QETH_DBF_TEXT_(SETUP, 2, "%s", card->gdev->dev.kobj.name);
./drivers/s390/net/qeth_core_main.c:		card->options.isolation = access_ctrl_req->subcmd_code;
./drivers/s390/net/qeth_core_main.c:		if (card->options.isolation == ISOLATION_MODE_NONE) {
./drivers/s390/net/qeth_core_main.c:			dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:			dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:			card->gdev->dev.kobj.name,
./drivers/s390/net/qeth_core_main.c:			card->gdev->dev.kobj.name,
./drivers/s390/net/qeth_core_main.c:		dev_err(&card->gdev->dev, "Adapter does not "
./drivers/s390/net/qeth_core_main.c:		card->options.isolation = ISOLATION_MODE_NONE;
./drivers/s390/net/qeth_core_main.c:			card->gdev->dev.kobj.name,
./drivers/s390/net/qeth_core_main.c:		dev_err(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:		card->options.isolation = ISOLATION_MODE_NONE;
./drivers/s390/net/qeth_core_main.c:			card->gdev->dev.kobj.name,
./drivers/s390/net/qeth_core_main.c:		dev_err(&card->gdev->dev,
./drivers/s390/net/qeth_core_main.c:		card->options.isolation = ISOLATION_MODE_NONE;
./drivers/s390/net/qeth_core_main.c:			card->gdev->dev.kobj.name,
./drivers/s390/net/qeth_core_main.c:		card->options.isolation = ISOLATION_MODE_NONE;
./drivers/s390/net/qeth_core_main.c:	QETH_DBF_TEXT_(SETUP, 2, "%s", card->gdev->dev.kobj.name);
./drivers/s390/net/qeth_core_main.c:	if ((card->info.type == QETH_CARD_TYPE_OSD ||
./drivers/s390/net/qeth_core_main.c:	     card->info.type == QETH_CARD_TYPE_OSX) &&
./drivers/s390/net/qeth_core_main.c:			card->options.isolation);
./drivers/s390/net/qeth_core_main.c:				card->gdev->dev.kobj.name,
./drivers/s390/net/qeth_core_main.c:	} else if (card->options.isolation != ISOLATION_MODE_NONE) {
./drivers/s390/net/qeth_core_main.c:		card->options.isolation = ISOLATION_MODE_NONE;
./drivers/s390/net/qeth_core_main.c:		dev_err(&card->gdev->dev, "Adapter does not "
./drivers/s390/net/qeth_core_main.c:	card->stats.tx_errors++;
./drivers/s390/net/qeth_core_main.c:		if ((card->info.link_type != QETH_LINK_TYPE_GBIT_ETH) &&
./drivers/s390/net/qeth_core_main.c:		    (card->info.link_type != QETH_LINK_TYPE_OSN) &&
./drivers/s390/net/qeth_core_main.c:		    (card->info.link_type != QETH_LINK_TYPE_10GBIT_ETH))
./drivers/s390/net/qeth_core_main.c:		rc = card->stats.rx_errors;
./drivers/s390/net/qeth_core_main.c:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_core_main.c:	if (card->info.guestlan)
./drivers/s390/net/qeth_core_main.c:	    (!card->options.layer2)) {
./drivers/s390/net/qeth_core_main.c:	switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:			dev_name(&card->gdev->dev), rc);
./drivers/s390/net/qeth_core_main.c:	rc = qdio_get_ssqd_desc(ddev, &card->ssqd);
./drivers/s390/net/qeth_core_main.c:			virt_to_phys(card->qdio.in_q->bufs[i].buffer);
./drivers/s390/net/qeth_core_main.c:		kmalloc(card->qdio.no_out_queues * QDIO_MAX_BUFFERS_PER_Q *
./drivers/s390/net/qeth_core_main.c:	for (i = 0, k = 0; i < card->qdio.no_out_queues; ++i)
./drivers/s390/net/qeth_core_main.c:				card->qdio.out_qs[i]->bufs[j].buffer);
./drivers/s390/net/qeth_core_main.c:	init_data.no_output_qs           = card->qdio.no_out_queues;
./drivers/s390/net/qeth_core_main.c:	init_data.input_handler          = card->discipline.input_handler;
./drivers/s390/net/qeth_core_main.c:	init_data.output_handler         = card->discipline.output_handler;
./drivers/s390/net/qeth_core_main.c:	init_data.queue_start_poll	 = card->discipline.start_poll;
./drivers/s390/net/qeth_core_main.c:		(card->info.type == QETH_CARD_TYPE_IQD) ? 8 : 32;
./drivers/s390/net/qeth_core_main.c:	if (atomic_cmpxchg(&card->qdio.state, QETH_QDIO_ALLOCATED,
./drivers/s390/net/qeth_core_main.c:			atomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);
./drivers/s390/net/qeth_core_main.c:			atomic_set(&card->qdio.state, QETH_QDIO_ALLOCATED);
./drivers/s390/net/qeth_core_main.c:	qeth_clean_channel(&card->read);
./drivers/s390/net/qeth_core_main.c:	qeth_clean_channel(&card->write);
./drivers/s390/net/qeth_core_main.c:	if (card->dev)
./drivers/s390/net/qeth_core_main.c:		free_netdev(card->dev);
./drivers/s390/net/qeth_core_main.c:	kfree(card->ip_tbd_list);
./drivers/s390/net/qeth_core_main.c:	unregister_service_level(&card->qeth_service_level);
./drivers/s390/net/qeth_core_main.c:	atomic_set(&card->force_alloc_skb, 0);
./drivers/s390/net/qeth_core_main.c:			dev_name(&card->gdev->dev));
./drivers/s390/net/qeth_core_main.c:	rc = qeth_qdio_clear_card(card, card->info.type != QETH_CARD_TYPE_IQD);
./drivers/s390/net/qeth_core_main.c:	rc = qeth_idx_activate_channel(&card->read, qeth_idx_read_cb);
./drivers/s390/net/qeth_core_main.c:	rc = qeth_idx_activate_channel(&card->write, qeth_idx_write_cb);
./drivers/s390/net/qeth_core_main.c:	card->read_or_write_problem = 0;
./drivers/s390/net/qeth_core_main.c:	card->options.ipa4.supported_funcs = 0;
./drivers/s390/net/qeth_core_main.c:	card->options.adp.supported_funcs = 0;
./drivers/s390/net/qeth_core_main.c:	card->info.diagass_support = 0;
./drivers/s390/net/qeth_core_main.c:	dev_warn(&card->gdev->dev, "The qeth device driver failed to recover "
./drivers/s390/net/qeth_core_main.c:		dev_name(&card->gdev->dev), rc);
./drivers/s390/net/qeth_core_main.c:		if ((card->info.link_type == QETH_LINK_TYPE_LANE_TR) ||
./drivers/s390/net/qeth_core_main.c:		    (card->info.link_type == QETH_LINK_TYPE_HSTR))
./drivers/s390/net/qeth_core_main.c:	if ((skb_len >= card->options.rx_sg_cb) &&
./drivers/s390/net/qeth_core_main.c:	    (!(card->info.type == QETH_CARD_TYPE_OSN)) &&
./drivers/s390/net/qeth_core_main.c:	    (!atomic_read(&card->force_alloc_skb))) {
./drivers/s390/net/qeth_core_main.c:				card->stats.rx_errors++;
./drivers/s390/net/qeth_core_main.c:	if (use_rx_sg && card->options.performance_stats) {
./drivers/s390/net/qeth_core_main.c:		card->perf_stats.sg_skbs_rx++;
./drivers/s390/net/qeth_core_main.c:		card->perf_stats.sg_frags_rx += skb_shinfo(skb)->nr_frags;
./drivers/s390/net/qeth_core_main.c:	card->stats.rx_dropped++;
./drivers/s390/net/qeth_core_main.c:		card->discipline.ccwgdriver = try_then_request_module(
./drivers/s390/net/qeth_core_main.c:		card->discipline.ccwgdriver = try_then_request_module(
./drivers/s390/net/qeth_core_main.c:	if (!card->discipline.ccwgdriver) {
./drivers/s390/net/qeth_core_main.c:		dev_err(&card->gdev->dev, "There is no kernel module to "
./drivers/s390/net/qeth_core_main.c:	if (card->options.layer2)
./drivers/s390/net/qeth_core_main.c:	card->discipline.ccwgdriver = NULL;
./drivers/s390/net/qeth_core_main.c:	card->debug = debug_register(dbf_name, 2, 1, 8);
./drivers/s390/net/qeth_core_main.c:	if (!card->debug) {
./drivers/s390/net/qeth_core_main.c:	debug_register_view(card->debug, &debug_hex_ascii_view);
./drivers/s390/net/qeth_core_main.c:	card->read.ccwdev  = gdev->cdev[0];
./drivers/s390/net/qeth_core_main.c:	card->write.ccwdev = gdev->cdev[1];
./drivers/s390/net/qeth_core_main.c:	card->data.ccwdev  = gdev->cdev[2];
./drivers/s390/net/qeth_core_main.c:	card->gdev = gdev;
./drivers/s390/net/qeth_core_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_core_main.c:	switch (card->info.type) {
./drivers/s390/net/qeth_core_main.c:		rc = card->discipline.ccwgdriver->probe(card->gdev);
./drivers/s390/net/qeth_core_main.c:	list_add_tail(&card->list, &qeth_core_card_list.list);
./drivers/s390/net/qeth_core_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN)
./drivers/s390/net/qeth_core_main.c:	debug_unregister(card->debug);
./drivers/s390/net/qeth_core_main.c:	if (card->info.type == QETH_CARD_TYPE_OSN) {
./drivers/s390/net/qeth_core_main.c:	if (card->discipline.ccwgdriver) {
./drivers/s390/net/qeth_core_main.c:		card->discipline.ccwgdriver->remove(gdev);
./drivers/s390/net/qeth_core_main.c:	debug_unregister(card->debug);
./drivers/s390/net/qeth_core_main.c:	list_del(&card->list);
./drivers/s390/net/qeth_core_main.c:	if (!card->discipline.ccwgdriver) {
./drivers/s390/net/qeth_core_main.c:		if (card->info.type == QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_core_main.c:		rc = card->discipline.ccwgdriver->probe(card->gdev);
./drivers/s390/net/qeth_core_main.c:	rc = card->discipline.ccwgdriver->set_online(gdev);
./drivers/s390/net/qeth_core_main.c:	return card->discipline.ccwgdriver->set_offline(gdev);
./drivers/s390/net/qeth_core_main.c:	if (card->discipline.ccwgdriver &&
./drivers/s390/net/qeth_core_main.c:	    card->discipline.ccwgdriver->shutdown)
./drivers/s390/net/qeth_core_main.c:		card->discipline.ccwgdriver->shutdown(gdev);
./drivers/s390/net/qeth_core_main.c:	if (card->discipline.ccwgdriver &&
./drivers/s390/net/qeth_core_main.c:	    card->discipline.ccwgdriver->prepare)
./drivers/s390/net/qeth_core_main.c:		return card->discipline.ccwgdriver->prepare(gdev);
./drivers/s390/net/qeth_core_main.c:	if (card->discipline.ccwgdriver &&
./drivers/s390/net/qeth_core_main.c:	    card->discipline.ccwgdriver->complete)
./drivers/s390/net/qeth_core_main.c:		card->discipline.ccwgdriver->complete(gdev);
./drivers/s390/net/qeth_core_main.c:	if (card->discipline.ccwgdriver &&
./drivers/s390/net/qeth_core_main.c:	    card->discipline.ccwgdriver->freeze)
./drivers/s390/net/qeth_core_main.c:		return card->discipline.ccwgdriver->freeze(gdev);
./drivers/s390/net/qeth_core_main.c:	if (card->discipline.ccwgdriver &&
./drivers/s390/net/qeth_core_main.c:	    card->discipline.ccwgdriver->thaw)
./drivers/s390/net/qeth_core_main.c:		return card->discipline.ccwgdriver->thaw(gdev);
./drivers/s390/net/qeth_core_main.c:	if (card->discipline.ccwgdriver &&
./drivers/s390/net/qeth_core_main.c:	    card->discipline.ccwgdriver->restore)
./drivers/s390/net/qeth_core_main.c:		return card->discipline.ccwgdriver->restore(gdev);
./drivers/s390/net/qeth_core_main.c:	data[0] = card->stats.rx_packets -
./drivers/s390/net/qeth_core_main.c:				card->perf_stats.initial_rx_packets;
./drivers/s390/net/qeth_core_main.c:	data[1] = card->perf_stats.bufs_rec;
./drivers/s390/net/qeth_core_main.c:	data[2] = card->stats.tx_packets -
./drivers/s390/net/qeth_core_main.c:				card->perf_stats.initial_tx_packets;
./drivers/s390/net/qeth_core_main.c:	data[3] = card->perf_stats.bufs_sent;
./drivers/s390/net/qeth_core_main.c:	data[4] = card->stats.tx_packets - card->perf_stats.initial_tx_packets
./drivers/s390/net/qeth_core_main.c:			- card->perf_stats.skbs_sent_pack;
./drivers/s390/net/qeth_core_main.c:	data[5] = card->perf_stats.bufs_sent - card->perf_stats.bufs_sent_pack;
./drivers/s390/net/qeth_core_main.c:	data[6] = card->perf_stats.skbs_sent_pack;
./drivers/s390/net/qeth_core_main.c:	data[7] = card->perf_stats.bufs_sent_pack;
./drivers/s390/net/qeth_core_main.c:	data[8] = card->perf_stats.sg_skbs_sent;
./drivers/s390/net/qeth_core_main.c:	data[9] = card->perf_stats.sg_frags_sent;
./drivers/s390/net/qeth_core_main.c:	data[10] = card->perf_stats.sg_skbs_rx;
./drivers/s390/net/qeth_core_main.c:	data[11] = card->perf_stats.sg_frags_rx;
./drivers/s390/net/qeth_core_main.c:	data[12] = card->perf_stats.sg_alloc_page_rx;
./drivers/s390/net/qeth_core_main.c:	data[13] = (card->perf_stats.large_send_bytes >> 10);
./drivers/s390/net/qeth_core_main.c:	data[14] = card->perf_stats.large_send_cnt;
./drivers/s390/net/qeth_core_main.c:	data[15] = card->perf_stats.sc_dp_p;
./drivers/s390/net/qeth_core_main.c:	data[16] = card->perf_stats.sc_p_dp;
./drivers/s390/net/qeth_core_main.c:	data[19] = atomic_read(&card->qdio.out_qs[0]->used_buffers);
./drivers/s390/net/qeth_core_main.c:	data[20] = (card->qdio.no_out_queues > 1) ?
./drivers/s390/net/qeth_core_main.c:			atomic_read(&card->qdio.out_qs[1]->used_buffers) : 0;
./drivers/s390/net/qeth_core_main.c:	data[21] = (card->qdio.no_out_queues > 2) ?
./drivers/s390/net/qeth_core_main.c:			atomic_read(&card->qdio.out_qs[2]->used_buffers) : 0;
./drivers/s390/net/qeth_core_main.c:	data[22] = (card->qdio.no_out_queues > 3) ?
./drivers/s390/net/qeth_core_main.c:			atomic_read(&card->qdio.out_qs[3]->used_buffers) : 0;
./drivers/s390/net/qeth_core_main.c:	data[23] = card->perf_stats.inbound_time;
./drivers/s390/net/qeth_core_main.c:	data[24] = card->perf_stats.inbound_cnt;
./drivers/s390/net/qeth_core_main.c:	data[25] = card->perf_stats.inbound_do_qdio_time;
./drivers/s390/net/qeth_core_main.c:	data[26] = card->perf_stats.inbound_do_qdio_cnt;
./drivers/s390/net/qeth_core_main.c:	data[27] = card->perf_stats.outbound_handler_time;
./drivers/s390/net/qeth_core_main.c:	data[28] = card->perf_stats.outbound_handler_cnt;
./drivers/s390/net/qeth_core_main.c:	data[29] = card->perf_stats.outbound_time;
./drivers/s390/net/qeth_core_main.c:	data[30] = card->perf_stats.outbound_cnt;
./drivers/s390/net/qeth_core_main.c:	data[31] = card->perf_stats.outbound_do_qdio_time;
./drivers/s390/net/qeth_core_main.c:	data[32] = card->perf_stats.outbound_do_qdio_cnt;
./drivers/s390/net/qeth_core_main.c:	data[33] = card->perf_stats.tx_csum;
./drivers/s390/net/qeth_core_main.c:	data[34] = card->perf_stats.tx_lin;
./drivers/s390/net/qeth_core_main.c:	if (card->options.layer2)
./drivers/s390/net/qeth_core_main.c:	strcpy(info->fw_version, card->info.mcl_level);
./drivers/s390/net/qeth_core_main.c:	if ((card->info.type == QETH_CARD_TYPE_IQD) || (card->info.guestlan))
./drivers/s390/net/qeth_core_main.c:		link_type = card->info.link_type;
./drivers/s390/net/qeth_l3_main.c:	if (!card->ipato.enabled)
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry(ipatoe, &card->ipato.entries, entry) {
./drivers/s390/net/qeth_l3_main.c:	if ((addr->proto == QETH_PROT_IPV4) && card->ipato.invert4)
./drivers/s390/net/qeth_l3_main.c:	else if ((addr->proto == QETH_PROT_IPV6) && card->ipato.invert6)
./drivers/s390/net/qeth_l3_main.c:	if (card->options.sniffer)
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry_safe(tmp, t, card->ip_tbd_list, entry) {
./drivers/s390/net/qeth_l3_main.c:			list_add(&addr->entry, card->ip_tbd_list);
./drivers/s390/net/qeth_l3_main.c:			list_add_tail(&addr->entry, card->ip_tbd_list);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry(addr, &card->ip_list, entry) {
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry_safe(addr, tmp, &card->ip_list, entry) {
./drivers/s390/net/qeth_l3_main.c:			spin_unlock_irqrestore(&card->ip_lock, *flags);
./drivers/s390/net/qeth_l3_main.c:			spin_lock_irqsave(&card->ip_lock, *flags);
./drivers/s390/net/qeth_l3_main.c:	list_splice(&fail_list, &card->ip_list);
./drivers/s390/net/qeth_l3_main.c:	if ((card->state != CARD_STATE_UP &&
./drivers/s390/net/qeth_l3_main.c:	     card->state != CARD_STATE_SOFTSETUP) || card->options.sniffer) {
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	tbd_list = card->ip_tbd_list;
./drivers/s390/net/qeth_l3_main.c:	card->ip_tbd_list = kmalloc(sizeof(struct list_head), GFP_ATOMIC);
./drivers/s390/net/qeth_l3_main.c:	if (!card->ip_tbd_list) {
./drivers/s390/net/qeth_l3_main.c:		card->ip_tbd_list = tbd_list;
./drivers/s390/net/qeth_l3_main.c:		spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:		INIT_LIST_HEAD(card->ip_tbd_list);
./drivers/s390/net/qeth_l3_main.c:			spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:			spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:				list_add_tail(&todo->entry, &card->ip_list);
./drivers/s390/net/qeth_l3_main.c:			spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:			spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:				list_add_tail(&addr->entry, &card->ip_list);
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	if (recover && card->options.sniffer)
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry_safe(addr, tmp, card->ip_tbd_list, entry) {
./drivers/s390/net/qeth_l3_main.c:	while (!list_empty(&card->ip_list)) {
./drivers/s390/net/qeth_l3_main.c:		addr = list_entry(card->ip_list.next,
./drivers/s390/net/qeth_l3_main.c:		list_add_tail(&addr->entry, card->ip_tbd_list);
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_l3_main.c:	qeth_l3_correct_routing_type(card, &card->options.route4.type,
./drivers/s390/net/qeth_l3_main.c:	rc = qeth_l3_send_setrouting(card, card->options.route4.type,
./drivers/s390/net/qeth_l3_main.c:		card->options.route4.type = NO_ROUTER;
./drivers/s390/net/qeth_l3_main.c:	qeth_l3_correct_routing_type(card, &card->options.route6.type,
./drivers/s390/net/qeth_l3_main.c:	rc = qeth_l3_send_setrouting(card, card->options.route6.type,
./drivers/s390/net/qeth_l3_main.c:		card->options.route6.type = NO_ROUTER;
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry(ipatoe, &card->ipato.entries, entry) {
./drivers/s390/net/qeth_l3_main.c:		list_add_tail(&new->entry, &card->ipato.entries);
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	list_for_each_entry_safe(ipatoe, tmp, &card->ipato.entries, entry) {
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	if (qeth_l3_address_exists_in_list(&card->ip_list, ipaddr, 0) ||
./drivers/s390/net/qeth_l3_main.c:	    qeth_l3_address_exists_in_list(card->ip_tbd_list, ipaddr, 0))
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:	if (qeth_l3_address_exists_in_list(&card->ip_list, ipaddr, 0) ||
./drivers/s390/net/qeth_l3_main.c:	    qeth_l3_address_exists_in_list(card->ip_tbd_list, ipaddr, 0))
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->ip_lock, flags);
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:					card->options.broadcast_mode);
./drivers/s390/net/qeth_l3_main.c:					card->options.macaddr_mode);
./drivers/s390/net/qeth_l3_main.c:	if (card->options.broadcast_mode == QETH_TR_BROADCAST_LOCAL)
./drivers/s390/net/qeth_l3_main.c:	if (card->options.macaddr_mode == QETH_TR_MACADDR_CANONICAL)
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:			"0x%x\n", dev_name(&card->gdev->dev), rc);
./drivers/s390/net/qeth_l3_main.c:			dev_warn(&card->gdev->dev, "Reading the adapter MAC"
./drivers/s390/net/qeth_l3_main.c:	if ((card->info.link_type == QETH_LINK_TYPE_HSTR) ||
./drivers/s390/net/qeth_l3_main.c:	    (card->info.link_type == QETH_LINK_TYPE_LANE_TR))
./drivers/s390/net/qeth_l3_main.c:			card->options.ipa4.enabled_funcs = cmd->hdr.ipa_enabled;
./drivers/s390/net/qeth_l3_main.c:			card->options.ipa6.enabled_funcs = cmd->hdr.ipa_enabled;
./drivers/s390/net/qeth_l3_main.c:		card->info.csum_mask = cmd->data.setassparms.data.flags_32bit;
./drivers/s390/net/qeth_l3_main.c:		QETH_CARD_TEXT_(card, 3, "csum:%d", card->info.csum_mask);
./drivers/s390/net/qeth_l3_main.c:		card->info.tx_csum_mask =
./drivers/s390/net/qeth_l3_main.c:		QETH_CARD_TEXT_(card, 3, "tcsu:%d", card->info.tx_csum_mask);
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev, "VLAN enabled\n");
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev, "Multicast enabled\n");
./drivers/s390/net/qeth_l3_main.c:		card->dev->flags |= IFF_MULTICAST;
./drivers/s390/net/qeth_l3_main.c:	if (card->info.type == QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_l3_main.c:		dev_err(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_err(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_err(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:	dev_info(&card->gdev->dev, "IPV6 enabled\n");
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:	card->info.broadcast_capable = 0;
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev, "Enabling broadcast filtering for "
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:	card->info.broadcast_capable = QETH_BROADCAST_WITH_ECHO;
./drivers/s390/net/qeth_l3_main.c:	dev_info(&card->gdev->dev, "Broadcast enabled\n");
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev, "Setting up broadcast echo "
./drivers/s390/net/qeth_l3_main.c:	card->info.broadcast_capable = QETH_BROADCAST_WITHOUT_ECHO;
./drivers/s390/net/qeth_l3_main.c:	if (card->info.broadcast_capable)
./drivers/s390/net/qeth_l3_main.c:		card->dev->flags |= IFF_BROADCAST;
./drivers/s390/net/qeth_l3_main.c:		card->dev->flags &= ~IFF_BROADCAST;
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev, "Starting HW checksumming for %s "
./drivers/s390/net/qeth_l3_main.c:					  card->info.csum_mask);
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev, "Enabling HW checksumming for %s "
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:	if (card->dev->features & NETIF_F_RXCSUM) {
./drivers/s390/net/qeth_l3_main.c:		card->dev->features &= ~NETIF_F_RXCSUM;
./drivers/s390/net/qeth_l3_main.c:		netdev_update_features(card->dev);
./drivers/s390/net/qeth_l3_main.c:			  IPA_CMD_ASS_ENABLE, card->info.tx_csum_mask);
./drivers/s390/net/qeth_l3_main.c:	dev_info(&card->gdev->dev, "HW TX Checksumming enabled\n");
./drivers/s390/net/qeth_l3_main.c:	dev_warn(&card->gdev->dev, "Enabling HW TX checksumming for %s "
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:			dev_warn(&card->gdev->dev, "Starting outbound TCP "
./drivers/s390/net/qeth_l3_main.c:			dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		card->dev->features &= ~NETIF_F_TSO;
./drivers/s390/net/qeth_l3_main.c:		memcpy(card->dev->dev_addr,
./drivers/s390/net/qeth_l3_main.c:		random_ether_addr(card->dev->dev_addr);
./drivers/s390/net/qeth_l3_main.c:			card->info.unique_id;
./drivers/s390/net/qeth_l3_main.c:		card->info.unique_id = *((__u16 *)
./drivers/s390/net/qeth_l3_main.c:		card->info.unique_id =  UNIQUE_ID_IF_CREATE_ADDR_FAILED |
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev, "The network adapter failed to "
./drivers/s390/net/qeth_l3_main.c:		card->info.unique_id =  UNIQUE_ID_IF_CREATE_ADDR_FAILED |
./drivers/s390/net/qeth_l3_main.c:			card->info.unique_id;
./drivers/s390/net/qeth_l3_main.c:			card->info.promisc_mode = SET_PROMISC_MODE_OFF;
./drivers/s390/net/qeth_l3_main.c:			dev_info(&card->gdev->dev, "The HiperSockets network "
./drivers/s390/net/qeth_l3_main.c:			card->info.promisc_mode = SET_PROMISC_MODE_ON;
./drivers/s390/net/qeth_l3_main.c:			dev_info(&card->gdev->dev, "The HiperSockets network "
./drivers/s390/net/qeth_l3_main.c:			dev_warn(&card->gdev->dev, "The device is not "
./drivers/s390/net/qeth_l3_main.c:			dev_warn(&card->gdev->dev, "A HiperSockets "
./drivers/s390/net/qeth_l3_main.c:	if (!qeth_is_supported(card, IPA_FULL_VLAN) || (card->vlangrp == NULL))
./drivers/s390/net/qeth_l3_main.c:	vg = card->vlangrp;
./drivers/s390/net/qeth_l3_main.c:	in4_dev = in_dev_get(card->dev);
./drivers/s390/net/qeth_l3_main.c:	if (!qeth_is_supported(card, IPA_FULL_VLAN) || (card->vlangrp == NULL))
./drivers/s390/net/qeth_l3_main.c:	vg = card->vlangrp;
./drivers/s390/net/qeth_l3_main.c:	in6_dev = in6_dev_get(card->dev);
./drivers/s390/net/qeth_l3_main.c:	in_dev = in_dev_get(vlan_group_get_device(card->vlangrp, vid));
./drivers/s390/net/qeth_l3_main.c:	in6_dev = in6_dev_get(vlan_group_get_device(card->vlangrp, vid));
./drivers/s390/net/qeth_l3_main.c:	if (!card->vlangrp)
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->vlanlock, flags);
./drivers/s390/net/qeth_l3_main.c:	card->vlangrp = grp;
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->vlanlock, flags);
./drivers/s390/net/qeth_l3_main.c:	spin_lock_irqsave(&card->vlanlock, flags);
./drivers/s390/net/qeth_l3_main.c:	vlan_group_set_device(card->vlangrp, vid, NULL);
./drivers/s390/net/qeth_l3_main.c:	spin_unlock_irqrestore(&card->vlanlock, flags);
./drivers/s390/net/qeth_l3_main.c:	qeth_l3_set_multicast_list(card->dev);
./drivers/s390/net/qeth_l3_main.c:				     tg_addr, card->dev, 0);
./drivers/s390/net/qeth_l3_main.c:				(card->dev->type == ARPHRD_IEEE802_TR) ?
./drivers/s390/net/qeth_l3_main.c:				memcpy(tg_addr, card->dev->broadcast,
./drivers/s390/net/qeth_l3_main.c:					card->dev->addr_len);
./drivers/s390/net/qeth_l3_main.c:			card->stats.multicast++;
./drivers/s390/net/qeth_l3_main.c:			memcpy(tg_addr, card->dev->broadcast,
./drivers/s390/net/qeth_l3_main.c:				card->dev->addr_len);
./drivers/s390/net/qeth_l3_main.c:			card->stats.multicast++;
./drivers/s390/net/qeth_l3_main.c:			if (card->options.sniffer)
./drivers/s390/net/qeth_l3_main.c:			memcpy(tg_addr, card->dev->dev_addr,
./drivers/s390/net/qeth_l3_main.c:				card->dev->addr_len);
./drivers/s390/net/qeth_l3_main.c:			card->dev->header_ops->create(skb, card->dev, prot,
./drivers/s390/net/qeth_l3_main.c:				card->dev->addr_len);
./drivers/s390/net/qeth_l3_main.c:			card->dev->header_ops->create(skb, card->dev, prot,
./drivers/s390/net/qeth_l3_main.c:				tg_addr, "FAKELL", card->dev->addr_len);
./drivers/s390/net/qeth_l3_main.c:	if (card->dev->type == ARPHRD_IEEE802_TR)
./drivers/s390/net/qeth_l3_main.c:		skb->protocol = tr_type_trans(skb, card->dev);
./drivers/s390/net/qeth_l3_main.c:		skb->protocol = eth_type_trans(skb, card->dev);
./drivers/s390/net/qeth_l3_main.c:	if (card->dev->features & NETIF_F_RXCSUM) {
./drivers/s390/net/qeth_l3_main.c:			card->qdio.in_q->bufs[card->rx.b_index].buffer,
./drivers/s390/net/qeth_l3_main.c:			&card->rx.b_element, &card->rx.e_offset, &hdr);
./drivers/s390/net/qeth_l3_main.c:		skb->dev = card->dev;
./drivers/s390/net/qeth_l3_main.c:			if (is_vlan && !card->options.sniffer)
./drivers/s390/net/qeth_l3_main.c:				vlan_gro_receive(&card->napi, card->vlangrp,
./drivers/s390/net/qeth_l3_main.c:				napi_gro_receive(&card->napi, skb);
./drivers/s390/net/qeth_l3_main.c:		card->stats.rx_packets++;
./drivers/s390/net/qeth_l3_main.c:		card->stats.rx_bytes += len;
./drivers/s390/net/qeth_l3_main.c:	if (card->options.performance_stats) {
./drivers/s390/net/qeth_l3_main.c:		card->perf_stats.inbound_cnt++;
./drivers/s390/net/qeth_l3_main.c:		card->perf_stats.inbound_start_time = qeth_get_micros();
./drivers/s390/net/qeth_l3_main.c:		if (!card->rx.b_count) {
./drivers/s390/net/qeth_l3_main.c:			card->rx.qdio_err = 0;
./drivers/s390/net/qeth_l3_main.c:			card->rx.b_count = qdio_get_next_buffers(
./drivers/s390/net/qeth_l3_main.c:				card->data.ccwdev, 0, &card->rx.b_index,
./drivers/s390/net/qeth_l3_main.c:				&card->rx.qdio_err);
./drivers/s390/net/qeth_l3_main.c:			if (card->rx.b_count <= 0) {
./drivers/s390/net/qeth_l3_main.c:				card->rx.b_count = 0;
./drivers/s390/net/qeth_l3_main.c:			card->rx.b_element =
./drivers/s390/net/qeth_l3_main.c:				&card->qdio.in_q->bufs[card->rx.b_index]
./drivers/s390/net/qeth_l3_main.c:			card->rx.e_offset = 0;
./drivers/s390/net/qeth_l3_main.c:		while (card->rx.b_count) {
./drivers/s390/net/qeth_l3_main.c:			buffer = &card->qdio.in_q->bufs[card->rx.b_index];
./drivers/s390/net/qeth_l3_main.c:			if (!(card->rx.qdio_err &&
./drivers/s390/net/qeth_l3_main.c:			    card->rx.qdio_err, "qinerr")))
./drivers/s390/net/qeth_l3_main.c:				if (card->options.performance_stats)
./drivers/s390/net/qeth_l3_main.c:					card->perf_stats.bufs_rec++;
./drivers/s390/net/qeth_l3_main.c:				qeth_queue_input_buffer(card, card->rx.b_index);
./drivers/s390/net/qeth_l3_main.c:				card->rx.b_count--;
./drivers/s390/net/qeth_l3_main.c:				if (card->rx.b_count) {
./drivers/s390/net/qeth_l3_main.c:					card->rx.b_index =
./drivers/s390/net/qeth_l3_main.c:						(card->rx.b_index + 1) %
./drivers/s390/net/qeth_l3_main.c:					card->rx.b_element =
./drivers/s390/net/qeth_l3_main.c:						&card->qdio.in_q
./drivers/s390/net/qeth_l3_main.c:						->bufs[card->rx.b_index]
./drivers/s390/net/qeth_l3_main.c:					card->rx.e_offset = 0;
./drivers/s390/net/qeth_l3_main.c:	if (qdio_start_irq(card->data.ccwdev, 0))
./drivers/s390/net/qeth_l3_main.c:		napi_schedule(&card->napi);
./drivers/s390/net/qeth_l3_main.c:	if (card->options.performance_stats)
./drivers/s390/net/qeth_l3_main.c:		card->perf_stats.inbound_time += qeth_get_micros() -
./drivers/s390/net/qeth_l3_main.c:			card->perf_stats.inbound_start_time;
./drivers/s390/net/qeth_l3_main.c:	vg = card->vlangrp;
./drivers/s390/net/qeth_l3_main.c:		if (card->dev == dev) {
./drivers/s390/net/qeth_l3_main.c:	if (card && card->options.layer2)
./drivers/s390/net/qeth_l3_main.c:	if (card->options.sniffer &&
./drivers/s390/net/qeth_l3_main.c:	    (card->info.promisc_mode == SET_PROMISC_MODE_ON))
./drivers/s390/net/qeth_l3_main.c:	if (card->read.state == CH_STATE_UP &&
./drivers/s390/net/qeth_l3_main.c:	    card->write.state == CH_STATE_UP &&
./drivers/s390/net/qeth_l3_main.c:	    (card->state == CARD_STATE_UP)) {
./drivers/s390/net/qeth_l3_main.c:			qeth_l3_stop(card->dev);
./drivers/s390/net/qeth_l3_main.c:			dev_close(card->dev);
./drivers/s390/net/qeth_l3_main.c:		card->state = CARD_STATE_SOFTSETUP;
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_SOFTSETUP) {
./drivers/s390/net/qeth_l3_main.c:		card->state = CARD_STATE_HARDSETUP;
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_HARDSETUP) {
./drivers/s390/net/qeth_l3_main.c:		card->state = CARD_STATE_DOWN;
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_DOWN) {
./drivers/s390/net/qeth_l3_main.c:		qeth_clear_cmd_buffers(&card->read);
./drivers/s390/net/qeth_l3_main.c:		qeth_clear_cmd_buffers(&card->write);
./drivers/s390/net/qeth_l3_main.c:	struct net_device *dev = card->dev;
./drivers/s390/net/qeth_l3_main.c:	     (card->info.promisc_mode == SET_PROMISC_MODE_ON)) ||
./drivers/s390/net/qeth_l3_main.c:	     (card->info.promisc_mode == SET_PROMISC_MODE_OFF)))
./drivers/s390/net/qeth_l3_main.c:	if (card->info.guestlan) {		/* Guestlan trace */
./drivers/s390/net/qeth_l3_main.c:	} else if (card->options.sniffer &&	/* HiperSockets trace */
./drivers/s390/net/qeth_l3_main.c:	    (card->state != CARD_STATE_UP))
./drivers/s390/net/qeth_l3_main.c:	if (!card->options.sniffer) {
./drivers/s390/net/qeth_l3_main.c:	if (card->info.guestlan)
./drivers/s390/net/qeth_l3_main.c:	       &card->token.ulp_connection_r, QETH_MPC_TOKEN_LENGTH);
./drivers/s390/net/qeth_l3_main.c:	if (card->info.guestlan)
./drivers/s390/net/qeth_l3_main.c:	if (card->info.guestlan)
./drivers/s390/net/qeth_l3_main.c:	if (card->info.guestlan || (card->info.type == QETH_CARD_TYPE_IQD))
./drivers/s390/net/qeth_l3_main.c:	if ((card->state != CARD_STATE_UP) &&
./drivers/s390/net/qeth_l3_main.c:		(card->state != CARD_STATE_SOFTSETUP))
./drivers/s390/net/qeth_l3_main.c:		if ((card->info.type == QETH_CARD_TYPE_OSD ||
./drivers/s390/net/qeth_l3_main.c:		     card->info.type == QETH_CARD_TYPE_OSX) &&
./drivers/s390/net/qeth_l3_main.c:		    !card->info.guestlan)
./drivers/s390/net/qeth_l3_main.c:		switch (card->info.link_type) {
./drivers/s390/net/qeth_l3_main.c:	if (card->vlangrp && vlan_tx_tag_present(skb)) {
./drivers/s390/net/qeth_l3_main.c:		if ((ipv == 4) || (card->info.type == QETH_CARD_TYPE_IQD))
./drivers/s390/net/qeth_l3_main.c:		if (card->info.type == QETH_CARD_TYPE_IQD)
./drivers/s390/net/qeth_l3_main.c:	if (card->options.performance_stats)
./drivers/s390/net/qeth_l3_main.c:		card->perf_stats.tx_csum++;
./drivers/s390/net/qeth_l3_main.c:	struct qeth_qdio_out_q *queue = card->qdio.out_qs
./drivers/s390/net/qeth_l3_main.c:	if (((card->info.type == QETH_CARD_TYPE_IQD) && (!ipv)) ||
./drivers/s390/net/qeth_l3_main.c:	     card->options.sniffer)
./drivers/s390/net/qeth_l3_main.c:	if ((card->state != CARD_STATE_UP) || !card->lan_online) {
./drivers/s390/net/qeth_l3_main.c:		card->stats.tx_carrier_errors++;
./drivers/s390/net/qeth_l3_main.c:	    (card->info.broadcast_capable == 0))
./drivers/s390/net/qeth_l3_main.c:	if (card->options.performance_stats) {
./drivers/s390/net/qeth_l3_main.c:		card->perf_stats.outbound_cnt++;
./drivers/s390/net/qeth_l3_main.c:		card->perf_stats.outbound_start_time = qeth_get_micros();
./drivers/s390/net/qeth_l3_main.c:	if ((card->info.type == QETH_CARD_TYPE_IQD) && (!large_send) &&
./drivers/s390/net/qeth_l3_main.c:	if (card->info.type == QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_l3_main.c:			if (card->dev->type == ARPHRD_IEEE802_TR)
./drivers/s390/net/qeth_l3_main.c:		if (ipv != 4 && card->vlangrp &&
./drivers/s390/net/qeth_l3_main.c:			if (card->options.performance_stats)
./drivers/s390/net/qeth_l3_main.c:				card->perf_stats.tx_lin++;
./drivers/s390/net/qeth_l3_main.c:	if (card->info.type != QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_l3_main.c:		card->stats.tx_packets++;
./drivers/s390/net/qeth_l3_main.c:		card->stats.tx_bytes += tx_bytes;
./drivers/s390/net/qeth_l3_main.c:		if (card->options.performance_stats) {
./drivers/s390/net/qeth_l3_main.c:				card->perf_stats.large_send_bytes += tx_bytes;
./drivers/s390/net/qeth_l3_main.c:				card->perf_stats.large_send_cnt++;
./drivers/s390/net/qeth_l3_main.c:				card->perf_stats.sg_skbs_sent++;
./drivers/s390/net/qeth_l3_main.c:				card->perf_stats.sg_frags_sent += nr_frags + 1;
./drivers/s390/net/qeth_l3_main.c:	if (card->options.performance_stats)
./drivers/s390/net/qeth_l3_main.c:		card->perf_stats.outbound_time += qeth_get_micros() -
./drivers/s390/net/qeth_l3_main.c:			card->perf_stats.outbound_start_time;
./drivers/s390/net/qeth_l3_main.c:	card->stats.tx_dropped++;
./drivers/s390/net/qeth_l3_main.c:	card->stats.tx_errors++;
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_UP)
./drivers/s390/net/qeth_l3_main.c:	if (card->state != CARD_STATE_SOFTSETUP)
./drivers/s390/net/qeth_l3_main.c:	card->data.state = CH_STATE_UP;
./drivers/s390/net/qeth_l3_main.c:	card->state = CARD_STATE_UP;
./drivers/s390/net/qeth_l3_main.c:	if (qdio_stop_irq(card->data.ccwdev, 0) >= 0) {
./drivers/s390/net/qeth_l3_main.c:		napi_enable(&card->napi);
./drivers/s390/net/qeth_l3_main.c:		napi_schedule(&card->napi);
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_UP) {
./drivers/s390/net/qeth_l3_main.c:		card->state = CARD_STATE_SOFTSETUP;
./drivers/s390/net/qeth_l3_main.c:		napi_disable(&card->napi);
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_DOWN ||
./drivers/s390/net/qeth_l3_main.c:	    card->state == CARD_STATE_RECOVER)
./drivers/s390/net/qeth_l3_main.c:	if (card->info.type == QETH_CARD_TYPE_OSD ||
./drivers/s390/net/qeth_l3_main.c:	    card->info.type == QETH_CARD_TYPE_OSX) {
./drivers/s390/net/qeth_l3_main.c:		if ((card->info.link_type == QETH_LINK_TYPE_LANE_TR) ||
./drivers/s390/net/qeth_l3_main.c:		    (card->info.link_type == QETH_LINK_TYPE_HSTR)) {
./drivers/s390/net/qeth_l3_main.c:			card->dev = alloc_trdev(0);
./drivers/s390/net/qeth_l3_main.c:			if (!card->dev)
./drivers/s390/net/qeth_l3_main.c:			card->dev->netdev_ops = &qeth_l3_netdev_ops;
./drivers/s390/net/qeth_l3_main.c:			card->dev = alloc_etherdev(0);
./drivers/s390/net/qeth_l3_main.c:			if (!card->dev)
./drivers/s390/net/qeth_l3_main.c:			card->dev->netdev_ops = &qeth_l3_osa_netdev_ops;
./drivers/s390/net/qeth_l3_main.c:			if (!(card->info.unique_id & UNIQUE_ID_NOT_BY_CARD))
./drivers/s390/net/qeth_l3_main.c:				card->dev->dev_id = card->info.unique_id &
./drivers/s390/net/qeth_l3_main.c:			if (!card->info.guestlan) {
./drivers/s390/net/qeth_l3_main.c:				card->dev->hw_features = NETIF_F_SG |
./drivers/s390/net/qeth_l3_main.c:				card->dev->features = NETIF_F_RXCSUM;
./drivers/s390/net/qeth_l3_main.c:	} else if (card->info.type == QETH_CARD_TYPE_IQD) {
./drivers/s390/net/qeth_l3_main.c:		card->dev = alloc_netdev(0, "hsi%d", ether_setup);
./drivers/s390/net/qeth_l3_main.c:		if (!card->dev)
./drivers/s390/net/qeth_l3_main.c:		card->dev->flags |= IFF_NOARP;
./drivers/s390/net/qeth_l3_main.c:		card->dev->netdev_ops = &qeth_l3_netdev_ops;
./drivers/s390/net/qeth_l3_main.c:	card->dev->ml_priv = card;
./drivers/s390/net/qeth_l3_main.c:	card->dev->watchdog_timeo = QETH_TX_TIMEOUT;
./drivers/s390/net/qeth_l3_main.c:	card->dev->mtu = card->info.initial_mtu;
./drivers/s390/net/qeth_l3_main.c:	SET_ETHTOOL_OPS(card->dev, &qeth_l3_ethtool_ops);
./drivers/s390/net/qeth_l3_main.c:	card->dev->features |=	NETIF_F_HW_VLAN_TX |
./drivers/s390/net/qeth_l3_main.c:	card->dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
./drivers/s390/net/qeth_l3_main.c:	card->dev->gso_max_size = 15 * PAGE_SIZE;
./drivers/s390/net/qeth_l3_main.c:	SET_NETDEV_DEV(card->dev, &card->gdev->dev);
./drivers/s390/net/qeth_l3_main.c:	netif_napi_add(card->dev, &card->napi, qeth_l3_poll, QETH_NAPI_WEIGHT);
./drivers/s390/net/qeth_l3_main.c:	return register_netdev(card->dev);
./drivers/s390/net/qeth_l3_main.c:	card->options.layer2 = 0;
./drivers/s390/net/qeth_l3_main.c:	card->info.hwtrap = 0;
./drivers/s390/net/qeth_l3_main.c:	card->discipline.start_poll = qeth_qdio_start_poll;
./drivers/s390/net/qeth_l3_main.c:	card->discipline.input_handler = (qdio_handler_t *)
./drivers/s390/net/qeth_l3_main.c:	card->discipline.output_handler = (qdio_handler_t *)
./drivers/s390/net/qeth_l3_main.c:	card->discipline.recover = qeth_l3_recover;
./drivers/s390/net/qeth_l3_main.c:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./drivers/s390/net/qeth_l3_main.c:	if (card->dev) {
./drivers/s390/net/qeth_l3_main.c:		unregister_netdev(card->dev);
./drivers/s390/net/qeth_l3_main.c:		card->dev = NULL;
./drivers/s390/net/qeth_l3_main.c:	mutex_lock(&card->discipline_mutex);
./drivers/s390/net/qeth_l3_main.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_main.c:	recover_flag = card->state;
./drivers/s390/net/qeth_l3_main.c:	if (!card->dev && qeth_l3_setup_netdev(card)) {
./drivers/s390/net/qeth_l3_main.c:		if (card->info.hwtrap &&
./drivers/s390/net/qeth_l3_main.c:			card->info.hwtrap = 0;
./drivers/s390/net/qeth_l3_main.c:		card->info.hwtrap = 0;
./drivers/s390/net/qeth_l3_main.c:	card->state = CARD_STATE_HARDSETUP;
./drivers/s390/net/qeth_l3_main.c:	memset(&card->rx, 0, sizeof(struct qeth_rx));
./drivers/s390/net/qeth_l3_main.c:			dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:			card->lan_online = 0;
./drivers/s390/net/qeth_l3_main.c:		card->lan_online = 1;
./drivers/s390/net/qeth_l3_main.c:	if (!card->options.sniffer) {
./drivers/s390/net/qeth_l3_main.c:	netif_tx_disable(card->dev);
./drivers/s390/net/qeth_l3_main.c:	card->state = CARD_STATE_SOFTSETUP;
./drivers/s390/net/qeth_l3_main.c:	if (card->lan_online)
./drivers/s390/net/qeth_l3_main.c:		netif_carrier_on(card->dev);
./drivers/s390/net/qeth_l3_main.c:		netif_carrier_off(card->dev);
./drivers/s390/net/qeth_l3_main.c:			__qeth_l3_open(card->dev);
./drivers/s390/net/qeth_l3_main.c:			dev_open(card->dev);
./drivers/s390/net/qeth_l3_main.c:		qeth_l3_set_multicast_list(card->dev);
./drivers/s390/net/qeth_l3_main.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_main.c:	mutex_unlock(&card->discipline_mutex);
./drivers/s390/net/qeth_l3_main.c:		card->state = CARD_STATE_RECOVER;
./drivers/s390/net/qeth_l3_main.c:		card->state = CARD_STATE_DOWN;
./drivers/s390/net/qeth_l3_main.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_main.c:	mutex_unlock(&card->discipline_mutex);
./drivers/s390/net/qeth_l3_main.c:	mutex_lock(&card->discipline_mutex);
./drivers/s390/net/qeth_l3_main.c:	mutex_lock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_main.c:	if (card->dev && netif_carrier_ok(card->dev))
./drivers/s390/net/qeth_l3_main.c:		netif_carrier_off(card->dev);
./drivers/s390/net/qeth_l3_main.c:	recover_flag = card->state;
./drivers/s390/net/qeth_l3_main.c:	if ((!recovery_mode && card->info.hwtrap) || card->info.hwtrap == 2) {
./drivers/s390/net/qeth_l3_main.c:		card->info.hwtrap = 1;
./drivers/s390/net/qeth_l3_main.c:		card->state = CARD_STATE_RECOVER;
./drivers/s390/net/qeth_l3_main.c:	mutex_unlock(&card->conf_mutex);
./drivers/s390/net/qeth_l3_main.c:	mutex_unlock(&card->discipline_mutex);
./drivers/s390/net/qeth_l3_main.c:	dev_warn(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:	__qeth_l3_set_offline(card->gdev, 1);
./drivers/s390/net/qeth_l3_main.c:	rc = __qeth_l3_set_online(card->gdev, 1);
./drivers/s390/net/qeth_l3_main.c:		dev_info(&card->gdev->dev,
./drivers/s390/net/qeth_l3_main.c:		dev_close(card->dev);
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev, "The qeth device driver "
./drivers/s390/net/qeth_l3_main.c:	if ((gdev->state == CCWGROUP_ONLINE) && card->info.hwtrap)
./drivers/s390/net/qeth_l3_main.c:	if (card->dev)
./drivers/s390/net/qeth_l3_main.c:		netif_device_detach(card->dev);
./drivers/s390/net/qeth_l3_main.c:	wait_event(card->wait_q, qeth_threads_running(card, 0xffffffff) == 0);
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_UP) {
./drivers/s390/net/qeth_l3_main.c:		if (card->info.hwtrap)
./drivers/s390/net/qeth_l3_main.c:		__qeth_l3_set_offline(card->gdev, 1);
./drivers/s390/net/qeth_l3_main.c:		__qeth_l3_set_offline(card->gdev, 0);
./drivers/s390/net/qeth_l3_main.c:	if (card->state == CARD_STATE_RECOVER) {
./drivers/s390/net/qeth_l3_main.c:		rc = __qeth_l3_set_online(card->gdev, 1);
./drivers/s390/net/qeth_l3_main.c:			dev_close(card->dev);
./drivers/s390/net/qeth_l3_main.c:		rc = __qeth_l3_set_online(card->gdev, 0);
./drivers/s390/net/qeth_l3_main.c:	if (card->dev)
./drivers/s390/net/qeth_l3_main.c:		netif_device_attach(card->dev);
./drivers/s390/net/qeth_l3_main.c:		dev_warn(&card->gdev->dev, "The qeth device driver "
./tools/perf/builtin-script.c:	"perf script [<options>] record <script> [<record-options>] <command>",
./tools/perf/builtin-script.c:	"perf script [<options>] <script> [<record-options>] <command>",
./tools/perf/util/header.c:	 * may be coming from an arch with a different word-size, ergo different
